{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar boxPlot = require('../box/plot');\nvar linePoints = require('../scatter/line_points');\nvar helpers = require('./helpers');\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n  var isStatic = gd._context.staticPlot;\n  var fullLayout = gd._fullLayout;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  function makePath(pts, trace) {\n    var segments = linePoints(pts, {\n      xaxis: xa,\n      yaxis: ya,\n      trace: trace,\n      connectGaps: true,\n      baseTolerance: 0.75,\n      shape: 'spline',\n      simplify: true,\n      linearized: true\n    });\n    return Drawing.smoothopen(segments[0], 1);\n  }\n  Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace;\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n    var bPos = t.bPos;\n    var bdPos = t.bdPos;\n    var valAxis = plotinfo[t.valLetter + 'axis'];\n    var posAxis = plotinfo[t.posLetter + 'axis'];\n    var hasBothSides = trace.side === 'both';\n    var hasPositiveSide = hasBothSides || trace.side === 'positive';\n    var hasNegativeSide = hasBothSides || trace.side === 'negative';\n    var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n    violins.enter().append('path').style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').attr('class', 'violin');\n    violins.exit().remove();\n    violins.each(function (d) {\n      var pathSel = d3.select(this);\n      var density = d.density;\n      var len = density.length;\n      var posCenter = posAxis.c2l(d.pos + bPos, true);\n      var posCenterPx = posAxis.l2p(posCenter);\n      var scale;\n      if (trace.width) {\n        scale = t.maxKDE / bdPos;\n      } else {\n        var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n        scale = trace.scalemode === 'count' ? groupStats.maxKDE / bdPos * (groupStats.maxCount / d.pts.length) : groupStats.maxKDE / bdPos;\n      }\n      var pathPos, pathNeg, path;\n      var i, k, pts, pt;\n      if (hasPositiveSide) {\n        pts = new Array(len);\n        for (i = 0; i < len; i++) {\n          pt = pts[i] = {};\n          pt[t.posLetter] = posCenter + density[i].v / scale;\n          pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n        }\n        pathPos = makePath(pts, trace);\n      }\n      if (hasNegativeSide) {\n        pts = new Array(len);\n        for (k = 0, i = len - 1; k < len; k++, i--) {\n          pt = pts[k] = {};\n          pt[t.posLetter] = posCenter - density[i].v / scale;\n          pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n        }\n        pathNeg = makePath(pts, trace);\n      }\n      if (hasBothSides) {\n        path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n      } else {\n        var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n        var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n        if (trace.orientation === 'h') {\n          startPt.reverse();\n          endPt.reverse();\n        }\n        if (hasPositiveSide) {\n          path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n        } else {\n          path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n        }\n      }\n      pathSel.attr('d', path);\n\n      // save a few things used in getPositionOnKdePath, getKdeValue\n      // on hover and for meanline draw block below\n      d.posCenterPx = posCenterPx;\n      d.posDensityScale = scale * bdPos;\n      d.path = pathSel.node();\n      d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n    });\n    var boxAttrs = trace.box;\n    var boxWidth = boxAttrs.width;\n    var boxLineWidth = (boxAttrs.line || {}).width;\n    var bdPosScaled;\n    var bPosPxOffset;\n    if (hasBothSides) {\n      bdPosScaled = bdPos * boxWidth;\n      bPosPxOffset = 0;\n    } else if (hasPositiveSide) {\n      bdPosScaled = [0, bdPos * boxWidth / 2];\n      bPosPxOffset = boxLineWidth * {\n        x: 1,\n        y: -1\n      }[t.posLetter];\n    } else {\n      bdPosScaled = [bdPos * boxWidth / 2, 0];\n      bPosPxOffset = boxLineWidth * {\n        x: -1,\n        y: 1\n      }[t.posLetter];\n    }\n\n    // inner box\n    boxPlot.plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    });\n\n    // meanline insider box\n    boxPlot.plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    });\n    var fn;\n    if (!trace.box.visible && trace.meanline.visible) {\n      fn = Lib.identity;\n    }\n\n    // N.B. use different class name than boxPlot.plotBoxMean,\n    // to avoid selectAll conflict\n    var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n    meanPaths.enter().append('path').attr('class', 'meanline').style('fill', 'none').style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke');\n    meanPaths.exit().remove();\n    meanPaths.each(function (d) {\n      var v = valAxis.c2p(d.mean, true);\n      var p = helpers.getPositionOnKdePath(d, trace, v);\n      d3.select(this).attr('d', trace.orientation === 'h' ? 'M' + v + ',' + p[0] + 'V' + p[1] : 'M' + p[0] + ',' + v + 'H' + p[1]);\n    });\n    boxPlot.plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n  });\n};","map":{"version":3,"names":["d3","require","Lib","Drawing","boxPlot","linePoints","helpers","module","exports","plot","gd","plotinfo","cdViolins","violinLayer","isStatic","_context","staticPlot","fullLayout","_fullLayout","xa","xaxis","ya","yaxis","makePath","pts","trace","segments","connectGaps","baseTolerance","shape","simplify","linearized","smoothopen","makeTraceGroups","each","cd","plotGroup","select","cd0","t","visible","empty","remove","bPos","bdPos","valAxis","valLetter","posAxis","posLetter","hasBothSides","side","hasPositiveSide","hasNegativeSide","violins","selectAll","data","identity","enter","append","style","attr","exit","d","pathSel","density","len","length","posCenter","c2l","pos","posCenterPx","l2p","scale","width","maxKDE","groupStats","_violinScaleGroupStats","scalegroup","scalemode","maxCount","pathPos","pathNeg","path","i","k","pt","Array","v","substr","startPt","c2p","endPt","orientation","reverse","posDensityScale","node","pathLength","getTotalLength","boxAttrs","box","boxWidth","boxLineWidth","line","bdPosScaled","bPosPxOffset","x","y","plotBoxAndWhiskers","val","plotBoxMean","fn","meanline","meanPaths","mean","p","getPositionOnKdePath","plotPoints"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/violin/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\nvar boxPlot = require('../box/plot');\nvar linePoints = require('../scatter/line_points');\nvar helpers = require('./helpers');\n\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n    var isStatic = gd._context.staticPlot;\n    var fullLayout = gd._fullLayout;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    function makePath(pts, trace) {\n        var segments = linePoints(pts, {\n            xaxis: xa,\n            yaxis: ya,\n            trace: trace,\n            connectGaps: true,\n            baseTolerance: 0.75,\n            shape: 'spline',\n            simplify: true,\n            linearized: true\n        });\n        return Drawing.smoothopen(segments[0], 1);\n    }\n\n    Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n\n        if(trace.visible !== true || t.empty) {\n            plotGroup.remove();\n            return;\n        }\n\n        var bPos = t.bPos;\n        var bdPos = t.bdPos;\n        var valAxis = plotinfo[t.valLetter + 'axis'];\n        var posAxis = plotinfo[t.posLetter + 'axis'];\n        var hasBothSides = trace.side === 'both';\n        var hasPositiveSide = hasBothSides || trace.side === 'positive';\n        var hasNegativeSide = hasBothSides || trace.side === 'negative';\n\n        var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n\n        violins.enter().append('path')\n            .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke')\n            .attr('class', 'violin');\n\n        violins.exit().remove();\n\n        violins.each(function(d) {\n            var pathSel = d3.select(this);\n            var density = d.density;\n            var len = density.length;\n            var posCenter = posAxis.c2l(d.pos + bPos, true);\n            var posCenterPx = posAxis.l2p(posCenter);\n\n            var scale;\n            if(trace.width) {\n                scale = t.maxKDE / bdPos;\n            } else {\n                var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n                scale = trace.scalemode === 'count' ?\n                    (groupStats.maxKDE / bdPos) * (groupStats.maxCount / d.pts.length) :\n                    groupStats.maxKDE / bdPos;\n            }\n\n            var pathPos, pathNeg, path;\n            var i, k, pts, pt;\n\n            if(hasPositiveSide) {\n                pts = new Array(len);\n                for(i = 0; i < len; i++) {\n                    pt = pts[i] = {};\n                    pt[t.posLetter] = posCenter + (density[i].v / scale);\n                    pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n                }\n                pathPos = makePath(pts, trace);\n            }\n\n            if(hasNegativeSide) {\n                pts = new Array(len);\n                for(k = 0, i = len - 1; k < len; k++, i--) {\n                    pt = pts[k] = {};\n                    pt[t.posLetter] = posCenter - (density[i].v / scale);\n                    pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n                }\n                pathNeg = makePath(pts, trace);\n            }\n\n            if(hasBothSides) {\n                path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n            } else {\n                var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n                var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n\n                if(trace.orientation === 'h') {\n                    startPt.reverse();\n                    endPt.reverse();\n                }\n\n                if(hasPositiveSide) {\n                    path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n                } else {\n                    path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n                }\n            }\n            pathSel.attr('d', path);\n\n            // save a few things used in getPositionOnKdePath, getKdeValue\n            // on hover and for meanline draw block below\n            d.posCenterPx = posCenterPx;\n            d.posDensityScale = scale * bdPos;\n            d.path = pathSel.node();\n            d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n        });\n\n        var boxAttrs = trace.box;\n        var boxWidth = boxAttrs.width;\n        var boxLineWidth = (boxAttrs.line || {}).width;\n        var bdPosScaled;\n        var bPosPxOffset;\n\n        if(hasBothSides) {\n            bdPosScaled = bdPos * boxWidth;\n            bPosPxOffset = 0;\n        } else if(hasPositiveSide) {\n            bdPosScaled = [0, bdPos * boxWidth / 2];\n            bPosPxOffset = boxLineWidth * {x: 1, y: -1}[t.posLetter];\n        } else {\n            bdPosScaled = [bdPos * boxWidth / 2, 0];\n            bPosPxOffset = boxLineWidth * {x: -1, y: 1}[t.posLetter];\n        }\n\n        // inner box\n        boxPlot.plotBoxAndWhiskers(plotGroup, {pos: posAxis, val: valAxis}, trace, {\n            bPos: bPos,\n            bdPos: bdPosScaled,\n            bPosPxOffset: bPosPxOffset\n        });\n\n        // meanline insider box\n        boxPlot.plotBoxMean(plotGroup, {pos: posAxis, val: valAxis}, trace, {\n            bPos: bPos,\n            bdPos: bdPosScaled,\n            bPosPxOffset: bPosPxOffset\n        });\n\n        var fn;\n        if(!trace.box.visible && trace.meanline.visible) {\n            fn = Lib.identity;\n        }\n\n        // N.B. use different class name than boxPlot.plotBoxMean,\n        // to avoid selectAll conflict\n        var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n        meanPaths.enter().append('path')\n            .attr('class', 'meanline')\n            .style('fill', 'none')\n            .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke');\n        meanPaths.exit().remove();\n        meanPaths.each(function(d) {\n            var v = valAxis.c2p(d.mean, true);\n            var p = helpers.getPositionOnKdePath(d, trace, v);\n\n            d3.select(this).attr('d',\n                trace.orientation === 'h' ?\n                    'M' + v + ',' + p[0] + 'V' + p[1] :\n                    'M' + p[0] + ',' + v + 'H' + p[1]\n            );\n        });\n\n        boxPlot.plotPoints(plotGroup, {x: xa, y: ya}, trace, t);\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}