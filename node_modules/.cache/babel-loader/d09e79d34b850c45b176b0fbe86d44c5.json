{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar convert = require('./convert');\nvar LAYER_PREFIX = require('../../plots/mapbox/constants').traceLayerPrefix;\nvar ORDER = {\n  cluster: ['cluster', 'clusterCount', 'circle'],\n  nonCluster: ['fill', 'line', 'circle', 'symbol']\n};\nfunction ScatterMapbox(subplot, uid, clusterEnabled, isHidden) {\n  this.type = 'scattermapbox';\n  this.subplot = subplot;\n  this.uid = uid;\n  this.clusterEnabled = clusterEnabled;\n  this.isHidden = isHidden;\n  this.sourceIds = {\n    fill: 'source-' + uid + '-fill',\n    line: 'source-' + uid + '-line',\n    circle: 'source-' + uid + '-circle',\n    symbol: 'source-' + uid + '-symbol',\n    cluster: 'source-' + uid + '-circle',\n    clusterCount: 'source-' + uid + '-circle'\n  };\n  this.layerIds = {\n    fill: LAYER_PREFIX + uid + '-fill',\n    line: LAYER_PREFIX + uid + '-line',\n    circle: LAYER_PREFIX + uid + '-circle',\n    symbol: LAYER_PREFIX + uid + '-symbol',\n    cluster: LAYER_PREFIX + uid + '-cluster',\n    clusterCount: LAYER_PREFIX + uid + '-cluster-count'\n  };\n\n  // We could merge the 'fill' source with the 'line' source and\n  // the 'circle' source with the 'symbol' source if ever having\n  // for up-to 4 sources per 'scattermapbox' traces becomes a problem.\n\n  // previous 'below' value,\n  // need this to update it properly\n  this.below = null;\n}\nvar proto = ScatterMapbox.prototype;\nproto.addSource = function (k, opts, cluster) {\n  var sourceOpts = {\n    type: 'geojson',\n    data: opts.geojson\n  };\n  if (cluster && cluster.enabled) {\n    Lib.extendFlat(sourceOpts, {\n      cluster: true,\n      clusterMaxZoom: cluster.maxzoom\n    });\n  }\n  var isSourceExists = this.subplot.map.getSource(this.sourceIds[k]);\n  if (isSourceExists) {\n    isSourceExists.setData(opts.geojson);\n  } else {\n    this.subplot.map.addSource(this.sourceIds[k], sourceOpts);\n  }\n};\nproto.setSourceData = function (k, opts) {\n  this.subplot.map.getSource(this.sourceIds[k]).setData(opts.geojson);\n};\nproto.addLayer = function (k, opts, below) {\n  var source = {\n    type: opts.type,\n    id: this.layerIds[k],\n    source: this.sourceIds[k],\n    layout: opts.layout,\n    paint: opts.paint\n  };\n  if (opts.filter) {\n    source.filter = opts.filter;\n  }\n  var currentLayerId = this.layerIds[k];\n  var layerExist;\n  var layers = this.subplot.getMapLayers();\n  for (var i = 0; i < layers.length; i++) {\n    if (layers[i].id === currentLayerId) {\n      layerExist = true;\n      break;\n    }\n  }\n  if (layerExist) {\n    this.subplot.setOptions(currentLayerId, 'setLayoutProperty', source.layout);\n    if (source.layout.visibility === 'visible') {\n      this.subplot.setOptions(currentLayerId, 'setPaintProperty', source.paint);\n    }\n  } else {\n    this.subplot.addLayer(source, below);\n  }\n};\nproto.update = function update(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var subplot = this.subplot;\n  var map = subplot.map;\n  var optsAll = convert(subplot.gd, calcTrace);\n  var below = subplot.belowLookup['trace-' + this.uid];\n  var hasCluster = !!(trace.cluster && trace.cluster.enabled);\n  var hadCluster = !!this.clusterEnabled;\n  var lThis = this;\n  function addCluster(noSource) {\n    if (!noSource) lThis.addSource('circle', optsAll.circle, trace.cluster);\n    var order = ORDER.cluster;\n    for (var i = 0; i < order.length; i++) {\n      var k = order[i];\n      var opts = optsAll[k];\n      lThis.addLayer(k, opts, below);\n    }\n  }\n  function removeCluster(noSource) {\n    var order = ORDER.cluster;\n    for (var i = order.length - 1; i >= 0; i--) {\n      var k = order[i];\n      map.removeLayer(lThis.layerIds[k]);\n    }\n    if (!noSource) map.removeSource(lThis.sourceIds.circle);\n  }\n  function addNonCluster(noSource) {\n    var order = ORDER.nonCluster;\n    for (var i = 0; i < order.length; i++) {\n      var k = order[i];\n      var opts = optsAll[k];\n      if (!noSource) lThis.addSource(k, opts);\n      lThis.addLayer(k, opts, below);\n    }\n  }\n  function removeNonCluster(noSource) {\n    var order = ORDER.nonCluster;\n    for (var i = order.length - 1; i >= 0; i--) {\n      var k = order[i];\n      map.removeLayer(lThis.layerIds[k]);\n      if (!noSource) map.removeSource(lThis.sourceIds[k]);\n    }\n  }\n  function remove(noSource) {\n    if (hadCluster) removeCluster(noSource);else removeNonCluster(noSource);\n  }\n  function add(noSource) {\n    if (hasCluster) addCluster(noSource);else addNonCluster(noSource);\n  }\n  function repaint() {\n    var order = hasCluster ? ORDER.cluster : ORDER.nonCluster;\n    for (var i = 0; i < order.length; i++) {\n      var k = order[i];\n      var opts = optsAll[k];\n      if (!opts) continue;\n      subplot.setOptions(lThis.layerIds[k], 'setLayoutProperty', opts.layout);\n      if (opts.layout.visibility === 'visible') {\n        if (k !== 'cluster') {\n          lThis.setSourceData(k, opts);\n        }\n        subplot.setOptions(lThis.layerIds[k], 'setPaintProperty', opts.paint);\n      }\n    }\n  }\n  var wasHidden = this.isHidden;\n  var isHidden = trace.visible !== true;\n  if (isHidden) {\n    if (!wasHidden) remove();\n  } else if (wasHidden) {\n    if (!isHidden) add();\n  } else if (hadCluster !== hasCluster) {\n    remove();\n    add();\n  } else if (this.below !== below) {\n    remove(true);\n    add(true);\n    repaint();\n  } else {\n    repaint();\n  }\n  this.clusterEnabled = hasCluster;\n  this.isHidden = isHidden;\n  this.below = below;\n\n  // link ref for quick update during selections\n  calcTrace[0].trace._glTrace = this;\n};\nproto.dispose = function dispose() {\n  var map = this.subplot.map;\n  var order = this.clusterEnabled ? ORDER.cluster : ORDER.nonCluster;\n  for (var i = order.length - 1; i >= 0; i--) {\n    var k = order[i];\n    map.removeLayer(this.layerIds[k]);\n    map.removeSource(this.sourceIds[k]);\n  }\n};\nmodule.exports = function createScatterMapbox(subplot, calcTrace) {\n  var trace = calcTrace[0].trace;\n  var hasCluster = trace.cluster && trace.cluster.enabled;\n  var isHidden = trace.visible !== true;\n  var scatterMapbox = new ScatterMapbox(subplot, trace.uid, hasCluster, isHidden);\n  var optsAll = convert(subplot.gd, calcTrace);\n  var below = scatterMapbox.below = subplot.belowLookup['trace-' + trace.uid];\n  var i, k, opts;\n  if (hasCluster) {\n    scatterMapbox.addSource('circle', optsAll.circle, trace.cluster);\n    for (i = 0; i < ORDER.cluster.length; i++) {\n      k = ORDER.cluster[i];\n      opts = optsAll[k];\n      scatterMapbox.addLayer(k, opts, below);\n    }\n  } else {\n    for (i = 0; i < ORDER.nonCluster.length; i++) {\n      k = ORDER.nonCluster[i];\n      opts = optsAll[k];\n      scatterMapbox.addSource(k, opts, trace.cluster);\n      scatterMapbox.addLayer(k, opts, below);\n    }\n  }\n\n  // link ref for quick update during selections\n  calcTrace[0].trace._glTrace = scatterMapbox;\n  return scatterMapbox;\n};","map":{"version":3,"names":["Lib","require","convert","LAYER_PREFIX","traceLayerPrefix","ORDER","cluster","nonCluster","ScatterMapbox","subplot","uid","clusterEnabled","isHidden","type","sourceIds","fill","line","circle","symbol","clusterCount","layerIds","below","proto","prototype","addSource","k","opts","sourceOpts","data","geojson","enabled","extendFlat","clusterMaxZoom","maxzoom","isSourceExists","map","getSource","setData","setSourceData","addLayer","source","id","layout","paint","filter","currentLayerId","layerExist","layers","getMapLayers","i","length","setOptions","visibility","update","calcTrace","trace","optsAll","gd","belowLookup","hasCluster","hadCluster","lThis","addCluster","noSource","order","removeCluster","removeLayer","removeSource","addNonCluster","removeNonCluster","remove","add","repaint","wasHidden","visible","_glTrace","dispose","module","exports","createScatterMapbox","scatterMapbox"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scattermapbox/plot.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar convert = require('./convert');\nvar LAYER_PREFIX = require('../../plots/mapbox/constants').traceLayerPrefix;\nvar ORDER = {\n    cluster: ['cluster', 'clusterCount', 'circle'],\n    nonCluster: ['fill', 'line', 'circle', 'symbol'],\n};\n\nfunction ScatterMapbox(subplot, uid, clusterEnabled, isHidden) {\n    this.type = 'scattermapbox';\n    this.subplot = subplot;\n    this.uid = uid;\n    this.clusterEnabled = clusterEnabled;\n    this.isHidden = isHidden;\n\n    this.sourceIds = {\n        fill: 'source-' + uid + '-fill',\n        line: 'source-' + uid + '-line',\n        circle: 'source-' + uid + '-circle',\n        symbol: 'source-' + uid + '-symbol',\n        cluster: 'source-' + uid + '-circle',\n        clusterCount: 'source-' + uid + '-circle',\n    };\n\n    this.layerIds = {\n        fill: LAYER_PREFIX + uid + '-fill',\n        line: LAYER_PREFIX + uid + '-line',\n        circle: LAYER_PREFIX + uid + '-circle',\n        symbol: LAYER_PREFIX + uid + '-symbol',\n        cluster: LAYER_PREFIX + uid + '-cluster',\n        clusterCount: LAYER_PREFIX + uid + '-cluster-count',\n    };\n\n    // We could merge the 'fill' source with the 'line' source and\n    // the 'circle' source with the 'symbol' source if ever having\n    // for up-to 4 sources per 'scattermapbox' traces becomes a problem.\n\n    // previous 'below' value,\n    // need this to update it properly\n    this.below = null;\n}\n\nvar proto = ScatterMapbox.prototype;\n\nproto.addSource = function(k, opts, cluster) {\n    var sourceOpts = {\n        type: 'geojson',\n        data: opts.geojson,\n    };\n\n    if(cluster && cluster.enabled) {\n        Lib.extendFlat(sourceOpts, {\n            cluster: true,\n            clusterMaxZoom: cluster.maxzoom,\n        });\n    }\n    var isSourceExists = this.subplot.map.getSource(this.sourceIds[k]);\n    if(isSourceExists) {\n        isSourceExists.setData(opts.geojson);\n    } else {\n        this.subplot.map.addSource(this.sourceIds[k], sourceOpts);\n    }\n};\n\nproto.setSourceData = function(k, opts) {\n    this.subplot.map\n        .getSource(this.sourceIds[k])\n        .setData(opts.geojson);\n};\n\nproto.addLayer = function(k, opts, below) {\n    var source = {\n        type: opts.type,\n        id: this.layerIds[k],\n        source: this.sourceIds[k],\n        layout: opts.layout,\n        paint: opts.paint,\n    };\n    if(opts.filter) {\n        source.filter = opts.filter;\n    }\n    var currentLayerId = this.layerIds[k];\n    var layerExist;\n    var layers = this.subplot.getMapLayers();\n    for(var i = 0; i < layers.length; i++) {\n        if(layers[i].id === currentLayerId) {\n            layerExist = true;\n            break;\n        }\n    }\n\n    if(layerExist) {\n        this.subplot.setOptions(currentLayerId, 'setLayoutProperty', source.layout);\n        if(source.layout.visibility === 'visible') {\n            this.subplot.setOptions(currentLayerId, 'setPaintProperty', source.paint);\n        }\n    } else {\n        this.subplot.addLayer(source, below);\n    }\n};\n\nproto.update = function update(calcTrace) {\n    var trace = calcTrace[0].trace;\n    var subplot = this.subplot;\n    var map = subplot.map;\n    var optsAll = convert(subplot.gd, calcTrace);\n    var below = subplot.belowLookup['trace-' + this.uid];\n    var hasCluster = !!(trace.cluster && trace.cluster.enabled);\n    var hadCluster = !!this.clusterEnabled;\n    var lThis = this;\n\n    function addCluster(noSource) {\n        if(!noSource) lThis.addSource('circle', optsAll.circle, trace.cluster);\n        var order = ORDER.cluster;\n        for(var i = 0; i < order.length; i++) {\n            var k = order[i];\n            var opts = optsAll[k];\n            lThis.addLayer(k, opts, below);\n        }\n    }\n\n    function removeCluster(noSource) {\n        var order = ORDER.cluster;\n        for(var i = order.length - 1; i >= 0; i--) {\n            var k = order[i];\n            map.removeLayer(lThis.layerIds[k]);\n        }\n        if(!noSource) map.removeSource(lThis.sourceIds.circle);\n    }\n\n    function addNonCluster(noSource) {\n        var order = ORDER.nonCluster;\n        for(var i = 0; i < order.length; i++) {\n            var k = order[i];\n            var opts = optsAll[k];\n            if(!noSource) lThis.addSource(k, opts);\n            lThis.addLayer(k, opts, below);\n        }\n    }\n\n    function removeNonCluster(noSource) {\n        var order = ORDER.nonCluster;\n        for(var i = order.length - 1; i >= 0; i--) {\n            var k = order[i];\n            map.removeLayer(lThis.layerIds[k]);\n            if(!noSource) map.removeSource(lThis.sourceIds[k]);\n        }\n    }\n\n    function remove(noSource) {\n        if(hadCluster) removeCluster(noSource); else removeNonCluster(noSource);\n    }\n\n    function add(noSource) {\n        if(hasCluster) addCluster(noSource); else addNonCluster(noSource);\n    }\n\n    function repaint() {\n        var order = hasCluster ? ORDER.cluster : ORDER.nonCluster;\n        for(var i = 0; i < order.length; i++) {\n            var k = order[i];\n            var opts = optsAll[k];\n            if(!opts) continue;\n\n            subplot.setOptions(lThis.layerIds[k], 'setLayoutProperty', opts.layout);\n\n            if(opts.layout.visibility === 'visible') {\n                if(k !== 'cluster') {\n                    lThis.setSourceData(k, opts);\n                }\n                subplot.setOptions(lThis.layerIds[k], 'setPaintProperty', opts.paint);\n            }\n        }\n    }\n\n    var wasHidden = this.isHidden;\n    var isHidden = trace.visible !== true;\n\n    if(isHidden) {\n        if(!wasHidden) remove();\n    } else if(wasHidden) {\n        if(!isHidden) add();\n    } else if(hadCluster !== hasCluster) {\n        remove();\n        add();\n    } else if(this.below !== below) {\n        remove(true);\n        add(true);\n        repaint();\n    } else {\n        repaint();\n    }\n\n    this.clusterEnabled = hasCluster;\n    this.isHidden = isHidden;\n    this.below = below;\n\n    // link ref for quick update during selections\n    calcTrace[0].trace._glTrace = this;\n};\n\nproto.dispose = function dispose() {\n    var map = this.subplot.map;\n    var order = this.clusterEnabled ? ORDER.cluster : ORDER.nonCluster;\n    for(var i = order.length - 1; i >= 0; i--) {\n        var k = order[i];\n        map.removeLayer(this.layerIds[k]);\n        map.removeSource(this.sourceIds[k]);\n    }\n};\n\nmodule.exports = function createScatterMapbox(subplot, calcTrace) {\n    var trace = calcTrace[0].trace;\n    var hasCluster = trace.cluster && trace.cluster.enabled;\n    var isHidden = trace.visible !== true;\n\n    var scatterMapbox = new ScatterMapbox(\n        subplot,\n        trace.uid,\n        hasCluster,\n        isHidden\n    );\n\n    var optsAll = convert(subplot.gd, calcTrace);\n    var below = scatterMapbox.below = subplot.belowLookup['trace-' + trace.uid];\n    var i, k, opts;\n\n    if(hasCluster) {\n        scatterMapbox.addSource('circle', optsAll.circle, trace.cluster);\n        for(i = 0; i < ORDER.cluster.length; i++) {\n            k = ORDER.cluster[i];\n            opts = optsAll[k];\n            scatterMapbox.addLayer(k, opts, below);\n        }\n    } else {\n        for(i = 0; i < ORDER.nonCluster.length; i++) {\n            k = ORDER.nonCluster[i];\n            opts = optsAll[k];\n            scatterMapbox.addSource(k, opts, trace.cluster);\n            scatterMapbox.addLayer(k, opts, below);\n        }\n    }\n\n    // link ref for quick update during selections\n    calcTrace[0].trace._glTrace = scatterMapbox;\n\n    return scatterMapbox;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}