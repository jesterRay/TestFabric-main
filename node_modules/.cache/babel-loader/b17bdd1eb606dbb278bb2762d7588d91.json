{"ast":null,"code":"'use strict';\n\nvar mouseOffset = require('mouse-event-offset');\nvar hasHover = require('has-hover');\nvar supportsPassive = require('has-passive-events');\nvar removeElement = require('../../lib').removeElement;\nvar constants = require('../../plots/cartesian/constants');\nvar dragElement = module.exports = {};\ndragElement.align = require('./align');\ndragElement.getCursor = require('./cursor');\nvar unhover = require('./unhover');\ndragElement.unhover = unhover.wrapped;\ndragElement.unhoverRaw = unhover.raw;\n\n/**\n * Abstracts click & drag interactions\n *\n * During the interaction, a \"coverSlip\" element - a transparent\n * div covering the whole page - is created, which has two key effects:\n * - Lets you drag beyond the boundaries of the plot itself without\n *   dropping (but if you drag all the way out of the browser window the\n *   interaction will end)\n * - Freezes the cursor: whatever mouse cursor the drag element had when the\n *   interaction started gets copied to the coverSlip for use until mouseup\n *\n * If the user executes a drag bigger than MINDRAG, callbacks will fire as:\n *      prepFn, moveFn (1 or more times), doneFn\n * If the user does not drag enough, prepFn and clickFn will fire.\n *\n * Note: If you cancel contextmenu, clickFn will fire even with a right click\n * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:\n *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });\n * TODO: we should probably turn this into a `config` parameter, so we can fix it\n * such that if you *don't* cancel contextmenu, we can prevent partial drags, which\n * put you in a weird state.\n *\n * If the user clicks multiple times quickly, clickFn will fire each time\n * but numClicks will increase to help you recognize doubleclicks.\n *\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy)\n *          executed on move, ONLY after we've exceeded MINDRAG\n *          (we keep executing moveFn if you move back to where you started)\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(e)\n *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be\n *          sure that moveFn has been called at least once)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mouseup event\n *      clickFn (optional) function(numClicks, e)\n *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn\n *          has not been called at all)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mousedown event\n *      clampFn (optional, function(dx, dy) return [dx2, dy2])\n *          Provide custom clamping function for small displacements.\n *          By default, clamping is done using `minDrag` to x and y displacements\n *          independently.\n */\ndragElement.init = function init(options) {\n  var gd = options.gd;\n  var numClicks = 1;\n  var doubleClickDelay = gd._context.doubleClickDelay;\n  var element = options.element;\n  var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;\n  if (!gd._mouseDownTime) gd._mouseDownTime = 0;\n  element.style.pointerEvents = 'all';\n  element.onmousedown = onStart;\n  if (!supportsPassive) {\n    element.ontouchstart = onStart;\n  } else {\n    if (element._ontouchstart) {\n      element.removeEventListener('touchstart', element._ontouchstart);\n    }\n    element._ontouchstart = onStart;\n    element.addEventListener('touchstart', onStart, {\n      passive: false\n    });\n  }\n  function _clampFn(dx, dy, minDrag) {\n    if (Math.abs(dx) < minDrag) dx = 0;\n    if (Math.abs(dy) < minDrag) dy = 0;\n    return [dx, dy];\n  }\n  var clampFn = options.clampFn || _clampFn;\n  function onStart(e) {\n    // make dragging and dragged into properties of gd\n    // so that others can look at and modify them\n    gd._dragged = false;\n    gd._dragging = true;\n    var offset = pointerOffset(e);\n    startX = offset[0];\n    startY = offset[1];\n    initialTarget = e.target;\n    initialEvent = e;\n    rightClick = e.buttons === 2 || e.ctrlKey;\n\n    // fix Fx.hover for touch events\n    if (typeof e.clientX === 'undefined' && typeof e.clientY === 'undefined') {\n      e.clientX = startX;\n      e.clientY = startY;\n    }\n    newMouseDownTime = new Date().getTime();\n    if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {\n      // in a click train\n      numClicks += 1;\n    } else {\n      // new click train\n      numClicks = 1;\n      gd._mouseDownTime = newMouseDownTime;\n    }\n    if (options.prepFn) options.prepFn(e, startX, startY);\n    if (hasHover && !rightClick) {\n      dragCover = coverSlip();\n      dragCover.style.cursor = window.getComputedStyle(element).cursor;\n    } else if (!hasHover) {\n      // document acts as a dragcover for mobile, bc we can't create dragcover dynamically\n      dragCover = document;\n      cursor = window.getComputedStyle(document.documentElement).cursor;\n      document.documentElement.style.cursor = window.getComputedStyle(element).cursor;\n    }\n    document.addEventListener('mouseup', onDone);\n    document.addEventListener('touchend', onDone);\n    if (options.dragmode !== false) {\n      e.preventDefault();\n      document.addEventListener('mousemove', onMove);\n      document.addEventListener('touchmove', onMove, {\n        passive: false\n      });\n    }\n    return;\n  }\n  function onMove(e) {\n    e.preventDefault();\n    var offset = pointerOffset(e);\n    var minDrag = options.minDrag || constants.MINDRAG;\n    var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);\n    var dx = dxdy[0];\n    var dy = dxdy[1];\n    if (dx || dy) {\n      gd._dragged = true;\n      dragElement.unhover(gd, e);\n    }\n    if (gd._dragged && options.moveFn && !rightClick) {\n      gd._dragdata = {\n        element: element,\n        dx: dx,\n        dy: dy\n      };\n      options.moveFn(dx, dy);\n    }\n    return;\n  }\n  function onDone(e) {\n    delete gd._dragdata;\n    if (options.dragmode !== false) {\n      e.preventDefault();\n      document.removeEventListener('mousemove', onMove);\n      document.removeEventListener('touchmove', onMove);\n    }\n    document.removeEventListener('mouseup', onDone);\n    document.removeEventListener('touchend', onDone);\n    if (hasHover) {\n      removeElement(dragCover);\n    } else if (cursor) {\n      dragCover.documentElement.style.cursor = cursor;\n      cursor = null;\n    }\n    if (!gd._dragging) {\n      gd._dragged = false;\n      return;\n    }\n    gd._dragging = false;\n\n    // don't count as a dblClick unless the mouseUp is also within\n    // the dblclick delay\n    if (new Date().getTime() - gd._mouseDownTime > doubleClickDelay) {\n      numClicks = Math.max(numClicks - 1, 1);\n    }\n    if (gd._dragged) {\n      if (options.doneFn) options.doneFn();\n    } else {\n      if (options.clickFn) options.clickFn(numClicks, initialEvent);\n\n      // If we haven't dragged, this should be a click. But because of the\n      // coverSlip changing the element, the natural system might not generate one,\n      // so we need to make our own. But right clicks don't normally generate\n      // click events, only contextmenu events, which happen on mousedown.\n      if (!rightClick) {\n        var e2;\n        try {\n          e2 = new MouseEvent('click', e);\n        } catch (err) {\n          var offset = pointerOffset(e);\n          e2 = document.createEvent('MouseEvents');\n          e2.initMouseEvent('click', e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, offset[0], offset[1], e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n        }\n        initialTarget.dispatchEvent(e2);\n      }\n    }\n    gd._dragging = false;\n    gd._dragged = false;\n    return;\n  }\n};\nfunction coverSlip() {\n  var cover = document.createElement('div');\n  cover.className = 'dragcover';\n  var cStyle = cover.style;\n  cStyle.position = 'fixed';\n  cStyle.left = 0;\n  cStyle.right = 0;\n  cStyle.top = 0;\n  cStyle.bottom = 0;\n  cStyle.zIndex = 999999999;\n  cStyle.background = 'none';\n  document.body.appendChild(cover);\n  return cover;\n}\ndragElement.coverSlip = coverSlip;\nfunction pointerOffset(e) {\n  return mouseOffset(e.changedTouches ? e.changedTouches[0] : e, document.body);\n}","map":{"version":3,"names":["mouseOffset","require","hasHover","supportsPassive","removeElement","constants","dragElement","module","exports","align","getCursor","unhover","wrapped","unhoverRaw","raw","init","options","gd","numClicks","doubleClickDelay","_context","element","startX","startY","newMouseDownTime","cursor","dragCover","initialEvent","initialTarget","rightClick","_mouseDownTime","style","pointerEvents","onmousedown","onStart","ontouchstart","_ontouchstart","removeEventListener","addEventListener","passive","_clampFn","dx","dy","minDrag","Math","abs","clampFn","e","_dragged","_dragging","offset","pointerOffset","target","buttons","ctrlKey","clientX","clientY","Date","getTime","prepFn","coverSlip","window","getComputedStyle","document","documentElement","onDone","dragmode","preventDefault","onMove","MINDRAG","dxdy","moveFn","_dragdata","max","doneFn","clickFn","e2","MouseEvent","err","createEvent","initMouseEvent","bubbles","cancelable","view","detail","screenX","screenY","altKey","shiftKey","metaKey","button","relatedTarget","dispatchEvent","cover","createElement","className","cStyle","position","left","right","top","bottom","zIndex","background","body","appendChild","changedTouches"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/dragelement/index.js"],"sourcesContent":["'use strict';\n\nvar mouseOffset = require('mouse-event-offset');\nvar hasHover = require('has-hover');\nvar supportsPassive = require('has-passive-events');\n\nvar removeElement = require('../../lib').removeElement;\nvar constants = require('../../plots/cartesian/constants');\n\nvar dragElement = module.exports = {};\n\ndragElement.align = require('./align');\ndragElement.getCursor = require('./cursor');\n\nvar unhover = require('./unhover');\ndragElement.unhover = unhover.wrapped;\ndragElement.unhoverRaw = unhover.raw;\n\n/**\n * Abstracts click & drag interactions\n *\n * During the interaction, a \"coverSlip\" element - a transparent\n * div covering the whole page - is created, which has two key effects:\n * - Lets you drag beyond the boundaries of the plot itself without\n *   dropping (but if you drag all the way out of the browser window the\n *   interaction will end)\n * - Freezes the cursor: whatever mouse cursor the drag element had when the\n *   interaction started gets copied to the coverSlip for use until mouseup\n *\n * If the user executes a drag bigger than MINDRAG, callbacks will fire as:\n *      prepFn, moveFn (1 or more times), doneFn\n * If the user does not drag enough, prepFn and clickFn will fire.\n *\n * Note: If you cancel contextmenu, clickFn will fire even with a right click\n * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:\n *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });\n * TODO: we should probably turn this into a `config` parameter, so we can fix it\n * such that if you *don't* cancel contextmenu, we can prevent partial drags, which\n * put you in a weird state.\n *\n * If the user clicks multiple times quickly, clickFn will fire each time\n * but numClicks will increase to help you recognize doubleclicks.\n *\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy)\n *          executed on move, ONLY after we've exceeded MINDRAG\n *          (we keep executing moveFn if you move back to where you started)\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(e)\n *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be\n *          sure that moveFn has been called at least once)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mouseup event\n *      clickFn (optional) function(numClicks, e)\n *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn\n *          has not been called at all)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mousedown event\n *      clampFn (optional, function(dx, dy) return [dx2, dy2])\n *          Provide custom clamping function for small displacements.\n *          By default, clamping is done using `minDrag` to x and y displacements\n *          independently.\n */\ndragElement.init = function init(options) {\n    var gd = options.gd;\n    var numClicks = 1;\n    var doubleClickDelay = gd._context.doubleClickDelay;\n    var element = options.element;\n\n    var startX,\n        startY,\n        newMouseDownTime,\n        cursor,\n        dragCover,\n        initialEvent,\n        initialTarget,\n        rightClick;\n\n    if(!gd._mouseDownTime) gd._mouseDownTime = 0;\n\n    element.style.pointerEvents = 'all';\n\n    element.onmousedown = onStart;\n\n    if(!supportsPassive) {\n        element.ontouchstart = onStart;\n    } else {\n        if(element._ontouchstart) {\n            element.removeEventListener('touchstart', element._ontouchstart);\n        }\n        element._ontouchstart = onStart;\n        element.addEventListener('touchstart', onStart, {passive: false});\n    }\n\n    function _clampFn(dx, dy, minDrag) {\n        if(Math.abs(dx) < minDrag) dx = 0;\n        if(Math.abs(dy) < minDrag) dy = 0;\n        return [dx, dy];\n    }\n\n    var clampFn = options.clampFn || _clampFn;\n\n    function onStart(e) {\n        // make dragging and dragged into properties of gd\n        // so that others can look at and modify them\n        gd._dragged = false;\n        gd._dragging = true;\n        var offset = pointerOffset(e);\n        startX = offset[0];\n        startY = offset[1];\n        initialTarget = e.target;\n        initialEvent = e;\n        rightClick = e.buttons === 2 || e.ctrlKey;\n\n        // fix Fx.hover for touch events\n        if(typeof e.clientX === 'undefined' && typeof e.clientY === 'undefined') {\n            e.clientX = startX;\n            e.clientY = startY;\n        }\n\n        newMouseDownTime = (new Date()).getTime();\n        if(newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {\n            // in a click train\n            numClicks += 1;\n        } else {\n            // new click train\n            numClicks = 1;\n            gd._mouseDownTime = newMouseDownTime;\n        }\n\n        if(options.prepFn) options.prepFn(e, startX, startY);\n\n        if(hasHover && !rightClick) {\n            dragCover = coverSlip();\n            dragCover.style.cursor = window.getComputedStyle(element).cursor;\n        } else if(!hasHover) {\n            // document acts as a dragcover for mobile, bc we can't create dragcover dynamically\n            dragCover = document;\n            cursor = window.getComputedStyle(document.documentElement).cursor;\n            document.documentElement.style.cursor = window.getComputedStyle(element).cursor;\n        }\n\n        document.addEventListener('mouseup', onDone);\n        document.addEventListener('touchend', onDone);\n\n        if(options.dragmode !== false) {\n            e.preventDefault();\n            document.addEventListener('mousemove', onMove);\n            document.addEventListener('touchmove', onMove, {passive: false});\n        }\n\n        return;\n    }\n\n    function onMove(e) {\n        e.preventDefault();\n\n        var offset = pointerOffset(e);\n        var minDrag = options.minDrag || constants.MINDRAG;\n        var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);\n        var dx = dxdy[0];\n        var dy = dxdy[1];\n\n        if(dx || dy) {\n            gd._dragged = true;\n            dragElement.unhover(gd, e);\n        }\n\n        if(gd._dragged && options.moveFn && !rightClick) {\n            gd._dragdata = {\n                element: element,\n                dx: dx,\n                dy: dy\n            };\n            options.moveFn(dx, dy);\n        }\n\n        return;\n    }\n\n    function onDone(e) {\n        delete gd._dragdata;\n\n        if(options.dragmode !== false) {\n            e.preventDefault();\n            document.removeEventListener('mousemove', onMove);\n            document.removeEventListener('touchmove', onMove);\n        }\n\n        document.removeEventListener('mouseup', onDone);\n        document.removeEventListener('touchend', onDone);\n\n        if(hasHover) {\n            removeElement(dragCover);\n        } else if(cursor) {\n            dragCover.documentElement.style.cursor = cursor;\n            cursor = null;\n        }\n\n        if(!gd._dragging) {\n            gd._dragged = false;\n            return;\n        }\n        gd._dragging = false;\n\n        // don't count as a dblClick unless the mouseUp is also within\n        // the dblclick delay\n        if((new Date()).getTime() - gd._mouseDownTime > doubleClickDelay) {\n            numClicks = Math.max(numClicks - 1, 1);\n        }\n\n        if(gd._dragged) {\n            if(options.doneFn) options.doneFn();\n        } else {\n            if(options.clickFn) options.clickFn(numClicks, initialEvent);\n\n            // If we haven't dragged, this should be a click. But because of the\n            // coverSlip changing the element, the natural system might not generate one,\n            // so we need to make our own. But right clicks don't normally generate\n            // click events, only contextmenu events, which happen on mousedown.\n            if(!rightClick) {\n                var e2;\n\n                try {\n                    e2 = new MouseEvent('click', e);\n                } catch(err) {\n                    var offset = pointerOffset(e);\n                    e2 = document.createEvent('MouseEvents');\n                    e2.initMouseEvent('click',\n                        e.bubbles, e.cancelable,\n                        e.view, e.detail,\n                        e.screenX, e.screenY,\n                        offset[0], offset[1],\n                        e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n                        e.button, e.relatedTarget);\n                }\n\n                initialTarget.dispatchEvent(e2);\n            }\n        }\n\n        gd._dragging = false;\n        gd._dragged = false;\n        return;\n    }\n};\n\nfunction coverSlip() {\n    var cover = document.createElement('div');\n\n    cover.className = 'dragcover';\n    var cStyle = cover.style;\n    cStyle.position = 'fixed';\n    cStyle.left = 0;\n    cStyle.right = 0;\n    cStyle.top = 0;\n    cStyle.bottom = 0;\n    cStyle.zIndex = 999999999;\n    cStyle.background = 'none';\n\n    document.body.appendChild(cover);\n\n    return cover;\n}\n\ndragElement.coverSlip = coverSlip;\n\nfunction pointerOffset(e) {\n    return mouseOffset(\n        e.changedTouches ? e.changedTouches[0] : e,\n        document.body\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}