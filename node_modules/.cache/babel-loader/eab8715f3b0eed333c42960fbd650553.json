{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar Color = require('../../components/color');\nvar fillText = require('../../lib').fillText;\nvar getLineWidth = require('./helpers').getLineWidth;\nvar hoverLabelText = require('../../plots/cartesian/axes').hoverLabelText;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nfunction hoverPoints(pointData, xval, yval, hovermode, opts) {\n  var barPointData = hoverOnBars(pointData, xval, yval, hovermode, opts);\n  if (barPointData) {\n    var cd = barPointData.cd;\n    var trace = cd[0].trace;\n    var di = cd[barPointData.index];\n    barPointData.color = getTraceColor(trace, di);\n    Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, barPointData);\n    return [barPointData];\n  }\n}\nfunction hoverOnBars(pointData, xval, yval, hovermode, opts) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isClosest = hovermode === 'closest';\n  var isWaterfall = trace.type === 'waterfall';\n  var maxHoverDistance = pointData.maxHoverDistance;\n  var maxSpikeDistance = pointData.maxSpikeDistance;\n  var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n  if (trace.orientation === 'h') {\n    posVal = yval;\n    sizeVal = xval;\n    posLetter = 'y';\n    sizeLetter = 'x';\n    dx = sizeFn;\n    dy = positionFn;\n  } else {\n    posVal = xval;\n    sizeVal = yval;\n    posLetter = 'x';\n    sizeLetter = 'y';\n    dy = sizeFn;\n    dx = positionFn;\n  }\n  var period = trace[posLetter + 'period'];\n  var isClosestOrPeriod = isClosest || period;\n  function thisBarMinPos(di) {\n    return thisBarExtPos(di, -1);\n  }\n  function thisBarMaxPos(di) {\n    return thisBarExtPos(di, 1);\n  }\n  function thisBarExtPos(di, sgn) {\n    var w = di.w;\n    return di[posLetter] + sgn * w / 2;\n  }\n  function periodLength(di) {\n    return di[posLetter + 'End'] - di[posLetter + 'Start'];\n  }\n  var minPos = isClosest ? thisBarMinPos : period ? function (di) {\n    return di.p - periodLength(di) / 2;\n  } : function (di) {\n    /*\n     * In compare mode, accept a bar if you're on it *or* its group.\n     * Nearly always it's the group that matters, but in case the bar\n     * was explicitly set wider than its group we'd better accept the\n     * whole bar.\n     *\n     * use `bardelta` instead of `bargroupwidth` so we accept hover\n     * in the gap. That way hover doesn't flash on and off as you\n     * mouse over the plot in compare modes.\n     * In 'closest' mode though the flashing seems inevitable,\n     * without far more complex logic\n     */\n    return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n  };\n  var maxPos = isClosest ? thisBarMaxPos : period ? function (di) {\n    return di.p + periodLength(di) / 2;\n  } : function (di) {\n    return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n  };\n  function inbox(_minPos, _maxPos, maxDistance) {\n    if (opts.finiteRange) maxDistance = 0;\n\n    // add a little to the pseudo-distance for wider bars, so that like scatter,\n    // if you are over two overlapping bars, the narrower one wins.\n    return Fx.inbox(_minPos - posVal, _maxPos - posVal, maxDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n  }\n  function positionFn(di) {\n    return inbox(minPos(di), maxPos(di), maxHoverDistance);\n  }\n  function thisBarPositionFn(di) {\n    return inbox(thisBarMinPos(di), thisBarMaxPos(di), maxSpikeDistance);\n  }\n  function getSize(di) {\n    var s = di[sizeLetter];\n    if (isWaterfall) {\n      var rawS = Math.abs(di.rawS) || 0;\n      if (sizeVal > 0) {\n        s += rawS;\n      } else if (sizeVal < 0) {\n        s -= rawS;\n      }\n    }\n    return s;\n  }\n  function sizeFn(di) {\n    var v = sizeVal;\n    var b = di.b;\n    var s = getSize(di);\n\n    // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n    return Fx.inbox(b - v, s - v, maxHoverDistance + (s - v) / (s - b) - 1);\n  }\n  function thisBarSizeFn(di) {\n    var v = sizeVal;\n    var b = di.b;\n    var s = getSize(di);\n\n    // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n    return Fx.inbox(b - v, s - v, maxSpikeDistance + (s - v) / (s - b) - 1);\n  }\n  var pa = pointData[posLetter + 'a'];\n  var sa = pointData[sizeLetter + 'a'];\n  pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData);\n\n  // skip the rest (for this trace) if we didn't find a close point\n  if (pointData.index === false) return;\n\n  // skip points inside axis rangebreaks\n  if (cd[pointData.index].p === BADNUM) return;\n\n  // if we get here and we're not in 'closest' mode, push min/max pos back\n  // onto the group - even though that means occasionally the mouse will be\n  // over the hover label.\n  if (!isClosestOrPeriod) {\n    minPos = function (di) {\n      return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n    };\n    maxPos = function (di) {\n      return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n    };\n  }\n\n  // the closest data point\n  var index = pointData.index;\n  var di = cd[index];\n  var size = trace.base ? di.b + di.s : di.s;\n  pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n  pointData[sizeLetter + 'LabelVal'] = size;\n  var extent = t.extents[t.extents.round(di.p)];\n  pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n  pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n  var hasPeriod = di.orig_p !== undefined;\n  pointData[posLetter + 'LabelVal'] = hasPeriod ? di.orig_p : di.p;\n  pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + 'LabelVal'], trace[posLetter + 'hoverformat']);\n  pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + 'LabelVal'], trace[sizeLetter + 'hoverformat']);\n  pointData.baseLabel = hoverLabelText(sa, di.b, trace[sizeLetter + 'hoverformat']);\n\n  // spikelines always want \"closest\" distance regardless of hovermode\n  pointData.spikeDistance = (thisBarSizeFn(di) + thisBarPositionFn(di)) / 2;\n  // they also want to point to the data value, regardless of where the label goes\n  // in case of bars shifted within groups\n  pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n  fillText(di, trace, pointData);\n  pointData.hovertemplate = trace.hovertemplate;\n  return pointData;\n}\nfunction getTraceColor(trace, di) {\n  var mc = di.mcc || trace.marker.color;\n  var mlc = di.mlcc || trace.marker.line.color;\n  var mlw = getLineWidth(trace, di);\n  if (Color.opacity(mc)) return mc;else if (Color.opacity(mlc) && mlw) return mlc;\n}\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBars: hoverOnBars,\n  getTraceColor: getTraceColor\n};","map":{"version":3,"names":["Fx","require","Registry","Color","fillText","getLineWidth","hoverLabelText","BADNUM","hoverPoints","pointData","xval","yval","hovermode","opts","barPointData","hoverOnBars","cd","trace","di","index","color","getTraceColor","getComponentMethod","t","isClosest","isWaterfall","type","maxHoverDistance","maxSpikeDistance","posVal","sizeVal","posLetter","sizeLetter","dx","dy","pRangeCalc","orientation","sizeFn","positionFn","period","isClosestOrPeriod","thisBarMinPos","thisBarExtPos","thisBarMaxPos","sgn","w","periodLength","minPos","p","Math","min","bardelta","maxPos","max","inbox","_minPos","_maxPos","maxDistance","finiteRange","abs","thisBarPositionFn","getSize","s","rawS","v","b","thisBarSizeFn","pa","sa","r2c","range","dxy","distfn","getDistanceFunction","getClosest","bargroupwidth","size","base","c2p","extent","extents","round","hasPeriod","orig_p","undefined","labelLabel","valueLabel","baseLabel","spikeDistance","hovertemplate","mc","mcc","marker","mlc","mlcc","line","mlw","opacity","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/bar/hover.js"],"sourcesContent":["'use strict';\n\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar Color = require('../../components/color');\n\nvar fillText = require('../../lib').fillText;\nvar getLineWidth = require('./helpers').getLineWidth;\nvar hoverLabelText = require('../../plots/cartesian/axes').hoverLabelText;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction hoverPoints(pointData, xval, yval, hovermode, opts) {\n    var barPointData = hoverOnBars(pointData, xval, yval, hovermode, opts);\n\n    if(barPointData) {\n        var cd = barPointData.cd;\n        var trace = cd[0].trace;\n        var di = cd[barPointData.index];\n\n        barPointData.color = getTraceColor(trace, di);\n        Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, barPointData);\n\n        return [barPointData];\n    }\n}\n\nfunction hoverOnBars(pointData, xval, yval, hovermode, opts) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isClosest = (hovermode === 'closest');\n    var isWaterfall = (trace.type === 'waterfall');\n    var maxHoverDistance = pointData.maxHoverDistance;\n    var maxSpikeDistance = pointData.maxSpikeDistance;\n\n    var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n\n    if(trace.orientation === 'h') {\n        posVal = yval;\n        sizeVal = xval;\n        posLetter = 'y';\n        sizeLetter = 'x';\n        dx = sizeFn;\n        dy = positionFn;\n    } else {\n        posVal = xval;\n        sizeVal = yval;\n        posLetter = 'x';\n        sizeLetter = 'y';\n        dy = sizeFn;\n        dx = positionFn;\n    }\n\n    var period = trace[posLetter + 'period'];\n    var isClosestOrPeriod = isClosest || period;\n\n    function thisBarMinPos(di) { return thisBarExtPos(di, -1); }\n    function thisBarMaxPos(di) { return thisBarExtPos(di, 1); }\n\n    function thisBarExtPos(di, sgn) {\n        var w = di.w;\n\n        return di[posLetter] + sgn * w / 2;\n    }\n\n    function periodLength(di) {\n        return di[posLetter + 'End'] - di[posLetter + 'Start'];\n    }\n\n    var minPos = isClosest ?\n        thisBarMinPos : period ?\n        function(di) {\n            return di.p - periodLength(di) / 2;\n        } :\n        function(di) {\n            /*\n             * In compare mode, accept a bar if you're on it *or* its group.\n             * Nearly always it's the group that matters, but in case the bar\n             * was explicitly set wider than its group we'd better accept the\n             * whole bar.\n             *\n             * use `bardelta` instead of `bargroupwidth` so we accept hover\n             * in the gap. That way hover doesn't flash on and off as you\n             * mouse over the plot in compare modes.\n             * In 'closest' mode though the flashing seems inevitable,\n             * without far more complex logic\n             */\n            return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n        };\n\n    var maxPos = isClosest ?\n        thisBarMaxPos : period ?\n        function(di) {\n            return di.p + periodLength(di) / 2;\n        } :\n        function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n        };\n\n    function inbox(_minPos, _maxPos, maxDistance) {\n        if(opts.finiteRange) maxDistance = 0;\n\n        // add a little to the pseudo-distance for wider bars, so that like scatter,\n        // if you are over two overlapping bars, the narrower one wins.\n        return Fx.inbox(_minPos - posVal, _maxPos - posVal,\n            maxDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n    }\n\n    function positionFn(di) {\n        return inbox(minPos(di), maxPos(di), maxHoverDistance);\n    }\n\n    function thisBarPositionFn(di) {\n        return inbox(thisBarMinPos(di), thisBarMaxPos(di), maxSpikeDistance);\n    }\n\n    function getSize(di) {\n        var s = di[sizeLetter];\n\n        if(isWaterfall) {\n            var rawS = Math.abs(di.rawS) || 0;\n            if(sizeVal > 0) {\n                s += rawS;\n            } else if(sizeVal < 0) {\n                s -= rawS;\n            }\n        }\n\n        return s;\n    }\n\n    function sizeFn(di) {\n        var v = sizeVal;\n        var b = di.b;\n        var s = getSize(di);\n\n        // add a gradient so hovering near the end of a\n        // bar makes it a little closer match\n        return Fx.inbox(b - v, s - v, maxHoverDistance + (s - v) / (s - b) - 1);\n    }\n\n    function thisBarSizeFn(di) {\n        var v = sizeVal;\n        var b = di.b;\n        var s = getSize(di);\n\n        // add a gradient so hovering near the end of a\n        // bar makes it a little closer match\n        return Fx.inbox(b - v, s - v, maxSpikeDistance + (s - v) / (s - b) - 1);\n    }\n\n    var pa = pointData[posLetter + 'a'];\n    var sa = pointData[sizeLetter + 'a'];\n\n    pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    // skip points inside axis rangebreaks\n    if(cd[pointData.index].p === BADNUM) return;\n\n    // if we get here and we're not in 'closest' mode, push min/max pos back\n    // onto the group - even though that means occasionally the mouse will be\n    // over the hover label.\n    if(!isClosestOrPeriod) {\n        minPos = function(di) {\n            return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n        };\n        maxPos = function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n        };\n    }\n\n    // the closest data point\n    var index = pointData.index;\n    var di = cd[index];\n\n    var size = (trace.base) ? di.b + di.s : di.s;\n    pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n    pointData[sizeLetter + 'LabelVal'] = size;\n\n    var extent = t.extents[t.extents.round(di.p)];\n    pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n    pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n\n    var hasPeriod = di.orig_p !== undefined;\n    pointData[posLetter + 'LabelVal'] = hasPeriod ? di.orig_p : di.p;\n\n    pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + 'LabelVal'], trace[posLetter + 'hoverformat']);\n    pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + 'LabelVal'], trace[sizeLetter + 'hoverformat']);\n    pointData.baseLabel = hoverLabelText(sa, di.b, trace[sizeLetter + 'hoverformat']);\n\n    // spikelines always want \"closest\" distance regardless of hovermode\n    pointData.spikeDistance = (thisBarSizeFn(di) + thisBarPositionFn(di)) / 2;\n    // they also want to point to the data value, regardless of where the label goes\n    // in case of bars shifted within groups\n    pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n\n    fillText(di, trace, pointData);\n    pointData.hovertemplate = trace.hovertemplate;\n\n    return pointData;\n}\n\nfunction getTraceColor(trace, di) {\n    var mc = di.mcc || trace.marker.color;\n    var mlc = di.mlcc || trace.marker.line.color;\n    var mlw = getLineWidth(trace, di);\n\n    if(Color.opacity(mc)) return mc;\n    else if(Color.opacity(mlc) && mlw) return mlc;\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    hoverOnBars: hoverOnBars,\n    getTraceColor: getTraceColor\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}