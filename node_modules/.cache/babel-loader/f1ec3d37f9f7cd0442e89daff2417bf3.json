{"ast":null,"code":"'use strict';\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\nvar isPlainObject = require('./is_plain_object');\n\n/**\n * Relink private _keys and keys with a function value from one container\n * to the new container.\n * Relink means copying if object is pass-by-value and adding a reference\n * if object is pass-by-ref.\n * This prevents deepCopying massive structures like a webgl context.\n */\nmodule.exports = function relinkPrivateKeys(toContainer, fromContainer) {\n  for (var k in fromContainer) {\n    var fromVal = fromContainer[k];\n    var toVal = toContainer[k];\n    if (toVal === fromVal) continue;\n    if (k.charAt(0) === '_' || typeof fromVal === 'function') {\n      // if it already exists at this point, it's something\n      // that we recreate each time around, so ignore it\n      if (k in toContainer) continue;\n      toContainer[k] = fromVal;\n    } else if (isArrayOrTypedArray(fromVal) && isArrayOrTypedArray(toVal) && isPlainObject(fromVal[0])) {\n      // filter out data_array items that can contain user objects\n      // most of the time the toVal === fromVal check will catch these early\n      // but if the user makes new ones we also don't want to recurse in.\n      if (k === 'customdata' || k === 'ids') continue;\n\n      // recurse into arrays containers\n      var minLen = Math.min(fromVal.length, toVal.length);\n      for (var j = 0; j < minLen; j++) {\n        if (toVal[j] !== fromVal[j] && isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {\n          relinkPrivateKeys(toVal[j], fromVal[j]);\n        }\n      }\n    } else if (isPlainObject(fromVal) && isPlainObject(toVal)) {\n      // recurse into objects, but only if they still exist\n      relinkPrivateKeys(toVal, fromVal);\n      if (!Object.keys(toVal).length) delete toContainer[k];\n    }\n  }\n};","map":{"version":3,"names":["isArrayOrTypedArray","require","isPlainObject","module","exports","relinkPrivateKeys","toContainer","fromContainer","k","fromVal","toVal","charAt","minLen","Math","min","length","j","Object","keys"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/lib/relink_private.js"],"sourcesContent":["'use strict';\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\nvar isPlainObject = require('./is_plain_object');\n\n/**\n * Relink private _keys and keys with a function value from one container\n * to the new container.\n * Relink means copying if object is pass-by-value and adding a reference\n * if object is pass-by-ref.\n * This prevents deepCopying massive structures like a webgl context.\n */\nmodule.exports = function relinkPrivateKeys(toContainer, fromContainer) {\n    for(var k in fromContainer) {\n        var fromVal = fromContainer[k];\n        var toVal = toContainer[k];\n\n        if(toVal === fromVal) continue;\n\n        if(k.charAt(0) === '_' || typeof fromVal === 'function') {\n            // if it already exists at this point, it's something\n            // that we recreate each time around, so ignore it\n            if(k in toContainer) continue;\n\n            toContainer[k] = fromVal;\n        } else if(isArrayOrTypedArray(fromVal) && isArrayOrTypedArray(toVal) && isPlainObject(fromVal[0])) {\n            // filter out data_array items that can contain user objects\n            // most of the time the toVal === fromVal check will catch these early\n            // but if the user makes new ones we also don't want to recurse in.\n            if(k === 'customdata' || k === 'ids') continue;\n\n            // recurse into arrays containers\n            var minLen = Math.min(fromVal.length, toVal.length);\n            for(var j = 0; j < minLen; j++) {\n                if((toVal[j] !== fromVal[j]) && isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {\n                    relinkPrivateKeys(toVal[j], fromVal[j]);\n                }\n            }\n        } else if(isPlainObject(fromVal) && isPlainObject(toVal)) {\n            // recurse into objects, but only if they still exist\n            relinkPrivateKeys(toVal, fromVal);\n\n            if(!Object.keys(toVal).length) delete toContainer[k];\n        }\n    }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,mBAAmB,GAAGC,OAAO,CAAC,SAAS,CAAC,CAACD,mBAAmB;AAChE,IAAIE,aAAa,GAAGD,OAAO,CAAC,mBAAmB,CAAC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG,SAASC,iBAAiBA,CAACC,WAAW,EAAEC,aAAa,EAAE;EACpE,KAAI,IAAIC,CAAC,IAAID,aAAa,EAAE;IACxB,IAAIE,OAAO,GAAGF,aAAa,CAACC,CAAC,CAAC;IAC9B,IAAIE,KAAK,GAAGJ,WAAW,CAACE,CAAC,CAAC;IAE1B,IAAGE,KAAK,KAAKD,OAAO,EAAE;IAEtB,IAAGD,CAAC,CAACG,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,OAAOF,OAAO,KAAK,UAAU,EAAE;MACrD;MACA;MACA,IAAGD,CAAC,IAAIF,WAAW,EAAE;MAErBA,WAAW,CAACE,CAAC,CAAC,GAAGC,OAAO;IAC5B,CAAC,MAAM,IAAGT,mBAAmB,CAACS,OAAO,CAAC,IAAIT,mBAAmB,CAACU,KAAK,CAAC,IAAIR,aAAa,CAACO,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;MAC/F;MACA;MACA;MACA,IAAGD,CAAC,KAAK,YAAY,IAAIA,CAAC,KAAK,KAAK,EAAE;;MAEtC;MACA,IAAII,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACL,OAAO,CAACM,MAAM,EAAEL,KAAK,CAACK,MAAM,CAAC;MACnD,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,EAAEI,CAAC,EAAE,EAAE;QAC5B,IAAIN,KAAK,CAACM,CAAC,CAAC,KAAKP,OAAO,CAACO,CAAC,CAAC,IAAKd,aAAa,CAACO,OAAO,CAACO,CAAC,CAAC,CAAC,IAAId,aAAa,CAACQ,KAAK,CAACM,CAAC,CAAC,CAAC,EAAE;UAClFX,iBAAiB,CAACK,KAAK,CAACM,CAAC,CAAC,EAAEP,OAAO,CAACO,CAAC,CAAC,CAAC;QAC3C;MACJ;IACJ,CAAC,MAAM,IAAGd,aAAa,CAACO,OAAO,CAAC,IAAIP,aAAa,CAACQ,KAAK,CAAC,EAAE;MACtD;MACAL,iBAAiB,CAACK,KAAK,EAAED,OAAO,CAAC;MAEjC,IAAG,CAACQ,MAAM,CAACC,IAAI,CAACR,KAAK,CAAC,CAACK,MAAM,EAAE,OAAOT,WAAW,CAACE,CAAC,CAAC;IACxD;EACJ;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}