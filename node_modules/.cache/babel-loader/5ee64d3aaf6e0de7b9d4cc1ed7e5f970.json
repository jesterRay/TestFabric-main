{"ast":null,"code":"'use strict';\n\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\nvar str2arr = require('../common').str2arr;\nvar sliceEq = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\nvar readUInt32LE = require('../common').readUInt32LE;\nvar exif = require('../exif_utils');\nvar SIG_RIFF = str2arr('RIFF');\nvar SIG_WEBP = str2arr('WEBP');\nfunction parseVP8(data, offset) {\n  if (data[offset + 3] !== 0x9D || data[offset + 4] !== 0x01 || data[offset + 5] !== 0x2A) {\n    // bad code block signature\n    return;\n  }\n  return {\n    width: readUInt16LE(data, offset + 6) & 0x3FFF,\n    height: readUInt16LE(data, offset + 8) & 0x3FFF,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\nfunction parseVP8L(data, offset) {\n  if (data[offset] !== 0x2F) return;\n  var bits = readUInt32LE(data, offset + 1);\n  return {\n    width: (bits & 0x3FFF) + 1,\n    height: (bits >> 14 & 0x3FFF) + 1,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\nfunction parseVP8X(data, offset) {\n  return {\n    // TODO: replace with `data.readUIntLE(8, 3) + 1`\n    //       when 0.10 support is dropped\n    width: (data[offset + 6] << 16 | data[offset + 5] << 8 | data[offset + 4]) + 1,\n    height: (data[offset + 9] << offset | data[offset + 8] << 8 | data[offset + 7]) + 1,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\nmodule.exports = function (data) {\n  if (data.length < 16) return;\n\n  // check /^RIFF....WEBPVP8([ LX])$/ signature\n  if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;\n  var offset = 12;\n  var result = null;\n  var exif_orientation = 0;\n  var fileLength = readUInt32LE(data, 4) + 8;\n  if (fileLength > data.length) return;\n  while (offset + 8 < fileLength) {\n    if (data[offset] === 0) {\n      // after each chunk of odd size there should be 0 byte of padding, skip those\n      offset++;\n      continue;\n    }\n    var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));\n    var length = readUInt32LE(data, offset + 4);\n    if (header === 'VP8 ' && length >= 10) {\n      result = result || parseVP8(data, offset + 8);\n    } else if (header === 'VP8L' && length >= 9) {\n      result = result || parseVP8L(data, offset + 8);\n    } else if (header === 'VP8X' && length >= 10) {\n      result = result || parseVP8X(data, offset + 8);\n    } else if (header === 'EXIF') {\n      exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length));\n\n      // exif is the last chunk we care about, stop after it\n      offset = Infinity;\n    }\n    offset += 8 + length;\n  }\n  if (!result) return;\n  if (exif_orientation > 0) {\n    result.orientation = exif_orientation;\n  }\n  return result;\n};","map":{"version":3,"names":["str2arr","require","sliceEq","readUInt16LE","readUInt32LE","exif","SIG_RIFF","SIG_WEBP","parseVP8","data","offset","width","height","type","mime","wUnits","hUnits","parseVP8L","bits","parseVP8X","module","exports","length","result","exif_orientation","fileLength","header","String","fromCharCode","apply","slice","get_orientation","Infinity","orientation"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/probe-image-size/lib/parse_sync/webp.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\nvar readUInt32LE = require('../common').readUInt32LE;\nvar exif         = require('../exif_utils');\n\n\nvar SIG_RIFF = str2arr('RIFF');\nvar SIG_WEBP = str2arr('WEBP');\n\n\nfunction parseVP8(data, offset) {\n  if (data[offset + 3] !== 0x9D || data[offset + 4] !== 0x01 || data[offset + 5] !== 0x2A) {\n    // bad code block signature\n    return;\n  }\n\n  return {\n    width:  readUInt16LE(data, offset + 6) & 0x3FFF,\n    height: readUInt16LE(data, offset + 8) & 0x3FFF,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nfunction parseVP8L(data, offset) {\n  if (data[offset] !== 0x2F) return;\n\n  var bits = readUInt32LE(data, offset + 1);\n\n  return {\n    width:  (bits & 0x3FFF) + 1,\n    height: ((bits >> 14) & 0x3FFF) + 1,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nfunction parseVP8X(data, offset) {\n  return  {\n    // TODO: replace with `data.readUIntLE(8, 3) + 1`\n    //       when 0.10 support is dropped\n    width:  ((data[offset + 6] << 16) | (data[offset + 5] << 8) | data[offset + 4]) + 1,\n    height: ((data[offset + 9] << offset) | (data[offset + 8] << 8) | data[offset + 7]) + 1,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nmodule.exports = function (data) {\n  if (data.length < 16) return;\n\n  // check /^RIFF....WEBPVP8([ LX])$/ signature\n  if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;\n\n  var offset = 12;\n  var result = null;\n  var exif_orientation = 0;\n  var fileLength = readUInt32LE(data, 4) + 8;\n\n  if (fileLength > data.length) return;\n\n  while (offset + 8 < fileLength) {\n    if (data[offset] === 0) {\n      // after each chunk of odd size there should be 0 byte of padding, skip those\n      offset++;\n      continue;\n    }\n\n    var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));\n    var length = readUInt32LE(data, offset + 4);\n\n    if (header === 'VP8 ' && length >= 10) {\n      result = result || parseVP8(data, offset + 8);\n    } else if (header === 'VP8L' && length >= 9) {\n      result = result || parseVP8L(data, offset + 8);\n    } else if (header === 'VP8X' && length >= 10) {\n      result = result || parseVP8X(data, offset + 8);\n    } else if (header === 'EXIF') {\n      exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length));\n\n      // exif is the last chunk we care about, stop after it\n      offset = Infinity;\n    }\n\n    offset += 8 + length;\n  }\n\n  if (!result) return;\n\n  if (exif_orientation > 0) {\n    result.orientation = exif_orientation;\n  }\n\n  return result;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}