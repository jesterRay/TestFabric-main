{"ast":null,"code":"'use strict';\n\nvar calc = require('./calc');\nvar setGroupPositions = require('../bar/cross_trace_calc').setGroupPositions;\nfunction groupCrossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorz = [];\n  var calcTracesVert = [];\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n    if (fullTrace.visible === true && fullTrace.type === 'scatter' && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorz.push(calcTraces[i]);\n      } else if (fullTrace.orientation === 'v') {\n        // check for v since certain scatter traces may not have an orientation\n        calcTracesVert.push(calcTraces[i]);\n      }\n    }\n  }\n  var opts = {\n    mode: fullLayout.scattermode,\n    gap: fullLayout.scattergap\n  };\n  setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n  if (gd._fullLayout.scattermode === 'group') {\n    groupCrossTraceCalc(gd, plotinfo);\n  }\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var subplot = xa._id + ya._id;\n  var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n  if (!subplotStackOpts) return;\n  var calcTraces = gd.calcdata;\n  var i, j, k, i2, cd, cd0, posj, sumj, norm;\n  var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n  var hasAnyBlanks;\n  for (var stackGroup in subplotStackOpts) {\n    groupOpts = subplotStackOpts[stackGroup];\n    var indices = groupOpts.traceIndices;\n\n    // can get here with no indices if the stack axis is non-numeric\n    if (!indices.length) continue;\n    interpolate = groupOpts.stackgaps === 'interpolate';\n    groupnorm = groupOpts.groupnorm;\n    if (groupOpts.orientation === 'v') {\n      posAttr = 'x';\n      valAttr = 'y';\n    } else {\n      posAttr = 'y';\n      valAttr = 'x';\n    }\n    hasAnyBlanks = new Array(indices.length);\n    for (i = 0; i < hasAnyBlanks.length; i++) {\n      hasAnyBlanks[i] = false;\n    }\n\n    // Collect the complete set of all positions across ALL traces.\n    // Start with the first trace, then interleave items from later traces\n    // as needed.\n    // Fill in mising items as we go.\n    cd0 = calcTraces[indices[0]];\n    var allPositions = new Array(cd0.length);\n    for (i = 0; i < cd0.length; i++) {\n      allPositions[i] = cd0[i][posAttr];\n    }\n    for (i = 1; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n      for (j = k = 0; j < cd.length; j++) {\n        posj = cd[j][posAttr];\n        for (; posj > allPositions[k] && k < allPositions.length; k++) {\n          // the current trace is missing a position from some previous trace(s)\n          insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n          j++;\n        }\n        if (posj !== allPositions[k]) {\n          // previous trace(s) are missing a position from the current trace\n          for (i2 = 0; i2 < i; i2++) {\n            insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n          }\n          allPositions.splice(k, 0, posj);\n        }\n        k++;\n      }\n      for (; k < allPositions.length; k++) {\n        insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n        j++;\n      }\n    }\n    var serieslen = allPositions.length;\n\n    // stack (and normalize)!\n    for (j = 0; j < cd0.length; j++) {\n      sumj = cd0[j][valAttr] = cd0[j].s;\n      for (i = 1; i < indices.length; i++) {\n        cd = calcTraces[indices[i]];\n        cd[0].trace._rawLength = cd[0].trace._length;\n        cd[0].trace._length = serieslen;\n        sumj += cd[j].s;\n        cd[j][valAttr] = sumj;\n      }\n      if (groupnorm) {\n        norm = (groupnorm === 'fraction' ? sumj : sumj / 100) || 1;\n        for (i = 0; i < indices.length; i++) {\n          var cdj = calcTraces[indices[i]][j];\n          cdj[valAttr] /= norm;\n          cdj.sNorm = cdj.s / norm;\n        }\n      }\n    }\n\n    // autorange\n    for (i = 0; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n      var trace = cd[0].trace;\n      var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n      var arrayPad = Array.isArray(ppad);\n      if (ppad && hasAnyBlanks[i] || arrayPad) {\n        var ppadRaw = ppad;\n        ppad = new Array(serieslen);\n        for (j = 0; j < serieslen; j++) {\n          ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;\n        }\n      }\n      var x = new Array(serieslen);\n      var y = new Array(serieslen);\n      for (j = 0; j < serieslen; j++) {\n        x[j] = cd[j].x;\n        y[j] = cd[j].y;\n      }\n      calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n\n      // while we're here (in a loop over all traces in the stack)\n      // record the orientation, so hover can find it easily\n      cd[0].t.orientation = groupOpts.orientation;\n    }\n  }\n};\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n  hasAnyBlanks[traceIndex] = true;\n  var newEntry = {\n    i: null,\n    gap: true,\n    s: 0\n  };\n  newEntry[posAttr] = position;\n  calcTrace.splice(index, 0, newEntry);\n  // Even if we're not interpolating, if one trace has multiple\n  // values at the same position and this trace only has one value there,\n  // we just duplicate that one value rather than insert a zero.\n  // We also make it look like a real point - because it's ambiguous which\n  // one really is the real one!\n  if (index && position === calcTrace[index - 1][posAttr]) {\n    var prevEntry = calcTrace[index - 1];\n    newEntry.s = prevEntry.s;\n    // TODO is it going to cause any problems to have multiple\n    // calcdata points with the same index?\n    newEntry.i = prevEntry.i;\n    newEntry.gap = prevEntry.gap;\n  } else if (interpolate) {\n    newEntry.s = getInterp(calcTrace, index, position, posAttr);\n  }\n  if (!index) {\n    // t and trace need to stay on the first cd entry\n    calcTrace[0].t = calcTrace[1].t;\n    calcTrace[0].trace = calcTrace[1].trace;\n    delete calcTrace[1].t;\n    delete calcTrace[1].trace;\n  }\n}\nfunction getInterp(calcTrace, index, position, posAttr) {\n  var pt0 = calcTrace[index - 1];\n  var pt1 = calcTrace[index + 1];\n  if (!pt1) return pt0.s;\n  if (!pt0) return pt1.s;\n  return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}","map":{"version":3,"names":["calc","require","setGroupPositions","groupCrossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","fullLayout","_fullLayout","fullTraces","_fullData","calcTraces","calcdata","calcTracesHorz","calcTracesVert","i","length","fullTrace","visible","type","_id","orientation","push","opts","mode","scattermode","gap","scattergap","module","exports","crossTraceCalc","subplot","subplotStackOpts","_scatterStackOpts","j","k","i2","cd","cd0","posj","sumj","norm","groupOpts","interpolate","groupnorm","posAttr","valAttr","hasAnyBlanks","stackGroup","indices","traceIndices","stackgaps","Array","allPositions","insertBlank","splice","serieslen","s","trace","_rawLength","_length","cdj","sNorm","ppad","calcMarkerSize","arrayPad","isArray","ppadRaw","x","y","calcAxisExpansion","t","calcTrace","index","position","traceIndex","newEntry","prevEntry","getInterp","pt0","pt1"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scatter/cross_trace_calc.js"],"sourcesContent":["'use strict';\n\nvar calc = require('./calc');\nvar setGroupPositions = require('../bar/cross_trace_calc').setGroupPositions;\n\nfunction groupCrossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var fullTraces = gd._fullData;\n    var calcTraces = gd.calcdata;\n    var calcTracesHorz = [];\n    var calcTracesVert = [];\n\n    for(var i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            fullTrace.type === 'scatter' &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorz.push(calcTraces[i]);\n            } else if(fullTrace.orientation === 'v') { // check for v since certain scatter traces may not have an orientation\n                calcTracesVert.push(calcTraces[i]);\n            }\n        }\n    }\n\n    var opts = {\n        mode: fullLayout.scattermode,\n        gap: fullLayout.scattergap\n    };\n\n    setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n    setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n    if(gd._fullLayout.scattermode === 'group') {\n        groupCrossTraceCalc(gd, plotinfo);\n    }\n\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var subplot = xa._id + ya._id;\n\n    var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n    if(!subplotStackOpts) return;\n\n    var calcTraces = gd.calcdata;\n\n    var i, j, k, i2, cd, cd0, posj, sumj, norm;\n    var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n    var hasAnyBlanks;\n\n    for(var stackGroup in subplotStackOpts) {\n        groupOpts = subplotStackOpts[stackGroup];\n        var indices = groupOpts.traceIndices;\n\n        // can get here with no indices if the stack axis is non-numeric\n        if(!indices.length) continue;\n\n        interpolate = groupOpts.stackgaps === 'interpolate';\n        groupnorm = groupOpts.groupnorm;\n        if(groupOpts.orientation === 'v') {\n            posAttr = 'x';\n            valAttr = 'y';\n        } else {\n            posAttr = 'y';\n            valAttr = 'x';\n        }\n        hasAnyBlanks = new Array(indices.length);\n        for(i = 0; i < hasAnyBlanks.length; i++) {\n            hasAnyBlanks[i] = false;\n        }\n\n        // Collect the complete set of all positions across ALL traces.\n        // Start with the first trace, then interleave items from later traces\n        // as needed.\n        // Fill in mising items as we go.\n        cd0 = calcTraces[indices[0]];\n        var allPositions = new Array(cd0.length);\n        for(i = 0; i < cd0.length; i++) {\n            allPositions[i] = cd0[i][posAttr];\n        }\n\n        for(i = 1; i < indices.length; i++) {\n            cd = calcTraces[indices[i]];\n\n            for(j = k = 0; j < cd.length; j++) {\n                posj = cd[j][posAttr];\n                for(; posj > allPositions[k] && k < allPositions.length; k++) {\n                    // the current trace is missing a position from some previous trace(s)\n                    insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n                    j++;\n                }\n                if(posj !== allPositions[k]) {\n                    // previous trace(s) are missing a position from the current trace\n                    for(i2 = 0; i2 < i; i2++) {\n                        insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n                    }\n                    allPositions.splice(k, 0, posj);\n                }\n                k++;\n            }\n            for(; k < allPositions.length; k++) {\n                insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n                j++;\n            }\n        }\n\n        var serieslen = allPositions.length;\n\n        // stack (and normalize)!\n        for(j = 0; j < cd0.length; j++) {\n            sumj = cd0[j][valAttr] = cd0[j].s;\n            for(i = 1; i < indices.length; i++) {\n                cd = calcTraces[indices[i]];\n                cd[0].trace._rawLength = cd[0].trace._length;\n                cd[0].trace._length = serieslen;\n                sumj += cd[j].s;\n                cd[j][valAttr] = sumj;\n            }\n\n            if(groupnorm) {\n                norm = ((groupnorm === 'fraction') ? sumj : (sumj / 100)) || 1;\n                for(i = 0; i < indices.length; i++) {\n                    var cdj = calcTraces[indices[i]][j];\n                    cdj[valAttr] /= norm;\n                    cdj.sNorm = cdj.s / norm;\n                }\n            }\n        }\n\n        // autorange\n        for(i = 0; i < indices.length; i++) {\n            cd = calcTraces[indices[i]];\n            var trace = cd[0].trace;\n            var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n            var arrayPad = Array.isArray(ppad);\n            if((ppad && hasAnyBlanks[i]) || arrayPad) {\n                var ppadRaw = ppad;\n                ppad = new Array(serieslen);\n                for(j = 0; j < serieslen; j++) {\n                    ppad[j] = cd[j].gap ? 0 : (arrayPad ? ppadRaw[cd[j].i] : ppadRaw);\n                }\n            }\n            var x = new Array(serieslen);\n            var y = new Array(serieslen);\n            for(j = 0; j < serieslen; j++) {\n                x[j] = cd[j].x;\n                y[j] = cd[j].y;\n            }\n            calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n\n            // while we're here (in a loop over all traces in the stack)\n            // record the orientation, so hover can find it easily\n            cd[0].t.orientation = groupOpts.orientation;\n        }\n    }\n};\n\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n    hasAnyBlanks[traceIndex] = true;\n    var newEntry = {\n        i: null,\n        gap: true,\n        s: 0\n    };\n    newEntry[posAttr] = position;\n    calcTrace.splice(index, 0, newEntry);\n    // Even if we're not interpolating, if one trace has multiple\n    // values at the same position and this trace only has one value there,\n    // we just duplicate that one value rather than insert a zero.\n    // We also make it look like a real point - because it's ambiguous which\n    // one really is the real one!\n    if(index && position === calcTrace[index - 1][posAttr]) {\n        var prevEntry = calcTrace[index - 1];\n        newEntry.s = prevEntry.s;\n        // TODO is it going to cause any problems to have multiple\n        // calcdata points with the same index?\n        newEntry.i = prevEntry.i;\n        newEntry.gap = prevEntry.gap;\n    } else if(interpolate) {\n        newEntry.s = getInterp(calcTrace, index, position, posAttr);\n    }\n    if(!index) {\n        // t and trace need to stay on the first cd entry\n        calcTrace[0].t = calcTrace[1].t;\n        calcTrace[0].trace = calcTrace[1].trace;\n        delete calcTrace[1].t;\n        delete calcTrace[1].trace;\n    }\n}\n\nfunction getInterp(calcTrace, index, position, posAttr) {\n    var pt0 = calcTrace[index - 1];\n    var pt1 = calcTrace[index + 1];\n    if(!pt1) return pt0.s;\n    if(!pt0) return pt1.s;\n    return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}