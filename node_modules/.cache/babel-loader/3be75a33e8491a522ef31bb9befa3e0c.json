{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar timeFormatLocale = require('d3-time-format').timeFormatLocale;\nvar formatLocale = require('d3-format').formatLocale;\nvar isNumeric = require('fast-isnumeric');\nvar b64encode = require('base64-arraybuffer');\nvar Registry = require('../registry');\nvar PlotSchema = require('../plot_api/plot_schema');\nvar Template = require('../plot_api/plot_template');\nvar Lib = require('../lib');\nvar Color = require('../components/color');\nvar BADNUM = require('../constants/numerical').BADNUM;\nvar axisIDs = require('./cartesian/axis_ids');\nvar clearOutline = require('../components/shapes/handle_outline').clearOutline;\nvar scatterAttrs = require('../traces/scatter/layout_attributes');\nvar animationAttrs = require('./animation_attributes');\nvar frameAttrs = require('./frame_attributes');\nvar getModuleCalcData = require('../plots/get_data').getModuleCalcData;\nvar relinkPrivateKeys = Lib.relinkPrivateKeys;\nvar _ = Lib._;\nvar plots = module.exports = {};\n\n// Expose registry methods on Plots for backward-compatibility\nLib.extendFlat(plots, Registry);\nplots.attributes = require('./attributes');\nplots.attributes.type.values = plots.allTypes;\nplots.fontAttrs = require('./font_attributes');\nplots.layoutAttributes = require('./layout_attributes');\nvar transformsRegistry = plots.transformsRegistry;\nvar commandModule = require('./command');\nplots.executeAPICommand = commandModule.executeAPICommand;\nplots.computeAPICommandBindings = commandModule.computeAPICommandBindings;\nplots.manageCommandObserver = commandModule.manageCommandObserver;\nplots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;\n\n// in some cases the browser doesn't seem to know how big\n// the text is at first, so it needs to draw it,\n// then wait a little, then draw it again\nplots.redrawText = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      if (!gd._fullLayout) return;\n      Registry.getComponentMethod('annotations', 'draw')(gd);\n      Registry.getComponentMethod('legend', 'draw')(gd);\n      Registry.getComponentMethod('colorbar', 'draw')(gd);\n      resolve(plots.previousPromises(gd));\n    }, 300);\n  });\n};\n\n// resize plot about the container size\nplots.resize = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  var resolveLastResize;\n  var p = new Promise(function (resolve, reject) {\n    if (!gd || Lib.isHidden(gd)) {\n      reject(new Error('Resize must be passed a displayed plot div element.'));\n    }\n    if (gd._redrawTimer) clearTimeout(gd._redrawTimer);\n    if (gd._resolveResize) resolveLastResize = gd._resolveResize;\n    gd._resolveResize = resolve;\n    gd._redrawTimer = setTimeout(function () {\n      // return if there is nothing to resize or is hidden\n      if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {\n        resolve(gd);\n        return;\n      }\n      delete gd.layout.width;\n      delete gd.layout.height;\n\n      // autosizing doesn't count as a change that needs saving\n      var oldchanged = gd.changed;\n\n      // nor should it be included in the undo queue\n      gd.autoplay = true;\n      Registry.call('relayout', gd, {\n        autosize: true\n      }).then(function () {\n        gd.changed = oldchanged;\n        // Only resolve if a new call hasn't been made!\n        if (gd._resolveResize === resolve) {\n          delete gd._resolveResize;\n          resolve(gd);\n        }\n      });\n    }, 100);\n  });\n  if (resolveLastResize) resolveLastResize(p);\n  return p;\n};\n\n// for use in Lib.syncOrAsync, check if there are any\n// pending promises in this plot and wait for them\nplots.previousPromises = function (gd) {\n  if ((gd._promises || []).length) {\n    return Promise.all(gd._promises).then(function () {\n      gd._promises = [];\n    });\n  }\n};\n\n/**\n * Adds the 'Edit chart' link.\n * Note that now _doPlot calls this so it can regenerate whenever it replots\n *\n * Add source links to your graph inside the 'showSources' config argument.\n */\nplots.addLinks = function (gd) {\n  // Do not do anything if showLink and showSources are not set to true in config\n  if (!gd._context.showLink && !gd._context.showSources) return;\n  var fullLayout = gd._fullLayout;\n  var linkContainer = Lib.ensureSingle(fullLayout._paper, 'text', 'js-plot-link-container', function (s) {\n    s.style({\n      'font-family': '\"Open Sans\", Arial, sans-serif',\n      'font-size': '12px',\n      fill: Color.defaultLine,\n      'pointer-events': 'all'\n    }).each(function () {\n      var links = d3.select(this);\n      links.append('tspan').classed('js-link-to-tool', true);\n      links.append('tspan').classed('js-link-spacer', true);\n      links.append('tspan').classed('js-sourcelinks', true);\n    });\n  });\n\n  // The text node inside svg\n  var text = linkContainer.node();\n  var attrs = {\n    y: fullLayout._paper.attr('height') - 9\n  };\n\n  // If text's width is bigger than the layout\n  // Check that text is a child node or document.body\n  // because otherwise IE/Edge might throw an exception\n  // when calling getComputedTextLength().\n  // Apparently offsetParent is null for invisibles.\n  if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {\n    // Align the text at the left\n    attrs['text-anchor'] = 'start';\n    attrs.x = 5;\n  } else {\n    // Align the text at the right\n    attrs['text-anchor'] = 'end';\n    attrs.x = fullLayout._paper.attr('width') - 7;\n  }\n  linkContainer.attr(attrs);\n  var toolspan = linkContainer.select('.js-link-to-tool');\n  var spacespan = linkContainer.select('.js-link-spacer');\n  var sourcespan = linkContainer.select('.js-sourcelinks');\n  if (gd._context.showSources) gd._context.showSources(gd);\n\n  // 'view in plotly' link for embedded plots\n  if (gd._context.showLink) positionPlayWithData(gd, toolspan);\n\n  // separator if we have both sources and tool link\n  spacespan.text(toolspan.text() && sourcespan.text() ? ' - ' : '');\n};\n\n// note that now this function is only adding the brand in\n// iframes and 3rd-party apps\nfunction positionPlayWithData(gd, container) {\n  container.text('');\n  var link = container.append('a').attr({\n    'xlink:xlink:href': '#',\n    class: 'link--impt link--embedview',\n    'font-weight': 'bold'\n  }).text(gd._context.linkText + ' ' + String.fromCharCode(187));\n  if (gd._context.sendData) {\n    link.on('click', function () {\n      plots.sendDataToCloud(gd);\n    });\n  } else {\n    var path = window.location.pathname.split('/');\n    var query = window.location.search;\n    link.attr({\n      'xlink:xlink:show': 'new',\n      'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query\n    });\n  }\n}\nplots.sendDataToCloud = function (gd) {\n  var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;\n  if (!baseUrl) return;\n  gd.emit('plotly_beforeexport');\n  var hiddenformDiv = d3.select(gd).append('div').attr('id', 'hiddenform').style('display', 'none');\n  var hiddenform = hiddenformDiv.append('form').attr({\n    action: baseUrl + '/external',\n    method: 'post',\n    target: '_blank'\n  });\n  var hiddenformInput = hiddenform.append('input').attr({\n    type: 'text',\n    name: 'data'\n  });\n  hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');\n  hiddenform.node().submit();\n  hiddenformDiv.remove();\n  gd.emit('plotly_afterexport');\n  return false;\n};\nvar d3FormatKeys = ['days', 'shortDays', 'months', 'shortMonths', 'periods', 'dateTime', 'date', 'time', 'decimal', 'thousands', 'grouping', 'currency'];\nvar extraFormatKeys = ['year', 'month', 'dayMonth', 'dayMonthYear'];\n\n/*\n * Fill in default values\n * @param {DOM element} gd\n * @param {object} opts\n * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks\n *   compatible with the new gd._fullData we finish by linking the new _fullData traces\n *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,\n *   if there are calcTransforms on the trace, we first remap data arrays from the old full\n *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)\n *\n * gd.data, gd.layout:\n *   are precisely what the user specified (except as modified by cleanData/cleanLayout),\n *   these fields shouldn't be modified (except for filling in some auto values)\n *   nor used directly after the supply defaults step.\n *\n * gd._fullData, gd._fullLayout:\n *   are complete descriptions of how to draw the plot,\n *   use these fields in all required computations.\n *\n * gd._fullLayout._modules\n *   is a list of all the trace modules required to draw the plot.\n *\n * gd._fullLayout._visibleModules\n *   subset of _modules, a list of modules corresponding to visible:true traces.\n *\n * gd._fullLayout._basePlotModules\n *   is a list of all the plot modules required to draw the plot.\n *\n * gd._fullLayout._transformModules\n *   is a list of all the transform modules invoked.\n *\n */\nplots.supplyDefaults = function (gd, opts) {\n  var skipUpdateCalc = opts && opts.skipUpdateCalc;\n  var oldFullLayout = gd._fullLayout || {};\n  if (oldFullLayout._skipDefaults) {\n    delete oldFullLayout._skipDefaults;\n    return;\n  }\n  var newFullLayout = gd._fullLayout = {};\n  var newLayout = gd.layout || {};\n  var oldFullData = gd._fullData || [];\n  var newFullData = gd._fullData = [];\n  var newData = gd.data || [];\n  var oldCalcdata = gd.calcdata || [];\n  var context = gd._context || {};\n  var i;\n\n  // Create all the storage space for frames, but only if doesn't already exist\n  if (!gd._transitionData) plots.createTransitionData(gd);\n\n  // So we only need to do this once (and since we have gd here)\n  // get the translated placeholder titles.\n  // These ones get used as default values so need to be known at supplyDefaults\n  // others keep their blank defaults but render the placeholder as desired later\n  // TODO: make these work the same way, only inserting the placeholder text at draw time?\n  // The challenge is that this has slightly different behavior right now in editable mode:\n  // using the placeholder as default makes this text permanently (but lightly) visible,\n  // but explicit '' for these titles gives you a placeholder that's hidden until you mouse\n  // over it - so you're not distracted by it if you really don't want a title, but if you do\n  // and you're new to plotly you may not be able to find it.\n  // When editable=false the two behave the same, no title is drawn.\n  newFullLayout._dfltTitle = {\n    plot: _(gd, 'Click to enter Plot title'),\n    subtitle: _(gd, 'Click to enter Plot subtitle'),\n    x: _(gd, 'Click to enter X axis title'),\n    y: _(gd, 'Click to enter Y axis title'),\n    colorbar: _(gd, 'Click to enter Colorscale title'),\n    annotation: _(gd, 'new text')\n  };\n  newFullLayout._traceWord = _(gd, 'trace');\n  var formatObj = getFormatObj(gd, d3FormatKeys);\n\n  // stash the token from context so mapbox subplots can use it as default\n  newFullLayout._mapboxAccessToken = context.mapboxAccessToken;\n\n  // first fill in what we can of layout without looking at data\n  // because fullData needs a few things from layout\n  if (oldFullLayout._initialAutoSizeIsDone) {\n    // coerce the updated layout while preserving width and height\n    var oldWidth = oldFullLayout.width;\n    var oldHeight = oldFullLayout.height;\n    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n    if (!newLayout.width) newFullLayout.width = oldWidth;\n    if (!newLayout.height) newFullLayout.height = oldHeight;\n    plots.sanitizeMargins(newFullLayout);\n  } else {\n    // coerce the updated layout and autosize if needed\n    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n    var missingWidthOrHeight = !newLayout.width || !newLayout.height;\n    var autosize = newFullLayout.autosize;\n    var autosizable = context.autosizable;\n    var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);\n    if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);\n\n    // for backwards-compatibility with Plotly v1.x.x\n    if (!autosize && missingWidthOrHeight) {\n      newLayout.width = newFullLayout.width;\n      newLayout.height = newFullLayout.height;\n    }\n  }\n  newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);\n  newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);\n  newFullLayout._initialAutoSizeIsDone = true;\n\n  // keep track of how many traces are inputted\n  newFullLayout._dataLength = newData.length;\n\n  // clear the lists of trace and baseplot modules, and subplots\n  newFullLayout._modules = [];\n  newFullLayout._visibleModules = [];\n  newFullLayout._basePlotModules = [];\n  var subplots = newFullLayout._subplots = emptySubplotLists();\n\n  // initialize axis and subplot hash objects for splom-generated grids\n  var splomAxes = newFullLayout._splomAxes = {\n    x: {},\n    y: {}\n  };\n  var splomSubplots = newFullLayout._splomSubplots = {};\n  // initialize splom grid defaults\n  newFullLayout._splomGridDflt = {};\n\n  // for stacked area traces to share config across traces\n  newFullLayout._scatterStackOpts = {};\n  // for the first scatter trace on each subplot (so it knows tonext->tozero)\n  newFullLayout._firstScatter = {};\n  // for grouped bar/box/violin trace to share config across traces\n  newFullLayout._alignmentOpts = {};\n  // track color axes referenced in the data\n  newFullLayout._colorAxes = {};\n\n  // for traces to request a default rangeslider on their x axes\n  // eg set `_requestRangeslider.x2 = true` for xaxis2\n  newFullLayout._requestRangeslider = {};\n\n  // pull uids from old data to use as new defaults\n  newFullLayout._traceUids = getTraceUids(oldFullData, newData);\n\n  // then do the data\n  newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;\n  plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);\n\n  // redo grid size defaults with info about splom x/y axes,\n  // and fill in generated cartesian axes and subplots\n  var splomXa = Object.keys(splomAxes.x);\n  var splomYa = Object.keys(splomAxes.y);\n  if (splomXa.length > 1 && splomYa.length > 1) {\n    Registry.getComponentMethod('grid', 'sizeDefaults')(newLayout, newFullLayout);\n    for (i = 0; i < splomXa.length; i++) {\n      Lib.pushUnique(subplots.xaxis, splomXa[i]);\n    }\n    for (i = 0; i < splomYa.length; i++) {\n      Lib.pushUnique(subplots.yaxis, splomYa[i]);\n    }\n    for (var k in splomSubplots) {\n      Lib.pushUnique(subplots.cartesian, k);\n    }\n  }\n\n  // attach helper method to check whether a plot type is present on graph\n  newFullLayout._has = plots._hasPlotType.bind(newFullLayout);\n  if (oldFullData.length === newFullData.length) {\n    for (i = 0; i < newFullData.length; i++) {\n      relinkPrivateKeys(newFullData[i], oldFullData[i]);\n    }\n  }\n\n  // finally, fill in the pieces of layout that may need to look at data\n  plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);\n\n  // Special cases that introduce interactions between traces.\n  // This is after relinkPrivateKeys so we can use those in crossTraceDefaults\n  // and after layout module defaults, so we can use eg barmode\n  var _modules = newFullLayout._visibleModules;\n  var crossTraceDefaultsFuncs = [];\n  for (i = 0; i < _modules.length; i++) {\n    var funci = _modules[i].crossTraceDefaults;\n    // some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)\n    if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);\n  }\n  for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {\n    crossTraceDefaultsFuncs[i](newFullData, newFullLayout);\n  }\n\n  // turn on flag to optimize large splom-only graphs\n  // mostly by omitting SVG layers during Cartesian.drawFramework\n  newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === 'splom' && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0;\n\n  // relink / initialize subplot axis objects\n  plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);\n\n  // clean subplots and other artifacts from previous plot calls\n  plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);\n  var hadGL2D = !!(oldFullLayout._has && oldFullLayout._has('gl2d'));\n  var hasGL2D = !!(newFullLayout._has && newFullLayout._has('gl2d'));\n  var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has('cartesian'));\n  var hasCartesian = !!(newFullLayout._has && newFullLayout._has('cartesian'));\n  var hadBgLayer = hadCartesian || hadGL2D;\n  var hasBgLayer = hasCartesian || hasGL2D;\n  if (hadBgLayer && !hasBgLayer) {\n    // remove bgLayer\n    oldFullLayout._bgLayer.remove();\n  } else if (hasBgLayer && !hadBgLayer) {\n    // create bgLayer\n    newFullLayout._shouldCreateBgLayer = true;\n  }\n\n  // clear selection outline until we implement persistent selection,\n  // don't clear them though when drag handlers (e.g. listening to\n  // `plotly_selecting`) update the graph.\n  // we should try to come up with a better solution when implementing\n  // https://github.com/plotly/plotly.js/issues/1851\n  if (oldFullLayout._zoomlayer && !gd._dragging) {\n    clearOutline({\n      // mock old gd\n      _fullLayout: oldFullLayout\n    });\n  }\n\n  // fill in meta helpers\n  fillMetaTextHelpers(newFullData, newFullLayout);\n\n  // relink functions and _ attributes to promote consistency between plots\n  relinkPrivateKeys(newFullLayout, oldFullLayout);\n\n  // colorscale crossTraceDefaults needs newFullLayout with relinked keys\n  Registry.getComponentMethod('colorscale', 'crossTraceDefaults')(newFullData, newFullLayout);\n\n  // For persisting GUI-driven changes in layout\n  // _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys\n  if (!newFullLayout._preGUI) newFullLayout._preGUI = {};\n  // track trace GUI changes by uid rather than by trace index\n  if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};\n  var tracePreGUI = newFullLayout._tracePreGUI;\n  var uids = {};\n  var uid;\n  for (uid in tracePreGUI) uids[uid] = 'old';\n  for (i = 0; i < newFullData.length; i++) {\n    uid = newFullData[i]._fullInput.uid;\n    if (!uids[uid]) tracePreGUI[uid] = {};\n    uids[uid] = 'new';\n  }\n  for (uid in uids) {\n    if (uids[uid] === 'old') delete tracePreGUI[uid];\n  }\n\n  // set up containers for margin calculations\n  initMargins(newFullLayout);\n\n  // collect and do some initial calculations for rangesliders\n  Registry.getComponentMethod('rangeslider', 'makeData')(newFullLayout);\n\n  // update object references in calcdata\n  if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {\n    plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);\n  }\n};\nplots.supplyDefaultsUpdateCalc = function (oldCalcdata, newFullData) {\n  for (var i = 0; i < newFullData.length; i++) {\n    var newTrace = newFullData[i];\n    var cd0 = (oldCalcdata[i] || [])[0];\n    if (cd0 && cd0.trace) {\n      var oldTrace = cd0.trace;\n      if (oldTrace._hasCalcTransform) {\n        var arrayAttrs = oldTrace._arrayAttrs;\n        var j, astr, oldArrayVal;\n        for (j = 0; j < arrayAttrs.length; j++) {\n          astr = arrayAttrs[j];\n          oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();\n          Lib.nestedProperty(newTrace, astr).set(oldArrayVal);\n        }\n      }\n      cd0.trace = newTrace;\n    }\n  }\n};\n\n/**\n * Create a list of uid strings satisfying (in this order of importance):\n * 1. all unique, all strings\n * 2. matches input uids if provided\n * 3. matches previous data uids\n */\nfunction getTraceUids(oldFullData, newData) {\n  var len = newData.length;\n  var oldFullInput = [];\n  var i, prevFullInput;\n  for (i = 0; i < oldFullData.length; i++) {\n    var thisFullInput = oldFullData[i]._fullInput;\n    if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);\n    prevFullInput = thisFullInput;\n  }\n  var oldLen = oldFullInput.length;\n  var out = new Array(len);\n  var seenUids = {};\n  function setUid(uid, i) {\n    out[i] = uid;\n    seenUids[uid] = 1;\n  }\n  function tryUid(uid, i) {\n    if (uid && typeof uid === 'string' && !seenUids[uid]) {\n      setUid(uid, i);\n      return true;\n    }\n  }\n  for (i = 0; i < len; i++) {\n    var newUid = newData[i].uid;\n    if (typeof newUid === 'number') newUid = String(newUid);\n    if (tryUid(newUid, i)) continue;\n    if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;\n    setUid(Lib.randstr(seenUids), i);\n  }\n  return out;\n}\n\n/**\n * Make a container for collecting subplots we need to display.\n *\n * Finds all subplot types we need to enumerate once and caches it,\n * but makes a new output object each time.\n * Single-trace subplots (which have no `id`) such as pie, table, etc\n * do not need to be collected because we just draw all visible traces.\n */\nfunction emptySubplotLists() {\n  var collectableSubplotTypes = Registry.collectableSubplotTypes;\n  var out = {};\n  var i, j;\n  if (!collectableSubplotTypes) {\n    collectableSubplotTypes = [];\n    var subplotsRegistry = Registry.subplotsRegistry;\n    for (var subplotType in subplotsRegistry) {\n      var subplotModule = subplotsRegistry[subplotType];\n      var subplotAttr = subplotModule.attr;\n      if (subplotAttr) {\n        collectableSubplotTypes.push(subplotType);\n\n        // special case, currently just for cartesian:\n        // we need to enumerate axes, not just subplots\n        if (Array.isArray(subplotAttr)) {\n          for (j = 0; j < subplotAttr.length; j++) {\n            Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);\n          }\n        }\n      }\n    }\n  }\n  for (i = 0; i < collectableSubplotTypes.length; i++) {\n    out[collectableSubplotTypes[i]] = [];\n  }\n  return out;\n}\n\n/**\n * getFormatObj: use _context to get the format object from locale.\n * Used to get d3.locale argument object and extraFormat argument object\n *\n * Regarding d3.locale argument :\n * decimal and thousands can be overridden later by layout.separators\n * grouping and currency are not presently used by our automatic number\n * formatting system but can be used by custom formats.\n *\n * @returns {object} d3.locale format object\n */\nfunction getFormatObj(gd, formatKeys) {\n  var locale = gd._context.locale;\n  if (!locale) locale = 'en-US';\n  var formatDone = false;\n  var formatObj = {};\n  function includeFormat(newFormat) {\n    var formatFinished = true;\n    for (var i = 0; i < formatKeys.length; i++) {\n      var formatKey = formatKeys[i];\n      if (!formatObj[formatKey]) {\n        if (newFormat[formatKey]) {\n          formatObj[formatKey] = newFormat[formatKey];\n        } else formatFinished = false;\n      }\n    }\n    if (formatFinished) formatDone = true;\n  }\n\n  // same as localize, look for format parts in each format spec in the chain\n  for (var i = 0; i < 2; i++) {\n    var locales = gd._context.locales;\n    for (var j = 0; j < 2; j++) {\n      var formatj = (locales[locale] || {}).format;\n      if (formatj) {\n        includeFormat(formatj);\n        if (formatDone) break;\n      }\n      locales = Registry.localeRegistry;\n    }\n    var baseLocale = locale.split('-')[0];\n    if (formatDone || baseLocale === locale) break;\n    locale = baseLocale;\n  }\n\n  // lastly pick out defaults from english (non-US, as DMY is so much more common)\n  if (!formatDone) includeFormat(Registry.localeRegistry.en.format);\n  return formatObj;\n}\n\n/**\n * getFormatter: combine the final separators with the locale formatting object\n * we pulled earlier to generate number and time formatters\n * TODO: remove separators in v3, only use locale, so we don't need this step?\n *\n * @param {object} formatObj: d3.locale format object\n * @param {string} separators: length-2 string to override decimal and thousands\n *   separators in number formatting\n *\n * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions\n *   for numbers and time\n */\nfunction getFormatter(formatObj, separators) {\n  formatObj.decimal = separators.charAt(0);\n  formatObj.thousands = separators.charAt(1);\n  return {\n    numberFormat: function (formatStr) {\n      try {\n        formatStr = formatLocale(formatObj).format(Lib.adjustFormat(formatStr));\n      } catch (e) {\n        Lib.warnBadFormat(formatStr);\n        return Lib.noFormat;\n      }\n      return formatStr;\n    },\n    timeFormat: timeFormatLocale(formatObj).utcFormat\n  };\n}\nfunction fillMetaTextHelpers(newFullData, newFullLayout) {\n  var _meta;\n  var meta4data = [];\n  if (newFullLayout.meta) {\n    _meta = newFullLayout._meta = {\n      meta: newFullLayout.meta,\n      layout: {\n        meta: newFullLayout.meta\n      }\n    };\n  }\n  for (var i = 0; i < newFullData.length; i++) {\n    var trace = newFullData[i];\n    if (trace.meta) {\n      meta4data[trace.index] = trace._meta = {\n        meta: trace.meta\n      };\n    } else if (newFullLayout.meta) {\n      trace._meta = {\n        meta: newFullLayout.meta\n      };\n    }\n    if (newFullLayout.meta) {\n      trace._meta.layout = {\n        meta: newFullLayout.meta\n      };\n    }\n  }\n  if (meta4data.length) {\n    if (!_meta) {\n      _meta = newFullLayout._meta = {};\n    }\n    _meta.data = meta4data;\n  }\n}\n\n// Create storage for all of the data related to frames and transitions:\nplots.createTransitionData = function (gd) {\n  // Set up the default keyframe if it doesn't exist:\n  if (!gd._transitionData) {\n    gd._transitionData = {};\n  }\n  if (!gd._transitionData._frames) {\n    gd._transitionData._frames = [];\n  }\n  if (!gd._transitionData._frameHash) {\n    gd._transitionData._frameHash = {};\n  }\n  if (!gd._transitionData._counter) {\n    gd._transitionData._counter = 0;\n  }\n  if (!gd._transitionData._interruptCallbacks) {\n    gd._transitionData._interruptCallbacks = [];\n  }\n};\n\n// helper function to be bound to fullLayout to check\n// whether a certain plot type is present on plot\n// or trace has a category\nplots._hasPlotType = function (category) {\n  var i;\n\n  // check base plot modules\n  var basePlotModules = this._basePlotModules || [];\n  for (i = 0; i < basePlotModules.length; i++) {\n    if (basePlotModules[i].name === category) return true;\n  }\n\n  // check trace modules (including non-visible:true)\n  var modules = this._modules || [];\n  for (i = 0; i < modules.length; i++) {\n    var name = modules[i].name;\n    if (name === category) return true;\n    // N.B. this is modules[i] along with 'categories' as a hash object\n    var _module = Registry.modules[name];\n    if (_module && _module.categories[category]) return true;\n  }\n  return false;\n};\nplots.cleanPlot = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var i, j;\n  var basePlotModules = oldFullLayout._basePlotModules || [];\n  for (i = 0; i < basePlotModules.length; i++) {\n    var _module = basePlotModules[i];\n    if (_module.clean) {\n      _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\n    }\n  }\n  var hadGl = oldFullLayout._has && oldFullLayout._has('gl');\n  var hasGl = newFullLayout._has && newFullLayout._has('gl');\n  if (hadGl && !hasGl) {\n    if (oldFullLayout._glcontainer !== undefined) {\n      oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();\n      oldFullLayout._glcontainer.selectAll('.no-webgl').remove();\n      oldFullLayout._glcanvas = null;\n    }\n  }\n  var hasInfoLayer = !!oldFullLayout._infolayer;\n  oldLoop: for (i = 0; i < oldFullData.length; i++) {\n    var oldTrace = oldFullData[i];\n    var oldUid = oldTrace.uid;\n    for (j = 0; j < newFullData.length; j++) {\n      var newTrace = newFullData[j];\n      if (oldUid === newTrace.uid) continue oldLoop;\n    }\n\n    // clean old colorbars\n    if (hasInfoLayer) {\n      oldFullLayout._infolayer.select('.cb' + oldUid).remove();\n    }\n  }\n};\nplots.linkSubplots = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var i, j;\n  var oldSubplots = oldFullLayout._plots || {};\n  var newSubplots = newFullLayout._plots = {};\n  var newSubplotList = newFullLayout._subplots;\n  var mockGd = {\n    _fullData: newFullData,\n    _fullLayout: newFullLayout\n  };\n  var ids = newSubplotList.cartesian.concat(newSubplotList.gl2d || []);\n  for (i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    var oldSubplot = oldSubplots[id];\n    var xaxis = axisIDs.getFromId(mockGd, id, 'x');\n    var yaxis = axisIDs.getFromId(mockGd, id, 'y');\n    var plotinfo;\n\n    // link or create subplot object\n    if (oldSubplot) {\n      plotinfo = newSubplots[id] = oldSubplot;\n    } else {\n      plotinfo = newSubplots[id] = {};\n      plotinfo.id = id;\n    }\n\n    // add these axis ids to each others' subplot lists\n    xaxis._counterAxes.push(yaxis._id);\n    yaxis._counterAxes.push(xaxis._id);\n    xaxis._subplotsWith.push(id);\n    yaxis._subplotsWith.push(id);\n\n    // update x and y axis layout object refs\n    plotinfo.xaxis = xaxis;\n    plotinfo.yaxis = yaxis;\n\n    // By default, we clip at the subplot level,\n    // but if one trace on a given subplot has *cliponaxis* set to false,\n    // we need to clip at the trace module layer level;\n    // find this out here, once of for all.\n    plotinfo._hasClipOnAxisFalse = false;\n    for (j = 0; j < newFullData.length; j++) {\n      var trace = newFullData[j];\n      if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {\n        plotinfo._hasClipOnAxisFalse = true;\n        break;\n      }\n    }\n  }\n\n  // while we're at it, link overlaying axes to their main axes and\n  // anchored axes to the axes they're anchored to\n  var axList = axisIDs.list(mockGd, null, true);\n  var ax;\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    var mainAx = null;\n    if (ax.overlaying) {\n      mainAx = axisIDs.getFromId(mockGd, ax.overlaying);\n\n      // you cannot overlay an axis that's already overlaying another\n      if (mainAx && mainAx.overlaying) {\n        ax.overlaying = false;\n        mainAx = null;\n      }\n    }\n    ax._mainAxis = mainAx || ax;\n\n    /*\n     * For now force overlays to overlay completely... so they\n     * can drag together correctly and share backgrounds.\n     * Later perhaps we make separate axis domain and\n     * tick/line domain or something, so they can still share\n     * the (possibly larger) dragger and background but don't\n     * have to both be drawn over that whole domain\n     */\n    if (mainAx) ax.domain = mainAx.domain.slice();\n    ax._anchorAxis = ax.anchor === 'free' ? null : axisIDs.getFromId(mockGd, ax.anchor);\n  }\n\n  // finally, we can find the main subplot for each axis\n  // (on which the ticks & labels are drawn)\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    ax._counterAxes.sort(axisIDs.idSort);\n    ax._subplotsWith.sort(Lib.subplotSort);\n    ax._mainSubplot = findMainSubplot(ax, newFullLayout);\n\n    // find \"full\" domain span of counter axes,\n    // this loop can be costly, so only compute it when required\n    if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf('across') !== -1 || ax.automargin && ax.mirror && ax.anchor !== 'free' || Registry.getComponentMethod('rangeslider', 'isVisible')(ax))) {\n      var min = 1;\n      var max = 0;\n      for (j = 0; j < ax._counterAxes.length; j++) {\n        var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);\n        min = Math.min(min, ax2.domain[0]);\n        max = Math.max(max, ax2.domain[1]);\n      }\n      if (min < max) {\n        ax._counterDomainMin = min;\n        ax._counterDomainMax = max;\n      }\n    }\n  }\n};\nfunction findMainSubplot(ax, fullLayout) {\n  var mockGd = {\n    _fullLayout: fullLayout\n  };\n  var isX = ax._id.charAt(0) === 'x';\n  var anchorAx = ax._mainAxis._anchorAxis;\n  var mainSubplotID = '';\n  var nextBestMainSubplotID = '';\n  var anchorID = '';\n\n  // First try the main ID with the anchor\n  if (anchorAx) {\n    anchorID = anchorAx._mainAxis._id;\n    mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;\n  }\n\n  // Then look for a subplot with the counteraxis overlaying the anchor\n  // If that fails just use the first subplot including this axis\n  if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {\n    mainSubplotID = '';\n    var counterIDs = ax._counterAxes;\n    for (var j = 0; j < counterIDs.length; j++) {\n      var counterPart = counterIDs[j];\n      var id = isX ? ax._id + counterPart : counterPart + ax._id;\n      if (!nextBestMainSubplotID) nextBestMainSubplotID = id;\n      var counterAx = axisIDs.getFromId(mockGd, counterPart);\n      if (anchorID && counterAx.overlaying === anchorID) {\n        mainSubplotID = id;\n        break;\n      }\n    }\n  }\n  return mainSubplotID || nextBestMainSubplotID;\n}\n\n// This function clears any trace attributes with valType: color and\n// no set dflt filed in the plot schema. This is needed because groupby (which\n// is the only transform for which this currently applies) supplies parent\n// trace defaults, then expanded trace defaults. The result is that `null`\n// colors are default-supplied and inherited as a color instead of a null.\n// The result is that expanded trace default colors have no effect, with\n// the final result that groups are indistinguishable. This function clears\n// those colors so that individual groupby groups get unique colors.\nplots.clearExpandedTraceDefaultColors = function (trace) {\n  var colorAttrs, path, i;\n\n  // This uses weird closure state in order to satisfy the linter rule\n  // that we can't create functions in a loop.\n  function locateColorAttrs(attr, attrName, attrs, level) {\n    path[level] = attrName;\n    path.length = level + 1;\n    if (attr.valType === 'color' && attr.dflt === undefined) {\n      colorAttrs.push(path.join('.'));\n    }\n  }\n  path = [];\n\n  // Get the cached colorAttrs:\n  colorAttrs = trace._module._colorAttrs;\n\n  // Or else compute and cache the colorAttrs on the module:\n  if (!colorAttrs) {\n    trace._module._colorAttrs = colorAttrs = [];\n    PlotSchema.crawl(trace._module.attributes, locateColorAttrs);\n  }\n  for (i = 0; i < colorAttrs.length; i++) {\n    var origprop = Lib.nestedProperty(trace, '_input.' + colorAttrs[i]);\n    if (!origprop.get()) {\n      Lib.nestedProperty(trace, colorAttrs[i]).set(null);\n    }\n  }\n};\nplots.supplyDataDefaults = function (dataIn, dataOut, layout, fullLayout) {\n  var modules = fullLayout._modules;\n  var visibleModules = fullLayout._visibleModules;\n  var basePlotModules = fullLayout._basePlotModules;\n  var cnt = 0;\n  var colorCnt = 0;\n  var i, fullTrace, trace;\n  fullLayout._transformModules = [];\n  function pushModule(fullTrace) {\n    dataOut.push(fullTrace);\n    var _module = fullTrace._module;\n    if (!_module) return;\n    Lib.pushUnique(modules, _module);\n    if (fullTrace.visible === true) Lib.pushUnique(visibleModules, _module);\n    Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);\n    cnt++;\n\n    // TODO: do we really want color not to increment for explicitly invisible traces?\n    // This logic is weird, but matches previous behavior: traces that you explicitly\n    // set to visible:false do not increment the color, but traces WE determine to be\n    // empty or invalid (and thus set to visible:false) DO increment color.\n    // I kind of think we should just let all traces increment color, visible or not.\n    // see mock: axes-autotype-empty vs. a test of restyling visible: false that\n    // I can't find right now...\n    if (fullTrace._input.visible !== false) colorCnt++;\n  }\n  var carpetIndex = {};\n  var carpetDependents = [];\n  var dataTemplate = (layout.template || {}).data || {};\n  var templater = Template.traceTemplater(dataTemplate);\n  for (i = 0; i < dataIn.length; i++) {\n    trace = dataIn[i];\n\n    // reuse uid we may have pulled out of oldFullData\n    // Note: templater supplies trace type\n    fullTrace = templater.newTrace(trace);\n    fullTrace.uid = fullLayout._traceUids[i];\n    plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);\n    fullTrace.index = i;\n    fullTrace._input = trace;\n    fullTrace._expandedIndex = cnt;\n    if (fullTrace.transforms && fullTrace.transforms.length) {\n      var sdInvisible = trace.visible !== false && fullTrace.visible === false;\n      var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);\n      for (var j = 0; j < expandedTraces.length; j++) {\n        var expandedTrace = expandedTraces[j];\n\n        // No further templating during transforms.\n        var fullExpandedTrace = {\n          _template: fullTrace._template,\n          type: fullTrace.type,\n          // set uid using parent uid and expanded index\n          // to promote consistency between update calls\n          uid: fullTrace.uid + j\n        };\n\n        // If the first supplyDefaults created `visible: false`,\n        // clear it before running supplyDefaults a second time,\n        // because sometimes there are items we still want to coerce\n        // inside trace modules before determining that the trace is\n        // again `visible: false`, for example partial visibilities\n        // in `splom` traces.\n        if (sdInvisible && expandedTrace.visible === false) {\n          delete expandedTrace.visible;\n        }\n        plots.supplyTraceDefaults(expandedTrace, fullExpandedTrace, cnt, fullLayout, i);\n\n        // relink private (i.e. underscore) keys expanded trace to full expanded trace so\n        // that transform supply-default methods can set _ keys for future use.\n        relinkPrivateKeys(fullExpandedTrace, expandedTrace);\n\n        // add info about parent data trace\n        fullExpandedTrace.index = i;\n        fullExpandedTrace._input = trace;\n        fullExpandedTrace._fullInput = fullTrace;\n\n        // add info about the expanded data\n        fullExpandedTrace._expandedIndex = cnt;\n        fullExpandedTrace._expandedInput = expandedTrace;\n        pushModule(fullExpandedTrace);\n      }\n    } else {\n      // add identify refs for consistency with transformed traces\n      fullTrace._fullInput = fullTrace;\n      fullTrace._expandedInput = fullTrace;\n      pushModule(fullTrace);\n    }\n    if (Registry.traceIs(fullTrace, 'carpetAxis')) {\n      carpetIndex[fullTrace.carpet] = fullTrace;\n    }\n    if (Registry.traceIs(fullTrace, 'carpetDependent')) {\n      carpetDependents.push(i);\n    }\n  }\n  for (i = 0; i < carpetDependents.length; i++) {\n    fullTrace = dataOut[carpetDependents[i]];\n    if (!fullTrace.visible) continue;\n    var carpetAxis = carpetIndex[fullTrace.carpet];\n    fullTrace._carpet = carpetAxis;\n    if (!carpetAxis || !carpetAxis.visible) {\n      fullTrace.visible = false;\n      continue;\n    }\n    fullTrace.xaxis = carpetAxis.xaxis;\n    fullTrace.yaxis = carpetAxis.yaxis;\n  }\n};\nplots.supplyAnimationDefaults = function (opts) {\n  opts = opts || {};\n  var i;\n  var optsOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);\n  }\n  coerce('mode');\n  coerce('direction');\n  coerce('fromcurrent');\n  if (Array.isArray(opts.frame)) {\n    optsOut.frame = [];\n    for (i = 0; i < opts.frame.length; i++) {\n      optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});\n    }\n  } else {\n    optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});\n  }\n  if (Array.isArray(opts.transition)) {\n    optsOut.transition = [];\n    for (i = 0; i < opts.transition.length; i++) {\n      optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});\n    }\n  } else {\n    optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});\n  }\n  return optsOut;\n};\nplots.supplyAnimationFrameDefaults = function (opts) {\n  var optsOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);\n  }\n  coerce('duration');\n  coerce('redraw');\n  return optsOut;\n};\nplots.supplyAnimationTransitionDefaults = function (opts) {\n  var optsOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);\n  }\n  coerce('duration');\n  coerce('easing');\n  return optsOut;\n};\nplots.supplyFrameDefaults = function (frameIn) {\n  var frameOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);\n  }\n  coerce('group');\n  coerce('name');\n  coerce('traces');\n  coerce('baseframe');\n  coerce('data');\n  coerce('layout');\n  return frameOut;\n};\nplots.supplyTraceDefaults = function (traceIn, traceOut, colorIndex, layout, traceInIndex) {\n  var colorway = layout.colorway || Color.defaults;\n  var defaultColor = colorway[colorIndex % colorway.length];\n  var i;\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);\n  }\n  var visible = coerce('visible');\n  coerce('type');\n  coerce('name', layout._traceWord + ' ' + traceInIndex);\n  coerce('uirevision', layout.uirevision);\n\n  // we want even invisible traces to make their would-be subplots visible\n  // so coerce the subplot id(s) now no matter what\n  var _module = plots.getModule(traceOut);\n  traceOut._module = _module;\n  if (_module) {\n    var basePlotModule = _module.basePlotModule;\n    var subplotAttr = basePlotModule.attr;\n    var subplotAttrs = basePlotModule.attributes;\n    if (subplotAttr && subplotAttrs) {\n      var subplots = layout._subplots;\n      var subplotId = '';\n      if (visible || basePlotModule.name !== 'gl2d' // for now just drop empty gl2d subplots\n      // TODO - currently if we draw an empty gl2d subplot, it draws\n      // nothing then gets stuck and you can't get it back without newPlot\n      // sort this out in the regl refactor?\n      ) {\n        if (Array.isArray(subplotAttr)) {\n          for (i = 0; i < subplotAttr.length; i++) {\n            var attri = subplotAttr[i];\n            var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);\n            if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);\n            subplotId += vali;\n          }\n        } else {\n          subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);\n        }\n        if (subplots[basePlotModule.name]) {\n          Lib.pushUnique(subplots[basePlotModule.name], subplotId);\n        }\n      }\n    }\n  }\n  if (visible) {\n    coerce('customdata');\n    coerce('ids');\n    coerce('meta');\n    if (Registry.traceIs(traceOut, 'showLegend')) {\n      Lib.coerce(traceIn, traceOut, _module.attributes.showlegend ? _module.attributes : plots.attributes, 'showlegend');\n      coerce('legend');\n      coerce('legendwidth');\n      coerce('legendgroup');\n      coerce('legendgrouptitle.text');\n      coerce('legendrank');\n      traceOut._dfltShowLegend = true;\n    } else {\n      traceOut._dfltShowLegend = false;\n    }\n    if (_module) {\n      _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);\n    }\n    if (!Registry.traceIs(traceOut, 'noOpacity')) {\n      coerce('opacity');\n    }\n    if (Registry.traceIs(traceOut, 'notLegendIsolatable')) {\n      // This clears out the legendonly state for traces like carpet that\n      // cannot be isolated in the legend\n      traceOut.visible = !!traceOut.visible;\n    }\n    if (!Registry.traceIs(traceOut, 'noHover')) {\n      if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);\n\n      // parcats support hover, but not hoverlabel stylings (yet)\n      if (traceOut.type !== 'parcats') {\n        Registry.getComponentMethod('fx', 'supplyDefaults')(traceIn, traceOut, defaultColor, layout);\n      }\n    }\n    if (_module && _module.selectPoints) {\n      var selectedpoints = coerce('selectedpoints');\n      if (Lib.isTypedArray(selectedpoints)) {\n        traceOut.selectedpoints = Array.from(selectedpoints);\n      }\n    }\n    plots.supplyTransformDefaults(traceIn, traceOut, layout);\n  }\n  return traceOut;\n};\n\n/**\n * hasMakesDataTransform: does this trace have a transform that makes its own\n * data, either by grabbing it from somewhere else or by creating it from input\n * parameters? If so, we should still keep going with supplyDefaults\n * even if the trace is invisible, which may just be because it has no data yet.\n */\nfunction hasMakesDataTransform(trace) {\n  var transforms = trace.transforms;\n  if (Array.isArray(transforms) && transforms.length) {\n    for (var i = 0; i < transforms.length; i++) {\n      var ti = transforms[i];\n      var _module = ti._module || transformsRegistry[ti.type];\n      if (_module && _module.makesData) return true;\n    }\n  }\n  return false;\n}\nplots.hasMakesDataTransform = hasMakesDataTransform;\nplots.supplyTransformDefaults = function (traceIn, traceOut, layout) {\n  // For now we only allow transforms on 1D traces, ie those that specify a _length.\n  // If we were to implement 2D transforms, we'd need to have each transform\n  // describe its own applicability and disable itself when it doesn't apply.\n  // Also allow transforms that make their own data, but not in globalTransforms\n  if (!(traceOut._length || hasMakesDataTransform(traceIn))) return;\n  var globalTransforms = layout._globalTransforms || [];\n  var transformModules = layout._transformModules || [];\n  if (!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;\n  var containerIn = traceIn.transforms || [];\n  var transformList = globalTransforms.concat(containerIn);\n  var containerOut = traceOut.transforms = [];\n  for (var i = 0; i < transformList.length; i++) {\n    var transformIn = transformList[i];\n    var type = transformIn.type;\n    var _module = transformsRegistry[type];\n    var transformOut;\n\n    /*\n     * Supply defaults may run twice. First pass runs all supply defaults steps\n     * and adds the _module to any output transforms.\n     * If transforms exist another pass is run so that any generated traces also\n     * go through supply defaults. This has the effect of rerunning\n     * supplyTransformDefaults. If the transform does not have a `transform`\n     * function it could not have generated any new traces and the second stage\n     * is unnecessary. We detect this case with the following variables.\n     */\n    var isFirstStage = !(transformIn._module && transformIn._module === _module);\n    var doLaterStages = _module && typeof _module.transform === 'function';\n    if (!_module) Lib.warn('Unrecognized transform type ' + type + '.');\n    if (_module && _module.supplyDefaults && (isFirstStage || doLaterStages)) {\n      transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);\n      transformOut.type = type;\n      transformOut._module = _module;\n      Lib.pushUnique(transformModules, _module);\n    } else {\n      transformOut = Lib.extendFlat({}, transformIn);\n    }\n    containerOut.push(transformOut);\n  }\n};\nfunction applyTransforms(fullTrace, fullData, layout, fullLayout) {\n  var container = fullTrace.transforms;\n  var dataOut = [fullTrace];\n  for (var i = 0; i < container.length; i++) {\n    var transform = container[i];\n    var _module = transformsRegistry[transform.type];\n    if (_module && _module.transform) {\n      dataOut = _module.transform(dataOut, {\n        transform: transform,\n        fullTrace: fullTrace,\n        fullData: fullData,\n        layout: layout,\n        fullLayout: fullLayout,\n        transformIndex: i\n      });\n    }\n  }\n  return dataOut;\n}\nplots.supplyLayoutGlobalDefaults = function (layoutIn, layoutOut, formatObj) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);\n  }\n  var template = layoutIn.template;\n  if (Lib.isPlainObject(template)) {\n    layoutOut.template = template;\n    layoutOut._template = template.layout;\n    layoutOut._dataTemplate = template.data;\n  }\n  coerce('autotypenumbers');\n  var font = Lib.coerceFont(coerce, 'font');\n  var fontSize = font.size;\n  Lib.coerceFont(coerce, 'title.font', font, {\n    overrideDflt: {\n      size: Math.round(fontSize * 1.4)\n    }\n  });\n  coerce('title.text', layoutOut._dfltTitle.plot);\n  coerce('title.xref');\n  var titleYref = coerce('title.yref');\n  coerce('title.pad.t');\n  coerce('title.pad.r');\n  coerce('title.pad.b');\n  coerce('title.pad.l');\n  var titleAutomargin = coerce('title.automargin');\n  coerce('title.x');\n  coerce('title.xanchor');\n  coerce('title.y');\n  coerce('title.yanchor');\n  coerce('title.subtitle.text', layoutOut._dfltTitle.subtitle);\n  Lib.coerceFont(coerce, 'title.subtitle.font', font, {\n    overrideDflt: {\n      size: Math.round(layoutOut.title.font.size * 0.7)\n    }\n  });\n  if (titleAutomargin) {\n    // when automargin=true\n    // title.y is 1 or 0 if paper ref\n    // 'auto' is not supported for either title.y or title.yanchor\n\n    // TODO: mention this smart default in the title.y and title.yanchor descriptions\n\n    if (titleYref === 'paper') {\n      if (layoutOut.title.y !== 0) layoutOut.title.y = 1;\n      if (layoutOut.title.yanchor === 'auto') {\n        layoutOut.title.yanchor = layoutOut.title.y === 0 ? 'top' : 'bottom';\n      }\n    }\n    if (titleYref === 'container') {\n      if (layoutOut.title.y === 'auto') layoutOut.title.y = 1;\n      if (layoutOut.title.yanchor === 'auto') {\n        layoutOut.title.yanchor = layoutOut.title.y < 0.5 ? 'bottom' : 'top';\n      }\n    }\n  }\n  var uniformtextMode = coerce('uniformtext.mode');\n  if (uniformtextMode) {\n    coerce('uniformtext.minsize');\n  }\n\n  // Make sure that autosize is defaulted to *true*\n  // on layouts with no set width and height for backward compatibly,\n  // in particular https://plotly.com/javascript/responsive-fluid-layout/\n  //\n  // Before https://github.com/plotly/plotly.js/pull/635 ,\n  // layouts with no set width and height were set temporary set to 'initial'\n  // to pass through the autosize routine\n  //\n  // This behavior is subject to change in v3.\n  coerce('autosize', !(layoutIn.width && layoutIn.height));\n  coerce('width');\n  coerce('height');\n  coerce('minreducedwidth');\n  coerce('minreducedheight');\n  coerce('margin.l');\n  coerce('margin.r');\n  coerce('margin.t');\n  coerce('margin.b');\n  coerce('margin.pad');\n  coerce('margin.autoexpand');\n  if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);\n  Registry.getComponentMethod('grid', 'sizeDefaults')(layoutIn, layoutOut);\n  coerce('paper_bgcolor');\n  coerce('separators', formatObj.decimal + formatObj.thousands);\n  coerce('hidesources');\n  coerce('colorway');\n  coerce('datarevision');\n  var uirevision = coerce('uirevision');\n  coerce('editrevision', uirevision);\n  coerce('selectionrevision', uirevision);\n  Registry.getComponentMethod('modebar', 'supplyLayoutDefaults')(layoutIn, layoutOut);\n  Registry.getComponentMethod('shapes', 'supplyDrawNewShapeDefaults')(layoutIn, layoutOut, coerce);\n  Registry.getComponentMethod('selections', 'supplyDrawNewSelectionDefaults')(layoutIn, layoutOut, coerce);\n  coerce('meta');\n\n  // do not include defaults in fullLayout when users do not set transition\n  if (Lib.isPlainObject(layoutIn.transition)) {\n    coerce('transition.duration');\n    coerce('transition.easing');\n    coerce('transition.ordering');\n  }\n  Registry.getComponentMethod('calendars', 'handleDefaults')(layoutIn, layoutOut, 'calendar');\n  Registry.getComponentMethod('fx', 'supplyLayoutGlobalDefaults')(layoutIn, layoutOut, coerce);\n  Lib.coerce(layoutIn, layoutOut, scatterAttrs, 'scattermode');\n};\nfunction getComputedSize(attr) {\n  return typeof attr === 'string' && attr.substr(attr.length - 2) === 'px' && parseFloat(attr);\n}\nplots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {\n  var context = gd._context || {};\n  var frameMargins = context.frameMargins;\n  var newWidth;\n  var newHeight;\n  var isPlotDiv = Lib.isPlotDiv(gd);\n  if (isPlotDiv) gd.emit('plotly_autosize');\n\n  // embedded in an iframe - just take the full iframe size\n  // if we get to this point, with no aspect ratio restrictions\n  if (context.fillFrame) {\n    newWidth = window.innerWidth;\n    newHeight = window.innerHeight;\n\n    // somehow we get a few extra px height sometimes...\n    // just hide it\n    document.body.style.overflow = 'hidden';\n  } else {\n    // plotly.js - let the developers do what they want, either\n    // provide height and width for the container div,\n    // specify size in layout, or take the defaults,\n    // but don't enforce any ratio restrictions\n    var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};\n    newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;\n    newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;\n    if (isNumeric(frameMargins) && frameMargins > 0) {\n      var factor = 1 - 2 * frameMargins;\n      newWidth = Math.round(factor * newWidth);\n      newHeight = Math.round(factor * newHeight);\n    }\n  }\n  var minWidth = plots.layoutAttributes.width.min;\n  var minHeight = plots.layoutAttributes.height.min;\n  if (newWidth < minWidth) newWidth = minWidth;\n  if (newHeight < minHeight) newHeight = minHeight;\n  var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;\n  var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;\n  if (heightHasChanged || widthHasChanged) {\n    if (widthHasChanged) fullLayout.width = newWidth;\n    if (heightHasChanged) fullLayout.height = newHeight;\n  }\n\n  // cache initial autosize value, used in relayout when\n  // width or height values are set to null\n  if (!gd._initialAutoSize) {\n    gd._initialAutoSize = {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n  plots.sanitizeMargins(fullLayout);\n};\nplots.supplyLayoutModuleDefaults = function (layoutIn, layoutOut, fullData, transitionData) {\n  var componentsRegistry = Registry.componentsRegistry;\n  var basePlotModules = layoutOut._basePlotModules;\n  var component, i, _module;\n  var Cartesian = Registry.subplotsRegistry.cartesian;\n\n  // check if any components need to add more base plot modules\n  // that weren't captured by traces\n  for (component in componentsRegistry) {\n    _module = componentsRegistry[component];\n    if (_module.includeBasePlot) {\n      _module.includeBasePlot(layoutIn, layoutOut);\n    }\n  }\n\n  // make sure we *at least* have some cartesian axes\n  if (!basePlotModules.length) {\n    basePlotModules.push(Cartesian);\n  }\n\n  // ensure all cartesian axes have at least one subplot\n  if (layoutOut._has('cartesian')) {\n    Registry.getComponentMethod('grid', 'contentDefaults')(layoutIn, layoutOut);\n    Cartesian.finalizeSubplots(layoutIn, layoutOut);\n  }\n\n  // sort subplot lists\n  for (var subplotType in layoutOut._subplots) {\n    layoutOut._subplots[subplotType].sort(Lib.subplotSort);\n  }\n\n  // base plot module layout defaults\n  for (i = 0; i < basePlotModules.length; i++) {\n    _module = basePlotModules[i];\n\n    // e.g. pie does not have a layout-defaults step\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  }\n\n  // trace module layout defaults\n  // use _modules rather than _visibleModules so that even\n  // legendonly traces can include settings - eg barmode, which affects\n  // legend.traceorder default value.\n  var modules = layoutOut._modules;\n  for (i = 0; i < modules.length; i++) {\n    _module = modules[i];\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  }\n\n  // transform module layout defaults\n  var transformModules = layoutOut._transformModules;\n  for (i = 0; i < transformModules.length; i++) {\n    _module = transformModules[i];\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);\n    }\n  }\n  for (component in componentsRegistry) {\n    _module = componentsRegistry[component];\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  }\n};\n\n// Remove all plotly attributes from a div so it can be replotted fresh\n// TODO: these really need to be encapsulated into a much smaller set...\nplots.purge = function (gd) {\n  // note: we DO NOT remove _context because it doesn't change when we insert\n  // a new plot, and may have been set outside of our scope.\n\n  var fullLayout = gd._fullLayout || {};\n  if (fullLayout._glcontainer !== undefined) {\n    fullLayout._glcontainer.selectAll('.gl-canvas').remove();\n    fullLayout._glcontainer.remove();\n    fullLayout._glcanvas = null;\n  }\n\n  // remove modebar\n  if (fullLayout._modeBar) fullLayout._modeBar.destroy();\n  if (gd._transitionData) {\n    // Ensure any dangling callbacks are simply dropped if the plot is purged.\n    // This is more or less only actually important for testing.\n    if (gd._transitionData._interruptCallbacks) {\n      gd._transitionData._interruptCallbacks.length = 0;\n    }\n    if (gd._transitionData._animationRaf) {\n      window.cancelAnimationFrame(gd._transitionData._animationRaf);\n    }\n  }\n\n  // remove any planned throttles\n  Lib.clearThrottle();\n\n  // remove responsive handler\n  Lib.clearResponsive(gd);\n\n  // data and layout\n  delete gd.data;\n  delete gd.layout;\n  delete gd._fullData;\n  delete gd._fullLayout;\n  delete gd.calcdata;\n  delete gd.empty;\n  delete gd.fid;\n  delete gd.undoqueue; // action queue\n  delete gd.undonum;\n  delete gd.autoplay; // are we doing an action that doesn't go in undo queue?\n  delete gd.changed;\n\n  // these get recreated on _doPlot anyway, but just to be safe\n  // (and to have a record of them...)\n  delete gd._promises;\n  delete gd._redrawTimer;\n  delete gd._hmlumcount;\n  delete gd._hmpixcount;\n  delete gd._transitionData;\n  delete gd._transitioning;\n  delete gd._initialAutoSize;\n  delete gd._transitioningWithDuration;\n\n  // created during certain events, that *should* clean them up\n  // themselves, but may not if there was an error\n  delete gd._dragging;\n  delete gd._dragged;\n  delete gd._dragdata;\n  delete gd._hoverdata;\n  delete gd._snapshotInProgress;\n  delete gd._editing;\n  delete gd._mouseDownTime;\n  delete gd._legendMouseDownTime;\n\n  // remove all event listeners\n  if (gd.removeAllListeners) gd.removeAllListeners();\n};\nplots.style = function (gd) {\n  var _modules = gd._fullLayout._visibleModules;\n  var styleModules = [];\n  var i;\n\n  // some trace modules reuse the same style method,\n  // make sure to not unnecessary call them multiple times.\n\n  for (i = 0; i < _modules.length; i++) {\n    var _module = _modules[i];\n    if (_module.style) {\n      Lib.pushUnique(styleModules, _module.style);\n    }\n  }\n  for (i = 0; i < styleModules.length; i++) {\n    styleModules[i](gd);\n  }\n};\nplots.sanitizeMargins = function (fullLayout) {\n  // polar doesn't do margins...\n  if (!fullLayout || !fullLayout.margin) return;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var margin = fullLayout.margin;\n  var plotWidth = width - (margin.l + margin.r);\n  var plotHeight = height - (margin.t + margin.b);\n  var correction;\n\n  // if margin.l + margin.r = 0 then plotWidth > 0\n  // as width >= 10 by supplyDefaults\n  // similarly for margin.t + margin.b\n\n  if (plotWidth < 0) {\n    correction = (width - 1) / (margin.l + margin.r);\n    margin.l = Math.floor(correction * margin.l);\n    margin.r = Math.floor(correction * margin.r);\n  }\n  if (plotHeight < 0) {\n    correction = (height - 1) / (margin.t + margin.b);\n    margin.t = Math.floor(correction * margin.t);\n    margin.b = Math.floor(correction * margin.b);\n  }\n};\nplots.clearAutoMarginIds = function (gd) {\n  gd._fullLayout._pushmarginIds = {};\n};\nplots.allowAutoMargin = function (gd, id) {\n  gd._fullLayout._pushmarginIds[id] = 1;\n};\nfunction initMargins(fullLayout) {\n  var margin = fullLayout.margin;\n  if (!fullLayout._size) {\n    var gs = fullLayout._size = {\n      l: Math.round(margin.l),\n      r: Math.round(margin.r),\n      t: Math.round(margin.t),\n      b: Math.round(margin.b),\n      p: Math.round(margin.pad)\n    };\n    gs.w = Math.round(fullLayout.width) - gs.l - gs.r;\n    gs.h = Math.round(fullLayout.height) - gs.t - gs.b;\n  }\n  if (!fullLayout._pushmargin) fullLayout._pushmargin = {};\n  if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};\n  if (!fullLayout._reservedMargin) fullLayout._reservedMargin = {};\n}\n\n// non-negotiable - this is the smallest height we will allow users to specify via explicit margins\nvar MIN_SPECIFIED_WIDTH = 2;\nvar MIN_SPECIFIED_HEIGHT = 2;\n\n/**\n * autoMargin: called by components that may need to expand the margins to\n * be rendered on-plot.\n *\n * @param {DOM element} gd\n * @param {string} id - an identifier unique (within this plot) to this object,\n *     so we can remove a previous margin expansion from the same object.\n * @param {object} o - the margin requirements of this object, or omit to delete\n *     this entry (like if it's hidden). Keys are:\n *     x, y: plot fraction of the anchor point.\n *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,\n *         you can specify both edges as plot fractions in each dimension\n *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]\n *     pad: extra pixels to add in all directions, default 12 (why?)\n */\nplots.autoMargin = function (gd, id, o) {\n  var fullLayout = gd._fullLayout;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var margin = fullLayout.margin;\n  var minreducedwidth = fullLayout.minreducedwidth;\n  var minreducedheight = fullLayout.minreducedheight;\n  var minFinalWidth = Lib.constrain(width - margin.l - margin.r, MIN_SPECIFIED_WIDTH, minreducedwidth);\n  var minFinalHeight = Lib.constrain(height - margin.t - margin.b, MIN_SPECIFIED_HEIGHT, minreducedheight);\n  var maxSpaceW = Math.max(0, width - minFinalWidth);\n  var maxSpaceH = Math.max(0, height - minFinalHeight);\n  var pushMargin = fullLayout._pushmargin;\n  var pushMarginIds = fullLayout._pushmarginIds;\n  if (margin.autoexpand !== false) {\n    if (!o) {\n      delete pushMargin[id];\n      delete pushMarginIds[id];\n    } else {\n      var pad = o.pad;\n      if (pad === undefined) {\n        // if no explicit pad is given, use 12px unless there's a\n        // specified margin that's smaller than that\n        pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);\n      }\n\n      // if the item is too big, just give it enough automargin to\n      // make sure you can still grab it and bring it back\n      if (maxSpaceW) {\n        var rW = (o.l + o.r) / maxSpaceW;\n        if (rW > 1) {\n          o.l /= rW;\n          o.r /= rW;\n        }\n      }\n      if (maxSpaceH) {\n        var rH = (o.t + o.b) / maxSpaceH;\n        if (rH > 1) {\n          o.t /= rH;\n          o.b /= rH;\n        }\n      }\n      var xl = o.xl !== undefined ? o.xl : o.x;\n      var xr = o.xr !== undefined ? o.xr : o.x;\n      var yt = o.yt !== undefined ? o.yt : o.y;\n      var yb = o.yb !== undefined ? o.yb : o.y;\n      pushMargin[id] = {\n        l: {\n          val: xl,\n          size: o.l + pad\n        },\n        r: {\n          val: xr,\n          size: o.r + pad\n        },\n        b: {\n          val: yb,\n          size: o.b + pad\n        },\n        t: {\n          val: yt,\n          size: o.t + pad\n        }\n      };\n      pushMarginIds[id] = 1;\n    }\n    if (!fullLayout._replotting) {\n      return plots.doAutoMargin(gd);\n    }\n  }\n};\nfunction needsRedrawForShift(gd) {\n  if ('_redrawFromAutoMarginCount' in gd._fullLayout) {\n    return false;\n  }\n  var axList = axisIDs.list(gd, '', true);\n  for (var ax in axList) {\n    if (axList[ax].autoshift || axList[ax].shift) return true;\n  }\n  return false;\n}\nplots.doAutoMargin = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  if (!fullLayout._size) fullLayout._size = {};\n  initMargins(fullLayout);\n  var gs = fullLayout._size;\n  var margin = fullLayout.margin;\n  var reservedMargins = {\n    t: 0,\n    b: 0,\n    l: 0,\n    r: 0\n  };\n  var oldMargins = Lib.extendFlat({}, gs);\n\n  // adjust margins for outside components\n  // fullLayout.margin is the requested margin,\n  // fullLayout._size has margins and plotsize after adjustment\n  var ml = margin.l;\n  var mr = margin.r;\n  var mt = margin.t;\n  var mb = margin.b;\n  var pushMargin = fullLayout._pushmargin;\n  var pushMarginIds = fullLayout._pushmarginIds;\n  var minreducedwidth = fullLayout.minreducedwidth;\n  var minreducedheight = fullLayout.minreducedheight;\n  if (margin.autoexpand !== false) {\n    for (var k in pushMargin) {\n      if (!pushMarginIds[k]) delete pushMargin[k];\n    }\n    var margins = gd._fullLayout._reservedMargin;\n    for (var key in margins) {\n      for (var side in margins[key]) {\n        var val = margins[key][side];\n        reservedMargins[side] = Math.max(reservedMargins[side], val);\n      }\n    }\n    // fill in the requested margins\n    pushMargin.base = {\n      l: {\n        val: 0,\n        size: ml\n      },\n      r: {\n        val: 1,\n        size: mr\n      },\n      t: {\n        val: 1,\n        size: mt\n      },\n      b: {\n        val: 0,\n        size: mb\n      }\n    };\n\n    // make sure that the reservedMargin is the minimum needed\n    for (var s in reservedMargins) {\n      var autoMarginPush = 0;\n      for (var m in pushMargin) {\n        if (m !== 'base') {\n          if (isNumeric(pushMargin[m][s].size)) {\n            autoMarginPush = pushMargin[m][s].size > autoMarginPush ? pushMargin[m][s].size : autoMarginPush;\n          }\n        }\n      }\n      var extraMargin = Math.max(0, margin[s] - autoMarginPush);\n      reservedMargins[s] = Math.max(0, reservedMargins[s] - extraMargin);\n    }\n\n    // now cycle through all the combinations of l and r\n    // (and t and b) to find the required margins\n    for (var k1 in pushMargin) {\n      var pushleft = pushMargin[k1].l || {};\n      var pushbottom = pushMargin[k1].b || {};\n      var fl = pushleft.val;\n      var pl = pushleft.size;\n      var fb = pushbottom.val;\n      var pb = pushbottom.size;\n      var availableWidth = width - reservedMargins.r - reservedMargins.l;\n      var availableHeight = height - reservedMargins.t - reservedMargins.b;\n      for (var k2 in pushMargin) {\n        if (isNumeric(pl) && pushMargin[k2].r) {\n          var fr = pushMargin[k2].r.val;\n          var pr = pushMargin[k2].r.size;\n          if (fr > fl) {\n            var newL = (pl * fr + (pr - availableWidth) * fl) / (fr - fl);\n            var newR = (pr * (1 - fl) + (pl - availableWidth) * (1 - fr)) / (fr - fl);\n            if (newL + newR > ml + mr) {\n              ml = newL;\n              mr = newR;\n            }\n          }\n        }\n        if (isNumeric(pb) && pushMargin[k2].t) {\n          var ft = pushMargin[k2].t.val;\n          var pt = pushMargin[k2].t.size;\n          if (ft > fb) {\n            var newB = (pb * ft + (pt - availableHeight) * fb) / (ft - fb);\n            var newT = (pt * (1 - fb) + (pb - availableHeight) * (1 - ft)) / (ft - fb);\n            if (newB + newT > mb + mt) {\n              mb = newB;\n              mt = newT;\n            }\n          }\n        }\n      }\n    }\n  }\n  var minFinalWidth = Lib.constrain(width - margin.l - margin.r, MIN_SPECIFIED_WIDTH, minreducedwidth);\n  var minFinalHeight = Lib.constrain(height - margin.t - margin.b, MIN_SPECIFIED_HEIGHT, minreducedheight);\n  var maxSpaceW = Math.max(0, width - minFinalWidth);\n  var maxSpaceH = Math.max(0, height - minFinalHeight);\n  if (maxSpaceW) {\n    var rW = (ml + mr) / maxSpaceW;\n    if (rW > 1) {\n      ml /= rW;\n      mr /= rW;\n    }\n  }\n  if (maxSpaceH) {\n    var rH = (mb + mt) / maxSpaceH;\n    if (rH > 1) {\n      mb /= rH;\n      mt /= rH;\n    }\n  }\n  gs.l = Math.round(ml) + reservedMargins.l;\n  gs.r = Math.round(mr) + reservedMargins.r;\n  gs.t = Math.round(mt) + reservedMargins.t;\n  gs.b = Math.round(mb) + reservedMargins.b;\n  gs.p = Math.round(margin.pad);\n  gs.w = Math.round(width) - gs.l - gs.r;\n  gs.h = Math.round(height) - gs.t - gs.b;\n\n  // if things changed and we're not already redrawing, trigger a redraw\n  if (!fullLayout._replotting && (plots.didMarginChange(oldMargins, gs) || needsRedrawForShift(gd))) {\n    if ('_redrawFromAutoMarginCount' in fullLayout) {\n      fullLayout._redrawFromAutoMarginCount++;\n    } else {\n      fullLayout._redrawFromAutoMarginCount = 1;\n    }\n\n    // Always allow at least one redraw and give each margin-push\n    // call 3 loops to converge. Of course, for most cases this way too many,\n    // but let's keep things on the safe side until we fix our\n    // auto-margin pipeline problems:\n    // https://github.com/plotly/plotly.js/issues/2704\n    var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);\n    if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {\n      return Registry.call('_doPlot', gd);\n    } else {\n      fullLayout._size = oldMargins;\n      Lib.warn('Too many auto-margin redraws.');\n    }\n  }\n  refineTicks(gd);\n};\nfunction refineTicks(gd) {\n  var axList = axisIDs.list(gd, '', true);\n  ['_adjustTickLabelsOverflow', '_hideCounterAxisInsideTickLabels'].forEach(function (k) {\n    for (var i = 0; i < axList.length; i++) {\n      var hideFn = axList[i][k];\n      if (hideFn) hideFn();\n    }\n  });\n}\nvar marginKeys = ['l', 'r', 't', 'b', 'p', 'w', 'h'];\nplots.didMarginChange = function (margin0, margin1) {\n  for (var i = 0; i < marginKeys.length; i++) {\n    var k = marginKeys[i];\n    var m0 = margin0[k];\n    var m1 = margin1[k];\n    // use 1px tolerance in case we old/new differ only\n    // by rounding errors, which can lead to infinite loops\n    if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * JSONify the graph data and layout\n *\n * This function needs to recurse because some src can be inside\n * sub-objects.\n *\n * It also strips out functions and private (starts with _) elements.\n * Therefore, we can add temporary things to data and layout that don't\n * get saved.\n *\n * @param gd The graphDiv\n * @param {Boolean} dataonly If true, don't return layout.\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\n *      keepref: remove data for which there's a src present\n *          eg if there's xsrc present (and xsrc is well-formed,\n *          ie has : and some chars before it), strip out x\n *      keepdata: remove all src tags, don't remove the data itself\n *      keepall: keep data and src\n * @param {String} output If you specify 'object', the result will not be stringified\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\n * @param {Boolean} includeConfig If truthy, include _context\n * @returns {Object|String}\n */\nplots.graphJson = function (gd, dataonly, mode, output, useDefaults, includeConfig) {\n  // if the defaults aren't supplied yet, we need to do that...\n  if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {\n    plots.supplyDefaults(gd);\n  }\n  var data = useDefaults ? gd._fullData : gd.data;\n  var layout = useDefaults ? gd._fullLayout : gd.layout;\n  var frames = (gd._transitionData || {})._frames;\n  function stripObj(d, keepFunction) {\n    if (typeof d === 'function') {\n      return keepFunction ? '_function_' : null;\n    }\n    if (Lib.isPlainObject(d)) {\n      var o = {};\n      var src;\n      Object.keys(d).sort().forEach(function (v) {\n        // remove private elements and functions\n        // _ is for private, [ is a mistake ie [object Object]\n        if (['_', '['].indexOf(v.charAt(0)) !== -1) return;\n\n        // if a function, add if necessary then move on\n        if (typeof d[v] === 'function') {\n          if (keepFunction) o[v] = '_function';\n          return;\n        }\n\n        // look for src/data matches and remove the appropriate one\n        if (mode === 'keepdata') {\n          // keepdata: remove all ...src tags\n          if (v.substr(v.length - 3) === 'src') {\n            return;\n          }\n        } else if (mode === 'keepstream') {\n          // keep sourced data if it's being streamed.\n          // similar to keepref, but if the 'stream' object exists\n          // in a trace, we will keep the data array.\n          src = d[v + 'src'];\n          if (typeof src === 'string' && src.indexOf(':') > 0) {\n            if (!Lib.isPlainObject(d.stream)) {\n              return;\n            }\n          }\n        } else if (mode !== 'keepall') {\n          // keepref: remove sourced data but only\n          // if the source tag is well-formed\n          src = d[v + 'src'];\n          if (typeof src === 'string' && src.indexOf(':') > 0) {\n            return;\n          }\n        }\n\n        // OK, we're including this... recurse into it\n        o[v] = stripObj(d[v], keepFunction);\n      });\n      return o;\n    }\n    var dIsArray = Array.isArray(d);\n    var dIsTypedArray = Lib.isTypedArray(d);\n    if ((dIsArray || dIsTypedArray) && d.dtype && d.shape) {\n      var bdata = d.bdata;\n      return stripObj({\n        dtype: d.dtype,\n        shape: d.shape,\n        bdata:\n        // case of ArrayBuffer\n        Lib.isArrayBuffer(bdata) ? b64encode.encode(bdata) :\n        // case of b64 string\n        bdata\n      }, keepFunction);\n    }\n    if (dIsArray) {\n      return d.map(function (x) {\n        return stripObj(x, keepFunction);\n      });\n    }\n    if (dIsTypedArray) {\n      return Lib.simpleMap(d, Lib.identity);\n    }\n\n    // convert native dates to date strings...\n    // mostly for external users exporting to plotly\n    if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);\n    return d;\n  }\n  var obj = {\n    data: (data || []).map(function (v) {\n      var d = stripObj(v);\n      // fit has some little arrays in it that don't contain data,\n      // just fit params and meta\n      if (dataonly) {\n        delete d.fit;\n      }\n      return d;\n    })\n  };\n  if (!dataonly) {\n    obj.layout = stripObj(layout);\n    if (useDefaults) {\n      var gs = layout._size;\n      obj.layout.computed = {\n        margin: {\n          b: gs.b,\n          l: gs.l,\n          r: gs.r,\n          t: gs.t\n        }\n      };\n    }\n  }\n  if (frames) obj.frames = stripObj(frames);\n  if (includeConfig) obj.config = stripObj(gd._context, true);\n  return output === 'object' ? obj : JSON.stringify(obj);\n};\n\n/**\n * Modify a keyframe using a list of operations:\n *\n * @param {array of objects} operations\n *      Sequence of operations to be performed on the keyframes\n */\nplots.modifyFrames = function (gd, operations) {\n  var i, op, frame;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n  for (i = 0; i < operations.length; i++) {\n    op = operations[i];\n    switch (op.type) {\n      // No reason this couldn't exist, but is currently unused/untested:\n      /* case 'rename':\n          frame = _frames[op.index];\n          delete _frameHash[frame.name];\n          _frameHash[op.name] = frame;\n          frame.name = op.name;\n          break;*/\n      case 'replace':\n        frame = op.value;\n        var oldName = (_frames[op.index] || {}).name;\n        var newName = frame.name;\n        _frames[op.index] = _frameHash[newName] = frame;\n        if (newName !== oldName) {\n          // If name has changed in addition to replacement, then update\n          // the lookup table:\n          delete _frameHash[oldName];\n          _frameHash[newName] = frame;\n        }\n        break;\n      case 'insert':\n        frame = op.value;\n        _frameHash[frame.name] = frame;\n        _frames.splice(op.index, 0, frame);\n        break;\n      case 'delete':\n        frame = _frames[op.index];\n        delete _frameHash[frame.name];\n        _frames.splice(op.index, 1);\n        break;\n    }\n  }\n  return Promise.resolve();\n};\n\n/*\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\n * expand properties.\n *\n * @param {object} frameLookup\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\n * @param {string} frame\n *      The name of the keyframe to be computed\n *\n * Returns: a new object with the merged content\n */\nplots.computeFrame = function (gd, frameName) {\n  var frameLookup = gd._transitionData._frameHash;\n  var i, traceIndices, traceIndex, destIndex;\n\n  // Null or undefined will fail on .toString(). We'll allow numbers since we\n  // make it clear frames must be given string names, but we'll allow numbers\n  // here since they're otherwise fine for looking up frames as long as they're\n  // properly cast to strings. We really just want to ensure here that this\n  // 1) doesn't fail, and\n  // 2) doens't give an incorrect answer (which String(frameName) would)\n  if (!frameName) {\n    throw new Error('computeFrame must be given a string frame name');\n  }\n  var framePtr = frameLookup[frameName.toString()];\n\n  // Return false if the name is invalid:\n  if (!framePtr) {\n    return false;\n  }\n  var frameStack = [framePtr];\n  var frameNameStack = [framePtr.name];\n\n  // Follow frame pointers:\n  while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {\n    // Avoid infinite loops:\n    if (frameNameStack.indexOf(framePtr.name) !== -1) break;\n    frameStack.push(framePtr);\n    frameNameStack.push(framePtr.name);\n  }\n\n  // A new object for the merged result:\n  var result = {};\n\n  // Merge, starting with the last and ending with the desired frame:\n  while (framePtr = frameStack.pop()) {\n    if (framePtr.layout) {\n      result.layout = plots.extendLayout(result.layout, framePtr.layout);\n    }\n    if (framePtr.data) {\n      if (!result.data) {\n        result.data = [];\n      }\n      traceIndices = framePtr.traces;\n      if (!traceIndices) {\n        // If not defined, assume serial order starting at zero\n        traceIndices = [];\n        for (i = 0; i < framePtr.data.length; i++) {\n          traceIndices[i] = i;\n        }\n      }\n      if (!result.traces) {\n        result.traces = [];\n      }\n      for (i = 0; i < framePtr.data.length; i++) {\n        // Loop through this frames data, find out where it should go,\n        // and merge it!\n        traceIndex = traceIndices[i];\n        if (traceIndex === undefined || traceIndex === null) {\n          continue;\n        }\n        destIndex = result.traces.indexOf(traceIndex);\n        if (destIndex === -1) {\n          destIndex = result.data.length;\n          result.traces[destIndex] = traceIndex;\n        }\n        result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\n * deleteFrames already manages this data one at a time, so the only time this\n * is necessary is if you poke around manually in `gd._transitionData._frames`\n * and create and haven't updated the lookup table.\n */\nplots.recomputeFrameHash = function (gd) {\n  var hash = gd._transitionData._frameHash = {};\n  var frames = gd._transitionData._frames;\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n    if (frame && frame.name) {\n      hash[frame.name] = frame;\n    }\n  }\n};\n\n/**\n * Extend an object, treating container arrays very differently by extracting\n * their contents and merging them separately.\n *\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\n * arrays without knowledge of the plot schema, but so that we may also manually\n * recurse into known container arrays, such as transforms.\n *\n * See extendTrace and extendLayout below for usage.\n */\nplots.extendObjectWithContainers = function (dest, src, containerPaths) {\n  var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;\n  var copy = Lib.extendDeepNoArrays({}, src || {});\n  var expandedObj = Lib.expandObjectPaths(copy);\n  var containerObj = {};\n\n  // Step through and extract any container properties. Otherwise extendDeepNoArrays\n  // will clobber any existing properties with an empty array and then supplyDefaults\n  // will reset everything to defaults.\n  if (containerPaths && containerPaths.length) {\n    for (i = 0; i < containerPaths.length; i++) {\n      containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);\n      containerVal = containerProp.get();\n      if (containerVal === undefined) {\n        Lib.nestedProperty(containerObj, containerPaths[i]).set(null);\n      } else {\n        containerProp.set(null);\n        Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);\n      }\n    }\n  }\n  dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);\n  if (containerPaths && containerPaths.length) {\n    for (i = 0; i < containerPaths.length; i++) {\n      srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);\n      srcContainer = srcProp.get();\n      if (!srcContainer) continue;\n      destProp = Lib.nestedProperty(dest, containerPaths[i]);\n      destContainer = destProp.get();\n      if (!Array.isArray(destContainer)) {\n        destContainer = [];\n        destProp.set(destContainer);\n      }\n      for (j = 0; j < srcContainer.length; j++) {\n        var srcObj = srcContainer[j];\n        if (srcObj === null) destContainer[j] = null;else {\n          destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);\n        }\n      }\n      destProp.set(destContainer);\n    }\n  }\n  return dest;\n};\nplots.dataArrayContainers = ['transforms', 'dimensions'];\nplots.layoutArrayContainers = Registry.layoutArrayContainers;\n\n/*\n * Extend a trace definition. This method:\n *\n *  1. directly transfers any array references\n *  2. manually recurses into container arrays like transforms\n *\n * The result is the original object reference with the new contents merged in.\n */\nplots.extendTrace = function (destTrace, srcTrace) {\n  return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);\n};\n\n/*\n * Extend a layout definition. This method:\n *\n *  1. directly transfers any array references (not critically important for\n *     layout since there aren't really data arrays)\n *  2. manually recurses into container arrays like annotations\n *\n * The result is the original object reference with the new contents merged in.\n */\nplots.extendLayout = function (destLayout, srcLayout) {\n  return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);\n};\n\n/**\n * Transition to a set of new data and layout properties from Plotly.animate\n *\n * @param {DOM element} gd\n * @param {Object[]} data\n *      an array of data objects following the normal Plotly data definition format\n * @param {Object} layout\n *      a layout object, following normal Plotly layout format\n * @param {Number[]} traces\n *      indices of the corresponding traces specified in `data`\n * @param {Object} frameOpts\n *      options for the frame (i.e. whether to redraw post-transition)\n * @param {Object} transitionOpts\n *      options for the transition\n */\nplots.transition = function (gd, data, layout, traces, frameOpts, transitionOpts) {\n  var opts = {\n    redraw: frameOpts.redraw\n  };\n  var transitionedTraces = {};\n  var axEdits = [];\n  opts.prepareFn = function () {\n    var dataLength = Array.isArray(data) ? data.length : 0;\n    var traceIndices = traces.slice(0, dataLength);\n    for (var i = 0; i < traceIndices.length; i++) {\n      var traceIdx = traceIndices[i];\n      var trace = gd._fullData[traceIdx];\n      var _module = trace._module;\n\n      // There's nothing to do if this module is not defined:\n      if (!_module) continue;\n\n      // Don't register the trace as transitioned if it doesn't know what to do.\n      // If it *is* registered, it will receive a callback that it's responsible\n      // for calling in order to register the transition as having completed.\n      if (_module.animatable) {\n        var n = _module.basePlotModule.name;\n        if (!transitionedTraces[n]) transitionedTraces[n] = [];\n        transitionedTraces[n].push(traceIdx);\n      }\n      gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);\n    }\n\n    // Follow the same procedure. Clone it so we don't mangle the input, then\n    // expand any object paths so we can merge deep into gd.layout:\n    var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));\n\n    // Before merging though, we need to modify the incoming layout. We only\n    // know how to *transition* layout ranges, so it's imperative that a new\n    // range not be sent to the layout before the transition has started. So\n    // we must remove the things we can transition:\n    var axisAttrRe = /^[xy]axis[0-9]*$/;\n    for (var attr in layoutUpdate) {\n      if (!axisAttrRe.test(attr)) continue;\n      delete layoutUpdate[attr].range;\n    }\n    plots.extendLayout(gd.layout, layoutUpdate);\n\n    // Supply defaults after applying the incoming properties. Note that any attempt\n    // to simplify this step and reduce the amount of work resulted in the reconstruction\n    // of essentially the whole supplyDefaults step, so that it seems sensible to just use\n    // supplyDefaults even though it's heavier than would otherwise be desired for\n    // transitions:\n\n    // first delete calcdata so supplyDefaults knows a calc step is coming\n    delete gd.calcdata;\n    plots.supplyDefaults(gd);\n    plots.doCalcdata(gd);\n    var newLayout = Lib.expandObjectPaths(layout);\n    if (newLayout) {\n      var subplots = gd._fullLayout._plots;\n      for (var k in subplots) {\n        var plotinfo = subplots[k];\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        var xr0 = xa.range.slice();\n        var yr0 = ya.range.slice();\n        var xr1 = null;\n        var yr1 = null;\n        var editX = null;\n        var editY = null;\n        if (Array.isArray(newLayout[xa._name + '.range'])) {\n          xr1 = newLayout[xa._name + '.range'].slice();\n        } else if (Array.isArray((newLayout[xa._name] || {}).range)) {\n          xr1 = newLayout[xa._name].range.slice();\n        }\n        if (Array.isArray(newLayout[ya._name + '.range'])) {\n          yr1 = newLayout[ya._name + '.range'].slice();\n        } else if (Array.isArray((newLayout[ya._name] || {}).range)) {\n          yr1 = newLayout[ya._name].range.slice();\n        }\n        if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {\n          editX = {\n            xr0: xr0,\n            xr1: xr1\n          };\n        }\n        if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {\n          editY = {\n            yr0: yr0,\n            yr1: yr1\n          };\n        }\n        if (editX || editY) {\n          axEdits.push(Lib.extendFlat({\n            plotinfo: plotinfo\n          }, editX, editY));\n        }\n      }\n    }\n    return Promise.resolve();\n  };\n  opts.runFn = function (makeCallback) {\n    var traceTransitionOpts;\n    var basePlotModules = gd._fullLayout._basePlotModules;\n    var hasAxisTransition = axEdits.length;\n    var i;\n    if (layout) {\n      for (i = 0; i < basePlotModules.length; i++) {\n        if (basePlotModules[i].transitionAxes) {\n          basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);\n        }\n      }\n    }\n\n    // Here handle the exception that we refuse to animate scales and axes at the same\n    // time. In other words, if there's an axis transition, then set the data transition\n    // to instantaneous.\n    if (hasAxisTransition) {\n      traceTransitionOpts = Lib.extendFlat({}, transitionOpts);\n      traceTransitionOpts.duration = 0;\n      // This means do not transition cartesian traces,\n      // this happens on layout-only (e.g. axis range) animations\n      delete transitionedTraces.cartesian;\n    } else {\n      traceTransitionOpts = transitionOpts;\n    }\n\n    // Note that we pass a callback to *create* the callback that must be invoked on completion.\n    // This is since not all traces know about transitions, so it greatly simplifies matters if\n    // the trace is responsible for creating a callback, if needed, and then executing it when\n    // the time is right.\n    for (var n in transitionedTraces) {\n      var traceIndices = transitionedTraces[n];\n      var _module = gd._fullData[traceIndices[0]]._module;\n      _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);\n    }\n  };\n  return _transition(gd, transitionOpts, opts);\n};\n\n/**\n * Transition to a set of new data and layout properties from Plotly.react\n *\n * @param {DOM element} gd\n * @param {object} restyleFlags\n * - anim {'all'|'some'}\n * @param {object} relayoutFlags\n * - anim {'all'|'some'}\n * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout\n */\nplots.transitionFromReact = function (gd, restyleFlags, relayoutFlags, oldFullLayout) {\n  var fullLayout = gd._fullLayout;\n  var transitionOpts = fullLayout.transition;\n  var opts = {};\n  var axEdits = [];\n  opts.prepareFn = function () {\n    var subplots = fullLayout._plots;\n\n    // no need to redraw at end of transition,\n    // if all changes are animatable\n    opts.redraw = false;\n    if (restyleFlags.anim === 'some') opts.redraw = true;\n    if (relayoutFlags.anim === 'some') opts.redraw = true;\n    for (var k in subplots) {\n      var plotinfo = subplots[k];\n      var xa = plotinfo.xaxis;\n      var ya = plotinfo.yaxis;\n      var xr0 = oldFullLayout[xa._name].range.slice();\n      var yr0 = oldFullLayout[ya._name].range.slice();\n      var xr1 = xa.range.slice();\n      var yr1 = ya.range.slice();\n      xa.setScale();\n      ya.setScale();\n      var editX = null;\n      var editY = null;\n      if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {\n        editX = {\n          xr0: xr0,\n          xr1: xr1\n        };\n      }\n      if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {\n        editY = {\n          yr0: yr0,\n          yr1: yr1\n        };\n      }\n      if (editX || editY) {\n        axEdits.push(Lib.extendFlat({\n          plotinfo: plotinfo\n        }, editX, editY));\n      }\n    }\n    return Promise.resolve();\n  };\n  opts.runFn = function (makeCallback) {\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var basePlotModules = fullLayout._basePlotModules;\n    var axisTransitionOpts;\n    var traceTransitionOpts;\n    var transitionedTraces;\n    var allTraceIndices = [];\n    for (var i = 0; i < fullData.length; i++) {\n      allTraceIndices.push(i);\n    }\n    function transitionAxes() {\n      if (!gd._fullLayout) return;\n      for (var j = 0; j < basePlotModules.length; j++) {\n        if (basePlotModules[j].transitionAxes) {\n          basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);\n        }\n      }\n    }\n    function transitionTraces() {\n      if (!gd._fullLayout) return;\n      for (var j = 0; j < basePlotModules.length; j++) {\n        basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);\n      }\n    }\n    if (axEdits.length && restyleFlags.anim) {\n      if (transitionOpts.ordering === 'traces first') {\n        axisTransitionOpts = Lib.extendFlat({}, transitionOpts, {\n          duration: 0\n        });\n        transitionedTraces = allTraceIndices;\n        traceTransitionOpts = transitionOpts;\n        setTimeout(transitionAxes, transitionOpts.duration);\n        transitionTraces();\n      } else {\n        axisTransitionOpts = transitionOpts;\n        transitionedTraces = null;\n        traceTransitionOpts = Lib.extendFlat({}, transitionOpts, {\n          duration: 0\n        });\n        setTimeout(transitionTraces, axisTransitionOpts.duration);\n        transitionAxes();\n      }\n    } else if (axEdits.length) {\n      axisTransitionOpts = transitionOpts;\n      transitionAxes();\n    } else if (restyleFlags.anim) {\n      transitionedTraces = allTraceIndices;\n      traceTransitionOpts = transitionOpts;\n      transitionTraces();\n    }\n  };\n  return _transition(gd, transitionOpts, opts);\n};\n\n/**\n * trace/layout transition wrapper that works\n * for transitions initiated by Plotly.animate and Plotly.react.\n *\n * @param {DOM element} gd\n * @param {object} transitionOpts\n * @param {object} opts\n * - redraw {boolean}\n * - prepareFn {function} *should return a Promise*\n * - runFn {function} ran inside executeTransitions\n */\nfunction _transition(gd, transitionOpts, opts) {\n  var aborted = false;\n  function executeCallbacks(list) {\n    var p = Promise.resolve();\n    if (!list) return p;\n    while (list.length) {\n      p = p.then(list.shift());\n    }\n    return p;\n  }\n  function flushCallbacks(list) {\n    if (!list) return;\n    while (list.length) {\n      list.shift();\n    }\n  }\n  function executeTransitions() {\n    gd.emit('plotly_transitioning', []);\n    return new Promise(function (resolve) {\n      // This flag is used to disabled things like autorange:\n      gd._transitioning = true;\n\n      // When instantaneous updates are coming through quickly, it's too much to simply disable\n      // all interaction, so store this flag so we can disambiguate whether mouse interactions\n      // should be fully disabled or not:\n      if (transitionOpts.duration > 0) {\n        gd._transitioningWithDuration = true;\n      }\n\n      // If another transition is triggered, this callback will be executed simply because it's\n      // in the interruptCallbacks queue. If this transition completes, it will instead flush\n      // that queue and forget about this callback.\n      gd._transitionData._interruptCallbacks.push(function () {\n        aborted = true;\n      });\n      if (opts.redraw) {\n        gd._transitionData._interruptCallbacks.push(function () {\n          return Registry.call('redraw', gd);\n        });\n      }\n\n      // Emit this and make sure it happens last:\n      gd._transitionData._interruptCallbacks.push(function () {\n        gd.emit('plotly_transitioninterrupted', []);\n      });\n\n      // Construct callbacks that are executed on transition end. This ensures the d3 transitions\n      // are *complete* before anything else is done.\n      var numCallbacks = 0;\n      var numCompleted = 0;\n      function makeCallback() {\n        numCallbacks++;\n        return function () {\n          numCompleted++;\n          // When all are complete, perform a redraw:\n          if (!aborted && numCompleted === numCallbacks) {\n            completeTransition(resolve);\n          }\n        };\n      }\n      opts.runFn(makeCallback);\n\n      // If nothing else creates a callback, then this will trigger the completion in the next tick:\n      setTimeout(makeCallback());\n    });\n  }\n  function completeTransition(callback) {\n    // This a simple workaround for tests which purge the graph before animations\n    // have completed. That's not a very common case, so this is the simplest\n    // fix.\n    if (!gd._transitionData) return;\n    flushCallbacks(gd._transitionData._interruptCallbacks);\n    return Promise.resolve().then(function () {\n      if (opts.redraw) {\n        return Registry.call('redraw', gd);\n      }\n    }).then(function () {\n      // Set transitioning false again once the redraw has occurred. This is used, for example,\n      // to prevent the trailing redraw from autoranging:\n      gd._transitioning = false;\n      gd._transitioningWithDuration = false;\n      gd.emit('plotly_transitioned', []);\n    }).then(callback);\n  }\n  function interruptPreviousTransitions() {\n    // Fail-safe against purged plot:\n    if (!gd._transitionData) return;\n\n    // If a transition is interrupted, set this to false. At the moment, the only thing that would\n    // interrupt a transition is another transition, so that it will momentarily be set to true\n    // again, but this determines whether autorange or dragbox work, so it's for the sake of\n    // cleanliness:\n    gd._transitioning = false;\n    return executeCallbacks(gd._transitionData._interruptCallbacks);\n  }\n  var seq = [plots.previousPromises, interruptPreviousTransitions, opts.prepareFn, plots.rehover, plots.reselect, executeTransitions];\n  var transitionStarting = Lib.syncOrAsync(seq, gd);\n  if (!transitionStarting || !transitionStarting.then) {\n    transitionStarting = Promise.resolve();\n  }\n  return transitionStarting.then(function () {\n    return gd;\n  });\n}\nplots.doCalcdata = function (gd, traces) {\n  var axList = axisIDs.list(gd);\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n  var trace, _module, i, j;\n\n  // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\n  // *all* needing doCalcdata:\n  var calcdata = new Array(fullData.length);\n  var oldCalcdata = (gd.calcdata || []).slice();\n  gd.calcdata = calcdata;\n\n  // extra helper variables\n\n  // how many box/violins plots do we have (in case they're grouped)\n  fullLayout._numBoxes = 0;\n  fullLayout._numViolins = 0;\n\n  // initialize violin per-scale-group stats container\n  fullLayout._violinScaleGroupStats = {};\n\n  // for calculating avg luminosity of heatmaps\n  gd._hmpixcount = 0;\n  gd._hmlumcount = 0;\n\n  // for sharing colors across pies / sunbursts / treemap / icicle / funnelarea (and for legend)\n  fullLayout._piecolormap = {};\n  fullLayout._sunburstcolormap = {};\n  fullLayout._treemapcolormap = {};\n  fullLayout._iciclecolormap = {};\n  fullLayout._funnelareacolormap = {};\n\n  // If traces were specified and this trace was not included,\n  // then transfer it over from the old calcdata:\n  for (i = 0; i < fullData.length; i++) {\n    if (Array.isArray(traces) && traces.indexOf(i) === -1) {\n      calcdata[i] = oldCalcdata[i];\n      continue;\n    }\n  }\n  for (i = 0; i < fullData.length; i++) {\n    trace = fullData[i];\n    trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);\n\n    // keep track of trace extremes (for autorange) in here\n    trace._extremes = {};\n  }\n\n  // add polar axes to axis list\n  var polarIds = fullLayout._subplots.polar || [];\n  for (i = 0; i < polarIds.length; i++) {\n    axList.push(fullLayout[polarIds[i]].radialaxis, fullLayout[polarIds[i]].angularaxis);\n  }\n\n  // clear relinked cmin/cmax values in shared axes to start aggregation from scratch\n  for (var k in fullLayout._colorAxes) {\n    var cOpts = fullLayout[k];\n    if (cOpts.cauto !== false) {\n      delete cOpts.cmin;\n      delete cOpts.cmax;\n    }\n  }\n  var hasCalcTransform = false;\n  function transformCalci(i) {\n    trace = fullData[i];\n    _module = trace._module;\n    if (trace.visible === true && trace.transforms) {\n      // we need one round of trace module calc before\n      // the calc transform to 'fill in' the categories list\n      // used for example in the data-to-coordinate method\n      if (_module && _module.calc) {\n        var cdi = _module.calc(gd, trace);\n\n        // must clear scene 'batches', so that 2nd\n        // _module.calc call starts from scratch\n        if (cdi[0] && cdi[0].t && cdi[0].t._scene) {\n          delete cdi[0].t._scene.dirty;\n        }\n      }\n      for (j = 0; j < trace.transforms.length; j++) {\n        var transform = trace.transforms[j];\n        _module = transformsRegistry[transform.type];\n        if (_module && _module.calcTransform) {\n          trace._hasCalcTransform = true;\n          hasCalcTransform = true;\n          _module.calcTransform(gd, trace, transform);\n        }\n      }\n    }\n  }\n  function calci(i, isContainer) {\n    trace = fullData[i];\n    _module = trace._module;\n    if (!!_module.isContainer !== isContainer) return;\n    var cd = [];\n    if (trace.visible === true && trace._length !== 0) {\n      // clear existing ref in case it got relinked\n      delete trace._indexToPoints;\n      // keep ref of index-to-points map object of the *last* enabled transform,\n      // this index-to-points map object is required to determine the calcdata indices\n      // that correspond to input indices (e.g. from 'selectedpoints')\n      var transforms = trace.transforms || [];\n      for (j = transforms.length - 1; j >= 0; j--) {\n        if (transforms[j].enabled) {\n          trace._indexToPoints = transforms[j]._indexToPoints;\n          break;\n        }\n      }\n      if (_module && _module.calc) {\n        cd = _module.calc(gd, trace);\n      }\n    }\n\n    // Make sure there is a first point.\n    //\n    // This ensures there is a calcdata item for every trace,\n    // even if cartesian logic doesn't handle it (for things like legends).\n    if (!Array.isArray(cd) || !cd[0]) {\n      cd = [{\n        x: BADNUM,\n        y: BADNUM\n      }];\n    }\n\n    // add the trace-wide properties to the first point,\n    // per point properties to every point\n    // t is the holder for trace-wide properties\n    if (!cd[0].t) cd[0].t = {};\n    cd[0].trace = trace;\n    calcdata[i] = cd;\n  }\n  setupAxisCategories(axList, fullData, fullLayout);\n\n  // 'transform' loop - must calc container traces first\n  // so that if their dependent traces can get transform properly\n  for (i = 0; i < fullData.length; i++) calci(i, true);\n  for (i = 0; i < fullData.length; i++) transformCalci(i);\n\n  // clear stuff that should recomputed in 'regular' loop\n  if (hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);\n\n  // 'regular' loop - make sure container traces (eg carpet) calc before\n  // contained traces (eg contourcarpet)\n  for (i = 0; i < fullData.length; i++) calci(i, true);\n  for (i = 0; i < fullData.length; i++) calci(i, false);\n  doCrossTraceCalc(gd);\n\n  // Sort axis categories per value if specified\n  var sorted = sortAxisCategoriesByValue(axList, gd);\n  if (sorted.length) {\n    // how many box/violins plots do we have (in case they're grouped)\n    fullLayout._numBoxes = 0;\n    fullLayout._numViolins = 0;\n    // If a sort operation was performed, run calc() again\n    for (i = 0; i < sorted.length; i++) calci(sorted[i], true);\n    for (i = 0; i < sorted.length; i++) calci(sorted[i], false);\n    doCrossTraceCalc(gd);\n  }\n  Registry.getComponentMethod('fx', 'calc')(gd);\n  Registry.getComponentMethod('errorbars', 'calc')(gd);\n};\nvar sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|geometric mean|median) (ascending|descending)/;\nfunction sortAxisCategoriesByValue(axList, gd) {\n  var affectedTraces = [];\n  var i, j, k, l, o;\n  function zMapCategory(type, ax, value) {\n    var axLetter = ax._id.charAt(0);\n    if (type === 'histogram2dcontour') {\n      var counterAxLetter = ax._counterAxes[0];\n      var counterAx = axisIDs.getFromId(gd, counterAxLetter);\n      var xCategorical = axLetter === 'x' || counterAxLetter === 'x' && counterAx.type === 'category';\n      var yCategorical = axLetter === 'y' || counterAxLetter === 'y' && counterAx.type === 'category';\n      return function (o, l) {\n        if (o === 0 || l === 0) return -1; // Skip first row and column\n        if (xCategorical && o === value[l].length - 1) return -1;\n        if (yCategorical && l === value.length - 1) return -1;\n        return (axLetter === 'y' ? l : o) - 1;\n      };\n    } else {\n      return function (o, l) {\n        return axLetter === 'y' ? l : o;\n      };\n    }\n  }\n  var aggFn = {\n    min: function (values) {\n      return Lib.aggNums(Math.min, null, values);\n    },\n    max: function (values) {\n      return Lib.aggNums(Math.max, null, values);\n    },\n    sum: function (values) {\n      return Lib.aggNums(function (a, b) {\n        return a + b;\n      }, null, values);\n    },\n    total: function (values) {\n      return Lib.aggNums(function (a, b) {\n        return a + b;\n      }, null, values);\n    },\n    mean: function (values) {\n      return Lib.mean(values);\n    },\n    'geometric mean': function (values) {\n      return Lib.geometricMean(values);\n    },\n    median: function (values) {\n      return Lib.median(values);\n    }\n  };\n  function sortAscending(a, b) {\n    return a[1] - b[1];\n  }\n  function sortDescending(a, b) {\n    return b[1] - a[1];\n  }\n  for (i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    if (ax.type !== 'category') continue;\n\n    // Order by value\n    var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);\n    if (match) {\n      var aggregator = match[1];\n      var order = match[2];\n      var axLetter = ax._id.charAt(0);\n      var isX = axLetter === 'x';\n\n      // Store values associated with each category\n      var categoriesValue = [];\n      for (j = 0; j < ax._categories.length; j++) {\n        categoriesValue.push([ax._categories[j], []]);\n      }\n\n      // Collect values across traces\n      for (j = 0; j < ax._traceIndices.length; j++) {\n        var traceIndex = ax._traceIndices[j];\n        var fullTrace = gd._fullData[traceIndex];\n\n        // Skip over invisible traces\n        if (fullTrace.visible !== true) continue;\n        var type = fullTrace.type;\n        if (Registry.traceIs(fullTrace, 'histogram')) {\n          delete fullTrace._xautoBinFinished;\n          delete fullTrace._yautoBinFinished;\n        }\n        var isSplom = type === 'splom';\n        var isScattergl = type === 'scattergl';\n        var cd = gd.calcdata[traceIndex];\n        for (k = 0; k < cd.length; k++) {\n          var cdi = cd[k];\n          var catIndex, value;\n          if (isSplom) {\n            // If `splom`, collect values across dimensions\n            // Find which dimension the current axis is representing\n            var currentDimensionIndex = fullTrace._axesDim[ax._id];\n\n            // Apply logic to associated x axis if it's defined\n            if (!isX) {\n              var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];\n              if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];\n            }\n            var categories = cdi.trace.dimensions[currentDimensionIndex].values;\n            for (l = 0; l < categories.length; l++) {\n              catIndex = ax._categoriesMap[categories[l]];\n\n              // Collect associated values at index `l` over all other dimensions\n              for (o = 0; o < cdi.trace.dimensions.length; o++) {\n                if (o === currentDimensionIndex) continue;\n                var dimension = cdi.trace.dimensions[o];\n                categoriesValue[catIndex][1].push(dimension.values[l]);\n              }\n            }\n          } else if (isScattergl) {\n            // If `scattergl`, collect all values stashed under cdi.t\n            for (l = 0; l < cdi.t.x.length; l++) {\n              if (isX) {\n                catIndex = cdi.t.x[l];\n                value = cdi.t.y[l];\n              } else {\n                catIndex = cdi.t.y[l];\n                value = cdi.t.x[l];\n              }\n              categoriesValue[catIndex][1].push(value);\n            }\n            // must clear scene 'batches', so that 2nd\n            // _module.calc call starts from scratch\n            if (cdi.t && cdi.t._scene) {\n              delete cdi.t._scene.dirty;\n            }\n          } else if (cdi.hasOwnProperty('z')) {\n            // If 2dMap, collect values in `z`\n            value = cdi.z;\n            var mapping = zMapCategory(fullTrace.type, ax, value);\n            for (l = 0; l < value.length; l++) {\n              for (o = 0; o < value[l].length; o++) {\n                catIndex = mapping(o, l);\n                if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);\n              }\n            }\n          } else {\n            // For all other 2d cartesian traces\n            catIndex = cdi.p;\n            if (catIndex === undefined) catIndex = cdi[axLetter];\n            value = cdi.s;\n            if (value === undefined) value = cdi.v;\n            if (value === undefined) value = isX ? cdi.y : cdi.x;\n            if (!Array.isArray(value)) {\n              if (value === undefined) value = [];else value = [value];\n            }\n            for (l = 0; l < value.length; l++) {\n              categoriesValue[catIndex][1].push(value[l]);\n            }\n          }\n        }\n      }\n      ax._categoriesValue = categoriesValue;\n      var categoriesAggregatedValue = [];\n      for (j = 0; j < categoriesValue.length; j++) {\n        categoriesAggregatedValue.push([categoriesValue[j][0], aggFn[aggregator](categoriesValue[j][1])]);\n      }\n\n      // Sort by aggregated value\n      categoriesAggregatedValue.sort(order === 'descending' ? sortDescending : sortAscending);\n      ax._categoriesAggregatedValue = categoriesAggregatedValue;\n\n      // Set new category order\n      ax._initialCategories = categoriesAggregatedValue.map(function (c) {\n        return c[0];\n      });\n\n      // Sort all matching axes\n      affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());\n    }\n  }\n  return affectedTraces;\n}\nfunction setupAxisCategories(axList, fullData, fullLayout) {\n  var axLookup = {};\n  function setupOne(ax) {\n    ax.clearCalc();\n    if (ax.type === 'multicategory') {\n      ax.setupMultiCategory(fullData);\n    }\n    axLookup[ax._id] = 1;\n  }\n  Lib.simpleMap(axList, setupOne);\n\n  // look into match groups for 'missing' axes\n  var matchGroups = fullLayout._axisMatchGroups || [];\n  for (var i = 0; i < matchGroups.length; i++) {\n    for (var axId in matchGroups[i]) {\n      if (!axLookup[axId]) {\n        setupOne(fullLayout[axisIDs.id2name(axId)]);\n      }\n    }\n  }\n}\nfunction doCrossTraceCalc(gd) {\n  var fullLayout = gd._fullLayout;\n  var modules = fullLayout._visibleModules;\n  var hash = {};\n  var i, j, k;\n\n  // position and range calculations for traces that\n  // depend on each other ie bars (stacked or grouped)\n  // and boxes (grouped) push each other out of the way\n\n  for (j = 0; j < modules.length; j++) {\n    var _module = modules[j];\n    var fn = _module.crossTraceCalc;\n    if (fn) {\n      var spType = _module.basePlotModule.name;\n      if (hash[spType]) {\n        Lib.pushUnique(hash[spType], fn);\n      } else {\n        hash[spType] = [fn];\n      }\n    }\n  }\n  for (k in hash) {\n    var methods = hash[k];\n    var subplots = fullLayout._subplots[k];\n    if (Array.isArray(subplots)) {\n      for (i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        var spInfo = k === 'cartesian' ? fullLayout._plots[sp] : fullLayout[sp];\n        for (j = 0; j < methods.length; j++) {\n          methods[j](gd, spInfo, sp);\n        }\n      }\n    } else {\n      for (j = 0; j < methods.length; j++) {\n        methods[j](gd);\n      }\n    }\n  }\n}\nplots.rehover = function (gd) {\n  if (gd._fullLayout._rehover) {\n    gd._fullLayout._rehover();\n  }\n};\nplots.redrag = function (gd) {\n  if (gd._fullLayout._redrag) {\n    gd._fullLayout._redrag();\n  }\n};\nplots.reselect = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var A = (gd.layout || {}).selections;\n  var B = fullLayout._previousSelections;\n  fullLayout._previousSelections = A;\n  var mayEmitSelected = fullLayout._reselect || JSON.stringify(A) !== JSON.stringify(B);\n  Registry.getComponentMethod('selections', 'reselect')(gd, mayEmitSelected);\n};\nplots.generalUpdatePerTraceModule = function (gd, subplot, subplotCalcData, subplotLayout) {\n  var traceHashOld = subplot.traceHash;\n  var traceHash = {};\n  var i;\n\n  // build up moduleName -> calcData hash\n  for (i = 0; i < subplotCalcData.length; i++) {\n    var calcTraces = subplotCalcData[i];\n    var trace = calcTraces[0].trace;\n\n    // skip over visible === false traces\n    // as they don't have `_module` ref\n    if (trace.visible) {\n      traceHash[trace.type] = traceHash[trace.type] || [];\n      traceHash[trace.type].push(calcTraces);\n    }\n  }\n\n  // when a trace gets deleted, make sure that its module's\n  // plot method is called so that it is properly\n  // removed from the DOM.\n  for (var moduleNameOld in traceHashOld) {\n    if (!traceHash[moduleNameOld]) {\n      var fakeCalcTrace = traceHashOld[moduleNameOld][0];\n      var fakeTrace = fakeCalcTrace[0].trace;\n      fakeTrace.visible = false;\n      traceHash[moduleNameOld] = [fakeCalcTrace];\n    }\n  }\n\n  // call module plot method\n  for (var moduleName in traceHash) {\n    var moduleCalcData = traceHash[moduleName];\n    var _module = moduleCalcData[0][0].trace._module;\n    _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);\n  }\n\n  // update moduleName -> calcData hash\n  subplot.traceHash = traceHash;\n};\nplots.plotBasePlot = function (desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {\n  var _module = Registry.getModule(desiredType);\n  var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];\n  _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);\n};\nplots.cleanBasePlot = function (desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var had = oldFullLayout._has && oldFullLayout._has(desiredType);\n  var has = newFullLayout._has && newFullLayout._has(desiredType);\n  if (had && !has) {\n    oldFullLayout['_' + desiredType + 'layer'].selectAll('g.trace').remove();\n  }\n};","map":{"version":3,"names":["d3","require","timeFormatLocale","formatLocale","isNumeric","b64encode","Registry","PlotSchema","Template","Lib","Color","BADNUM","axisIDs","clearOutline","scatterAttrs","animationAttrs","frameAttrs","getModuleCalcData","relinkPrivateKeys","_","plots","module","exports","extendFlat","attributes","type","values","allTypes","fontAttrs","layoutAttributes","transformsRegistry","commandModule","executeAPICommand","computeAPICommandBindings","manageCommandObserver","hasSimpleAPICommandBindings","redrawText","gd","getGraphDiv","Promise","resolve","setTimeout","_fullLayout","getComponentMethod","previousPromises","resize","resolveLastResize","p","reject","isHidden","Error","_redrawTimer","clearTimeout","_resolveResize","layout","width","height","oldchanged","changed","autoplay","call","autosize","then","_promises","length","all","addLinks","_context","showLink","showSources","fullLayout","linkContainer","ensureSingle","_paper","s","style","fill","defaultLine","each","links","select","append","classed","text","node","attrs","y","attr","document","body","contains","getComputedTextLength","x","toolspan","spacespan","sourcespan","positionPlayWithData","container","link","class","linkText","String","fromCharCode","sendData","on","sendDataToCloud","path","window","location","pathname","split","query","search","baseUrl","PLOTLYENV","BASE_URL","plotlyServerURL","emit","hiddenformDiv","hiddenform","action","method","target","hiddenformInput","name","value","graphJson","submit","remove","d3FormatKeys","extraFormatKeys","supplyDefaults","opts","skipUpdateCalc","oldFullLayout","_skipDefaults","newFullLayout","newLayout","oldFullData","_fullData","newFullData","newData","data","oldCalcdata","calcdata","context","i","_transitionData","createTransitionData","_dfltTitle","plot","subtitle","colorbar","annotation","_traceWord","formatObj","getFormatObj","_mapboxAccessToken","mapboxAccessToken","_initialAutoSizeIsDone","oldWidth","oldHeight","supplyLayoutGlobalDefaults","sanitizeMargins","missingWidthOrHeight","autosizable","initialAutoSize","plotAutoSize","_d3locale","getFormatter","separators","_extraFormat","_dataLength","_modules","_visibleModules","_basePlotModules","subplots","_subplots","emptySubplotLists","splomAxes","_splomAxes","splomSubplots","_splomSubplots","_splomGridDflt","_scatterStackOpts","_firstScatter","_alignmentOpts","_colorAxes","_requestRangeslider","_traceUids","getTraceUids","_globalTransforms","globalTransforms","supplyDataDefaults","splomXa","Object","keys","splomYa","pushUnique","xaxis","yaxis","k","cartesian","_has","_hasPlotType","bind","supplyLayoutModuleDefaults","crossTraceDefaultsFuncs","funci","crossTraceDefaults","_hasOnlyLargeSploms","shapes","images","linkSubplots","cleanPlot","hadGL2D","hasGL2D","hadCartesian","hasCartesian","hadBgLayer","hasBgLayer","_bgLayer","_shouldCreateBgLayer","_zoomlayer","_dragging","fillMetaTextHelpers","_preGUI","_tracePreGUI","tracePreGUI","uids","uid","_fullInput","initMargins","supplyDefaultsUpdateCalc","newTrace","cd0","trace","oldTrace","_hasCalcTransform","arrayAttrs","_arrayAttrs","j","astr","oldArrayVal","nestedProperty","get","slice","set","len","oldFullInput","prevFullInput","thisFullInput","push","oldLen","out","Array","seenUids","setUid","tryUid","newUid","randstr","collectableSubplotTypes","subplotsRegistry","subplotType","subplotModule","subplotAttr","isArray","formatKeys","locale","formatDone","includeFormat","newFormat","formatFinished","formatKey","locales","formatj","format","localeRegistry","baseLocale","en","decimal","charAt","thousands","numberFormat","formatStr","adjustFormat","e","warnBadFormat","noFormat","timeFormat","utcFormat","_meta","meta4data","meta","index","_frames","_frameHash","_counter","_interruptCallbacks","category","basePlotModules","modules","_module","categories","clean","hadGl","hasGl","_glcontainer","undefined","selectAll","_glcanvas","hasInfoLayer","_infolayer","oldLoop","oldUid","oldSubplots","_plots","newSubplots","newSubplotList","mockGd","ids","concat","gl2d","id","oldSubplot","getFromId","plotinfo","_counterAxes","_id","_subplotsWith","_hasClipOnAxisFalse","cliponaxis","axList","list","ax","mainAx","overlaying","_mainAxis","domain","_anchorAxis","anchor","sort","idSort","subplotSort","_mainSubplot","findMainSubplot","spikemode","indexOf","automargin","mirror","min","max","ax2","Math","_counterDomainMin","_counterDomainMax","isX","anchorAx","mainSubplotID","nextBestMainSubplotID","anchorID","counterIDs","counterPart","counterAx","clearExpandedTraceDefaultColors","colorAttrs","locateColorAttrs","attrName","level","valType","dflt","join","_colorAttrs","crawl","origprop","dataIn","dataOut","visibleModules","cnt","colorCnt","fullTrace","_transformModules","pushModule","visible","basePlotModule","_input","carpetIndex","carpetDependents","dataTemplate","template","templater","traceTemplater","supplyTraceDefaults","_expandedIndex","transforms","sdInvisible","expandedTraces","applyTransforms","expandedTrace","fullExpandedTrace","_template","_expandedInput","traceIs","carpet","carpetAxis","_carpet","supplyAnimationDefaults","optsOut","coerce","frame","supplyAnimationFrameDefaults","transition","supplyAnimationTransitionDefaults","supplyFrameDefaults","frameIn","frameOut","traceIn","traceOut","colorIndex","traceInIndex","colorway","defaults","defaultColor","uirevision","getModule","subplotAttrs","subplotId","attri","vali","showlegend","_dfltShowLegend","hovertemplate","coerceHoverinfo","selectPoints","selectedpoints","isTypedArray","from","supplyTransformDefaults","hasMakesDataTransform","ti","makesData","_length","transformModules","containerIn","transformList","containerOut","transformIn","transformOut","isFirstStage","doLaterStages","transform","warn","fullData","transformIndex","layoutIn","layoutOut","isPlainObject","_dataTemplate","font","coerceFont","fontSize","size","overrideDflt","round","titleYref","titleAutomargin","title","yanchor","uniformtextMode","getComputedSize","substr","parseFloat","frameMargins","newWidth","newHeight","isPlotDiv","fillFrame","innerWidth","innerHeight","overflow","computedStyle","getComputedStyle","maxWidth","maxHeight","factor","minWidth","minHeight","widthHasChanged","abs","heightHasChanged","_initialAutoSize","transitionData","componentsRegistry","component","Cartesian","includeBasePlot","finalizeSubplots","supplyLayoutDefaults","purge","_modeBar","destroy","_animationRaf","cancelAnimationFrame","clearThrottle","clearResponsive","empty","fid","undoqueue","undonum","_hmlumcount","_hmpixcount","_transitioning","_transitioningWithDuration","_dragged","_dragdata","_hoverdata","_snapshotInProgress","_editing","_mouseDownTime","_legendMouseDownTime","removeAllListeners","styleModules","margin","plotWidth","l","r","plotHeight","t","b","correction","floor","clearAutoMarginIds","_pushmarginIds","allowAutoMargin","_size","gs","pad","w","h","_pushmargin","_reservedMargin","MIN_SPECIFIED_WIDTH","MIN_SPECIFIED_HEIGHT","autoMargin","o","minreducedwidth","minreducedheight","minFinalWidth","constrain","minFinalHeight","maxSpaceW","maxSpaceH","pushMargin","pushMarginIds","autoexpand","rW","rH","xl","xr","yt","yb","val","_replotting","doAutoMargin","needsRedrawForShift","autoshift","shift","reservedMargins","oldMargins","ml","mr","mt","mb","margins","key","side","base","autoMarginPush","m","extraMargin","k1","pushleft","pushbottom","fl","pl","fb","pb","availableWidth","availableHeight","k2","fr","pr","newL","newR","ft","pt","newB","newT","didMarginChange","_redrawFromAutoMarginCount","maxNumberOfRedraws","refineTicks","forEach","hideFn","marginKeys","margin0","margin1","m0","m1","dataonly","mode","output","useDefaults","includeConfig","frames","stripObj","d","keepFunction","src","v","stream","dIsArray","dIsTypedArray","dtype","shape","bdata","isArrayBuffer","encode","map","simpleMap","identity","isJSDate","ms2DateTimeLocal","obj","fit","computed","config","JSON","stringify","modifyFrames","operations","op","oldName","newName","splice","computeFrame","frameName","frameLookup","traceIndices","traceIndex","destIndex","framePtr","toString","frameStack","frameNameStack","baseframe","result","pop","extendLayout","traces","extendTrace","recomputeFrameHash","hash","extendObjectWithContainers","dest","containerPaths","containerProp","containerVal","srcProp","destProp","srcContainer","destContainer","copy","extendDeepNoArrays","expandedObj","expandObjectPaths","containerObj","srcObj","dataArrayContainers","layoutArrayContainers","destTrace","srcTrace","destLayout","srcLayout","frameOpts","transitionOpts","redraw","transitionedTraces","axEdits","prepareFn","dataLength","traceIdx","animatable","n","layoutUpdate","axisAttrRe","test","range","doCalcdata","xa","ya","xr0","yr0","xr1","yr1","editX","editY","_name","r2l","runFn","makeCallback","traceTransitionOpts","hasAxisTransition","transitionAxes","duration","_transition","transitionFromReact","restyleFlags","relayoutFlags","anim","setScale","axisTransitionOpts","allTraceIndices","transitionTraces","ordering","aborted","executeCallbacks","flushCallbacks","executeTransitions","numCallbacks","numCompleted","completeTransition","callback","interruptPreviousTransitions","seq","rehover","reselect","transitionStarting","syncOrAsync","_numBoxes","_numViolins","_violinScaleGroupStats","_piecolormap","_sunburstcolormap","_treemapcolormap","_iciclecolormap","_funnelareacolormap","findArrayAttributes","_extremes","polarIds","polar","radialaxis","angularaxis","cOpts","cauto","cmin","cmax","hasCalcTransform","transformCalci","calc","cdi","_scene","dirty","calcTransform","calci","isContainer","cd","_indexToPoints","enabled","setupAxisCategories","doCrossTraceCalc","sorted","sortAxisCategoriesByValue","sortAxisCategoriesByValueRegex","affectedTraces","zMapCategory","axLetter","counterAxLetter","xCategorical","yCategorical","aggFn","aggNums","sum","a","total","mean","geometric mean","geometricMean","median","sortAscending","sortDescending","match","categoryorder","aggregator","order","categoriesValue","_categories","_traceIndices","_xautoBinFinished","_yautoBinFinished","isSplom","isScattergl","catIndex","currentDimensionIndex","_axesDim","associatedXAxisID","_diag","id2name","dimensions","_categoriesMap","dimension","hasOwnProperty","z","mapping","_categoriesValue","categoriesAggregatedValue","_categoriesAggregatedValue","_initialCategories","c","sortByInitialCategories","axLookup","setupOne","clearCalc","setupMultiCategory","matchGroups","_axisMatchGroups","axId","fn","crossTraceCalc","spType","methods","sp","spInfo","_rehover","redrag","_redrag","A","selections","B","_previousSelections","mayEmitSelected","_reselect","generalUpdatePerTraceModule","subplot","subplotCalcData","subplotLayout","traceHashOld","traceHash","calcTraces","moduleNameOld","fakeCalcTrace","fakeTrace","moduleName","moduleCalcData","filterVisible","plotBasePlot","desiredType","makeOnCompleteCallback","cdmodule","cleanBasePlot","had","has"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/plots.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar timeFormatLocale = require('d3-time-format').timeFormatLocale;\nvar formatLocale = require('d3-format').formatLocale;\nvar isNumeric = require('fast-isnumeric');\nvar b64encode = require('base64-arraybuffer');\n\nvar Registry = require('../registry');\nvar PlotSchema = require('../plot_api/plot_schema');\nvar Template = require('../plot_api/plot_template');\nvar Lib = require('../lib');\nvar Color = require('../components/color');\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nvar axisIDs = require('./cartesian/axis_ids');\nvar clearOutline = require('../components/shapes/handle_outline').clearOutline;\nvar scatterAttrs = require('../traces/scatter/layout_attributes');\n\nvar animationAttrs = require('./animation_attributes');\nvar frameAttrs = require('./frame_attributes');\n\nvar getModuleCalcData = require('../plots/get_data').getModuleCalcData;\n\nvar relinkPrivateKeys = Lib.relinkPrivateKeys;\nvar _ = Lib._;\n\nvar plots = module.exports = {};\n\n// Expose registry methods on Plots for backward-compatibility\nLib.extendFlat(plots, Registry);\n\nplots.attributes = require('./attributes');\nplots.attributes.type.values = plots.allTypes;\nplots.fontAttrs = require('./font_attributes');\nplots.layoutAttributes = require('./layout_attributes');\n\nvar transformsRegistry = plots.transformsRegistry;\n\nvar commandModule = require('./command');\nplots.executeAPICommand = commandModule.executeAPICommand;\nplots.computeAPICommandBindings = commandModule.computeAPICommandBindings;\nplots.manageCommandObserver = commandModule.manageCommandObserver;\nplots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;\n\n// in some cases the browser doesn't seem to know how big\n// the text is at first, so it needs to draw it,\n// then wait a little, then draw it again\nplots.redrawText = function(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    return new Promise(function(resolve) {\n        setTimeout(function() {\n            if(!gd._fullLayout) return;\n            Registry.getComponentMethod('annotations', 'draw')(gd);\n            Registry.getComponentMethod('legend', 'draw')(gd);\n            Registry.getComponentMethod('colorbar', 'draw')(gd);\n            resolve(plots.previousPromises(gd));\n        }, 300);\n    });\n};\n\n// resize plot about the container size\nplots.resize = function(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    var resolveLastResize;\n    var p = new Promise(function(resolve, reject) {\n        if(!gd || Lib.isHidden(gd)) {\n            reject(new Error('Resize must be passed a displayed plot div element.'));\n        }\n\n        if(gd._redrawTimer) clearTimeout(gd._redrawTimer);\n        if(gd._resolveResize) resolveLastResize = gd._resolveResize;\n        gd._resolveResize = resolve;\n\n        gd._redrawTimer = setTimeout(function() {\n            // return if there is nothing to resize or is hidden\n            if(!gd.layout || (gd.layout.width && gd.layout.height) || Lib.isHidden(gd)) {\n                resolve(gd);\n                return;\n            }\n\n            delete gd.layout.width;\n            delete gd.layout.height;\n\n            // autosizing doesn't count as a change that needs saving\n            var oldchanged = gd.changed;\n\n            // nor should it be included in the undo queue\n            gd.autoplay = true;\n\n            Registry.call('relayout', gd, {autosize: true}).then(function() {\n                gd.changed = oldchanged;\n                // Only resolve if a new call hasn't been made!\n                if(gd._resolveResize === resolve) {\n                    delete gd._resolveResize;\n                    resolve(gd);\n                }\n            });\n        }, 100);\n    });\n\n    if(resolveLastResize) resolveLastResize(p);\n    return p;\n};\n\n\n// for use in Lib.syncOrAsync, check if there are any\n// pending promises in this plot and wait for them\nplots.previousPromises = function(gd) {\n    if((gd._promises || []).length) {\n        return Promise.all(gd._promises)\n            .then(function() { gd._promises = []; });\n    }\n};\n\n/**\n * Adds the 'Edit chart' link.\n * Note that now _doPlot calls this so it can regenerate whenever it replots\n *\n * Add source links to your graph inside the 'showSources' config argument.\n */\nplots.addLinks = function(gd) {\n    // Do not do anything if showLink and showSources are not set to true in config\n    if(!gd._context.showLink && !gd._context.showSources) return;\n\n    var fullLayout = gd._fullLayout;\n\n    var linkContainer = Lib.ensureSingle(fullLayout._paper, 'text', 'js-plot-link-container', function(s) {\n        s.style({\n            'font-family': '\"Open Sans\", Arial, sans-serif',\n            'font-size': '12px',\n            fill: Color.defaultLine,\n            'pointer-events': 'all'\n        })\n        .each(function() {\n            var links = d3.select(this);\n            links.append('tspan').classed('js-link-to-tool', true);\n            links.append('tspan').classed('js-link-spacer', true);\n            links.append('tspan').classed('js-sourcelinks', true);\n        });\n    });\n\n    // The text node inside svg\n    var text = linkContainer.node();\n    var attrs = {y: fullLayout._paper.attr('height') - 9};\n\n    // If text's width is bigger than the layout\n    // Check that text is a child node or document.body\n    // because otherwise IE/Edge might throw an exception\n    // when calling getComputedTextLength().\n    // Apparently offsetParent is null for invisibles.\n    if(document.body.contains(text) && text.getComputedTextLength() >= (fullLayout.width - 20)) {\n        // Align the text at the left\n        attrs['text-anchor'] = 'start';\n        attrs.x = 5;\n    } else {\n        // Align the text at the right\n        attrs['text-anchor'] = 'end';\n        attrs.x = fullLayout._paper.attr('width') - 7;\n    }\n\n    linkContainer.attr(attrs);\n\n    var toolspan = linkContainer.select('.js-link-to-tool');\n    var spacespan = linkContainer.select('.js-link-spacer');\n    var sourcespan = linkContainer.select('.js-sourcelinks');\n\n    if(gd._context.showSources) gd._context.showSources(gd);\n\n    // 'view in plotly' link for embedded plots\n    if(gd._context.showLink) positionPlayWithData(gd, toolspan);\n\n    // separator if we have both sources and tool link\n    spacespan.text((toolspan.text() && sourcespan.text()) ? ' - ' : '');\n};\n\n// note that now this function is only adding the brand in\n// iframes and 3rd-party apps\nfunction positionPlayWithData(gd, container) {\n    container.text('');\n    var link = container.append('a')\n        .attr({\n            'xlink:xlink:href': '#',\n            class: 'link--impt link--embedview',\n            'font-weight': 'bold'\n        })\n        .text(gd._context.linkText + ' ' + String.fromCharCode(187));\n\n    if(gd._context.sendData) {\n        link.on('click', function() {\n            plots.sendDataToCloud(gd);\n        });\n    } else {\n        var path = window.location.pathname.split('/');\n        var query = window.location.search;\n        link.attr({\n            'xlink:xlink:show': 'new',\n            'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query\n        });\n    }\n}\n\nplots.sendDataToCloud = function(gd) {\n    var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;\n    if(!baseUrl) return;\n\n    gd.emit('plotly_beforeexport');\n\n    var hiddenformDiv = d3.select(gd)\n        .append('div')\n        .attr('id', 'hiddenform')\n        .style('display', 'none');\n\n    var hiddenform = hiddenformDiv\n        .append('form')\n        .attr({\n            action: baseUrl + '/external',\n            method: 'post',\n            target: '_blank'\n        });\n\n    var hiddenformInput = hiddenform\n        .append('input')\n        .attr({\n            type: 'text',\n            name: 'data'\n        });\n\n    hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');\n    hiddenform.node().submit();\n    hiddenformDiv.remove();\n\n    gd.emit('plotly_afterexport');\n    return false;\n};\n\nvar d3FormatKeys = [\n    'days', 'shortDays', 'months', 'shortMonths', 'periods',\n    'dateTime', 'date', 'time',\n    'decimal', 'thousands', 'grouping', 'currency'\n];\n\nvar extraFormatKeys = [\n    'year', 'month', 'dayMonth', 'dayMonthYear'\n];\n\n/*\n * Fill in default values\n * @param {DOM element} gd\n * @param {object} opts\n * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks\n *   compatible with the new gd._fullData we finish by linking the new _fullData traces\n *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,\n *   if there are calcTransforms on the trace, we first remap data arrays from the old full\n *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)\n *\n * gd.data, gd.layout:\n *   are precisely what the user specified (except as modified by cleanData/cleanLayout),\n *   these fields shouldn't be modified (except for filling in some auto values)\n *   nor used directly after the supply defaults step.\n *\n * gd._fullData, gd._fullLayout:\n *   are complete descriptions of how to draw the plot,\n *   use these fields in all required computations.\n *\n * gd._fullLayout._modules\n *   is a list of all the trace modules required to draw the plot.\n *\n * gd._fullLayout._visibleModules\n *   subset of _modules, a list of modules corresponding to visible:true traces.\n *\n * gd._fullLayout._basePlotModules\n *   is a list of all the plot modules required to draw the plot.\n *\n * gd._fullLayout._transformModules\n *   is a list of all the transform modules invoked.\n *\n */\nplots.supplyDefaults = function(gd, opts) {\n    var skipUpdateCalc = opts && opts.skipUpdateCalc;\n    var oldFullLayout = gd._fullLayout || {};\n\n    if(oldFullLayout._skipDefaults) {\n        delete oldFullLayout._skipDefaults;\n        return;\n    }\n\n    var newFullLayout = gd._fullLayout = {};\n    var newLayout = gd.layout || {};\n\n    var oldFullData = gd._fullData || [];\n    var newFullData = gd._fullData = [];\n    var newData = gd.data || [];\n\n    var oldCalcdata = gd.calcdata || [];\n\n    var context = gd._context || {};\n\n    var i;\n\n    // Create all the storage space for frames, but only if doesn't already exist\n    if(!gd._transitionData) plots.createTransitionData(gd);\n\n    // So we only need to do this once (and since we have gd here)\n    // get the translated placeholder titles.\n    // These ones get used as default values so need to be known at supplyDefaults\n    // others keep their blank defaults but render the placeholder as desired later\n    // TODO: make these work the same way, only inserting the placeholder text at draw time?\n    // The challenge is that this has slightly different behavior right now in editable mode:\n    // using the placeholder as default makes this text permanently (but lightly) visible,\n    // but explicit '' for these titles gives you a placeholder that's hidden until you mouse\n    // over it - so you're not distracted by it if you really don't want a title, but if you do\n    // and you're new to plotly you may not be able to find it.\n    // When editable=false the two behave the same, no title is drawn.\n    newFullLayout._dfltTitle = {\n        plot: _(gd, 'Click to enter Plot title'),\n        subtitle: _(gd, 'Click to enter Plot subtitle'),\n        x: _(gd, 'Click to enter X axis title'),\n        y: _(gd, 'Click to enter Y axis title'),\n        colorbar: _(gd, 'Click to enter Colorscale title'),\n        annotation: _(gd, 'new text')\n    };\n    newFullLayout._traceWord = _(gd, 'trace');\n\n    var formatObj = getFormatObj(gd, d3FormatKeys);\n\n    // stash the token from context so mapbox subplots can use it as default\n    newFullLayout._mapboxAccessToken = context.mapboxAccessToken;\n\n    // first fill in what we can of layout without looking at data\n    // because fullData needs a few things from layout\n    if(oldFullLayout._initialAutoSizeIsDone) {\n        // coerce the updated layout while preserving width and height\n        var oldWidth = oldFullLayout.width;\n        var oldHeight = oldFullLayout.height;\n\n        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n\n        if(!newLayout.width) newFullLayout.width = oldWidth;\n        if(!newLayout.height) newFullLayout.height = oldHeight;\n        plots.sanitizeMargins(newFullLayout);\n    } else {\n        // coerce the updated layout and autosize if needed\n        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n\n        var missingWidthOrHeight = (!newLayout.width || !newLayout.height);\n        var autosize = newFullLayout.autosize;\n        var autosizable = context.autosizable;\n        var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);\n\n        if(initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);\n        else if(missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);\n\n        // for backwards-compatibility with Plotly v1.x.x\n        if(!autosize && missingWidthOrHeight) {\n            newLayout.width = newFullLayout.width;\n            newLayout.height = newFullLayout.height;\n        }\n    }\n\n    newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);\n    newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);\n\n    newFullLayout._initialAutoSizeIsDone = true;\n\n    // keep track of how many traces are inputted\n    newFullLayout._dataLength = newData.length;\n\n    // clear the lists of trace and baseplot modules, and subplots\n    newFullLayout._modules = [];\n    newFullLayout._visibleModules = [];\n    newFullLayout._basePlotModules = [];\n    var subplots = newFullLayout._subplots = emptySubplotLists();\n\n    // initialize axis and subplot hash objects for splom-generated grids\n    var splomAxes = newFullLayout._splomAxes = {x: {}, y: {}};\n    var splomSubplots = newFullLayout._splomSubplots = {};\n    // initialize splom grid defaults\n    newFullLayout._splomGridDflt = {};\n\n    // for stacked area traces to share config across traces\n    newFullLayout._scatterStackOpts = {};\n    // for the first scatter trace on each subplot (so it knows tonext->tozero)\n    newFullLayout._firstScatter = {};\n    // for grouped bar/box/violin trace to share config across traces\n    newFullLayout._alignmentOpts = {};\n    // track color axes referenced in the data\n    newFullLayout._colorAxes = {};\n\n    // for traces to request a default rangeslider on their x axes\n    // eg set `_requestRangeslider.x2 = true` for xaxis2\n    newFullLayout._requestRangeslider = {};\n\n    // pull uids from old data to use as new defaults\n    newFullLayout._traceUids = getTraceUids(oldFullData, newData);\n\n    // then do the data\n    newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;\n    plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);\n\n    // redo grid size defaults with info about splom x/y axes,\n    // and fill in generated cartesian axes and subplots\n    var splomXa = Object.keys(splomAxes.x);\n    var splomYa = Object.keys(splomAxes.y);\n    if(splomXa.length > 1 && splomYa.length > 1) {\n        Registry.getComponentMethod('grid', 'sizeDefaults')(newLayout, newFullLayout);\n\n        for(i = 0; i < splomXa.length; i++) {\n            Lib.pushUnique(subplots.xaxis, splomXa[i]);\n        }\n        for(i = 0; i < splomYa.length; i++) {\n            Lib.pushUnique(subplots.yaxis, splomYa[i]);\n        }\n        for(var k in splomSubplots) {\n            Lib.pushUnique(subplots.cartesian, k);\n        }\n    }\n\n    // attach helper method to check whether a plot type is present on graph\n    newFullLayout._has = plots._hasPlotType.bind(newFullLayout);\n\n    if(oldFullData.length === newFullData.length) {\n        for(i = 0; i < newFullData.length; i++) {\n            relinkPrivateKeys(newFullData[i], oldFullData[i]);\n        }\n    }\n\n    // finally, fill in the pieces of layout that may need to look at data\n    plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);\n\n    // Special cases that introduce interactions between traces.\n    // This is after relinkPrivateKeys so we can use those in crossTraceDefaults\n    // and after layout module defaults, so we can use eg barmode\n    var _modules = newFullLayout._visibleModules;\n    var crossTraceDefaultsFuncs = [];\n    for(i = 0; i < _modules.length; i++) {\n        var funci = _modules[i].crossTraceDefaults;\n        // some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)\n        if(funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);\n    }\n    for(i = 0; i < crossTraceDefaultsFuncs.length; i++) {\n        crossTraceDefaultsFuncs[i](newFullData, newFullLayout);\n    }\n\n    // turn on flag to optimize large splom-only graphs\n    // mostly by omitting SVG layers during Cartesian.drawFramework\n    newFullLayout._hasOnlyLargeSploms = (\n        newFullLayout._basePlotModules.length === 1 &&\n        newFullLayout._basePlotModules[0].name === 'splom' &&\n        splomXa.length > 15 &&\n        splomYa.length > 15 &&\n        newFullLayout.shapes.length === 0 &&\n        newFullLayout.images.length === 0\n    );\n\n    // relink / initialize subplot axis objects\n    plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);\n\n    // clean subplots and other artifacts from previous plot calls\n    plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);\n\n    var hadGL2D = !!(oldFullLayout._has && oldFullLayout._has('gl2d'));\n    var hasGL2D = !!(newFullLayout._has && newFullLayout._has('gl2d'));\n    var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has('cartesian'));\n    var hasCartesian = !!(newFullLayout._has && newFullLayout._has('cartesian'));\n    var hadBgLayer = hadCartesian || hadGL2D;\n    var hasBgLayer = hasCartesian || hasGL2D;\n    if(hadBgLayer && !hasBgLayer) {\n        // remove bgLayer\n        oldFullLayout._bgLayer.remove();\n    } else if(hasBgLayer && !hadBgLayer) {\n        // create bgLayer\n        newFullLayout._shouldCreateBgLayer = true;\n    }\n\n    // clear selection outline until we implement persistent selection,\n    // don't clear them though when drag handlers (e.g. listening to\n    // `plotly_selecting`) update the graph.\n    // we should try to come up with a better solution when implementing\n    // https://github.com/plotly/plotly.js/issues/1851\n    if(oldFullLayout._zoomlayer && !gd._dragging) {\n        clearOutline({ // mock old gd\n            _fullLayout: oldFullLayout\n        });\n    }\n\n\n    // fill in meta helpers\n    fillMetaTextHelpers(newFullData, newFullLayout);\n\n    // relink functions and _ attributes to promote consistency between plots\n    relinkPrivateKeys(newFullLayout, oldFullLayout);\n\n    // colorscale crossTraceDefaults needs newFullLayout with relinked keys\n    Registry.getComponentMethod('colorscale', 'crossTraceDefaults')(newFullData, newFullLayout);\n\n    // For persisting GUI-driven changes in layout\n    // _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys\n    if(!newFullLayout._preGUI) newFullLayout._preGUI = {};\n    // track trace GUI changes by uid rather than by trace index\n    if(!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};\n    var tracePreGUI = newFullLayout._tracePreGUI;\n    var uids = {};\n    var uid;\n    for(uid in tracePreGUI) uids[uid] = 'old';\n    for(i = 0; i < newFullData.length; i++) {\n        uid = newFullData[i]._fullInput.uid;\n        if(!uids[uid]) tracePreGUI[uid] = {};\n        uids[uid] = 'new';\n    }\n    for(uid in uids) {\n        if(uids[uid] === 'old') delete tracePreGUI[uid];\n    }\n\n    // set up containers for margin calculations\n    initMargins(newFullLayout);\n\n    // collect and do some initial calculations for rangesliders\n    Registry.getComponentMethod('rangeslider', 'makeData')(newFullLayout);\n\n    // update object references in calcdata\n    if(!skipUpdateCalc && oldCalcdata.length === newFullData.length) {\n        plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);\n    }\n};\n\nplots.supplyDefaultsUpdateCalc = function(oldCalcdata, newFullData) {\n    for(var i = 0; i < newFullData.length; i++) {\n        var newTrace = newFullData[i];\n        var cd0 = (oldCalcdata[i] || [])[0];\n        if(cd0 && cd0.trace) {\n            var oldTrace = cd0.trace;\n            if(oldTrace._hasCalcTransform) {\n                var arrayAttrs = oldTrace._arrayAttrs;\n                var j, astr, oldArrayVal;\n\n                for(j = 0; j < arrayAttrs.length; j++) {\n                    astr = arrayAttrs[j];\n                    oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();\n                    Lib.nestedProperty(newTrace, astr).set(oldArrayVal);\n                }\n            }\n            cd0.trace = newTrace;\n        }\n    }\n};\n\n/**\n * Create a list of uid strings satisfying (in this order of importance):\n * 1. all unique, all strings\n * 2. matches input uids if provided\n * 3. matches previous data uids\n */\nfunction getTraceUids(oldFullData, newData) {\n    var len = newData.length;\n    var oldFullInput = [];\n    var i, prevFullInput;\n    for(i = 0; i < oldFullData.length; i++) {\n        var thisFullInput = oldFullData[i]._fullInput;\n        if(thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);\n        prevFullInput = thisFullInput;\n    }\n    var oldLen = oldFullInput.length;\n    var out = new Array(len);\n    var seenUids = {};\n\n    function setUid(uid, i) {\n        out[i] = uid;\n        seenUids[uid] = 1;\n    }\n\n    function tryUid(uid, i) {\n        if(uid && typeof uid === 'string' && !seenUids[uid]) {\n            setUid(uid, i);\n            return true;\n        }\n    }\n\n    for(i = 0; i < len; i++) {\n        var newUid = newData[i].uid;\n        if(typeof newUid === 'number') newUid = String(newUid);\n\n        if(tryUid(newUid, i)) continue;\n        if(i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;\n        setUid(Lib.randstr(seenUids), i);\n    }\n\n    return out;\n}\n\n/**\n * Make a container for collecting subplots we need to display.\n *\n * Finds all subplot types we need to enumerate once and caches it,\n * but makes a new output object each time.\n * Single-trace subplots (which have no `id`) such as pie, table, etc\n * do not need to be collected because we just draw all visible traces.\n */\nfunction emptySubplotLists() {\n    var collectableSubplotTypes = Registry.collectableSubplotTypes;\n    var out = {};\n    var i, j;\n\n    if(!collectableSubplotTypes) {\n        collectableSubplotTypes = [];\n\n        var subplotsRegistry = Registry.subplotsRegistry;\n\n        for(var subplotType in subplotsRegistry) {\n            var subplotModule = subplotsRegistry[subplotType];\n            var subplotAttr = subplotModule.attr;\n\n            if(subplotAttr) {\n                collectableSubplotTypes.push(subplotType);\n\n                // special case, currently just for cartesian:\n                // we need to enumerate axes, not just subplots\n                if(Array.isArray(subplotAttr)) {\n                    for(j = 0; j < subplotAttr.length; j++) {\n                        Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);\n                    }\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < collectableSubplotTypes.length; i++) {\n        out[collectableSubplotTypes[i]] = [];\n    }\n    return out;\n}\n\n/**\n * getFormatObj: use _context to get the format object from locale.\n * Used to get d3.locale argument object and extraFormat argument object\n *\n * Regarding d3.locale argument :\n * decimal and thousands can be overridden later by layout.separators\n * grouping and currency are not presently used by our automatic number\n * formatting system but can be used by custom formats.\n *\n * @returns {object} d3.locale format object\n */\nfunction getFormatObj(gd, formatKeys) {\n    var locale = gd._context.locale;\n    if(!locale) locale = 'en-US';\n\n    var formatDone = false;\n    var formatObj = {};\n\n    function includeFormat(newFormat) {\n        var formatFinished = true;\n        for(var i = 0; i < formatKeys.length; i++) {\n            var formatKey = formatKeys[i];\n            if(!formatObj[formatKey]) {\n                if(newFormat[formatKey]) {\n                    formatObj[formatKey] = newFormat[formatKey];\n                } else formatFinished = false;\n            }\n        }\n        if(formatFinished) formatDone = true;\n    }\n\n    // same as localize, look for format parts in each format spec in the chain\n    for(var i = 0; i < 2; i++) {\n        var locales = gd._context.locales;\n        for(var j = 0; j < 2; j++) {\n            var formatj = (locales[locale] || {}).format;\n            if(formatj) {\n                includeFormat(formatj);\n                if(formatDone) break;\n            }\n            locales = Registry.localeRegistry;\n        }\n\n        var baseLocale = locale.split('-')[0];\n        if(formatDone || baseLocale === locale) break;\n        locale = baseLocale;\n    }\n\n    // lastly pick out defaults from english (non-US, as DMY is so much more common)\n    if(!formatDone) includeFormat(Registry.localeRegistry.en.format);\n\n    return formatObj;\n}\n\n/**\n * getFormatter: combine the final separators with the locale formatting object\n * we pulled earlier to generate number and time formatters\n * TODO: remove separators in v3, only use locale, so we don't need this step?\n *\n * @param {object} formatObj: d3.locale format object\n * @param {string} separators: length-2 string to override decimal and thousands\n *   separators in number formatting\n *\n * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions\n *   for numbers and time\n */\nfunction getFormatter(formatObj, separators) {\n    formatObj.decimal = separators.charAt(0);\n    formatObj.thousands = separators.charAt(1);\n\n    return {\n        numberFormat: function(formatStr) {\n            try {\n                formatStr = formatLocale(formatObj).format(\n                    Lib.adjustFormat(formatStr)\n                );\n            } catch(e) {\n                Lib.warnBadFormat(formatStr);\n                return Lib.noFormat;\n            }\n\n            return formatStr;\n        },\n        timeFormat: timeFormatLocale(formatObj).utcFormat\n    };\n}\n\nfunction fillMetaTextHelpers(newFullData, newFullLayout) {\n    var _meta;\n    var meta4data = [];\n\n    if(newFullLayout.meta) {\n        _meta = newFullLayout._meta = {\n            meta: newFullLayout.meta,\n            layout: {meta: newFullLayout.meta}\n        };\n    }\n\n    for(var i = 0; i < newFullData.length; i++) {\n        var trace = newFullData[i];\n\n        if(trace.meta) {\n            meta4data[trace.index] = trace._meta = {meta: trace.meta};\n        } else if(newFullLayout.meta) {\n            trace._meta = {meta: newFullLayout.meta};\n        }\n        if(newFullLayout.meta) {\n            trace._meta.layout = {meta: newFullLayout.meta};\n        }\n    }\n\n    if(meta4data.length) {\n        if(!_meta) {\n            _meta = newFullLayout._meta = {};\n        }\n        _meta.data = meta4data;\n    }\n}\n\n// Create storage for all of the data related to frames and transitions:\nplots.createTransitionData = function(gd) {\n    // Set up the default keyframe if it doesn't exist:\n    if(!gd._transitionData) {\n        gd._transitionData = {};\n    }\n\n    if(!gd._transitionData._frames) {\n        gd._transitionData._frames = [];\n    }\n\n    if(!gd._transitionData._frameHash) {\n        gd._transitionData._frameHash = {};\n    }\n\n    if(!gd._transitionData._counter) {\n        gd._transitionData._counter = 0;\n    }\n\n    if(!gd._transitionData._interruptCallbacks) {\n        gd._transitionData._interruptCallbacks = [];\n    }\n};\n\n// helper function to be bound to fullLayout to check\n// whether a certain plot type is present on plot\n// or trace has a category\nplots._hasPlotType = function(category) {\n    var i;\n\n    // check base plot modules\n    var basePlotModules = this._basePlotModules || [];\n    for(i = 0; i < basePlotModules.length; i++) {\n        if(basePlotModules[i].name === category) return true;\n    }\n\n    // check trace modules (including non-visible:true)\n    var modules = this._modules || [];\n    for(i = 0; i < modules.length; i++) {\n        var name = modules[i].name;\n        if(name === category) return true;\n        // N.B. this is modules[i] along with 'categories' as a hash object\n        var _module = Registry.modules[name];\n        if(_module && _module.categories[category]) return true;\n    }\n\n    return false;\n};\n\nplots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var i, j;\n\n    var basePlotModules = oldFullLayout._basePlotModules || [];\n    for(i = 0; i < basePlotModules.length; i++) {\n        var _module = basePlotModules[i];\n\n        if(_module.clean) {\n            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\n        }\n    }\n\n    var hadGl = oldFullLayout._has && oldFullLayout._has('gl');\n    var hasGl = newFullLayout._has && newFullLayout._has('gl');\n\n    if(hadGl && !hasGl) {\n        if(oldFullLayout._glcontainer !== undefined) {\n            oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();\n            oldFullLayout._glcontainer.selectAll('.no-webgl').remove();\n            oldFullLayout._glcanvas = null;\n        }\n    }\n\n    var hasInfoLayer = !!oldFullLayout._infolayer;\n\n    oldLoop:\n    for(i = 0; i < oldFullData.length; i++) {\n        var oldTrace = oldFullData[i];\n        var oldUid = oldTrace.uid;\n\n        for(j = 0; j < newFullData.length; j++) {\n            var newTrace = newFullData[j];\n\n            if(oldUid === newTrace.uid) continue oldLoop;\n        }\n\n        // clean old colorbars\n        if(hasInfoLayer) {\n            oldFullLayout._infolayer.select('.cb' + oldUid).remove();\n        }\n    }\n};\n\nplots.linkSubplots = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var i, j;\n\n    var oldSubplots = oldFullLayout._plots || {};\n    var newSubplots = newFullLayout._plots = {};\n    var newSubplotList = newFullLayout._subplots;\n\n    var mockGd = {\n        _fullData: newFullData,\n        _fullLayout: newFullLayout\n    };\n\n    var ids = newSubplotList.cartesian.concat(newSubplotList.gl2d || []);\n\n    for(i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var oldSubplot = oldSubplots[id];\n        var xaxis = axisIDs.getFromId(mockGd, id, 'x');\n        var yaxis = axisIDs.getFromId(mockGd, id, 'y');\n        var plotinfo;\n\n        // link or create subplot object\n        if(oldSubplot) {\n            plotinfo = newSubplots[id] = oldSubplot;\n        } else {\n            plotinfo = newSubplots[id] = {};\n            plotinfo.id = id;\n        }\n\n        // add these axis ids to each others' subplot lists\n        xaxis._counterAxes.push(yaxis._id);\n        yaxis._counterAxes.push(xaxis._id);\n        xaxis._subplotsWith.push(id);\n        yaxis._subplotsWith.push(id);\n\n        // update x and y axis layout object refs\n        plotinfo.xaxis = xaxis;\n        plotinfo.yaxis = yaxis;\n\n        // By default, we clip at the subplot level,\n        // but if one trace on a given subplot has *cliponaxis* set to false,\n        // we need to clip at the trace module layer level;\n        // find this out here, once of for all.\n        plotinfo._hasClipOnAxisFalse = false;\n\n        for(j = 0; j < newFullData.length; j++) {\n            var trace = newFullData[j];\n\n            if(\n                trace.xaxis === plotinfo.xaxis._id &&\n                trace.yaxis === plotinfo.yaxis._id &&\n                trace.cliponaxis === false\n            ) {\n                plotinfo._hasClipOnAxisFalse = true;\n                break;\n            }\n        }\n    }\n\n    // while we're at it, link overlaying axes to their main axes and\n    // anchored axes to the axes they're anchored to\n    var axList = axisIDs.list(mockGd, null, true);\n    var ax;\n    for(i = 0; i < axList.length; i++) {\n        ax = axList[i];\n        var mainAx = null;\n\n        if(ax.overlaying) {\n            mainAx = axisIDs.getFromId(mockGd, ax.overlaying);\n\n            // you cannot overlay an axis that's already overlaying another\n            if(mainAx && mainAx.overlaying) {\n                ax.overlaying = false;\n                mainAx = null;\n            }\n        }\n        ax._mainAxis = mainAx || ax;\n\n        /*\n         * For now force overlays to overlay completely... so they\n         * can drag together correctly and share backgrounds.\n         * Later perhaps we make separate axis domain and\n         * tick/line domain or something, so they can still share\n         * the (possibly larger) dragger and background but don't\n         * have to both be drawn over that whole domain\n         */\n        if(mainAx) ax.domain = mainAx.domain.slice();\n\n        ax._anchorAxis = ax.anchor === 'free' ?\n            null :\n            axisIDs.getFromId(mockGd, ax.anchor);\n    }\n\n    // finally, we can find the main subplot for each axis\n    // (on which the ticks & labels are drawn)\n    for(i = 0; i < axList.length; i++) {\n        ax = axList[i];\n        ax._counterAxes.sort(axisIDs.idSort);\n        ax._subplotsWith.sort(Lib.subplotSort);\n        ax._mainSubplot = findMainSubplot(ax, newFullLayout);\n\n        // find \"full\" domain span of counter axes,\n        // this loop can be costly, so only compute it when required\n        if(ax._counterAxes.length && (\n            (ax.spikemode && ax.spikemode.indexOf('across') !== -1) ||\n            (ax.automargin && ax.mirror && ax.anchor !== 'free') ||\n            Registry.getComponentMethod('rangeslider', 'isVisible')(ax)\n        )) {\n            var min = 1;\n            var max = 0;\n            for(j = 0; j < ax._counterAxes.length; j++) {\n                var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);\n                min = Math.min(min, ax2.domain[0]);\n                max = Math.max(max, ax2.domain[1]);\n            }\n            if(min < max) {\n                ax._counterDomainMin = min;\n                ax._counterDomainMax = max;\n            }\n        }\n    }\n};\n\nfunction findMainSubplot(ax, fullLayout) {\n    var mockGd = {_fullLayout: fullLayout};\n\n    var isX = ax._id.charAt(0) === 'x';\n    var anchorAx = ax._mainAxis._anchorAxis;\n    var mainSubplotID = '';\n    var nextBestMainSubplotID = '';\n    var anchorID = '';\n\n    // First try the main ID with the anchor\n    if(anchorAx) {\n        anchorID = anchorAx._mainAxis._id;\n        mainSubplotID = isX ? (ax._id + anchorID) : (anchorID + ax._id);\n    }\n\n    // Then look for a subplot with the counteraxis overlaying the anchor\n    // If that fails just use the first subplot including this axis\n    if(!mainSubplotID || !fullLayout._plots[mainSubplotID]) {\n        mainSubplotID = '';\n\n        var counterIDs = ax._counterAxes;\n        for(var j = 0; j < counterIDs.length; j++) {\n            var counterPart = counterIDs[j];\n            var id = isX ? (ax._id + counterPart) : (counterPart + ax._id);\n            if(!nextBestMainSubplotID) nextBestMainSubplotID = id;\n            var counterAx = axisIDs.getFromId(mockGd, counterPart);\n            if(anchorID && counterAx.overlaying === anchorID) {\n                mainSubplotID = id;\n                break;\n            }\n        }\n    }\n\n    return mainSubplotID || nextBestMainSubplotID;\n}\n\n// This function clears any trace attributes with valType: color and\n// no set dflt filed in the plot schema. This is needed because groupby (which\n// is the only transform for which this currently applies) supplies parent\n// trace defaults, then expanded trace defaults. The result is that `null`\n// colors are default-supplied and inherited as a color instead of a null.\n// The result is that expanded trace default colors have no effect, with\n// the final result that groups are indistinguishable. This function clears\n// those colors so that individual groupby groups get unique colors.\nplots.clearExpandedTraceDefaultColors = function(trace) {\n    var colorAttrs, path, i;\n\n    // This uses weird closure state in order to satisfy the linter rule\n    // that we can't create functions in a loop.\n    function locateColorAttrs(attr, attrName, attrs, level) {\n        path[level] = attrName;\n        path.length = level + 1;\n        if(attr.valType === 'color' && attr.dflt === undefined) {\n            colorAttrs.push(path.join('.'));\n        }\n    }\n\n    path = [];\n\n    // Get the cached colorAttrs:\n    colorAttrs = trace._module._colorAttrs;\n\n    // Or else compute and cache the colorAttrs on the module:\n    if(!colorAttrs) {\n        trace._module._colorAttrs = colorAttrs = [];\n        PlotSchema.crawl(\n            trace._module.attributes,\n            locateColorAttrs\n        );\n    }\n\n    for(i = 0; i < colorAttrs.length; i++) {\n        var origprop = Lib.nestedProperty(trace, '_input.' + colorAttrs[i]);\n\n        if(!origprop.get()) {\n            Lib.nestedProperty(trace, colorAttrs[i]).set(null);\n        }\n    }\n};\n\n\nplots.supplyDataDefaults = function(dataIn, dataOut, layout, fullLayout) {\n    var modules = fullLayout._modules;\n    var visibleModules = fullLayout._visibleModules;\n    var basePlotModules = fullLayout._basePlotModules;\n    var cnt = 0;\n    var colorCnt = 0;\n\n    var i, fullTrace, trace;\n\n    fullLayout._transformModules = [];\n\n    function pushModule(fullTrace) {\n        dataOut.push(fullTrace);\n\n        var _module = fullTrace._module;\n        if(!_module) return;\n\n        Lib.pushUnique(modules, _module);\n        if(fullTrace.visible === true) Lib.pushUnique(visibleModules, _module);\n        Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);\n        cnt++;\n\n        // TODO: do we really want color not to increment for explicitly invisible traces?\n        // This logic is weird, but matches previous behavior: traces that you explicitly\n        // set to visible:false do not increment the color, but traces WE determine to be\n        // empty or invalid (and thus set to visible:false) DO increment color.\n        // I kind of think we should just let all traces increment color, visible or not.\n        // see mock: axes-autotype-empty vs. a test of restyling visible: false that\n        // I can't find right now...\n        if(fullTrace._input.visible !== false) colorCnt++;\n    }\n\n    var carpetIndex = {};\n    var carpetDependents = [];\n    var dataTemplate = (layout.template || {}).data || {};\n    var templater = Template.traceTemplater(dataTemplate);\n\n    for(i = 0; i < dataIn.length; i++) {\n        trace = dataIn[i];\n\n        // reuse uid we may have pulled out of oldFullData\n        // Note: templater supplies trace type\n        fullTrace = templater.newTrace(trace);\n        fullTrace.uid = fullLayout._traceUids[i];\n        plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);\n\n        fullTrace.index = i;\n        fullTrace._input = trace;\n        fullTrace._expandedIndex = cnt;\n\n        if(fullTrace.transforms && fullTrace.transforms.length) {\n            var sdInvisible = trace.visible !== false && fullTrace.visible === false;\n\n            var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);\n\n            for(var j = 0; j < expandedTraces.length; j++) {\n                var expandedTrace = expandedTraces[j];\n\n                // No further templating during transforms.\n                var fullExpandedTrace = {\n                    _template: fullTrace._template,\n                    type: fullTrace.type,\n                    // set uid using parent uid and expanded index\n                    // to promote consistency between update calls\n                    uid: fullTrace.uid + j\n                };\n\n                // If the first supplyDefaults created `visible: false`,\n                // clear it before running supplyDefaults a second time,\n                // because sometimes there are items we still want to coerce\n                // inside trace modules before determining that the trace is\n                // again `visible: false`, for example partial visibilities\n                // in `splom` traces.\n                if(sdInvisible && expandedTrace.visible === false) {\n                    delete expandedTrace.visible;\n                }\n\n                plots.supplyTraceDefaults(expandedTrace, fullExpandedTrace, cnt, fullLayout, i);\n\n                // relink private (i.e. underscore) keys expanded trace to full expanded trace so\n                // that transform supply-default methods can set _ keys for future use.\n                relinkPrivateKeys(fullExpandedTrace, expandedTrace);\n\n                // add info about parent data trace\n                fullExpandedTrace.index = i;\n                fullExpandedTrace._input = trace;\n                fullExpandedTrace._fullInput = fullTrace;\n\n                // add info about the expanded data\n                fullExpandedTrace._expandedIndex = cnt;\n                fullExpandedTrace._expandedInput = expandedTrace;\n\n                pushModule(fullExpandedTrace);\n            }\n        } else {\n            // add identify refs for consistency with transformed traces\n            fullTrace._fullInput = fullTrace;\n            fullTrace._expandedInput = fullTrace;\n\n            pushModule(fullTrace);\n        }\n\n        if(Registry.traceIs(fullTrace, 'carpetAxis')) {\n            carpetIndex[fullTrace.carpet] = fullTrace;\n        }\n\n        if(Registry.traceIs(fullTrace, 'carpetDependent')) {\n            carpetDependents.push(i);\n        }\n    }\n\n    for(i = 0; i < carpetDependents.length; i++) {\n        fullTrace = dataOut[carpetDependents[i]];\n\n        if(!fullTrace.visible) continue;\n\n        var carpetAxis = carpetIndex[fullTrace.carpet];\n        fullTrace._carpet = carpetAxis;\n\n        if(!carpetAxis || !carpetAxis.visible) {\n            fullTrace.visible = false;\n            continue;\n        }\n\n        fullTrace.xaxis = carpetAxis.xaxis;\n        fullTrace.yaxis = carpetAxis.yaxis;\n    }\n};\n\nplots.supplyAnimationDefaults = function(opts) {\n    opts = opts || {};\n    var i;\n    var optsOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);\n    }\n\n    coerce('mode');\n    coerce('direction');\n    coerce('fromcurrent');\n\n    if(Array.isArray(opts.frame)) {\n        optsOut.frame = [];\n        for(i = 0; i < opts.frame.length; i++) {\n            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});\n        }\n    } else {\n        optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});\n    }\n\n    if(Array.isArray(opts.transition)) {\n        optsOut.transition = [];\n        for(i = 0; i < opts.transition.length; i++) {\n            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});\n        }\n    } else {\n        optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});\n    }\n\n    return optsOut;\n};\n\nplots.supplyAnimationFrameDefaults = function(opts) {\n    var optsOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);\n    }\n\n    coerce('duration');\n    coerce('redraw');\n\n    return optsOut;\n};\n\nplots.supplyAnimationTransitionDefaults = function(opts) {\n    var optsOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);\n    }\n\n    coerce('duration');\n    coerce('easing');\n\n    return optsOut;\n};\n\nplots.supplyFrameDefaults = function(frameIn) {\n    var frameOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);\n    }\n\n    coerce('group');\n    coerce('name');\n    coerce('traces');\n    coerce('baseframe');\n    coerce('data');\n    coerce('layout');\n\n    return frameOut;\n};\n\nplots.supplyTraceDefaults = function(traceIn, traceOut, colorIndex, layout, traceInIndex) {\n    var colorway = layout.colorway || Color.defaults;\n    var defaultColor = colorway[colorIndex % colorway.length];\n\n    var i;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);\n    }\n\n    var visible = coerce('visible');\n\n    coerce('type');\n    coerce('name', layout._traceWord + ' ' + traceInIndex);\n\n    coerce('uirevision', layout.uirevision);\n\n    // we want even invisible traces to make their would-be subplots visible\n    // so coerce the subplot id(s) now no matter what\n    var _module = plots.getModule(traceOut);\n\n    traceOut._module = _module;\n    if(_module) {\n        var basePlotModule = _module.basePlotModule;\n        var subplotAttr = basePlotModule.attr;\n        var subplotAttrs = basePlotModule.attributes;\n        if(subplotAttr && subplotAttrs) {\n            var subplots = layout._subplots;\n            var subplotId = '';\n\n            if(\n                visible ||\n                basePlotModule.name !== 'gl2d' // for now just drop empty gl2d subplots\n                // TODO - currently if we draw an empty gl2d subplot, it draws\n                // nothing then gets stuck and you can't get it back without newPlot\n                // sort this out in the regl refactor?\n            ) {\n                if(Array.isArray(subplotAttr)) {\n                    for(i = 0; i < subplotAttr.length; i++) {\n                        var attri = subplotAttr[i];\n                        var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);\n\n                        if(subplots[attri]) Lib.pushUnique(subplots[attri], vali);\n                        subplotId += vali;\n                    }\n                } else {\n                    subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);\n                }\n\n                if(subplots[basePlotModule.name]) {\n                    Lib.pushUnique(subplots[basePlotModule.name], subplotId);\n                }\n            }\n        }\n    }\n\n    if(visible) {\n        coerce('customdata');\n        coerce('ids');\n        coerce('meta');\n\n        if(Registry.traceIs(traceOut, 'showLegend')) {\n            Lib.coerce(traceIn, traceOut,\n                _module.attributes.showlegend ? _module.attributes : plots.attributes,\n                'showlegend'\n            );\n\n            coerce('legend');\n            coerce('legendwidth');\n            coerce('legendgroup');\n            coerce('legendgrouptitle.text');\n            coerce('legendrank');\n\n            traceOut._dfltShowLegend = true;\n        } else {\n            traceOut._dfltShowLegend = false;\n        }\n\n        if(_module) {\n            _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);\n        }\n\n        if(!Registry.traceIs(traceOut, 'noOpacity')) {\n            coerce('opacity');\n        }\n\n        if(Registry.traceIs(traceOut, 'notLegendIsolatable')) {\n            // This clears out the legendonly state for traces like carpet that\n            // cannot be isolated in the legend\n            traceOut.visible = !!traceOut.visible;\n        }\n\n        if(!Registry.traceIs(traceOut, 'noHover')) {\n            if(!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);\n\n            // parcats support hover, but not hoverlabel stylings (yet)\n            if(traceOut.type !== 'parcats') {\n                Registry.getComponentMethod('fx', 'supplyDefaults')(traceIn, traceOut, defaultColor, layout);\n            }\n        }\n\n        if(_module && _module.selectPoints) {\n            var selectedpoints = coerce('selectedpoints');\n            if(Lib.isTypedArray(selectedpoints)) {\n                traceOut.selectedpoints = Array.from(selectedpoints);\n            }\n        }\n\n        plots.supplyTransformDefaults(traceIn, traceOut, layout);\n    }\n\n    return traceOut;\n};\n\n/**\n * hasMakesDataTransform: does this trace have a transform that makes its own\n * data, either by grabbing it from somewhere else or by creating it from input\n * parameters? If so, we should still keep going with supplyDefaults\n * even if the trace is invisible, which may just be because it has no data yet.\n */\nfunction hasMakesDataTransform(trace) {\n    var transforms = trace.transforms;\n    if(Array.isArray(transforms) && transforms.length) {\n        for(var i = 0; i < transforms.length; i++) {\n            var ti = transforms[i];\n            var _module = ti._module || transformsRegistry[ti.type];\n            if(_module && _module.makesData) return true;\n        }\n    }\n    return false;\n}\n\nplots.hasMakesDataTransform = hasMakesDataTransform;\n\nplots.supplyTransformDefaults = function(traceIn, traceOut, layout) {\n    // For now we only allow transforms on 1D traces, ie those that specify a _length.\n    // If we were to implement 2D transforms, we'd need to have each transform\n    // describe its own applicability and disable itself when it doesn't apply.\n    // Also allow transforms that make their own data, but not in globalTransforms\n    if(!(traceOut._length || hasMakesDataTransform(traceIn))) return;\n\n    var globalTransforms = layout._globalTransforms || [];\n    var transformModules = layout._transformModules || [];\n\n    if(!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;\n\n    var containerIn = traceIn.transforms || [];\n    var transformList = globalTransforms.concat(containerIn);\n    var containerOut = traceOut.transforms = [];\n\n    for(var i = 0; i < transformList.length; i++) {\n        var transformIn = transformList[i];\n        var type = transformIn.type;\n        var _module = transformsRegistry[type];\n        var transformOut;\n\n        /*\n         * Supply defaults may run twice. First pass runs all supply defaults steps\n         * and adds the _module to any output transforms.\n         * If transforms exist another pass is run so that any generated traces also\n         * go through supply defaults. This has the effect of rerunning\n         * supplyTransformDefaults. If the transform does not have a `transform`\n         * function it could not have generated any new traces and the second stage\n         * is unnecessary. We detect this case with the following variables.\n         */\n        var isFirstStage = !(transformIn._module && transformIn._module === _module);\n        var doLaterStages = _module && typeof _module.transform === 'function';\n\n        if(!_module) Lib.warn('Unrecognized transform type ' + type + '.');\n\n        if(_module && _module.supplyDefaults && (isFirstStage || doLaterStages)) {\n            transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);\n            transformOut.type = type;\n            transformOut._module = _module;\n\n            Lib.pushUnique(transformModules, _module);\n        } else {\n            transformOut = Lib.extendFlat({}, transformIn);\n        }\n\n        containerOut.push(transformOut);\n    }\n};\n\nfunction applyTransforms(fullTrace, fullData, layout, fullLayout) {\n    var container = fullTrace.transforms;\n    var dataOut = [fullTrace];\n\n    for(var i = 0; i < container.length; i++) {\n        var transform = container[i];\n        var _module = transformsRegistry[transform.type];\n\n        if(_module && _module.transform) {\n            dataOut = _module.transform(dataOut, {\n                transform: transform,\n                fullTrace: fullTrace,\n                fullData: fullData,\n                layout: layout,\n                fullLayout: fullLayout,\n                transformIndex: i\n            });\n        }\n    }\n\n    return dataOut;\n}\n\nplots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut, formatObj) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);\n    }\n\n    var template = layoutIn.template;\n    if(Lib.isPlainObject(template)) {\n        layoutOut.template = template;\n        layoutOut._template = template.layout;\n        layoutOut._dataTemplate = template.data;\n    }\n\n    coerce('autotypenumbers');\n\n    var font = Lib.coerceFont(coerce, 'font');\n    var fontSize = font.size;\n\n    Lib.coerceFont(coerce, 'title.font', font, { overrideDflt: {\n        size: Math.round(fontSize * 1.4)\n    }});\n\n    coerce('title.text', layoutOut._dfltTitle.plot);\n    coerce('title.xref');\n    var titleYref = coerce('title.yref');\n    coerce('title.pad.t');\n    coerce('title.pad.r');\n    coerce('title.pad.b');\n    coerce('title.pad.l');\n    var titleAutomargin = coerce('title.automargin');\n\n    coerce('title.x');\n    coerce('title.xanchor');\n    coerce('title.y');\n    coerce('title.yanchor');\n\n    coerce('title.subtitle.text', layoutOut._dfltTitle.subtitle);\n    Lib.coerceFont(coerce, 'title.subtitle.font', font, {\n        overrideDflt: {\n            size: Math.round(layoutOut.title.font.size * 0.7)\n        }\n    });\n\n    if(titleAutomargin) {\n        // when automargin=true\n        // title.y is 1 or 0 if paper ref\n        // 'auto' is not supported for either title.y or title.yanchor\n\n        // TODO: mention this smart default in the title.y and title.yanchor descriptions\n\n        if(titleYref === 'paper') {\n            if(layoutOut.title.y !== 0) layoutOut.title.y = 1;\n\n            if(layoutOut.title.yanchor === 'auto') {\n                layoutOut.title.yanchor = layoutOut.title.y === 0 ? 'top' : 'bottom';\n            }\n        }\n\n        if(titleYref === 'container') {\n            if(layoutOut.title.y === 'auto') layoutOut.title.y = 1;\n\n            if(layoutOut.title.yanchor === 'auto') {\n                layoutOut.title.yanchor = layoutOut.title.y < 0.5 ? 'bottom' : 'top';\n            }\n        }\n    }\n\n    var uniformtextMode = coerce('uniformtext.mode');\n    if(uniformtextMode) {\n        coerce('uniformtext.minsize');\n    }\n\n    // Make sure that autosize is defaulted to *true*\n    // on layouts with no set width and height for backward compatibly,\n    // in particular https://plotly.com/javascript/responsive-fluid-layout/\n    //\n    // Before https://github.com/plotly/plotly.js/pull/635 ,\n    // layouts with no set width and height were set temporary set to 'initial'\n    // to pass through the autosize routine\n    //\n    // This behavior is subject to change in v3.\n    coerce('autosize', !(layoutIn.width && layoutIn.height));\n\n    coerce('width');\n    coerce('height');\n    coerce('minreducedwidth');\n    coerce('minreducedheight');\n\n    coerce('margin.l');\n    coerce('margin.r');\n    coerce('margin.t');\n    coerce('margin.b');\n    coerce('margin.pad');\n    coerce('margin.autoexpand');\n\n    if(layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);\n\n    Registry.getComponentMethod('grid', 'sizeDefaults')(layoutIn, layoutOut);\n\n    coerce('paper_bgcolor');\n\n    coerce('separators', formatObj.decimal + formatObj.thousands);\n    coerce('hidesources');\n\n    coerce('colorway');\n\n    coerce('datarevision');\n    var uirevision = coerce('uirevision');\n    coerce('editrevision', uirevision);\n    coerce('selectionrevision', uirevision);\n\n    Registry.getComponentMethod(\n        'modebar',\n        'supplyLayoutDefaults'\n    )(layoutIn, layoutOut);\n\n    Registry.getComponentMethod(\n        'shapes',\n        'supplyDrawNewShapeDefaults'\n    )(layoutIn, layoutOut, coerce);\n\n    Registry.getComponentMethod(\n        'selections',\n        'supplyDrawNewSelectionDefaults'\n    )(layoutIn, layoutOut, coerce);\n\n    coerce('meta');\n\n    // do not include defaults in fullLayout when users do not set transition\n    if(Lib.isPlainObject(layoutIn.transition)) {\n        coerce('transition.duration');\n        coerce('transition.easing');\n        coerce('transition.ordering');\n    }\n\n    Registry.getComponentMethod(\n        'calendars',\n        'handleDefaults'\n    )(layoutIn, layoutOut, 'calendar');\n\n    Registry.getComponentMethod(\n        'fx',\n        'supplyLayoutGlobalDefaults'\n    )(layoutIn, layoutOut, coerce);\n\n    Lib.coerce(layoutIn, layoutOut, scatterAttrs, 'scattermode');\n};\n\nfunction getComputedSize(attr) {\n    return (\n        (typeof attr === 'string') &&\n        (attr.substr(attr.length - 2) === 'px') &&\n        parseFloat(attr)\n    );\n}\n\n\nplots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {\n    var context = gd._context || {};\n    var frameMargins = context.frameMargins;\n    var newWidth;\n    var newHeight;\n\n    var isPlotDiv = Lib.isPlotDiv(gd);\n\n    if(isPlotDiv) gd.emit('plotly_autosize');\n\n    // embedded in an iframe - just take the full iframe size\n    // if we get to this point, with no aspect ratio restrictions\n    if(context.fillFrame) {\n        newWidth = window.innerWidth;\n        newHeight = window.innerHeight;\n\n        // somehow we get a few extra px height sometimes...\n        // just hide it\n        document.body.style.overflow = 'hidden';\n    } else {\n        // plotly.js - let the developers do what they want, either\n        // provide height and width for the container div,\n        // specify size in layout, or take the defaults,\n        // but don't enforce any ratio restrictions\n        var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};\n\n        newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;\n        newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;\n\n        if(isNumeric(frameMargins) && frameMargins > 0) {\n            var factor = 1 - 2 * frameMargins;\n            newWidth = Math.round(factor * newWidth);\n            newHeight = Math.round(factor * newHeight);\n        }\n    }\n\n    var minWidth = plots.layoutAttributes.width.min;\n    var minHeight = plots.layoutAttributes.height.min;\n    if(newWidth < minWidth) newWidth = minWidth;\n    if(newHeight < minHeight) newHeight = minHeight;\n\n    var widthHasChanged = !layout.width &&\n        (Math.abs(fullLayout.width - newWidth) > 1);\n    var heightHasChanged = !layout.height &&\n        (Math.abs(fullLayout.height - newHeight) > 1);\n\n    if(heightHasChanged || widthHasChanged) {\n        if(widthHasChanged) fullLayout.width = newWidth;\n        if(heightHasChanged) fullLayout.height = newHeight;\n    }\n\n    // cache initial autosize value, used in relayout when\n    // width or height values are set to null\n    if(!gd._initialAutoSize) {\n        gd._initialAutoSize = { width: newWidth, height: newHeight };\n    }\n\n    plots.sanitizeMargins(fullLayout);\n};\n\nplots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {\n    var componentsRegistry = Registry.componentsRegistry;\n    var basePlotModules = layoutOut._basePlotModules;\n    var component, i, _module;\n\n    var Cartesian = Registry.subplotsRegistry.cartesian;\n\n    // check if any components need to add more base plot modules\n    // that weren't captured by traces\n    for(component in componentsRegistry) {\n        _module = componentsRegistry[component];\n\n        if(_module.includeBasePlot) {\n            _module.includeBasePlot(layoutIn, layoutOut);\n        }\n    }\n\n    // make sure we *at least* have some cartesian axes\n    if(!basePlotModules.length) {\n        basePlotModules.push(Cartesian);\n    }\n\n    // ensure all cartesian axes have at least one subplot\n    if(layoutOut._has('cartesian')) {\n        Registry.getComponentMethod('grid', 'contentDefaults')(layoutIn, layoutOut);\n        Cartesian.finalizeSubplots(layoutIn, layoutOut);\n    }\n\n    // sort subplot lists\n    for(var subplotType in layoutOut._subplots) {\n        layoutOut._subplots[subplotType].sort(Lib.subplotSort);\n    }\n\n    // base plot module layout defaults\n    for(i = 0; i < basePlotModules.length; i++) {\n        _module = basePlotModules[i];\n\n        // e.g. pie does not have a layout-defaults step\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n        }\n    }\n\n    // trace module layout defaults\n    // use _modules rather than _visibleModules so that even\n    // legendonly traces can include settings - eg barmode, which affects\n    // legend.traceorder default value.\n    var modules = layoutOut._modules;\n    for(i = 0; i < modules.length; i++) {\n        _module = modules[i];\n\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n        }\n    }\n\n    // transform module layout defaults\n    var transformModules = layoutOut._transformModules;\n    for(i = 0; i < transformModules.length; i++) {\n        _module = transformModules[i];\n\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);\n        }\n    }\n\n    for(component in componentsRegistry) {\n        _module = componentsRegistry[component];\n\n        if(_module.supplyLayoutDefaults) {\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n        }\n    }\n};\n\n// Remove all plotly attributes from a div so it can be replotted fresh\n// TODO: these really need to be encapsulated into a much smaller set...\nplots.purge = function(gd) {\n    // note: we DO NOT remove _context because it doesn't change when we insert\n    // a new plot, and may have been set outside of our scope.\n\n    var fullLayout = gd._fullLayout || {};\n    if(fullLayout._glcontainer !== undefined) {\n        fullLayout._glcontainer.selectAll('.gl-canvas').remove();\n        fullLayout._glcontainer.remove();\n        fullLayout._glcanvas = null;\n    }\n\n    // remove modebar\n    if(fullLayout._modeBar) fullLayout._modeBar.destroy();\n\n    if(gd._transitionData) {\n        // Ensure any dangling callbacks are simply dropped if the plot is purged.\n        // This is more or less only actually important for testing.\n        if(gd._transitionData._interruptCallbacks) {\n            gd._transitionData._interruptCallbacks.length = 0;\n        }\n\n        if(gd._transitionData._animationRaf) {\n            window.cancelAnimationFrame(gd._transitionData._animationRaf);\n        }\n    }\n\n    // remove any planned throttles\n    Lib.clearThrottle();\n\n    // remove responsive handler\n    Lib.clearResponsive(gd);\n\n    // data and layout\n    delete gd.data;\n    delete gd.layout;\n    delete gd._fullData;\n    delete gd._fullLayout;\n    delete gd.calcdata;\n    delete gd.empty;\n\n    delete gd.fid;\n\n    delete gd.undoqueue; // action queue\n    delete gd.undonum;\n    delete gd.autoplay; // are we doing an action that doesn't go in undo queue?\n    delete gd.changed;\n\n    // these get recreated on _doPlot anyway, but just to be safe\n    // (and to have a record of them...)\n    delete gd._promises;\n    delete gd._redrawTimer;\n    delete gd._hmlumcount;\n    delete gd._hmpixcount;\n    delete gd._transitionData;\n    delete gd._transitioning;\n    delete gd._initialAutoSize;\n    delete gd._transitioningWithDuration;\n\n    // created during certain events, that *should* clean them up\n    // themselves, but may not if there was an error\n    delete gd._dragging;\n    delete gd._dragged;\n    delete gd._dragdata;\n    delete gd._hoverdata;\n    delete gd._snapshotInProgress;\n    delete gd._editing;\n    delete gd._mouseDownTime;\n    delete gd._legendMouseDownTime;\n\n    // remove all event listeners\n    if(gd.removeAllListeners) gd.removeAllListeners();\n};\n\nplots.style = function(gd) {\n    var _modules = gd._fullLayout._visibleModules;\n    var styleModules = [];\n    var i;\n\n    // some trace modules reuse the same style method,\n    // make sure to not unnecessary call them multiple times.\n\n    for(i = 0; i < _modules.length; i++) {\n        var _module = _modules[i];\n        if(_module.style) {\n            Lib.pushUnique(styleModules, _module.style);\n        }\n    }\n\n    for(i = 0; i < styleModules.length; i++) {\n        styleModules[i](gd);\n    }\n};\n\nplots.sanitizeMargins = function(fullLayout) {\n    // polar doesn't do margins...\n    if(!fullLayout || !fullLayout.margin) return;\n\n    var width = fullLayout.width;\n    var height = fullLayout.height;\n    var margin = fullLayout.margin;\n    var plotWidth = width - (margin.l + margin.r);\n    var plotHeight = height - (margin.t + margin.b);\n    var correction;\n\n    // if margin.l + margin.r = 0 then plotWidth > 0\n    // as width >= 10 by supplyDefaults\n    // similarly for margin.t + margin.b\n\n    if(plotWidth < 0) {\n        correction = (width - 1) / (margin.l + margin.r);\n        margin.l = Math.floor(correction * margin.l);\n        margin.r = Math.floor(correction * margin.r);\n    }\n\n    if(plotHeight < 0) {\n        correction = (height - 1) / (margin.t + margin.b);\n        margin.t = Math.floor(correction * margin.t);\n        margin.b = Math.floor(correction * margin.b);\n    }\n};\n\nplots.clearAutoMarginIds = function(gd) {\n    gd._fullLayout._pushmarginIds = {};\n};\n\nplots.allowAutoMargin = function(gd, id) {\n    gd._fullLayout._pushmarginIds[id] = 1;\n};\n\nfunction initMargins(fullLayout) {\n    var margin = fullLayout.margin;\n\n    if(!fullLayout._size) {\n        var gs = fullLayout._size = {\n            l: Math.round(margin.l),\n            r: Math.round(margin.r),\n            t: Math.round(margin.t),\n            b: Math.round(margin.b),\n            p: Math.round(margin.pad)\n        };\n        gs.w = Math.round(fullLayout.width) - gs.l - gs.r;\n        gs.h = Math.round(fullLayout.height) - gs.t - gs.b;\n    }\n    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};\n    if(!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};\n    if(!fullLayout._reservedMargin) fullLayout._reservedMargin = {};\n}\n\n// non-negotiable - this is the smallest height we will allow users to specify via explicit margins\nvar MIN_SPECIFIED_WIDTH = 2;\nvar MIN_SPECIFIED_HEIGHT = 2;\n\n/**\n * autoMargin: called by components that may need to expand the margins to\n * be rendered on-plot.\n *\n * @param {DOM element} gd\n * @param {string} id - an identifier unique (within this plot) to this object,\n *     so we can remove a previous margin expansion from the same object.\n * @param {object} o - the margin requirements of this object, or omit to delete\n *     this entry (like if it's hidden). Keys are:\n *     x, y: plot fraction of the anchor point.\n *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,\n *         you can specify both edges as plot fractions in each dimension\n *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]\n *     pad: extra pixels to add in all directions, default 12 (why?)\n */\nplots.autoMargin = function(gd, id, o) {\n    var fullLayout = gd._fullLayout;\n    var width = fullLayout.width;\n    var height = fullLayout.height;\n    var margin = fullLayout.margin;\n    var minreducedwidth = fullLayout.minreducedwidth;\n    var minreducedheight = fullLayout.minreducedheight;\n\n    var minFinalWidth = Lib.constrain(\n        width - margin.l - margin.r,\n        MIN_SPECIFIED_WIDTH,\n        minreducedwidth\n    );\n\n    var minFinalHeight = Lib.constrain(\n        height - margin.t - margin.b,\n        MIN_SPECIFIED_HEIGHT,\n        minreducedheight\n    );\n\n    var maxSpaceW = Math.max(0, width - minFinalWidth);\n    var maxSpaceH = Math.max(0, height - minFinalHeight);\n\n    var pushMargin = fullLayout._pushmargin;\n    var pushMarginIds = fullLayout._pushmarginIds;\n\n    if(margin.autoexpand !== false) {\n        if(!o) {\n            delete pushMargin[id];\n            delete pushMarginIds[id];\n        } else {\n            var pad = o.pad;\n            if(pad === undefined) {\n                // if no explicit pad is given, use 12px unless there's a\n                // specified margin that's smaller than that\n                pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);\n            }\n\n            // if the item is too big, just give it enough automargin to\n            // make sure you can still grab it and bring it back\n            if(maxSpaceW) {\n                var rW = (o.l + o.r) / maxSpaceW;\n                if(rW > 1) {\n                    o.l /= rW;\n                    o.r /= rW;\n                }\n            }\n            if(maxSpaceH) {\n                var rH = (o.t + o.b) / maxSpaceH;\n                if(rH > 1) {\n                    o.t /= rH;\n                    o.b /= rH;\n                }\n            }\n\n            var xl = o.xl !== undefined ? o.xl : o.x;\n            var xr = o.xr !== undefined ? o.xr : o.x;\n            var yt = o.yt !== undefined ? o.yt : o.y;\n            var yb = o.yb !== undefined ? o.yb : o.y;\n\n            pushMargin[id] = {\n                l: {val: xl, size: o.l + pad},\n                r: {val: xr, size: o.r + pad},\n                b: {val: yb, size: o.b + pad},\n                t: {val: yt, size: o.t + pad}\n            };\n            pushMarginIds[id] = 1;\n        }\n\n        if(!fullLayout._replotting) {\n            return plots.doAutoMargin(gd);\n        }\n    }\n};\n\nfunction needsRedrawForShift(gd) {\n    if('_redrawFromAutoMarginCount' in gd._fullLayout) {\n        return false;\n    }\n    var axList = axisIDs.list(gd, '', true);\n    for(var ax in axList) {\n        if(axList[ax].autoshift || axList[ax].shift) return true;\n    }\n    return false;\n}\n\nplots.doAutoMargin = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var width = fullLayout.width;\n    var height = fullLayout.height;\n\n    if(!fullLayout._size) fullLayout._size = {};\n    initMargins(fullLayout);\n\n    var gs = fullLayout._size;\n    var margin = fullLayout.margin;\n    var reservedMargins = {t: 0, b: 0, l: 0, r: 0};\n    var oldMargins = Lib.extendFlat({}, gs);\n\n    // adjust margins for outside components\n    // fullLayout.margin is the requested margin,\n    // fullLayout._size has margins and plotsize after adjustment\n    var ml = margin.l;\n    var mr = margin.r;\n    var mt = margin.t;\n    var mb = margin.b;\n    var pushMargin = fullLayout._pushmargin;\n    var pushMarginIds = fullLayout._pushmarginIds;\n    var minreducedwidth = fullLayout.minreducedwidth;\n    var minreducedheight = fullLayout.minreducedheight;\n\n    if(margin.autoexpand !== false) {\n        for(var k in pushMargin) {\n            if(!pushMarginIds[k]) delete pushMargin[k];\n        }\n\n        var margins = gd._fullLayout._reservedMargin;\n        for(var key in margins) {\n            for(var side in margins[key]) {\n                var val = margins[key][side];\n                reservedMargins[side] = Math.max(reservedMargins[side], val);\n            }\n        }\n        // fill in the requested margins\n        pushMargin.base = {\n            l: {val: 0, size: ml},\n            r: {val: 1, size: mr},\n            t: {val: 1, size: mt},\n            b: {val: 0, size: mb}\n        };\n\n\n        // make sure that the reservedMargin is the minimum needed\n        for(var s in reservedMargins) {\n            var autoMarginPush = 0;\n            for(var m in pushMargin) {\n                if(m !== 'base') {\n                    if(isNumeric(pushMargin[m][s].size)) {\n                        autoMarginPush = pushMargin[m][s].size > autoMarginPush ? pushMargin[m][s].size : autoMarginPush;\n                    }\n                }\n            }\n            var extraMargin = Math.max(0, (margin[s] - autoMarginPush));\n            reservedMargins[s] = Math.max(0, reservedMargins[s] - extraMargin);\n        }\n\n        // now cycle through all the combinations of l and r\n        // (and t and b) to find the required margins\n        for(var k1 in pushMargin) {\n            var pushleft = pushMargin[k1].l || {};\n            var pushbottom = pushMargin[k1].b || {};\n            var fl = pushleft.val;\n            var pl = pushleft.size;\n            var fb = pushbottom.val;\n            var pb = pushbottom.size;\n            var availableWidth = width - reservedMargins.r - reservedMargins.l;\n            var availableHeight = height - reservedMargins.t - reservedMargins.b;\n\n            for(var k2 in pushMargin) {\n                if(isNumeric(pl) && pushMargin[k2].r) {\n                    var fr = pushMargin[k2].r.val;\n                    var pr = pushMargin[k2].r.size;\n                    if(fr > fl) {\n                        var newL = (pl * fr + (pr - availableWidth) * fl) / (fr - fl);\n                        var newR = (pr * (1 - fl) + (pl - availableWidth) * (1 - fr)) / (fr - fl);\n                        if(newL + newR > ml + mr) {\n                            ml = newL;\n                            mr = newR;\n                        }\n                    }\n                }\n\n                if(isNumeric(pb) && pushMargin[k2].t) {\n                    var ft = pushMargin[k2].t.val;\n                    var pt = pushMargin[k2].t.size;\n                    if(ft > fb) {\n                        var newB = (pb * ft + (pt - availableHeight) * fb) / (ft - fb);\n                        var newT = (pt * (1 - fb) + (pb - availableHeight) * (1 - ft)) / (ft - fb);\n                        if(newB + newT > mb + mt) {\n                            mb = newB;\n                            mt = newT;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    var minFinalWidth = Lib.constrain(\n        width - margin.l - margin.r,\n        MIN_SPECIFIED_WIDTH,\n        minreducedwidth\n    );\n\n    var minFinalHeight = Lib.constrain(\n        height - margin.t - margin.b,\n        MIN_SPECIFIED_HEIGHT,\n        minreducedheight\n    );\n\n    var maxSpaceW = Math.max(0, width - minFinalWidth);\n    var maxSpaceH = Math.max(0, height - minFinalHeight);\n\n    if(maxSpaceW) {\n        var rW = (ml + mr) / maxSpaceW;\n        if(rW > 1) {\n            ml /= rW;\n            mr /= rW;\n        }\n    }\n\n    if(maxSpaceH) {\n        var rH = (mb + mt) / maxSpaceH;\n        if(rH > 1) {\n            mb /= rH;\n            mt /= rH;\n        }\n    }\n\n\n    gs.l = Math.round(ml) + reservedMargins.l;\n    gs.r = Math.round(mr) + reservedMargins.r;\n    gs.t = Math.round(mt) + reservedMargins.t;\n    gs.b = Math.round(mb) + reservedMargins.b;\n    gs.p = Math.round(margin.pad);\n    gs.w = Math.round(width) - gs.l - gs.r;\n    gs.h = Math.round(height) - gs.t - gs.b;\n\n    // if things changed and we're not already redrawing, trigger a redraw\n    if(!fullLayout._replotting && (plots.didMarginChange(oldMargins, gs) || needsRedrawForShift(gd))) {\n        if('_redrawFromAutoMarginCount' in fullLayout) {\n            fullLayout._redrawFromAutoMarginCount++;\n        } else {\n            fullLayout._redrawFromAutoMarginCount = 1;\n        }\n\n        // Always allow at least one redraw and give each margin-push\n        // call 3 loops to converge. Of course, for most cases this way too many,\n        // but let's keep things on the safe side until we fix our\n        // auto-margin pipeline problems:\n        // https://github.com/plotly/plotly.js/issues/2704\n        var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);\n\n        if(fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {\n            return Registry.call('_doPlot', gd);\n        } else {\n            fullLayout._size = oldMargins;\n            Lib.warn('Too many auto-margin redraws.');\n        }\n    }\n\n    refineTicks(gd);\n};\n\nfunction refineTicks(gd) {\n    var axList = axisIDs.list(gd, '', true);\n\n    [\n        '_adjustTickLabelsOverflow',\n        '_hideCounterAxisInsideTickLabels'\n    ].forEach(function(k) {\n        for(var i = 0; i < axList.length; i++) {\n            var hideFn = axList[i][k];\n            if(hideFn) hideFn();\n        }\n    });\n}\n\nvar marginKeys = ['l', 'r', 't', 'b', 'p', 'w', 'h'];\n\nplots.didMarginChange = function(margin0, margin1) {\n    for(var i = 0; i < marginKeys.length; i++) {\n        var k = marginKeys[i];\n        var m0 = margin0[k];\n        var m1 = margin1[k];\n        // use 1px tolerance in case we old/new differ only\n        // by rounding errors, which can lead to infinite loops\n        if(!isNumeric(m0) || Math.abs(m1 - m0) > 1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * JSONify the graph data and layout\n *\n * This function needs to recurse because some src can be inside\n * sub-objects.\n *\n * It also strips out functions and private (starts with _) elements.\n * Therefore, we can add temporary things to data and layout that don't\n * get saved.\n *\n * @param gd The graphDiv\n * @param {Boolean} dataonly If true, don't return layout.\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\n *      keepref: remove data for which there's a src present\n *          eg if there's xsrc present (and xsrc is well-formed,\n *          ie has : and some chars before it), strip out x\n *      keepdata: remove all src tags, don't remove the data itself\n *      keepall: keep data and src\n * @param {String} output If you specify 'object', the result will not be stringified\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\n * @param {Boolean} includeConfig If truthy, include _context\n * @returns {Object|String}\n */\nplots.graphJson = function(gd, dataonly, mode, output, useDefaults, includeConfig) {\n    // if the defaults aren't supplied yet, we need to do that...\n    if((useDefaults && dataonly && !gd._fullData) ||\n            (useDefaults && !dataonly && !gd._fullLayout)) {\n        plots.supplyDefaults(gd);\n    }\n\n    var data = (useDefaults) ? gd._fullData : gd.data;\n    var layout = (useDefaults) ? gd._fullLayout : gd.layout;\n    var frames = (gd._transitionData || {})._frames;\n\n    function stripObj(d, keepFunction) {\n        if(typeof d === 'function') {\n            return keepFunction ? '_function_' : null;\n        }\n        if(Lib.isPlainObject(d)) {\n            var o = {};\n            var src;\n            Object.keys(d).sort().forEach(function(v) {\n                // remove private elements and functions\n                // _ is for private, [ is a mistake ie [object Object]\n                if(['_', '['].indexOf(v.charAt(0)) !== -1) return;\n\n                // if a function, add if necessary then move on\n                if(typeof d[v] === 'function') {\n                    if(keepFunction) o[v] = '_function';\n                    return;\n                }\n\n                // look for src/data matches and remove the appropriate one\n                if(mode === 'keepdata') {\n                    // keepdata: remove all ...src tags\n                    if(v.substr(v.length - 3) === 'src') {\n                        return;\n                    }\n                } else if(mode === 'keepstream') {\n                    // keep sourced data if it's being streamed.\n                    // similar to keepref, but if the 'stream' object exists\n                    // in a trace, we will keep the data array.\n                    src = d[v + 'src'];\n                    if(typeof src === 'string' && src.indexOf(':') > 0) {\n                        if(!Lib.isPlainObject(d.stream)) {\n                            return;\n                        }\n                    }\n                } else if(mode !== 'keepall') {\n                    // keepref: remove sourced data but only\n                    // if the source tag is well-formed\n                    src = d[v + 'src'];\n                    if(typeof src === 'string' && src.indexOf(':') > 0) {\n                        return;\n                    }\n                }\n\n                // OK, we're including this... recurse into it\n                o[v] = stripObj(d[v], keepFunction);\n            });\n            return o;\n        }\n\n        var dIsArray = Array.isArray(d);\n        var dIsTypedArray = Lib.isTypedArray(d);\n\n        if((dIsArray || dIsTypedArray) && d.dtype && d.shape) {\n            var bdata = d.bdata;\n            return stripObj({\n                dtype: d.dtype,\n                shape: d.shape,\n\n                bdata:\n                    // case of ArrayBuffer\n                    Lib.isArrayBuffer(bdata) ? b64encode.encode(bdata) :\n                    // case of b64 string\n                    bdata\n\n            }, keepFunction);\n        }\n\n        if(dIsArray) {\n            return d.map(function(x) {return stripObj(x, keepFunction);});\n        }\n\n        if(dIsTypedArray) {\n            return Lib.simpleMap(d, Lib.identity);\n        }\n\n        // convert native dates to date strings...\n        // mostly for external users exporting to plotly\n        if(Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);\n\n        return d;\n    }\n\n    var obj = {\n        data: (data || []).map(function(v) {\n            var d = stripObj(v);\n            // fit has some little arrays in it that don't contain data,\n            // just fit params and meta\n            if(dataonly) { delete d.fit; }\n            return d;\n        })\n    };\n    if(!dataonly) {\n        obj.layout = stripObj(layout);\n        if(useDefaults) {\n            var gs = layout._size;\n            obj.layout.computed = {\n                margin: {\n                    b: gs.b,\n                    l: gs.l,\n                    r: gs.r,\n                    t: gs.t\n                }\n            };\n        }\n    }\n\n    if(frames) obj.frames = stripObj(frames);\n\n    if(includeConfig) obj.config = stripObj(gd._context, true);\n\n    return (output === 'object') ? obj : JSON.stringify(obj);\n};\n\n/**\n * Modify a keyframe using a list of operations:\n *\n * @param {array of objects} operations\n *      Sequence of operations to be performed on the keyframes\n */\nplots.modifyFrames = function(gd, operations) {\n    var i, op, frame;\n    var _frames = gd._transitionData._frames;\n    var _frameHash = gd._transitionData._frameHash;\n\n    for(i = 0; i < operations.length; i++) {\n        op = operations[i];\n\n        switch(op.type) {\n            // No reason this couldn't exist, but is currently unused/untested:\n            /* case 'rename':\n                frame = _frames[op.index];\n                delete _frameHash[frame.name];\n                _frameHash[op.name] = frame;\n                frame.name = op.name;\n                break;*/\n            case 'replace':\n                frame = op.value;\n                var oldName = (_frames[op.index] || {}).name;\n                var newName = frame.name;\n                _frames[op.index] = _frameHash[newName] = frame;\n\n                if(newName !== oldName) {\n                    // If name has changed in addition to replacement, then update\n                    // the lookup table:\n                    delete _frameHash[oldName];\n                    _frameHash[newName] = frame;\n                }\n\n                break;\n            case 'insert':\n                frame = op.value;\n                _frameHash[frame.name] = frame;\n                _frames.splice(op.index, 0, frame);\n                break;\n            case 'delete':\n                frame = _frames[op.index];\n                delete _frameHash[frame.name];\n                _frames.splice(op.index, 1);\n                break;\n        }\n    }\n\n    return Promise.resolve();\n};\n\n/*\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\n * expand properties.\n *\n * @param {object} frameLookup\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\n * @param {string} frame\n *      The name of the keyframe to be computed\n *\n * Returns: a new object with the merged content\n */\nplots.computeFrame = function(gd, frameName) {\n    var frameLookup = gd._transitionData._frameHash;\n    var i, traceIndices, traceIndex, destIndex;\n\n    // Null or undefined will fail on .toString(). We'll allow numbers since we\n    // make it clear frames must be given string names, but we'll allow numbers\n    // here since they're otherwise fine for looking up frames as long as they're\n    // properly cast to strings. We really just want to ensure here that this\n    // 1) doesn't fail, and\n    // 2) doens't give an incorrect answer (which String(frameName) would)\n    if(!frameName) {\n        throw new Error('computeFrame must be given a string frame name');\n    }\n\n    var framePtr = frameLookup[frameName.toString()];\n\n    // Return false if the name is invalid:\n    if(!framePtr) {\n        return false;\n    }\n\n    var frameStack = [framePtr];\n    var frameNameStack = [framePtr.name];\n\n    // Follow frame pointers:\n    while(framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {\n        // Avoid infinite loops:\n        if(frameNameStack.indexOf(framePtr.name) !== -1) break;\n\n        frameStack.push(framePtr);\n        frameNameStack.push(framePtr.name);\n    }\n\n    // A new object for the merged result:\n    var result = {};\n\n    // Merge, starting with the last and ending with the desired frame:\n    while((framePtr = frameStack.pop())) {\n        if(framePtr.layout) {\n            result.layout = plots.extendLayout(result.layout, framePtr.layout);\n        }\n\n        if(framePtr.data) {\n            if(!result.data) {\n                result.data = [];\n            }\n            traceIndices = framePtr.traces;\n\n            if(!traceIndices) {\n                // If not defined, assume serial order starting at zero\n                traceIndices = [];\n                for(i = 0; i < framePtr.data.length; i++) {\n                    traceIndices[i] = i;\n                }\n            }\n\n            if(!result.traces) {\n                result.traces = [];\n            }\n\n            for(i = 0; i < framePtr.data.length; i++) {\n                // Loop through this frames data, find out where it should go,\n                // and merge it!\n                traceIndex = traceIndices[i];\n                if(traceIndex === undefined || traceIndex === null) {\n                    continue;\n                }\n\n                destIndex = result.traces.indexOf(traceIndex);\n                if(destIndex === -1) {\n                    destIndex = result.data.length;\n                    result.traces[destIndex] = traceIndex;\n                }\n\n                result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);\n            }\n        }\n    }\n\n    return result;\n};\n\n/*\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\n * deleteFrames already manages this data one at a time, so the only time this\n * is necessary is if you poke around manually in `gd._transitionData._frames`\n * and create and haven't updated the lookup table.\n */\nplots.recomputeFrameHash = function(gd) {\n    var hash = gd._transitionData._frameHash = {};\n    var frames = gd._transitionData._frames;\n    for(var i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        if(frame && frame.name) {\n            hash[frame.name] = frame;\n        }\n    }\n};\n\n/**\n * Extend an object, treating container arrays very differently by extracting\n * their contents and merging them separately.\n *\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\n * arrays without knowledge of the plot schema, but so that we may also manually\n * recurse into known container arrays, such as transforms.\n *\n * See extendTrace and extendLayout below for usage.\n */\nplots.extendObjectWithContainers = function(dest, src, containerPaths) {\n    var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;\n    var copy = Lib.extendDeepNoArrays({}, src || {});\n    var expandedObj = Lib.expandObjectPaths(copy);\n    var containerObj = {};\n\n    // Step through and extract any container properties. Otherwise extendDeepNoArrays\n    // will clobber any existing properties with an empty array and then supplyDefaults\n    // will reset everything to defaults.\n    if(containerPaths && containerPaths.length) {\n        for(i = 0; i < containerPaths.length; i++) {\n            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);\n            containerVal = containerProp.get();\n\n            if(containerVal === undefined) {\n                Lib.nestedProperty(containerObj, containerPaths[i]).set(null);\n            } else {\n                containerProp.set(null);\n                Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);\n            }\n        }\n    }\n\n    dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);\n\n    if(containerPaths && containerPaths.length) {\n        for(i = 0; i < containerPaths.length; i++) {\n            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);\n            srcContainer = srcProp.get();\n\n            if(!srcContainer) continue;\n\n            destProp = Lib.nestedProperty(dest, containerPaths[i]);\n            destContainer = destProp.get();\n\n            if(!Array.isArray(destContainer)) {\n                destContainer = [];\n                destProp.set(destContainer);\n            }\n\n            for(j = 0; j < srcContainer.length; j++) {\n                var srcObj = srcContainer[j];\n\n                if(srcObj === null) destContainer[j] = null;\n                else {\n                    destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);\n                }\n            }\n\n            destProp.set(destContainer);\n        }\n    }\n\n    return dest;\n};\n\nplots.dataArrayContainers = ['transforms', 'dimensions'];\nplots.layoutArrayContainers = Registry.layoutArrayContainers;\n\n/*\n * Extend a trace definition. This method:\n *\n *  1. directly transfers any array references\n *  2. manually recurses into container arrays like transforms\n *\n * The result is the original object reference with the new contents merged in.\n */\nplots.extendTrace = function(destTrace, srcTrace) {\n    return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);\n};\n\n/*\n * Extend a layout definition. This method:\n *\n *  1. directly transfers any array references (not critically important for\n *     layout since there aren't really data arrays)\n *  2. manually recurses into container arrays like annotations\n *\n * The result is the original object reference with the new contents merged in.\n */\nplots.extendLayout = function(destLayout, srcLayout) {\n    return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);\n};\n\n/**\n * Transition to a set of new data and layout properties from Plotly.animate\n *\n * @param {DOM element} gd\n * @param {Object[]} data\n *      an array of data objects following the normal Plotly data definition format\n * @param {Object} layout\n *      a layout object, following normal Plotly layout format\n * @param {Number[]} traces\n *      indices of the corresponding traces specified in `data`\n * @param {Object} frameOpts\n *      options for the frame (i.e. whether to redraw post-transition)\n * @param {Object} transitionOpts\n *      options for the transition\n */\nplots.transition = function(gd, data, layout, traces, frameOpts, transitionOpts) {\n    var opts = {redraw: frameOpts.redraw};\n    var transitionedTraces = {};\n    var axEdits = [];\n\n    opts.prepareFn = function() {\n        var dataLength = Array.isArray(data) ? data.length : 0;\n        var traceIndices = traces.slice(0, dataLength);\n\n        for(var i = 0; i < traceIndices.length; i++) {\n            var traceIdx = traceIndices[i];\n            var trace = gd._fullData[traceIdx];\n            var _module = trace._module;\n\n            // There's nothing to do if this module is not defined:\n            if(!_module) continue;\n\n            // Don't register the trace as transitioned if it doesn't know what to do.\n            // If it *is* registered, it will receive a callback that it's responsible\n            // for calling in order to register the transition as having completed.\n            if(_module.animatable) {\n                var n = _module.basePlotModule.name;\n                if(!transitionedTraces[n]) transitionedTraces[n] = [];\n                transitionedTraces[n].push(traceIdx);\n            }\n\n            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);\n        }\n\n        // Follow the same procedure. Clone it so we don't mangle the input, then\n        // expand any object paths so we can merge deep into gd.layout:\n        var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));\n\n        // Before merging though, we need to modify the incoming layout. We only\n        // know how to *transition* layout ranges, so it's imperative that a new\n        // range not be sent to the layout before the transition has started. So\n        // we must remove the things we can transition:\n        var axisAttrRe = /^[xy]axis[0-9]*$/;\n        for(var attr in layoutUpdate) {\n            if(!axisAttrRe.test(attr)) continue;\n            delete layoutUpdate[attr].range;\n        }\n\n        plots.extendLayout(gd.layout, layoutUpdate);\n\n        // Supply defaults after applying the incoming properties. Note that any attempt\n        // to simplify this step and reduce the amount of work resulted in the reconstruction\n        // of essentially the whole supplyDefaults step, so that it seems sensible to just use\n        // supplyDefaults even though it's heavier than would otherwise be desired for\n        // transitions:\n\n        // first delete calcdata so supplyDefaults knows a calc step is coming\n        delete gd.calcdata;\n\n        plots.supplyDefaults(gd);\n        plots.doCalcdata(gd);\n\n        var newLayout = Lib.expandObjectPaths(layout);\n\n        if(newLayout) {\n            var subplots = gd._fullLayout._plots;\n\n            for(var k in subplots) {\n                var plotinfo = subplots[k];\n                var xa = plotinfo.xaxis;\n                var ya = plotinfo.yaxis;\n                var xr0 = xa.range.slice();\n                var yr0 = ya.range.slice();\n\n                var xr1 = null;\n                var yr1 = null;\n                var editX = null;\n                var editY = null;\n\n                if(Array.isArray(newLayout[xa._name + '.range'])) {\n                    xr1 = newLayout[xa._name + '.range'].slice();\n                } else if(Array.isArray((newLayout[xa._name] || {}).range)) {\n                    xr1 = newLayout[xa._name].range.slice();\n                }\n                if(Array.isArray(newLayout[ya._name + '.range'])) {\n                    yr1 = newLayout[ya._name + '.range'].slice();\n                } else if(Array.isArray((newLayout[ya._name] || {}).range)) {\n                    yr1 = newLayout[ya._name].range.slice();\n                }\n\n                if(xr0 && xr1 &&\n                    (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))\n                ) {\n                    editX = {xr0: xr0, xr1: xr1};\n                }\n                if(yr0 && yr1 &&\n                    (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))\n                ) {\n                    editY = {yr0: yr0, yr1: yr1};\n                }\n\n                if(editX || editY) {\n                    axEdits.push(Lib.extendFlat({plotinfo: plotinfo}, editX, editY));\n                }\n            }\n        }\n\n        return Promise.resolve();\n    };\n\n    opts.runFn = function(makeCallback) {\n        var traceTransitionOpts;\n        var basePlotModules = gd._fullLayout._basePlotModules;\n        var hasAxisTransition = axEdits.length;\n        var i;\n\n        if(layout) {\n            for(i = 0; i < basePlotModules.length; i++) {\n                if(basePlotModules[i].transitionAxes) {\n                    basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);\n                }\n            }\n        }\n\n        // Here handle the exception that we refuse to animate scales and axes at the same\n        // time. In other words, if there's an axis transition, then set the data transition\n        // to instantaneous.\n        if(hasAxisTransition) {\n            traceTransitionOpts = Lib.extendFlat({}, transitionOpts);\n            traceTransitionOpts.duration = 0;\n            // This means do not transition cartesian traces,\n            // this happens on layout-only (e.g. axis range) animations\n            delete transitionedTraces.cartesian;\n        } else {\n            traceTransitionOpts = transitionOpts;\n        }\n\n        // Note that we pass a callback to *create* the callback that must be invoked on completion.\n        // This is since not all traces know about transitions, so it greatly simplifies matters if\n        // the trace is responsible for creating a callback, if needed, and then executing it when\n        // the time is right.\n        for(var n in transitionedTraces) {\n            var traceIndices = transitionedTraces[n];\n            var _module = gd._fullData[traceIndices[0]]._module;\n            _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);\n        }\n    };\n\n    return _transition(gd, transitionOpts, opts);\n};\n\n/**\n * Transition to a set of new data and layout properties from Plotly.react\n *\n * @param {DOM element} gd\n * @param {object} restyleFlags\n * - anim {'all'|'some'}\n * @param {object} relayoutFlags\n * - anim {'all'|'some'}\n * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout\n */\nplots.transitionFromReact = function(gd, restyleFlags, relayoutFlags, oldFullLayout) {\n    var fullLayout = gd._fullLayout;\n    var transitionOpts = fullLayout.transition;\n    var opts = {};\n    var axEdits = [];\n\n    opts.prepareFn = function() {\n        var subplots = fullLayout._plots;\n\n        // no need to redraw at end of transition,\n        // if all changes are animatable\n        opts.redraw = false;\n        if(restyleFlags.anim === 'some') opts.redraw = true;\n        if(relayoutFlags.anim === 'some') opts.redraw = true;\n\n        for(var k in subplots) {\n            var plotinfo = subplots[k];\n            var xa = plotinfo.xaxis;\n            var ya = plotinfo.yaxis;\n            var xr0 = oldFullLayout[xa._name].range.slice();\n            var yr0 = oldFullLayout[ya._name].range.slice();\n            var xr1 = xa.range.slice();\n            var yr1 = ya.range.slice();\n\n            xa.setScale();\n            ya.setScale();\n\n            var editX = null;\n            var editY = null;\n\n            if(xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {\n                editX = {xr0: xr0, xr1: xr1};\n            }\n            if(ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {\n                editY = {yr0: yr0, yr1: yr1};\n            }\n\n            if(editX || editY) {\n                axEdits.push(Lib.extendFlat({plotinfo: plotinfo}, editX, editY));\n            }\n        }\n\n        return Promise.resolve();\n    };\n\n    opts.runFn = function(makeCallback) {\n        var fullData = gd._fullData;\n        var fullLayout = gd._fullLayout;\n        var basePlotModules = fullLayout._basePlotModules;\n\n        var axisTransitionOpts;\n        var traceTransitionOpts;\n        var transitionedTraces;\n\n        var allTraceIndices = [];\n        for(var i = 0; i < fullData.length; i++) {\n            allTraceIndices.push(i);\n        }\n\n        function transitionAxes() {\n            if(!gd._fullLayout) return;\n            for(var j = 0; j < basePlotModules.length; j++) {\n                if(basePlotModules[j].transitionAxes) {\n                    basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);\n                }\n            }\n        }\n\n        function transitionTraces() {\n            if(!gd._fullLayout) return;\n            for(var j = 0; j < basePlotModules.length; j++) {\n                basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);\n            }\n        }\n\n        if(axEdits.length && restyleFlags.anim) {\n            if(transitionOpts.ordering === 'traces first') {\n                axisTransitionOpts = Lib.extendFlat({}, transitionOpts, {duration: 0});\n                transitionedTraces = allTraceIndices;\n                traceTransitionOpts = transitionOpts;\n                setTimeout(transitionAxes, transitionOpts.duration);\n                transitionTraces();\n            } else {\n                axisTransitionOpts = transitionOpts;\n                transitionedTraces = null;\n                traceTransitionOpts = Lib.extendFlat({}, transitionOpts, {duration: 0});\n                setTimeout(transitionTraces, axisTransitionOpts.duration);\n                transitionAxes();\n            }\n        } else if(axEdits.length) {\n            axisTransitionOpts = transitionOpts;\n            transitionAxes();\n        } else if(restyleFlags.anim) {\n            transitionedTraces = allTraceIndices;\n            traceTransitionOpts = transitionOpts;\n            transitionTraces();\n        }\n    };\n\n    return _transition(gd, transitionOpts, opts);\n};\n\n/**\n * trace/layout transition wrapper that works\n * for transitions initiated by Plotly.animate and Plotly.react.\n *\n * @param {DOM element} gd\n * @param {object} transitionOpts\n * @param {object} opts\n * - redraw {boolean}\n * - prepareFn {function} *should return a Promise*\n * - runFn {function} ran inside executeTransitions\n */\nfunction _transition(gd, transitionOpts, opts) {\n    var aborted = false;\n\n    function executeCallbacks(list) {\n        var p = Promise.resolve();\n        if(!list) return p;\n        while(list.length) {\n            p = p.then((list.shift()));\n        }\n        return p;\n    }\n\n    function flushCallbacks(list) {\n        if(!list) return;\n        while(list.length) {\n            list.shift();\n        }\n    }\n\n    function executeTransitions() {\n        gd.emit('plotly_transitioning', []);\n\n        return new Promise(function(resolve) {\n            // This flag is used to disabled things like autorange:\n            gd._transitioning = true;\n\n            // When instantaneous updates are coming through quickly, it's too much to simply disable\n            // all interaction, so store this flag so we can disambiguate whether mouse interactions\n            // should be fully disabled or not:\n            if(transitionOpts.duration > 0) {\n                gd._transitioningWithDuration = true;\n            }\n\n            // If another transition is triggered, this callback will be executed simply because it's\n            // in the interruptCallbacks queue. If this transition completes, it will instead flush\n            // that queue and forget about this callback.\n            gd._transitionData._interruptCallbacks.push(function() {\n                aborted = true;\n            });\n\n            if(opts.redraw) {\n                gd._transitionData._interruptCallbacks.push(function() {\n                    return Registry.call('redraw', gd);\n                });\n            }\n\n            // Emit this and make sure it happens last:\n            gd._transitionData._interruptCallbacks.push(function() {\n                gd.emit('plotly_transitioninterrupted', []);\n            });\n\n            // Construct callbacks that are executed on transition end. This ensures the d3 transitions\n            // are *complete* before anything else is done.\n            var numCallbacks = 0;\n            var numCompleted = 0;\n            function makeCallback() {\n                numCallbacks++;\n                return function() {\n                    numCompleted++;\n                    // When all are complete, perform a redraw:\n                    if(!aborted && numCompleted === numCallbacks) {\n                        completeTransition(resolve);\n                    }\n                };\n            }\n\n            opts.runFn(makeCallback);\n\n            // If nothing else creates a callback, then this will trigger the completion in the next tick:\n            setTimeout(makeCallback());\n        });\n    }\n\n    function completeTransition(callback) {\n        // This a simple workaround for tests which purge the graph before animations\n        // have completed. That's not a very common case, so this is the simplest\n        // fix.\n        if(!gd._transitionData) return;\n\n        flushCallbacks(gd._transitionData._interruptCallbacks);\n\n        return Promise.resolve().then(function() {\n            if(opts.redraw) {\n                return Registry.call('redraw', gd);\n            }\n        }).then(function() {\n            // Set transitioning false again once the redraw has occurred. This is used, for example,\n            // to prevent the trailing redraw from autoranging:\n            gd._transitioning = false;\n            gd._transitioningWithDuration = false;\n\n            gd.emit('plotly_transitioned', []);\n        }).then(callback);\n    }\n\n    function interruptPreviousTransitions() {\n        // Fail-safe against purged plot:\n        if(!gd._transitionData) return;\n\n        // If a transition is interrupted, set this to false. At the moment, the only thing that would\n        // interrupt a transition is another transition, so that it will momentarily be set to true\n        // again, but this determines whether autorange or dragbox work, so it's for the sake of\n        // cleanliness:\n        gd._transitioning = false;\n\n        return executeCallbacks(gd._transitionData._interruptCallbacks);\n    }\n\n    var seq = [\n        plots.previousPromises,\n        interruptPreviousTransitions,\n        opts.prepareFn,\n        plots.rehover,\n        plots.reselect,\n        executeTransitions\n    ];\n\n    var transitionStarting = Lib.syncOrAsync(seq, gd);\n\n    if(!transitionStarting || !transitionStarting.then) {\n        transitionStarting = Promise.resolve();\n    }\n\n    return transitionStarting.then(function() { return gd; });\n}\n\nplots.doCalcdata = function(gd, traces) {\n    var axList = axisIDs.list(gd);\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n\n    var trace, _module, i, j;\n\n    // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\n    // *all* needing doCalcdata:\n    var calcdata = new Array(fullData.length);\n    var oldCalcdata = (gd.calcdata || []).slice();\n    gd.calcdata = calcdata;\n\n    // extra helper variables\n\n    // how many box/violins plots do we have (in case they're grouped)\n    fullLayout._numBoxes = 0;\n    fullLayout._numViolins = 0;\n\n    // initialize violin per-scale-group stats container\n    fullLayout._violinScaleGroupStats = {};\n\n    // for calculating avg luminosity of heatmaps\n    gd._hmpixcount = 0;\n    gd._hmlumcount = 0;\n\n    // for sharing colors across pies / sunbursts / treemap / icicle / funnelarea (and for legend)\n    fullLayout._piecolormap = {};\n    fullLayout._sunburstcolormap = {};\n    fullLayout._treemapcolormap = {};\n    fullLayout._iciclecolormap = {};\n    fullLayout._funnelareacolormap = {};\n\n    // If traces were specified and this trace was not included,\n    // then transfer it over from the old calcdata:\n    for(i = 0; i < fullData.length; i++) {\n        if(Array.isArray(traces) && traces.indexOf(i) === -1) {\n            calcdata[i] = oldCalcdata[i];\n            continue;\n        }\n    }\n\n    for(i = 0; i < fullData.length; i++) {\n        trace = fullData[i];\n\n        trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);\n\n        // keep track of trace extremes (for autorange) in here\n        trace._extremes = {};\n    }\n\n    // add polar axes to axis list\n    var polarIds = fullLayout._subplots.polar || [];\n    for(i = 0; i < polarIds.length; i++) {\n        axList.push(\n            fullLayout[polarIds[i]].radialaxis,\n            fullLayout[polarIds[i]].angularaxis\n        );\n    }\n\n    // clear relinked cmin/cmax values in shared axes to start aggregation from scratch\n    for(var k in fullLayout._colorAxes) {\n        var cOpts = fullLayout[k];\n        if(cOpts.cauto !== false) {\n            delete cOpts.cmin;\n            delete cOpts.cmax;\n        }\n    }\n\n    var hasCalcTransform = false;\n\n    function transformCalci(i) {\n        trace = fullData[i];\n        _module = trace._module;\n\n        if(trace.visible === true && trace.transforms) {\n            // we need one round of trace module calc before\n            // the calc transform to 'fill in' the categories list\n            // used for example in the data-to-coordinate method\n            if(_module && _module.calc) {\n                var cdi = _module.calc(gd, trace);\n\n                // must clear scene 'batches', so that 2nd\n                // _module.calc call starts from scratch\n                if(cdi[0] && cdi[0].t && cdi[0].t._scene) {\n                    delete cdi[0].t._scene.dirty;\n                }\n            }\n\n            for(j = 0; j < trace.transforms.length; j++) {\n                var transform = trace.transforms[j];\n\n                _module = transformsRegistry[transform.type];\n                if(_module && _module.calcTransform) {\n                    trace._hasCalcTransform = true;\n                    hasCalcTransform = true;\n                    _module.calcTransform(gd, trace, transform);\n                }\n            }\n        }\n    }\n\n    function calci(i, isContainer) {\n        trace = fullData[i];\n        _module = trace._module;\n\n        if(!!_module.isContainer !== isContainer) return;\n\n        var cd = [];\n\n        if(trace.visible === true && trace._length !== 0) {\n            // clear existing ref in case it got relinked\n            delete trace._indexToPoints;\n            // keep ref of index-to-points map object of the *last* enabled transform,\n            // this index-to-points map object is required to determine the calcdata indices\n            // that correspond to input indices (e.g. from 'selectedpoints')\n            var transforms = trace.transforms || [];\n            for(j = transforms.length - 1; j >= 0; j--) {\n                if(transforms[j].enabled) {\n                    trace._indexToPoints = transforms[j]._indexToPoints;\n                    break;\n                }\n            }\n\n            if(_module && _module.calc) {\n                cd = _module.calc(gd, trace);\n            }\n        }\n\n        // Make sure there is a first point.\n        //\n        // This ensures there is a calcdata item for every trace,\n        // even if cartesian logic doesn't handle it (for things like legends).\n        if(!Array.isArray(cd) || !cd[0]) {\n            cd = [{x: BADNUM, y: BADNUM}];\n        }\n\n        // add the trace-wide properties to the first point,\n        // per point properties to every point\n        // t is the holder for trace-wide properties\n        if(!cd[0].t) cd[0].t = {};\n        cd[0].trace = trace;\n\n        calcdata[i] = cd;\n    }\n\n    setupAxisCategories(axList, fullData, fullLayout);\n\n    // 'transform' loop - must calc container traces first\n    // so that if their dependent traces can get transform properly\n    for(i = 0; i < fullData.length; i++) calci(i, true);\n    for(i = 0; i < fullData.length; i++) transformCalci(i);\n\n    // clear stuff that should recomputed in 'regular' loop\n    if(hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);\n\n    // 'regular' loop - make sure container traces (eg carpet) calc before\n    // contained traces (eg contourcarpet)\n    for(i = 0; i < fullData.length; i++) calci(i, true);\n    for(i = 0; i < fullData.length; i++) calci(i, false);\n\n    doCrossTraceCalc(gd);\n\n    // Sort axis categories per value if specified\n    var sorted = sortAxisCategoriesByValue(axList, gd);\n    if(sorted.length) {\n        // how many box/violins plots do we have (in case they're grouped)\n        fullLayout._numBoxes = 0;\n        fullLayout._numViolins = 0;\n        // If a sort operation was performed, run calc() again\n        for(i = 0; i < sorted.length; i++) calci(sorted[i], true);\n        for(i = 0; i < sorted.length; i++) calci(sorted[i], false);\n        doCrossTraceCalc(gd);\n    }\n\n    Registry.getComponentMethod('fx', 'calc')(gd);\n    Registry.getComponentMethod('errorbars', 'calc')(gd);\n};\n\nvar sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|geometric mean|median) (ascending|descending)/;\n\nfunction sortAxisCategoriesByValue(axList, gd) {\n    var affectedTraces = [];\n    var i, j, k, l, o;\n\n    function zMapCategory(type, ax, value) {\n        var axLetter = ax._id.charAt(0);\n        if(type === 'histogram2dcontour') {\n            var counterAxLetter = ax._counterAxes[0];\n            var counterAx = axisIDs.getFromId(gd, counterAxLetter);\n\n            var xCategorical = axLetter === 'x' || (counterAxLetter === 'x' && counterAx.type === 'category');\n            var yCategorical = axLetter === 'y' || (counterAxLetter === 'y' && counterAx.type === 'category');\n\n            return function(o, l) {\n                if(o === 0 || l === 0) return -1; // Skip first row and column\n                if(xCategorical && o === value[l].length - 1) return -1;\n                if(yCategorical && l === value.length - 1) return -1;\n\n                return (axLetter === 'y' ? l : o) - 1;\n            };\n        } else {\n            return function(o, l) {\n                return axLetter === 'y' ? l : o;\n            };\n        }\n    }\n\n    var aggFn = {\n        min: function(values) {return Lib.aggNums(Math.min, null, values);},\n        max: function(values) {return Lib.aggNums(Math.max, null, values);},\n        sum: function(values) {return Lib.aggNums(function(a, b) { return a + b;}, null, values);},\n        total: function(values) {return Lib.aggNums(function(a, b) { return a + b;}, null, values);},\n        mean: function(values) {return Lib.mean(values);},\n        'geometric mean': function(values) {return Lib.geometricMean(values);},\n        median: function(values) {return Lib.median(values);}\n    };\n\n    function sortAscending(a, b) {\n        return a[1] - b[1];\n    }\n\n    function sortDescending(a, b) {\n        return b[1] - a[1];\n    }\n\n    for(i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        if(ax.type !== 'category') continue;\n\n        // Order by value\n        var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);\n        if(match) {\n            var aggregator = match[1];\n            var order = match[2];\n\n            var axLetter = ax._id.charAt(0);\n            var isX = axLetter === 'x';\n\n            // Store values associated with each category\n            var categoriesValue = [];\n            for(j = 0; j < ax._categories.length; j++) {\n                categoriesValue.push([ax._categories[j], []]);\n            }\n\n            // Collect values across traces\n            for(j = 0; j < ax._traceIndices.length; j++) {\n                var traceIndex = ax._traceIndices[j];\n                var fullTrace = gd._fullData[traceIndex];\n\n                // Skip over invisible traces\n                if(fullTrace.visible !== true) continue;\n\n                var type = fullTrace.type;\n                if(Registry.traceIs(fullTrace, 'histogram')) {\n                    delete fullTrace._xautoBinFinished;\n                    delete fullTrace._yautoBinFinished;\n                }\n                var isSplom = type === 'splom';\n                var isScattergl = type === 'scattergl';\n\n                var cd = gd.calcdata[traceIndex];\n                for(k = 0; k < cd.length; k++) {\n                    var cdi = cd[k];\n                    var catIndex, value;\n\n                    if(isSplom) {\n                        // If `splom`, collect values across dimensions\n                        // Find which dimension the current axis is representing\n                        var currentDimensionIndex = fullTrace._axesDim[ax._id];\n\n                        // Apply logic to associated x axis if it's defined\n                        if(!isX) {\n                            var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];\n                            if(associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];\n                        }\n\n                        var categories = cdi.trace.dimensions[currentDimensionIndex].values;\n                        for(l = 0; l < categories.length; l++) {\n                            catIndex = ax._categoriesMap[categories[l]];\n\n                            // Collect associated values at index `l` over all other dimensions\n                            for(o = 0; o < cdi.trace.dimensions.length; o++) {\n                                if(o === currentDimensionIndex) continue;\n                                var dimension = cdi.trace.dimensions[o];\n                                categoriesValue[catIndex][1].push(dimension.values[l]);\n                            }\n                        }\n                    } else if(isScattergl) {\n                        // If `scattergl`, collect all values stashed under cdi.t\n                        for(l = 0; l < cdi.t.x.length; l++) {\n                            if(isX) {\n                                catIndex = cdi.t.x[l];\n                                value = cdi.t.y[l];\n                            } else {\n                                catIndex = cdi.t.y[l];\n                                value = cdi.t.x[l];\n                            }\n                            categoriesValue[catIndex][1].push(value);\n                        }\n                        // must clear scene 'batches', so that 2nd\n                        // _module.calc call starts from scratch\n                        if(cdi.t && cdi.t._scene) {\n                            delete cdi.t._scene.dirty;\n                        }\n                    } else if(cdi.hasOwnProperty('z')) {\n                        // If 2dMap, collect values in `z`\n                        value = cdi.z;\n                        var mapping = zMapCategory(fullTrace.type, ax, value);\n\n                        for(l = 0; l < value.length; l++) {\n                            for(o = 0; o < value[l].length; o++) {\n                                catIndex = mapping(o, l);\n                                if(catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);\n                            }\n                        }\n                    } else {\n                        // For all other 2d cartesian traces\n                        catIndex = cdi.p;\n                        if(catIndex === undefined) catIndex = cdi[axLetter];\n\n                        value = cdi.s;\n                        if(value === undefined) value = cdi.v;\n                        if(value === undefined) value = isX ? cdi.y : cdi.x;\n\n                        if(!Array.isArray(value)) {\n                            if(value === undefined) value = [];\n                            else value = [value];\n                        }\n                        for(l = 0; l < value.length; l++) {\n                            categoriesValue[catIndex][1].push(value[l]);\n                        }\n                    }\n                }\n            }\n\n            ax._categoriesValue = categoriesValue;\n\n            var categoriesAggregatedValue = [];\n            for(j = 0; j < categoriesValue.length; j++) {\n                categoriesAggregatedValue.push([\n                    categoriesValue[j][0],\n                    aggFn[aggregator](categoriesValue[j][1])\n                ]);\n            }\n\n            // Sort by aggregated value\n            categoriesAggregatedValue.sort(order === 'descending' ? sortDescending : sortAscending);\n\n            ax._categoriesAggregatedValue = categoriesAggregatedValue;\n\n            // Set new category order\n            ax._initialCategories = categoriesAggregatedValue.map(function(c) {\n                return c[0];\n            });\n\n            // Sort all matching axes\n            affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());\n        }\n    }\n    return affectedTraces;\n}\n\nfunction setupAxisCategories(axList, fullData, fullLayout) {\n    var axLookup = {};\n\n    function setupOne(ax) {\n        ax.clearCalc();\n        if(ax.type === 'multicategory') {\n            ax.setupMultiCategory(fullData);\n        }\n\n        axLookup[ax._id] = 1;\n    }\n\n    Lib.simpleMap(axList, setupOne);\n\n    // look into match groups for 'missing' axes\n    var matchGroups = fullLayout._axisMatchGroups || [];\n    for(var i = 0; i < matchGroups.length; i++) {\n        for(var axId in matchGroups[i]) {\n            if(!axLookup[axId]) {\n                setupOne(fullLayout[axisIDs.id2name(axId)]);\n            }\n        }\n    }\n}\n\nfunction doCrossTraceCalc(gd) {\n    var fullLayout = gd._fullLayout;\n    var modules = fullLayout._visibleModules;\n    var hash = {};\n    var i, j, k;\n\n    // position and range calculations for traces that\n    // depend on each other ie bars (stacked or grouped)\n    // and boxes (grouped) push each other out of the way\n\n    for(j = 0; j < modules.length; j++) {\n        var _module = modules[j];\n        var fn = _module.crossTraceCalc;\n        if(fn) {\n            var spType = _module.basePlotModule.name;\n            if(hash[spType]) {\n                Lib.pushUnique(hash[spType], fn);\n            } else {\n                hash[spType] = [fn];\n            }\n        }\n    }\n\n    for(k in hash) {\n        var methods = hash[k];\n        var subplots = fullLayout._subplots[k];\n\n        if(Array.isArray(subplots)) {\n            for(i = 0; i < subplots.length; i++) {\n                var sp = subplots[i];\n                var spInfo = k === 'cartesian' ?\n                    fullLayout._plots[sp] :\n                    fullLayout[sp];\n\n                for(j = 0; j < methods.length; j++) {\n                    methods[j](gd, spInfo, sp);\n                }\n            }\n        } else {\n            for(j = 0; j < methods.length; j++) {\n                methods[j](gd);\n            }\n        }\n    }\n}\n\nplots.rehover = function(gd) {\n    if(gd._fullLayout._rehover) {\n        gd._fullLayout._rehover();\n    }\n};\n\nplots.redrag = function(gd) {\n    if(gd._fullLayout._redrag) {\n        gd._fullLayout._redrag();\n    }\n};\n\nplots.reselect = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var A = (gd.layout || {}).selections;\n    var B = fullLayout._previousSelections;\n    fullLayout._previousSelections = A;\n\n    var mayEmitSelected = fullLayout._reselect ||\n        JSON.stringify(A) !== JSON.stringify(B);\n\n    Registry.getComponentMethod('selections', 'reselect')(gd, mayEmitSelected);\n};\n\nplots.generalUpdatePerTraceModule = function(gd, subplot, subplotCalcData, subplotLayout) {\n    var traceHashOld = subplot.traceHash;\n    var traceHash = {};\n    var i;\n\n    // build up moduleName -> calcData hash\n    for(i = 0; i < subplotCalcData.length; i++) {\n        var calcTraces = subplotCalcData[i];\n        var trace = calcTraces[0].trace;\n\n        // skip over visible === false traces\n        // as they don't have `_module` ref\n        if(trace.visible) {\n            traceHash[trace.type] = traceHash[trace.type] || [];\n            traceHash[trace.type].push(calcTraces);\n        }\n    }\n\n    // when a trace gets deleted, make sure that its module's\n    // plot method is called so that it is properly\n    // removed from the DOM.\n    for(var moduleNameOld in traceHashOld) {\n        if(!traceHash[moduleNameOld]) {\n            var fakeCalcTrace = traceHashOld[moduleNameOld][0];\n            var fakeTrace = fakeCalcTrace[0].trace;\n\n            fakeTrace.visible = false;\n            traceHash[moduleNameOld] = [fakeCalcTrace];\n        }\n    }\n\n    // call module plot method\n    for(var moduleName in traceHash) {\n        var moduleCalcData = traceHash[moduleName];\n        var _module = moduleCalcData[0][0].trace._module;\n\n        _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);\n    }\n\n    // update moduleName -> calcData hash\n    subplot.traceHash = traceHash;\n};\n\nplots.plotBasePlot = function(desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {\n    var _module = Registry.getModule(desiredType);\n    var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];\n    _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);\n};\n\nplots.cleanBasePlot = function(desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {\n    var had = (oldFullLayout._has && oldFullLayout._has(desiredType));\n    var has = (newFullLayout._has && newFullLayout._has(desiredType));\n\n    if(had && !has) {\n        oldFullLayout['_' + desiredType + 'layer'].selectAll('g.trace').remove();\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}