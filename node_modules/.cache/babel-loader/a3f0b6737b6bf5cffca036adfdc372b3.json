{"ast":null,"code":"'use strict';\n\n/* eslint-disable consistent-return */\nvar readUInt16BE = require('../common').readUInt16BE;\nvar str2arr = require('../common').str2arr;\nvar sliceEq = require('../common').sliceEq;\nvar exif = require('../exif_utils');\nvar SIG_EXIF = str2arr('Exif\\0\\0');\nmodule.exports = function (data) {\n  if (data.length < 2) return;\n\n  // first marker of the file MUST be 0xFFD8,\n  // following by either 0xFFE0, 0xFFE2 or 0xFFE3\n  if (data[0] !== 0xFF || data[1] !== 0xD8 || data[2] !== 0xFF) return;\n  var offset = 2;\n  for (;;) {\n    // skip until we see 0xFF, see https://github.com/nodeca/probe-image-size/issues/68\n    for (;;) {\n      if (data.length - offset < 2) return;\n      if (data[offset++] === 0xFF) break;\n    }\n    var code = data[offset++];\n    var length;\n\n    // skip padding bytes\n    while (code === 0xFF) code = data[offset++];\n\n    // standalone markers, according to JPEG 1992,\n    // http://www.w3.org/Graphics/JPEG/itu-t81.pdf, see Table B.1\n    if (0xD0 <= code && code <= 0xD9 || code === 0x01) {\n      length = 0;\n    } else if (0xC0 <= code && code <= 0xFE) {\n      // the rest of the unreserved markers\n      if (data.length - offset < 2) return;\n      length = readUInt16BE(data, offset) - 2;\n      offset += 2;\n    } else {\n      // unknown markers\n      return;\n    }\n    if (code === 0xD9 /* EOI */ || code === 0xDA /* SOS */) {\n      // end of the datastream\n      return;\n    }\n    var orientation;\n\n    // try to get orientation from Exif segment\n    if (code === 0xE1 && length >= 10 && sliceEq(data, offset, SIG_EXIF)) {\n      orientation = exif.get_orientation(data.slice(offset + 6, offset + length));\n    }\n    if (length >= 5 && 0xC0 <= code && code <= 0xCF && code !== 0xC4 && code !== 0xC8 && code !== 0xCC) {\n      if (data.length - offset < length) return;\n      var result = {\n        width: readUInt16BE(data, offset + 3),\n        height: readUInt16BE(data, offset + 1),\n        type: 'jpg',\n        mime: 'image/jpeg',\n        wUnits: 'px',\n        hUnits: 'px'\n      };\n      if (orientation > 0) {\n        result.orientation = orientation;\n      }\n      return result;\n    }\n    offset += length;\n  }\n};","map":{"version":3,"names":["readUInt16BE","require","str2arr","sliceEq","exif","SIG_EXIF","module","exports","data","length","offset","code","orientation","get_orientation","slice","result","width","height","type","mime","wUnits","hUnits"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/probe-image-size/lib/parse_sync/jpeg.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable consistent-return */\n\nvar readUInt16BE = require('../common').readUInt16BE;\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar exif         = require('../exif_utils');\n\n\nvar SIG_EXIF  = str2arr('Exif\\0\\0');\n\n\nmodule.exports = function (data) {\n  if (data.length < 2) return;\n\n  // first marker of the file MUST be 0xFFD8,\n  // following by either 0xFFE0, 0xFFE2 or 0xFFE3\n  if (data[0] !== 0xFF || data[1] !== 0xD8 || data[2] !== 0xFF) return;\n\n  var offset = 2;\n\n  for (;;) {\n    // skip until we see 0xFF, see https://github.com/nodeca/probe-image-size/issues/68\n    for (;;) {\n      if (data.length - offset < 2) return;\n      if (data[offset++] === 0xFF) break;\n    }\n\n    var code = data[offset++];\n    var length;\n\n    // skip padding bytes\n    while (code === 0xFF) code = data[offset++];\n\n    // standalone markers, according to JPEG 1992,\n    // http://www.w3.org/Graphics/JPEG/itu-t81.pdf, see Table B.1\n    if ((0xD0 <= code && code <= 0xD9) || code === 0x01) {\n      length = 0;\n    } else if (0xC0 <= code && code <= 0xFE) {\n      // the rest of the unreserved markers\n      if (data.length - offset < 2) return;\n\n      length = readUInt16BE(data, offset) - 2;\n      offset += 2;\n    } else {\n      // unknown markers\n      return;\n    }\n\n    if (code === 0xD9 /* EOI */ || code === 0xDA /* SOS */) {\n      // end of the datastream\n      return;\n    }\n\n    var orientation;\n\n    // try to get orientation from Exif segment\n    if (code === 0xE1 && length >= 10 && sliceEq(data, offset, SIG_EXIF)) {\n      orientation = exif.get_orientation(data.slice(offset + 6, offset + length));\n    }\n\n    if (length >= 5 &&\n        (0xC0 <= code && code <= 0xCF) &&\n        code !== 0xC4 && code !== 0xC8 && code !== 0xCC) {\n\n      if (data.length - offset < length) return;\n\n      var result = {\n        width:  readUInt16BE(data, offset + 3),\n        height: readUInt16BE(data, offset + 1),\n        type:   'jpg',\n        mime:   'image/jpeg',\n        wUnits: 'px',\n        hUnits: 'px'\n      };\n\n      if (orientation > 0) {\n        result.orientation = orientation;\n      }\n\n      return result;\n    }\n\n    offset += length;\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,WAAW,CAAC,CAACD,YAAY;AACpD,IAAIE,OAAO,GAAQD,OAAO,CAAC,WAAW,CAAC,CAACC,OAAO;AAC/C,IAAIC,OAAO,GAAQF,OAAO,CAAC,WAAW,CAAC,CAACE,OAAO;AAC/C,IAAIC,IAAI,GAAWH,OAAO,CAAC,eAAe,CAAC;AAG3C,IAAII,QAAQ,GAAIH,OAAO,CAAC,UAAU,CAAC;AAGnCI,MAAM,CAACC,OAAO,GAAG,UAAUC,IAAI,EAAE;EAC/B,IAAIA,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE;;EAErB;EACA;EACA,IAAID,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;EAE9D,IAAIE,MAAM,GAAG,CAAC;EAEd,SAAS;IACP;IACA,SAAS;MACP,IAAIF,IAAI,CAACC,MAAM,GAAGC,MAAM,GAAG,CAAC,EAAE;MAC9B,IAAIF,IAAI,CAACE,MAAM,EAAE,CAAC,KAAK,IAAI,EAAE;IAC/B;IAEA,IAAIC,IAAI,GAAGH,IAAI,CAACE,MAAM,EAAE,CAAC;IACzB,IAAID,MAAM;;IAEV;IACA,OAAOE,IAAI,KAAK,IAAI,EAAEA,IAAI,GAAGH,IAAI,CAACE,MAAM,EAAE,CAAC;;IAE3C;IACA;IACA,IAAK,IAAI,IAAIC,IAAI,IAAIA,IAAI,IAAI,IAAI,IAAKA,IAAI,KAAK,IAAI,EAAE;MACnDF,MAAM,GAAG,CAAC;IACZ,CAAC,MAAM,IAAI,IAAI,IAAIE,IAAI,IAAIA,IAAI,IAAI,IAAI,EAAE;MACvC;MACA,IAAIH,IAAI,CAACC,MAAM,GAAGC,MAAM,GAAG,CAAC,EAAE;MAE9BD,MAAM,GAAGT,YAAY,CAACQ,IAAI,EAAEE,MAAM,CAAC,GAAG,CAAC;MACvCA,MAAM,IAAI,CAAC;IACb,CAAC,MAAM;MACL;MACA;IACF;IAEA,IAAIC,IAAI,KAAK,IAAI,CAAC,aAAaA,IAAI,KAAK,IAAI,CAAC,WAAW;MACtD;MACA;IACF;IAEA,IAAIC,WAAW;;IAEf;IACA,IAAID,IAAI,KAAK,IAAI,IAAIF,MAAM,IAAI,EAAE,IAAIN,OAAO,CAACK,IAAI,EAAEE,MAAM,EAAEL,QAAQ,CAAC,EAAE;MACpEO,WAAW,GAAGR,IAAI,CAACS,eAAe,CAACL,IAAI,CAACM,KAAK,CAACJ,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,MAAM,CAAC,CAAC;IAC7E;IAEA,IAAIA,MAAM,IAAI,CAAC,IACV,IAAI,IAAIE,IAAI,IAAIA,IAAI,IAAI,IAAK,IAC9BA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,EAAE;MAEnD,IAAIH,IAAI,CAACC,MAAM,GAAGC,MAAM,GAAGD,MAAM,EAAE;MAEnC,IAAIM,MAAM,GAAG;QACXC,KAAK,EAAGhB,YAAY,CAACQ,IAAI,EAAEE,MAAM,GAAG,CAAC,CAAC;QACtCO,MAAM,EAAEjB,YAAY,CAACQ,IAAI,EAAEE,MAAM,GAAG,CAAC,CAAC;QACtCQ,IAAI,EAAI,KAAK;QACbC,IAAI,EAAI,YAAY;QACpBC,MAAM,EAAE,IAAI;QACZC,MAAM,EAAE;MACV,CAAC;MAED,IAAIT,WAAW,GAAG,CAAC,EAAE;QACnBG,MAAM,CAACH,WAAW,GAAGA,WAAW;MAClC;MAEA,OAAOG,MAAM;IACf;IAEAL,MAAM,IAAID,MAAM;EAClB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}