{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Fx = require('../fx');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar drawArrowHead = require('./draw_arrow_head');\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  drawRaw: drawRaw\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n  fullLayout._infolayer.selectAll('.annotation').remove();\n  for (var i = 0; i < fullLayout.annotations.length; i++) {\n    if (fullLayout.annotations[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n  return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n  var fullLayout = gd._fullLayout;\n  var options = fullLayout.annotations[index] || {};\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  if (xa) xa.setScale();\n  if (ya) ya.setScale();\n  drawRaw(gd, options, index, false, xa, ya);\n}\n\n// Convert pixels to the coordinates relevant for the axis referred to. For\n// example, for paper it would convert to a value normalized by the dimension of\n// the plot.\n// axDomainRef: if true and axa defined, draws relative to axis domain,\n// otherwise draws relative to data (if axa defined) or paper (if not).\nfunction shiftPosition(axa, dAx, axLetter, gs, options) {\n  var optAx = options[axLetter];\n  var axRef = options[axLetter + 'ref'];\n  var vertical = axLetter.indexOf('y') !== -1;\n  var axDomainRef = Axes.getRefType(axRef) === 'domain';\n  var gsDim = vertical ? gs.h : gs.w;\n  if (axa) {\n    if (axDomainRef) {\n      // here optAx normalized to length of axis (e.g., normally in range\n      // 0 to 1). But dAx is in pixels. So we normalize dAx to length of\n      // axis before doing the math.\n      return optAx + (vertical ? -dAx : dAx) / axa._length;\n    } else {\n      return axa.p2r(axa.r2p(optAx) + dAx);\n    }\n  } else {\n    return optAx + (vertical ? -dAx : dAx) / gsDim;\n  }\n}\n\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n  var fullLayout = gd._fullLayout;\n  var gs = gd._fullLayout._size;\n  var edits = gd._context.edits;\n  var className, containerStr;\n  if (subplotId) {\n    className = 'annotation-' + subplotId;\n    containerStr = subplotId + '.annotations';\n  } else {\n    className = 'annotation';\n    containerStr = 'annotations';\n  }\n  var editHelpers = arrayEditor(gd.layout, containerStr, options);\n  var modifyBase = editHelpers.modifyBase;\n  var modifyItem = editHelpers.modifyItem;\n  var getUpdateObj = editHelpers.getUpdateObj;\n\n  // remove the existing annotation if there is one\n  fullLayout._infolayer.selectAll('.' + className + '[data-index=\"' + index + '\"]').remove();\n  var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n  // this annotation is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n  if (!options._input || options.visible === false) {\n    d3.selectAll('#' + annClipID).remove();\n    return;\n  }\n\n  // calculated pixel positions\n  // x & y each will get text, head, and tail as appropriate\n  var annPosPx = {\n    x: {},\n    y: {}\n  };\n  var textangle = +options.textangle || 0;\n\n  // create the components\n  // made a single group to contain all, so opacity can work right\n  // with border/arrow together this could handle a whole bunch of\n  // cleanup at this point, but works for now\n  var annGroup = fullLayout._infolayer.append('g').classed(className, true).attr('data-index', String(index)).style('opacity', options.opacity);\n\n  // another group for text+background so that they can rotate together\n  var annTextGroup = annGroup.append('g').classed('annotation-text-g', true);\n  var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n  var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n  function makeEventData(initialEvent) {\n    var eventData = {\n      index: index,\n      annotation: options._input,\n      fullAnnotation: options,\n      event: initialEvent\n    };\n    if (subplotId) {\n      eventData.subplotId = subplotId;\n    }\n    return eventData;\n  }\n  var annTextGroupInner = annTextGroup.append('g').style('pointer-events', textEvents ? 'all' : null).call(setCursor, 'pointer').on('click', function () {\n    gd._dragging = false;\n    gd.emit('plotly_clickannotation', makeEventData(d3.event));\n  });\n  if (options.hovertext) {\n    annTextGroupInner.on('mouseover', function () {\n      var hoverOptions = options.hoverlabel;\n      var hoverFont = hoverOptions.font;\n      var bBox = this.getBoundingClientRect();\n      var bBoxRef = gd.getBoundingClientRect();\n      Fx.loneHover({\n        x0: bBox.left - bBoxRef.left,\n        x1: bBox.right - bBoxRef.left,\n        y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n        text: options.hovertext,\n        color: hoverOptions.bgcolor,\n        borderColor: hoverOptions.bordercolor,\n        fontFamily: hoverFont.family,\n        fontSize: hoverFont.size,\n        fontColor: hoverFont.color,\n        fontWeight: hoverFont.weight,\n        fontStyle: hoverFont.style,\n        fontVariant: hoverFont.variant,\n        fontShadow: hoverFont.fontShadow,\n        fontLineposition: hoverFont.fontLineposition,\n        fontTextcase: hoverFont.fontTextcase\n      }, {\n        container: fullLayout._hoverlayer.node(),\n        outerContainer: fullLayout._paper.node(),\n        gd: gd\n      });\n    }).on('mouseout', function () {\n      Fx.loneUnhover(fullLayout._hoverlayer.node());\n    });\n  }\n  var borderwidth = options.borderwidth;\n  var borderpad = options.borderpad;\n  var borderfull = borderwidth + borderpad;\n  var annTextBG = annTextGroupInner.append('rect').attr('class', 'bg').style('stroke-width', borderwidth + 'px').call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);\n  var isSizeConstrained = options.width || options.height;\n  var annTextClip = fullLayout._topclips.selectAll('#' + annClipID).data(isSizeConstrained ? [0] : []);\n  annTextClip.enter().append('clipPath').classed('annclip', true).attr('id', annClipID).append('rect');\n  annTextClip.exit().remove();\n  var font = options.font;\n  var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;\n  var annText = annTextGroupInner.append('text').classed('annotation-text', true).text(text);\n  function textLayout(s) {\n    s.call(Drawing.font, font).attr({\n      'text-anchor': {\n        left: 'start',\n        right: 'end'\n      }[options.align] || 'middle'\n    });\n    svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n    return s;\n  }\n  function drawGraphicalElements() {\n    // if the text has *only* a link, make the whole box into a link\n    var anchor3 = annText.selectAll('a');\n    if (anchor3.size() === 1 && anchor3.text() === annText.text()) {\n      var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n        'xlink:xlink:href': anchor3.attr('xlink:href'),\n        'xlink:xlink:show': anchor3.attr('xlink:show')\n      }).style({\n        cursor: 'pointer'\n      });\n      wholeLink.node().appendChild(annTextBG.node());\n    }\n    var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n    var hasMathjax = !mathjaxGroup.empty();\n    var anntextBB = Drawing.bBox((hasMathjax ? mathjaxGroup : annText).node());\n    var textWidth = anntextBB.width;\n    var textHeight = anntextBB.height;\n    var annWidth = options.width || textWidth;\n    var annHeight = options.height || textHeight;\n    var outerWidth = Math.round(annWidth + 2 * borderfull);\n    var outerHeight = Math.round(annHeight + 2 * borderfull);\n    function shiftFraction(v, anchor) {\n      if (anchor === 'auto') {\n        if (v < 1 / 3) anchor = 'left';else if (v > 2 / 3) anchor = 'right';else anchor = 'center';\n      }\n      return {\n        center: 0,\n        middle: 0,\n        left: 0.5,\n        bottom: -0.5,\n        right: -0.5,\n        top: 0.5\n      }[anchor];\n    }\n    var annotationIsOffscreen = false;\n    var letters = ['x', 'y'];\n    for (var i = 0; i < letters.length; i++) {\n      var axLetter = letters[i];\n      var axRef = options[axLetter + 'ref'] || axLetter;\n      var tailRef = options['a' + axLetter + 'ref'];\n      var ax = {\n        x: xa,\n        y: ya\n      }[axLetter];\n      var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;\n      // note that these two can be either positive or negative\n      var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n      var annSizeFromHeight = outerHeight * Math.sin(dimAngle);\n      // but this one is the positive total size\n      var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n      var anchor = options[axLetter + 'anchor'];\n      var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n      var posPx = annPosPx[axLetter];\n      var basePx;\n      var textPadShift;\n      var alignPosition;\n      var autoAlignFraction;\n      var textShift;\n      var axRefType = Axes.getRefType(axRef);\n\n      /*\n       * calculate the *primary* pixel position\n       * which is the arrowhead if there is one,\n       * otherwise the text anchor point\n       */\n      if (ax && axRefType !== 'domain') {\n        // check if annotation is off screen, to bypass DOM manipulations\n        var posFraction = ax.r2fraction(options[axLetter]);\n        if (posFraction < 0 || posFraction > 1) {\n          if (tailRef === axRef) {\n            posFraction = ax.r2fraction(options['a' + axLetter]);\n            if (posFraction < 0 || posFraction > 1) {\n              annotationIsOffscreen = true;\n            }\n          } else {\n            annotationIsOffscreen = true;\n          }\n        }\n        basePx = ax._offset + ax.r2p(options[axLetter]);\n        autoAlignFraction = 0.5;\n      } else {\n        var axRefTypeEqDomain = axRefType === 'domain';\n        if (axLetter === 'x') {\n          alignPosition = options[axLetter];\n          basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.l + gs.w * alignPosition;\n        } else {\n          alignPosition = 1 - options[axLetter];\n          basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.t + gs.h * alignPosition;\n        }\n        autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n      }\n\n      // now translate this into pixel positions of head, tail, and text\n      // as well as paddings for autorange\n      if (options.showarrow) {\n        posPx.head = basePx;\n        var arrowLength = options['a' + axLetter];\n\n        // with an arrow, the text rotates around the anchor point\n        textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n        if (tailRef === axRef) {\n          // In the case tailRefType is 'domain' or 'paper', the arrow's\n          // position is set absolutely, which is consistent with how\n          // it behaves when its position is set in data ('range')\n          // coordinates.\n          var tailRefType = Axes.getRefType(tailRef);\n          if (tailRefType === 'domain') {\n            if (axLetter === 'y') {\n              arrowLength = 1 - arrowLength;\n            }\n            posPx.tail = ax._offset + ax._length * arrowLength;\n          } else if (tailRefType === 'paper') {\n            if (axLetter === 'y') {\n              arrowLength = 1 - arrowLength;\n              posPx.tail = gs.t + gs.h * arrowLength;\n            } else {\n              posPx.tail = gs.l + gs.w * arrowLength;\n            }\n          } else {\n            // assumed tailRef is range or paper referenced\n            posPx.tail = ax._offset + ax.r2p(arrowLength);\n          }\n          // tail is range- or domain-referenced: autorange pads the\n          // text in px from the tail\n          textPadShift = textShift;\n        } else {\n          posPx.tail = basePx + arrowLength;\n          // tail is specified in px from head, so autorange also pads vs head\n          textPadShift = textShift + arrowLength;\n        }\n        posPx.text = posPx.tail + textShift;\n\n        // constrain pixel/paper referenced so the draggers are at least\n        // partially visible\n        var maxPx = fullLayout[axLetter === 'x' ? 'width' : 'height'];\n        if (axRef === 'paper') {\n          posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n        }\n        if (tailRef === 'pixel') {\n          var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n          var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n          if (shiftPlus > 0) {\n            posPx.tail += shiftPlus;\n            posPx.text += shiftPlus;\n          } else if (shiftMinus > 0) {\n            posPx.tail -= shiftMinus;\n            posPx.text -= shiftMinus;\n          }\n        }\n        posPx.tail += overallShift;\n        posPx.head += overallShift;\n      } else {\n        // with no arrow, the text rotates and *then* we put the anchor\n        // relative to the new bounding box\n        textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n        textPadShift = textShift;\n        posPx.text = basePx + textShift;\n      }\n      posPx.text += overallShift;\n      textShift += overallShift;\n      textPadShift += overallShift;\n\n      // padplus/minus are used by autorange\n      options['_' + axLetter + 'padplus'] = annSize / 2 + textPadShift;\n      options['_' + axLetter + 'padminus'] = annSize / 2 - textPadShift;\n\n      // size/shift are used during dragging\n      options['_' + axLetter + 'size'] = annSize;\n      options['_' + axLetter + 'shift'] = textShift;\n    }\n    if (annotationIsOffscreen) {\n      annTextGroupInner.remove();\n      return;\n    }\n    var xShift = 0;\n    var yShift = 0;\n    if (options.align !== 'left') {\n      xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n    }\n    if (options.valign !== 'top') {\n      yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n    }\n    if (hasMathjax) {\n      mathjaxGroup.select('svg').attr({\n        x: borderfull + xShift - 1,\n        y: borderfull + yShift\n      }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    } else {\n      var texty = borderfull + yShift - anntextBB.top;\n      var textx = borderfull + xShift - anntextBB.left;\n      annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    }\n    annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull, annWidth, annHeight);\n    annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2, outerWidth - borderwidth, outerHeight - borderwidth);\n    annTextGroupInner.call(Drawing.setTranslate, Math.round(annPosPx.x.text - outerWidth / 2), Math.round(annPosPx.y.text - outerHeight / 2));\n\n    /*\n     * rotate text and background\n     * we already calculated the text center position *as rotated*\n     * because we needed that for autoranging anyway, so now whether\n     * we have an arrow or not, we rotate about the text center.\n     */\n    annTextGroup.attr({\n      transform: 'rotate(' + textangle + ',' + annPosPx.x.text + ',' + annPosPx.y.text + ')'\n    });\n\n    /*\n     * add the arrow\n     * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n     * dx and dy are normally zero, but when you are dragging the textbox\n     * while the head stays put, dx and dy are the pixel offsets\n     */\n    var drawArrow = function (dx, dy) {\n      annGroup.selectAll('.annotation-arrow-g').remove();\n      var headX = annPosPx.x.head;\n      var headY = annPosPx.y.head;\n      var tailX = annPosPx.x.tail + dx;\n      var tailY = annPosPx.y.tail + dy;\n      var textX = annPosPx.x.text + dx;\n      var textY = annPosPx.y.text + dy;\n\n      // find the edge of the text box, where we'll start the arrow:\n      // create transform matrix to rotate the text box corners\n      var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n      var applyTransform = Lib.apply2DTransform(transform);\n      var applyTransform2 = Lib.apply2DTransform2(transform);\n\n      // calculate and transform bounding box\n      var width = +annTextBG.attr('width');\n      var height = +annTextBG.attr('height');\n      var xLeft = textX - 0.5 * width;\n      var xRight = xLeft + width;\n      var yTop = textY - 0.5 * height;\n      var yBottom = yTop + height;\n      var edges = [[xLeft, yTop, xLeft, yBottom], [xLeft, yBottom, xRight, yBottom], [xRight, yBottom, xRight, yTop], [xRight, yTop, xLeft, yTop]].map(applyTransform2);\n\n      // Remove the line if it ends inside the box.  Use ray\n      // casting for rotated boxes: see which edges intersect a\n      // line from the arrowhead to far away and reduce with xor\n      // to get the parity of the number of intersections.\n      if (edges.reduce(function (a, x) {\n        return a ^ !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6, x[0], x[1], x[2], x[3]);\n      }, false)) {\n        // no line or arrow - so quit drawArrow now\n        return;\n      }\n      edges.forEach(function (x) {\n        var p = Lib.segmentsIntersect(tailX, tailY, headX, headY, x[0], x[1], x[2], x[3]);\n        if (p) {\n          tailX = p.x;\n          tailY = p.y;\n        }\n      });\n      var strokewidth = options.arrowwidth;\n      var arrowColor = options.arrowcolor;\n      var arrowSide = options.arrowside;\n      var arrowGroup = annGroup.append('g').style({\n        opacity: Color.opacity(arrowColor)\n      }).classed('annotation-arrow-g', true);\n      var arrow = arrowGroup.append('path').attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY).style('stroke-width', strokewidth + 'px').call(Color.stroke, Color.rgb(arrowColor));\n      drawArrowHead(arrow, arrowSide, options);\n\n      // the arrow dragger is a small square right at the head, then a line to the tail,\n      // all expanded by a stroke width of 6px plus the arrow line width\n      if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n        var arrowDragHeadX = headX;\n        var arrowDragHeadY = headY;\n        if (options.standoff) {\n          var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n          arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n          arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n        }\n        var arrowDrag = arrowGroup.append('path').classed('annotation-arrow', true).classed('anndrag', true).classed('cursor-move', true).attr({\n          d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n          transform: strTranslate(arrowDragHeadX, arrowDragHeadY)\n        }).style('stroke-width', strokewidth + 6 + 'px').call(Color.stroke, 'rgba(0,0,0,0)').call(Color.fill, 'rgba(0,0,0,0)');\n        var annx0, anny0;\n\n        // dragger for the arrow & head: translates the whole thing\n        // (head/tail/text) all together\n        dragElement.init({\n          element: arrowDrag.node(),\n          gd: gd,\n          prepFn: function () {\n            var pos = Drawing.getTranslate(annTextGroupInner);\n            annx0 = pos.x;\n            anny0 = pos.y;\n            if (xa && xa.autorange) {\n              modifyBase(xa._name + '.autorange', true);\n            }\n            if (ya && ya.autorange) {\n              modifyBase(ya._name + '.autorange', true);\n            }\n          },\n          moveFn: function (dx, dy) {\n            var annxy0 = applyTransform(annx0, anny0);\n            var xcenter = annxy0[0] + dx;\n            var ycenter = annxy0[1] + dy;\n            annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n            modifyItem('x', shiftPosition(xa, dx, 'x', gs, options));\n            modifyItem('y', shiftPosition(ya, dy, 'y', gs, options));\n\n            // for these 2 calls to shiftPosition, it is assumed xa, ya are\n            // defined, so gsDim will not be used, but we put it in\n            // anyways for consistency\n            if (options.axref === options.xref) {\n              modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n            }\n            if (options.ayref === options.yref) {\n              modifyItem('ay', shiftPosition(ya, dy, 'ay', gs, options));\n            }\n            arrowGroup.attr('transform', strTranslate(dx, dy));\n            annTextGroup.attr({\n              transform: 'rotate(' + textangle + ',' + xcenter + ',' + ycenter + ')'\n            });\n          },\n          doneFn: function () {\n            Registry.call('_guiRelayout', gd, getUpdateObj());\n            var notesBox = document.querySelector('.js-notes-box-panel');\n            if (notesBox) notesBox.redraw(notesBox.selectedObj);\n          }\n        });\n      }\n    };\n    if (options.showarrow) drawArrow(0, 0);\n\n    // user dragging the annotation (text, not arrow)\n    if (editTextPosition) {\n      var baseTextTransform;\n\n      // dragger for the textbox: if there's an arrow, just drag the\n      // textbox and tail, leave the head untouched\n      dragElement.init({\n        element: annTextGroupInner.node(),\n        gd: gd,\n        prepFn: function () {\n          baseTextTransform = annTextGroup.attr('transform');\n        },\n        moveFn: function (dx, dy) {\n          var csr = 'pointer';\n          if (options.showarrow) {\n            // for these 2 calls to shiftPosition, it is assumed xa, ya are\n            // defined, so gsDim will not be used, but we put it in\n            // anyways for consistency\n            if (options.axref === options.xref) {\n              modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n            } else {\n              modifyItem('ax', options.ax + dx);\n            }\n            if (options.ayref === options.yref) {\n              modifyItem('ay', shiftPosition(ya, dy, 'ay', gs.w, options));\n            } else {\n              modifyItem('ay', options.ay + dy);\n            }\n            drawArrow(dx, dy);\n          } else if (!subplotId) {\n            var xUpdate, yUpdate;\n            if (xa) {\n              // shiftPosition will not execute code where xa was\n              // undefined, so we use to calculate xUpdate too\n              xUpdate = shiftPosition(xa, dx, 'x', gs, options);\n            } else {\n              var widthFraction = options._xsize / gs.w;\n              var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n              xUpdate = dragElement.align(xLeft + dx / gs.w, widthFraction, 0, 1, options.xanchor);\n            }\n            if (ya) {\n              // shiftPosition will not execute code where ya was\n              // undefined, so we use to calculate yUpdate too\n              yUpdate = shiftPosition(ya, dy, 'y', gs, options);\n            } else {\n              var heightFraction = options._ysize / gs.h;\n              var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n              yUpdate = dragElement.align(yBottom - dy / gs.h, heightFraction, 0, 1, options.yanchor);\n            }\n            modifyItem('x', xUpdate);\n            modifyItem('y', yUpdate);\n            if (!xa || !ya) {\n              csr = dragElement.getCursor(xa ? 0.5 : xUpdate, ya ? 0.5 : yUpdate, options.xanchor, options.yanchor);\n            }\n          } else return;\n          annTextGroup.attr({\n            transform: strTranslate(dx, dy) + baseTextTransform\n          });\n          setCursor(annTextGroupInner, csr);\n        },\n        clickFn: function (_, initialEvent) {\n          if (options.captureevents) {\n            gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n          }\n        },\n        doneFn: function () {\n          setCursor(annTextGroupInner);\n          Registry.call('_guiRelayout', gd, getUpdateObj());\n          var notesBox = document.querySelector('.js-notes-box-panel');\n          if (notesBox) notesBox.redraw(notesBox.selectedObj);\n        }\n      });\n    }\n  }\n  if (edits.annotationText) {\n    annText.call(svgTextUtils.makeEditable, {\n      delegate: annTextGroupInner,\n      gd: gd\n    }).call(textLayout).on('edit', function (_text) {\n      options.text = _text;\n      this.call(textLayout);\n      modifyItem('text', _text);\n      if (xa && xa.autorange) {\n        modifyBase(xa._name + '.autorange', true);\n      }\n      if (ya && ya.autorange) {\n        modifyBase(ya._name + '.autorange', true);\n      }\n      Registry.call('_guiRelayout', gd, getUpdateObj());\n    });\n  } else annText.call(textLayout);\n}","map":{"version":3,"names":["d3","require","Registry","Plots","Lib","strTranslate","Axes","Color","Drawing","Fx","svgTextUtils","setCursor","dragElement","arrayEditor","drawArrowHead","module","exports","draw","drawOne","drawRaw","gd","fullLayout","_fullLayout","_infolayer","selectAll","remove","i","annotations","length","visible","previousPromises","index","options","xa","getFromId","xref","ya","yref","setScale","shiftPosition","axa","dAx","axLetter","gs","optAx","axRef","vertical","indexOf","axDomainRef","getRefType","gsDim","h","w","_length","p2r","r2p","subplotId","_size","edits","_context","className","containerStr","editHelpers","layout","modifyBase","modifyItem","getUpdateObj","annClipID","_uid","_input","annPosPx","x","y","textangle","annGroup","append","classed","attr","String","style","opacity","annTextGroup","editTextPosition","showarrow","textEvents","captureevents","annotationText","makeEventData","initialEvent","eventData","annotation","fullAnnotation","event","annTextGroupInner","call","on","_dragging","emit","hovertext","hoverOptions","hoverlabel","hoverFont","font","bBox","getBoundingClientRect","bBoxRef","loneHover","x0","left","x1","right","top","bottom","text","color","bgcolor","borderColor","bordercolor","fontFamily","family","fontSize","size","fontColor","fontWeight","weight","fontStyle","fontVariant","variant","fontShadow","fontLineposition","fontTextcase","container","_hoverlayer","node","outerContainer","_paper","loneUnhover","borderwidth","borderpad","borderfull","annTextBG","stroke","fill","isSizeConstrained","width","height","annTextClip","_topclips","data","enter","exit","_meta","templateString","annText","textLayout","s","align","convertToTspans","drawGraphicalElements","anchor3","wholeLink","insert","cursor","appendChild","mathjaxGroup","select","hasMathjax","empty","anntextBB","textWidth","textHeight","annWidth","annHeight","outerWidth","Math","round","outerHeight","shiftFraction","v","anchor","center","middle","annotationIsOffscreen","letters","tailRef","ax","dimAngle","PI","annSizeFromWidth","cos","annSizeFromHeight","sin","annSize","abs","overallShift","posPx","basePx","textPadShift","alignPosition","autoAlignFraction","textShift","axRefType","posFraction","r2fraction","_offset","axRefTypeEqDomain","l","t","head","arrowLength","xanchor","yanchor","tailRefType","tail","maxPx","constrain","shiftPlus","max","shiftMinus","min","xShift","yShift","valign","setClipUrl","texty","textx","positionText","setRect","setTranslate","transform","drawArrow","dx","dy","headX","headY","tailX","tailY","textX","textY","rotationXYMatrix","applyTransform","apply2DTransform","applyTransform2","apply2DTransform2","xLeft","xRight","yTop","yBottom","edges","map","reduce","a","segmentsIntersect","forEach","p","strokewidth","arrowwidth","arrowColor","arrowcolor","arrowSide","arrowside","arrowGroup","arrow","rgb","annotationPosition","parentNode","arrowDragHeadX","arrowDragHeadY","standoff","sqrt","pow","arrowDrag","d","annx0","anny0","init","element","prepFn","pos","getTranslate","autorange","_name","moveFn","annxy0","xcenter","ycenter","axref","ayref","doneFn","notesBox","document","querySelector","redraw","selectedObj","baseTextTransform","csr","ay","xUpdate","yUpdate","widthFraction","_xsize","_xshift","xshift","heightFraction","_ysize","_yshift","yshift","getCursor","clickFn","_","makeEditable","delegate","_text"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/annotations/draw.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Fx = require('../fx');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head');\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    drawRaw: drawRaw\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    fullLayout._infolayer.selectAll('.annotation').remove();\n\n    for(var i = 0; i < fullLayout.annotations.length; i++) {\n        if(fullLayout.annotations[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n    var fullLayout = gd._fullLayout;\n    var options = fullLayout.annotations[index] || {};\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n\n    if(xa) xa.setScale();\n    if(ya) ya.setScale();\n\n    drawRaw(gd, options, index, false, xa, ya);\n}\n\n// Convert pixels to the coordinates relevant for the axis referred to. For\n// example, for paper it would convert to a value normalized by the dimension of\n// the plot.\n// axDomainRef: if true and axa defined, draws relative to axis domain,\n// otherwise draws relative to data (if axa defined) or paper (if not).\nfunction shiftPosition(axa, dAx, axLetter, gs, options) {\n    var optAx = options[axLetter];\n    var axRef = options[axLetter + 'ref'];\n    var vertical = axLetter.indexOf('y') !== -1;\n    var axDomainRef = Axes.getRefType(axRef) === 'domain';\n    var gsDim = vertical ? gs.h : gs.w;\n    if(axa) {\n        if(axDomainRef) {\n            // here optAx normalized to length of axis (e.g., normally in range\n            // 0 to 1). But dAx is in pixels. So we normalize dAx to length of\n            // axis before doing the math.\n            return optAx + (vertical ? -dAx : dAx) / axa._length;\n        } else {\n            return axa.p2r(axa.r2p(optAx) + dAx);\n        }\n    } else {\n        return optAx + (vertical ? -dAx : dAx) / gsDim;\n    }\n}\n\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n    var fullLayout = gd._fullLayout;\n    var gs = gd._fullLayout._size;\n    var edits = gd._context.edits;\n\n    var className, containerStr;\n\n    if(subplotId) {\n        className = 'annotation-' + subplotId;\n        containerStr = subplotId + '.annotations';\n    } else {\n        className = 'annotation';\n        containerStr = 'annotations';\n    }\n\n    var editHelpers = arrayEditor(gd.layout, containerStr, options);\n    var modifyBase = editHelpers.modifyBase;\n    var modifyItem = editHelpers.modifyItem;\n    var getUpdateObj = editHelpers.getUpdateObj;\n\n    // remove the existing annotation if there is one\n    fullLayout._infolayer\n        .selectAll('.' + className + '[data-index=\"' + index + '\"]')\n        .remove();\n\n    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n    // this annotation is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) {\n        d3.selectAll('#' + annClipID).remove();\n        return;\n    }\n\n    // calculated pixel positions\n    // x & y each will get text, head, and tail as appropriate\n    var annPosPx = {x: {}, y: {}};\n    var textangle = +options.textangle || 0;\n\n    // create the components\n    // made a single group to contain all, so opacity can work right\n    // with border/arrow together this could handle a whole bunch of\n    // cleanup at this point, but works for now\n    var annGroup = fullLayout._infolayer.append('g')\n        .classed(className, true)\n        .attr('data-index', String(index))\n        .style('opacity', options.opacity);\n\n    // another group for text+background so that they can rotate together\n    var annTextGroup = annGroup.append('g')\n        .classed('annotation-text-g', true);\n\n    var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n    var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n    function makeEventData(initialEvent) {\n        var eventData = {\n            index: index,\n            annotation: options._input,\n            fullAnnotation: options,\n            event: initialEvent\n        };\n        if(subplotId) {\n            eventData.subplotId = subplotId;\n        }\n        return eventData;\n    }\n\n    var annTextGroupInner = annTextGroup.append('g')\n        .style('pointer-events', textEvents ? 'all' : null)\n        .call(setCursor, 'pointer')\n        .on('click', function() {\n            gd._dragging = false;\n            gd.emit('plotly_clickannotation', makeEventData(d3.event));\n        });\n\n    if(options.hovertext) {\n        annTextGroupInner\n        .on('mouseover', function() {\n            var hoverOptions = options.hoverlabel;\n            var hoverFont = hoverOptions.font;\n            var bBox = this.getBoundingClientRect();\n            var bBoxRef = gd.getBoundingClientRect();\n\n            Fx.loneHover({\n                x0: bBox.left - bBoxRef.left,\n                x1: bBox.right - bBoxRef.left,\n                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n                text: options.hovertext,\n                color: hoverOptions.bgcolor,\n                borderColor: hoverOptions.bordercolor,\n                fontFamily: hoverFont.family,\n                fontSize: hoverFont.size,\n                fontColor: hoverFont.color,\n                fontWeight: hoverFont.weight,\n                fontStyle: hoverFont.style,\n                fontVariant: hoverFont.variant,\n                fontShadow: hoverFont.fontShadow,\n                fontLineposition: hoverFont.fontLineposition,\n                fontTextcase: hoverFont.fontTextcase,\n            }, {\n                container: fullLayout._hoverlayer.node(),\n                outerContainer: fullLayout._paper.node(),\n                gd: gd\n            });\n        })\n        .on('mouseout', function() {\n            Fx.loneUnhover(fullLayout._hoverlayer.node());\n        });\n    }\n\n    var borderwidth = options.borderwidth;\n    var borderpad = options.borderpad;\n    var borderfull = borderwidth + borderpad;\n\n    var annTextBG = annTextGroupInner.append('rect')\n        .attr('class', 'bg')\n        .style('stroke-width', borderwidth + 'px')\n        .call(Color.stroke, options.bordercolor)\n        .call(Color.fill, options.bgcolor);\n\n    var isSizeConstrained = options.width || options.height;\n\n    var annTextClip = fullLayout._topclips\n        .selectAll('#' + annClipID)\n        .data(isSizeConstrained ? [0] : []);\n\n    annTextClip.enter().append('clipPath')\n        .classed('annclip', true)\n        .attr('id', annClipID)\n      .append('rect');\n    annTextClip.exit().remove();\n\n    var font = options.font;\n\n    var text = fullLayout._meta ?\n        Lib.templateString(options.text, fullLayout._meta) :\n        options.text;\n\n    var annText = annTextGroupInner.append('text')\n        .classed('annotation-text', true)\n        .text(text);\n\n    function textLayout(s) {\n        s.call(Drawing.font, font)\n        .attr({\n            'text-anchor': {\n                left: 'start',\n                right: 'end'\n            }[options.align] || 'middle'\n        });\n\n        svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n        return s;\n    }\n\n    function drawGraphicalElements() {\n        // if the text has *only* a link, make the whole box into a link\n        var anchor3 = annText.selectAll('a');\n        if(anchor3.size() === 1 && anchor3.text() === annText.text()) {\n            var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n                'xlink:xlink:href': anchor3.attr('xlink:href'),\n                'xlink:xlink:show': anchor3.attr('xlink:show')\n            })\n            .style({cursor: 'pointer'});\n\n            wholeLink.node().appendChild(annTextBG.node());\n        }\n\n        var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n        var hasMathjax = !mathjaxGroup.empty();\n        var anntextBB = Drawing.bBox(\n                (hasMathjax ? mathjaxGroup : annText).node());\n        var textWidth = anntextBB.width;\n        var textHeight = anntextBB.height;\n        var annWidth = options.width || textWidth;\n        var annHeight = options.height || textHeight;\n        var outerWidth = Math.round(annWidth + 2 * borderfull);\n        var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n        function shiftFraction(v, anchor) {\n            if(anchor === 'auto') {\n                if(v < 1 / 3) anchor = 'left';\n                else if(v > 2 / 3) anchor = 'right';\n                else anchor = 'center';\n            }\n            return {\n                center: 0,\n                middle: 0,\n                left: 0.5,\n                bottom: -0.5,\n                right: -0.5,\n                top: 0.5\n            }[anchor];\n        }\n\n        var annotationIsOffscreen = false;\n        var letters = ['x', 'y'];\n\n        for(var i = 0; i < letters.length; i++) {\n            var axLetter = letters[i];\n            var axRef = options[axLetter + 'ref'] || axLetter;\n            var tailRef = options['a' + axLetter + 'ref'];\n            var ax = {x: xa, y: ya}[axLetter];\n            var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;\n            // note that these two can be either positive or negative\n            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);\n            // but this one is the positive total size\n            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n            var anchor = options[axLetter + 'anchor'];\n            var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n            var posPx = annPosPx[axLetter];\n            var basePx;\n            var textPadShift;\n            var alignPosition;\n            var autoAlignFraction;\n            var textShift;\n            var axRefType = Axes.getRefType(axRef);\n\n            /*\n             * calculate the *primary* pixel position\n             * which is the arrowhead if there is one,\n             * otherwise the text anchor point\n             */\n            if(ax && (axRefType !== 'domain')) {\n                // check if annotation is off screen, to bypass DOM manipulations\n                var posFraction = ax.r2fraction(options[axLetter]);\n                if(posFraction < 0 || posFraction > 1) {\n                    if(tailRef === axRef) {\n                        posFraction = ax.r2fraction(options['a' + axLetter]);\n                        if(posFraction < 0 || posFraction > 1) {\n                            annotationIsOffscreen = true;\n                        }\n                    } else {\n                        annotationIsOffscreen = true;\n                    }\n                }\n                basePx = ax._offset + ax.r2p(options[axLetter]);\n                autoAlignFraction = 0.5;\n            } else {\n                var axRefTypeEqDomain = axRefType === 'domain';\n                if(axLetter === 'x') {\n                    alignPosition = options[axLetter];\n                    basePx = axRefTypeEqDomain ?\n                        ax._offset + ax._length * alignPosition :\n                        basePx = gs.l + gs.w * alignPosition;\n                } else {\n                    alignPosition = 1 - options[axLetter];\n                    basePx = axRefTypeEqDomain ?\n                        ax._offset + ax._length * alignPosition :\n                        basePx = gs.t + gs.h * alignPosition;\n                }\n                autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n            }\n\n            // now translate this into pixel positions of head, tail, and text\n            // as well as paddings for autorange\n            if(options.showarrow) {\n                posPx.head = basePx;\n\n                var arrowLength = options['a' + axLetter];\n\n                // with an arrow, the text rotates around the anchor point\n                textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) -\n                    annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n                if(tailRef === axRef) {\n                    // In the case tailRefType is 'domain' or 'paper', the arrow's\n                    // position is set absolutely, which is consistent with how\n                    // it behaves when its position is set in data ('range')\n                    // coordinates.\n                    var tailRefType = Axes.getRefType(tailRef);\n                    if(tailRefType === 'domain') {\n                        if(axLetter === 'y') {\n                            arrowLength = 1 - arrowLength;\n                        }\n                        posPx.tail = ax._offset + ax._length * arrowLength;\n                    } else if(tailRefType === 'paper') {\n                        if(axLetter === 'y') {\n                            arrowLength = 1 - arrowLength;\n                            posPx.tail = gs.t + gs.h * arrowLength;\n                        } else {\n                            posPx.tail = gs.l + gs.w * arrowLength;\n                        }\n                    } else {\n                        // assumed tailRef is range or paper referenced\n                        posPx.tail = ax._offset + ax.r2p(arrowLength);\n                    }\n                    // tail is range- or domain-referenced: autorange pads the\n                    // text in px from the tail\n                    textPadShift = textShift;\n                } else {\n                    posPx.tail = basePx + arrowLength;\n                    // tail is specified in px from head, so autorange also pads vs head\n                    textPadShift = textShift + arrowLength;\n                }\n\n                posPx.text = posPx.tail + textShift;\n\n                // constrain pixel/paper referenced so the draggers are at least\n                // partially visible\n                var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];\n                if(axRef === 'paper') {\n                    posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n                }\n                if(tailRef === 'pixel') {\n                    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n                    var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n                    if(shiftPlus > 0) {\n                        posPx.tail += shiftPlus;\n                        posPx.text += shiftPlus;\n                    } else if(shiftMinus > 0) {\n                        posPx.tail -= shiftMinus;\n                        posPx.text -= shiftMinus;\n                    }\n                }\n\n                posPx.tail += overallShift;\n                posPx.head += overallShift;\n            } else {\n                // with no arrow, the text rotates and *then* we put the anchor\n                // relative to the new bounding box\n                textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n                textPadShift = textShift;\n                posPx.text = basePx + textShift;\n            }\n\n            posPx.text += overallShift;\n            textShift += overallShift;\n            textPadShift += overallShift;\n\n            // padplus/minus are used by autorange\n            options['_' + axLetter + 'padplus'] = (annSize / 2) + textPadShift;\n            options['_' + axLetter + 'padminus'] = (annSize / 2) - textPadShift;\n\n            // size/shift are used during dragging\n            options['_' + axLetter + 'size'] = annSize;\n            options['_' + axLetter + 'shift'] = textShift;\n        }\n\n        if(annotationIsOffscreen) {\n            annTextGroupInner.remove();\n            return;\n        }\n\n        var xShift = 0;\n        var yShift = 0;\n\n        if(options.align !== 'left') {\n            xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n        }\n        if(options.valign !== 'top') {\n            yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n        }\n\n        if(hasMathjax) {\n            mathjaxGroup.select('svg').attr({\n                x: borderfull + xShift - 1,\n                y: borderfull + yShift\n            })\n            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        } else {\n            var texty = borderfull + yShift - anntextBB.top;\n            var textx = borderfull + xShift - anntextBB.left;\n\n            annText.call(svgTextUtils.positionText, textx, texty)\n                .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        }\n\n        annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull,\n            annWidth, annHeight);\n\n        annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,\n            outerWidth - borderwidth, outerHeight - borderwidth);\n\n        annTextGroupInner.call(Drawing.setTranslate,\n            Math.round(annPosPx.x.text - outerWidth / 2),\n            Math.round(annPosPx.y.text - outerHeight / 2));\n\n        /*\n         * rotate text and background\n         * we already calculated the text center position *as rotated*\n         * because we needed that for autoranging anyway, so now whether\n         * we have an arrow or not, we rotate about the text center.\n         */\n        annTextGroup.attr({transform: 'rotate(' + textangle + ',' +\n                            annPosPx.x.text + ',' + annPosPx.y.text + ')'});\n\n        /*\n         * add the arrow\n         * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n         * dx and dy are normally zero, but when you are dragging the textbox\n         * while the head stays put, dx and dy are the pixel offsets\n         */\n        var drawArrow = function(dx, dy) {\n            annGroup\n                .selectAll('.annotation-arrow-g')\n                .remove();\n\n            var headX = annPosPx.x.head;\n            var headY = annPosPx.y.head;\n            var tailX = annPosPx.x.tail + dx;\n            var tailY = annPosPx.y.tail + dy;\n            var textX = annPosPx.x.text + dx;\n            var textY = annPosPx.y.text + dy;\n\n            // find the edge of the text box, where we'll start the arrow:\n            // create transform matrix to rotate the text box corners\n            var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n            var applyTransform = Lib.apply2DTransform(transform);\n            var applyTransform2 = Lib.apply2DTransform2(transform);\n\n            // calculate and transform bounding box\n            var width = +annTextBG.attr('width');\n            var height = +annTextBG.attr('height');\n            var xLeft = textX - 0.5 * width;\n            var xRight = xLeft + width;\n            var yTop = textY - 0.5 * height;\n            var yBottom = yTop + height;\n            var edges = [\n                [xLeft, yTop, xLeft, yBottom],\n                [xLeft, yBottom, xRight, yBottom],\n                [xRight, yBottom, xRight, yTop],\n                [xRight, yTop, xLeft, yTop]\n            ].map(applyTransform2);\n\n            // Remove the line if it ends inside the box.  Use ray\n            // casting for rotated boxes: see which edges intersect a\n            // line from the arrowhead to far away and reduce with xor\n            // to get the parity of the number of intersections.\n            if(edges.reduce(function(a, x) {\n                return a ^\n                    !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6,\n                            x[0], x[1], x[2], x[3]);\n            }, false)) {\n                // no line or arrow - so quit drawArrow now\n                return;\n            }\n\n            edges.forEach(function(x) {\n                var p = Lib.segmentsIntersect(tailX, tailY, headX, headY,\n                            x[0], x[1], x[2], x[3]);\n                if(p) {\n                    tailX = p.x;\n                    tailY = p.y;\n                }\n            });\n\n            var strokewidth = options.arrowwidth;\n            var arrowColor = options.arrowcolor;\n            var arrowSide = options.arrowside;\n\n            var arrowGroup = annGroup.append('g')\n                .style({opacity: Color.opacity(arrowColor)})\n                .classed('annotation-arrow-g', true);\n\n            var arrow = arrowGroup.append('path')\n                .attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY)\n                .style('stroke-width', strokewidth + 'px')\n                .call(Color.stroke, Color.rgb(arrowColor));\n\n            drawArrowHead(arrow, arrowSide, options);\n\n            // the arrow dragger is a small square right at the head, then a line to the tail,\n            // all expanded by a stroke width of 6px plus the arrow line width\n            if(edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n                var arrowDragHeadX = headX;\n                var arrowDragHeadY = headY;\n                if(options.standoff) {\n                    var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n                    arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n                    arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n                }\n                var arrowDrag = arrowGroup.append('path')\n                    .classed('annotation-arrow', true)\n                    .classed('anndrag', true)\n                    .classed('cursor-move', true)\n                    .attr({\n                        d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n                        transform: strTranslate(arrowDragHeadX, arrowDragHeadY)\n                    })\n                    .style('stroke-width', (strokewidth + 6) + 'px')\n                    .call(Color.stroke, 'rgba(0,0,0,0)')\n                    .call(Color.fill, 'rgba(0,0,0,0)');\n\n                var annx0, anny0;\n\n                // dragger for the arrow & head: translates the whole thing\n                // (head/tail/text) all together\n                dragElement.init({\n                    element: arrowDrag.node(),\n                    gd: gd,\n                    prepFn: function() {\n                        var pos = Drawing.getTranslate(annTextGroupInner);\n\n                        annx0 = pos.x;\n                        anny0 = pos.y;\n                        if(xa && xa.autorange) {\n                            modifyBase(xa._name + '.autorange', true);\n                        }\n                        if(ya && ya.autorange) {\n                            modifyBase(ya._name + '.autorange', true);\n                        }\n                    },\n                    moveFn: function(dx, dy) {\n                        var annxy0 = applyTransform(annx0, anny0);\n                        var xcenter = annxy0[0] + dx;\n                        var ycenter = annxy0[1] + dy;\n                        annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n\n                        modifyItem('x',\n                            shiftPosition(xa, dx, 'x', gs, options));\n                        modifyItem('y',\n                            shiftPosition(ya, dy, 'y', gs, options));\n\n                        // for these 2 calls to shiftPosition, it is assumed xa, ya are\n                        // defined, so gsDim will not be used, but we put it in\n                        // anyways for consistency\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', shiftPosition(ya, dy, 'ay', gs, options));\n                        }\n\n                        arrowGroup.attr('transform', strTranslate(dx, dy));\n                        annTextGroup.attr({\n                            transform: 'rotate(' + textangle + ',' +\n                                   xcenter + ',' + ycenter + ')'\n                        });\n                    },\n                    doneFn: function() {\n                        Registry.call('_guiRelayout', gd, getUpdateObj());\n                        var notesBox = document.querySelector('.js-notes-box-panel');\n                        if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                    }\n                });\n            }\n        };\n\n        if(options.showarrow) drawArrow(0, 0);\n\n        // user dragging the annotation (text, not arrow)\n        if(editTextPosition) {\n            var baseTextTransform;\n\n            // dragger for the textbox: if there's an arrow, just drag the\n            // textbox and tail, leave the head untouched\n            dragElement.init({\n                element: annTextGroupInner.node(),\n                gd: gd,\n                prepFn: function() {\n                    baseTextTransform = annTextGroup.attr('transform');\n                },\n                moveFn: function(dx, dy) {\n                    var csr = 'pointer';\n                    if(options.showarrow) {\n                        // for these 2 calls to shiftPosition, it is assumed xa, ya are\n                        // defined, so gsDim will not be used, but we put it in\n                        // anyways for consistency\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n                        } else {\n                            modifyItem('ax', options.ax + dx);\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', shiftPosition(ya, dy, 'ay', gs.w, options));\n                        } else {\n                            modifyItem('ay', options.ay + dy);\n                        }\n\n                        drawArrow(dx, dy);\n                    } else if(!subplotId) {\n                        var xUpdate, yUpdate;\n                        if(xa) {\n                            // shiftPosition will not execute code where xa was\n                            // undefined, so we use to calculate xUpdate too\n                            xUpdate = shiftPosition(xa, dx, 'x', gs, options);\n                        } else {\n                            var widthFraction = options._xsize / gs.w;\n                            var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n\n                            xUpdate = dragElement.align(xLeft + dx / gs.w,\n                                widthFraction, 0, 1, options.xanchor);\n                        }\n\n                        if(ya) {\n                            // shiftPosition will not execute code where ya was\n                            // undefined, so we use to calculate yUpdate too\n                            yUpdate = shiftPosition(ya, dy, 'y', gs, options);\n                        } else {\n                            var heightFraction = options._ysize / gs.h;\n                            var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n\n                            yUpdate = dragElement.align(yBottom - dy / gs.h,\n                                heightFraction, 0, 1, options.yanchor);\n                        }\n                        modifyItem('x', xUpdate);\n                        modifyItem('y', yUpdate);\n                        if(!xa || !ya) {\n                            csr = dragElement.getCursor(\n                                xa ? 0.5 : xUpdate,\n                                ya ? 0.5 : yUpdate,\n                                options.xanchor, options.yanchor\n                            );\n                        }\n                    } else return;\n\n                    annTextGroup.attr({\n                        transform: strTranslate(dx, dy) + baseTextTransform\n                    });\n\n                    setCursor(annTextGroupInner, csr);\n                },\n                clickFn: function(_, initialEvent) {\n                    if(options.captureevents) {\n                        gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n                    }\n                },\n                doneFn: function() {\n                    setCursor(annTextGroupInner);\n                    Registry.call('_guiRelayout', gd, getUpdateObj());\n                    var notesBox = document.querySelector('.js-notes-box-panel');\n                    if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                }\n            });\n        }\n    }\n\n    if(edits.annotationText) {\n        annText.call(svgTextUtils.makeEditable, {delegate: annTextGroupInner, gd: gd})\n            .call(textLayout)\n            .on('edit', function(_text) {\n                options.text = _text;\n\n                this.call(textLayout);\n\n                modifyItem('text', _text);\n\n                if(xa && xa.autorange) {\n                    modifyBase(xa._name + '.autorange', true);\n                }\n                if(ya && ya.autorange) {\n                    modifyBase(ya._name + '.autorange', true);\n                }\n\n                Registry.call('_guiRelayout', gd, getUpdateObj());\n            });\n    } else annText.call(textLayout);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}