{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar binFunctions = require('./bin_functions');\nvar normFunctions = require('./norm_functions');\nvar doAvg = require('./average');\nvar getBinSpanLabelRound = require('./bin_label_vals');\nfunction calc(gd, trace) {\n  var pos = [];\n  var size = [];\n  var isHorizontal = trace.orientation === 'h';\n  var pa = Axes.getFromId(gd, isHorizontal ? trace.yaxis : trace.xaxis);\n  var mainData = isHorizontal ? 'y' : 'x';\n  var counterData = {\n    x: 'y',\n    y: 'x'\n  }[mainData];\n  var calendar = trace[mainData + 'calendar'];\n  var cumulativeSpec = trace.cumulative;\n  var i;\n  var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n  var binSpec = binsAndPos[0];\n  var pos0 = binsAndPos[1];\n  var nonuniformBins = typeof binSpec.size === 'string';\n  var binEdges = [];\n  var bins = nonuniformBins ? binEdges : binSpec;\n  // make the empty bin array\n  var inc = [];\n  var counts = [];\n  var inputPoints = [];\n  var total = 0;\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densityNorm = norm.indexOf('density') !== -1;\n  var i2, binEnd, n;\n  if (cumulativeSpec.enabled && densityNorm) {\n    // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n    // which in the end means it's the same as without \"density\"\n    norm = norm.replace(/ ?density$/, '');\n    densityNorm = false;\n  }\n  var extremeFunc = func === 'max' || func === 'min';\n  var sizeInit = extremeFunc ? null : 0;\n  var binFunc = binFunctions.count;\n  var normFunc = normFunctions[norm];\n  var isAvg = false;\n  var pr2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n  var rawCounterData;\n  if (Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n    rawCounterData = trace[counterData];\n    isAvg = func === 'avg';\n    binFunc = binFunctions[func];\n  }\n\n  // create the bins (and any extra arrays needed)\n  // assume more than 1e6 bins is an error, so we don't crash the browser\n  i = pr2c(binSpec.start);\n\n  // decrease end a little in case of rounding errors\n  binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n  while (i < binEnd && pos.length < 1e6) {\n    i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n    pos.push((i + i2) / 2);\n    size.push(sizeInit);\n    inputPoints.push([]);\n    // nonuniform bins (like months) we need to search,\n    // rather than straight calculate the bin we're in\n    binEdges.push(i);\n    // nonuniform bins also need nonuniform normalization factors\n    if (densityNorm) inc.push(1 / (i2 - i));\n    if (isAvg) counts.push(0);\n    // break to avoid infinite loops\n    if (i2 <= i) break;\n    i = i2;\n  }\n  binEdges.push(i);\n\n  // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n  if (!nonuniformBins && pa.type === 'date') {\n    bins = {\n      start: pr2c(bins.start),\n      end: pr2c(bins.end),\n      size: bins.size\n    };\n  }\n\n  // stash left and right gaps by group\n  if (!gd._fullLayout._roundFnOpts) gd._fullLayout._roundFnOpts = {};\n  var groupName = trace['_' + mainData + 'bingroup'];\n  var roundFnOpts = {\n    leftGap: Infinity,\n    rightGap: Infinity\n  };\n  if (groupName) {\n    if (!gd._fullLayout._roundFnOpts[groupName]) gd._fullLayout._roundFnOpts[groupName] = roundFnOpts;\n    roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n  }\n\n  // bin the data\n  // and make histogram-specific pt-number-to-cd-index map object\n  var nMax = size.length;\n  var uniqueValsPerBin = true;\n  var leftGap = roundFnOpts.leftGap;\n  var rightGap = roundFnOpts.rightGap;\n  var ptNumber2cdIndex = {};\n  for (i = 0; i < pos0.length; i++) {\n    var posi = pos0[i];\n    n = Lib.findBin(posi, bins);\n    if (n >= 0 && n < nMax) {\n      total += binFunc(n, i, size, rawCounterData, counts);\n      if (uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n        uniqueValsPerBin = false;\n      }\n      inputPoints[n].push(i);\n      ptNumber2cdIndex[i] = n;\n      leftGap = Math.min(leftGap, posi - binEdges[n]);\n      rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n    }\n  }\n  roundFnOpts.leftGap = leftGap;\n  roundFnOpts.rightGap = rightGap;\n  var roundFn;\n  if (!uniqueValsPerBin) {\n    roundFn = function (v, isRightEdge) {\n      return function () {\n        var roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n        return getBinSpanLabelRound(roundFnOpts.leftGap, roundFnOpts.rightGap, binEdges, pa, calendar)(v, isRightEdge);\n      };\n    };\n  }\n\n  // average and/or normalize the data, if needed\n  if (isAvg) total = doAvg(size, counts);\n  if (normFunc) normFunc(size, total, inc);\n\n  // after all normalization etc, now we can accumulate if desired\n  if (cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n  var seriesLen = Math.min(pos.length, size.length);\n  var cd = [];\n  var firstNonzero = 0;\n  var lastNonzero = seriesLen - 1;\n\n  // look for empty bins at the ends to remove, so autoscale omits them\n  for (i = 0; i < seriesLen; i++) {\n    if (size[i]) {\n      firstNonzero = i;\n      break;\n    }\n  }\n  for (i = seriesLen - 1; i >= firstNonzero; i--) {\n    if (size[i]) {\n      lastNonzero = i;\n      break;\n    }\n  }\n\n  // create the \"calculated data\" to plot\n  for (i = firstNonzero; i <= lastNonzero; i++) {\n    if (isNumeric(pos[i]) && isNumeric(size[i])) {\n      var cdi = {\n        p: pos[i],\n        s: size[i],\n        b: 0\n      };\n\n      // setup hover and event data fields,\n      // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n      // for cumulative distributions\n      if (!cumulativeSpec.enabled) {\n        cdi.pts = inputPoints[i];\n        if (uniqueValsPerBin) {\n          cdi.ph0 = cdi.ph1 = inputPoints[i].length ? pos0[inputPoints[i][0]] : pos[i];\n        } else {\n          // Defer evaluation of ph(0|1) in crossTraceCalc\n          trace._computePh = true;\n          cdi.ph0 = roundFn(binEdges[i]);\n          cdi.ph1 = roundFn(binEdges[i + 1], true);\n        }\n      }\n      cd.push(cdi);\n    }\n  }\n  if (cd.length === 1) {\n    // when we collapse to a single bin, calcdata no longer describes bin size\n    // so we need to explicitly specify it\n    cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n  }\n  arraysToCalcdata(cd, trace);\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n  }\n  return cd;\n}\n\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n  var binAttr = mainData + 'bins';\n  var fullLayout = gd._fullLayout;\n  var groupName = trace['_' + mainData + 'bingroup'];\n  var binOpts = fullLayout._histogramBinOpts[groupName];\n  var isOverlay = fullLayout.barmode === 'overlay';\n  var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n  var r2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n  var c2r = function (v) {\n    return pa.c2r(v, 0, calendar);\n  };\n  var cleanBound = pa.type === 'date' ? function (v) {\n    return v || v === 0 ? Lib.cleanDate(v, null, calendar) : null;\n  } : function (v) {\n    return isNumeric(v) ? Number(v) : null;\n  };\n  function setBound(attr, bins, newBins) {\n    if (bins[attr + 'Found']) {\n      bins[attr] = cleanBound(bins[attr]);\n      if (bins[attr] === null) bins[attr] = newBins[attr];\n    } else {\n      autoVals[attr] = bins[attr] = newBins[attr];\n      Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n    }\n  }\n\n  // all but the first trace in this group has already been marked finished\n  // clear this flag, so next time we run calc we will run autobin again\n  if (trace['_' + mainData + 'autoBinFinished']) {\n    delete trace['_' + mainData + 'autoBinFinished'];\n  } else {\n    traces = binOpts.traces;\n    var allPos = [];\n\n    // Note: we're including `legendonly` traces here for autobin purposes,\n    // so that showing & hiding from the legend won't affect bins.\n    // But this complicates things a bit since those traces don't `calc`,\n    // hence `isFirstVisible`.\n    var isFirstVisible = true;\n    var has2dMap = false;\n    var hasHist2dContour = false;\n    for (i = 0; i < traces.length; i++) {\n      tracei = traces[i];\n      if (tracei.visible) {\n        var mainDatai = binOpts.dirs[i];\n        pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n        allPos = Lib.concat(allPos, pos0);\n        delete tracei['_' + mainData + 'autoBinFinished'];\n        if (trace.visible === true) {\n          if (isFirstVisible) {\n            isFirstVisible = false;\n          } else {\n            delete tracei._autoBin;\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n          }\n          if (Registry.traceIs(tracei, '2dMap')) {\n            has2dMap = true;\n          }\n          if (tracei.type === 'histogram2dcontour') {\n            hasHist2dContour = true;\n          }\n        }\n      }\n    }\n    calendar = traces[0][mainData + 'calendar'];\n    var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n    var autoBin = traces[0]._autoBin = {};\n    autoVals = autoBin[binOpts.dirs[0]] = {};\n    if (hasHist2dContour) {\n      // the \"true\" 2nd argument reverses the tick direction (which we can't\n      // just do with a minus sign because of month bins)\n      if (!binOpts.size) {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      }\n      if (binOpts.end === undefined) {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    }\n\n    // Edge case: single-valued histogram overlaying others\n    // Use them all together to calculate the bin size for the single-valued one\n    // Don't re-calculate bin width if user manually specified it (checing in bingroup=='' or xbins is defined)\n    if (isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 && pa.type !== 'category' && pa.type !== 'multicategory' && trace.bingroup === '' && typeof trace.xbins === 'undefined') {\n      // Several single-valued histograms! Stop infinite recursion,\n      // just return an extra flag that tells handleSingleValueOverlays\n      // to sort out this trace too\n      if (_overlayEdgeCase) return [newBinSpec, pos0, true];\n      newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n    }\n\n    // adjust for CDF edge cases\n    cumulativeSpec = tracei.cumulative || {};\n    if (cumulativeSpec.enabled && cumulativeSpec.currentbin !== 'include') {\n      if (cumulativeSpec.direction === 'decreasing') {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      } else {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    }\n    binOpts.size = newBinSpec.size;\n    if (!binOpts.sizeFound) {\n      autoVals.size = newBinSpec.size;\n      Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n    }\n    setBound('start', binOpts, newBinSpec);\n    setBound('end', binOpts, newBinSpec);\n  }\n  pos0 = trace['_' + mainData + 'pos0'];\n  delete trace['_' + mainData + 'pos0'];\n\n  // Each trace can specify its own start/end, or if omitted\n  // we ensure they're beyond the bounds of this trace's data,\n  // and we need to make sure start is aligned with the main start\n  var traceInputBins = trace._input[binAttr] || {};\n  var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n  var mainStart = binOpts.start;\n  var startIn = pa.r2l(traceInputBins.start);\n  var hasStart = startIn !== undefined;\n  if ((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n    // We have an explicit start to reconcile across traces\n    // if this trace has an explicit start, shift it down to a bin edge\n    // if another trace had an explicit start, shift it down to a\n    // bin edge past our data\n    var traceStart = hasStart ? startIn : Lib.aggNums(Math.min, null, pos0);\n    var dummyAx = {\n      type: pa.type === 'category' || pa.type === 'multicategory' ? 'linear' : pa.type,\n      r2l: pa.r2l,\n      dtick: binOpts.size,\n      tick0: mainStart,\n      calendar: calendar,\n      range: [traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)].map(pa.l2r)\n    };\n    var newStart = Axes.tickFirst(dummyAx);\n    if (newStart > pa.r2l(traceStart)) {\n      newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n    }\n    traceBinOptsCalc.start = pa.l2r(newStart);\n    if (!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n  }\n  var mainEnd = binOpts.end;\n  var endIn = pa.r2l(traceInputBins.end);\n  var hasEnd = endIn !== undefined;\n  if ((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n    // Reconciling an explicit end is easier, as it doesn't need to\n    // match bin edges\n    var traceEnd = hasEnd ? endIn : Lib.aggNums(Math.max, null, pos0);\n    traceBinOptsCalc.end = pa.l2r(traceEnd);\n    if (!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n  }\n\n  // Backward compatibility for one-time autobinning.\n  // autobin: true is handled in cleanData, but autobin: false\n  // needs to be here where we have determined the values.\n  var autoBinAttr = 'autobin' + mainData;\n  if (trace._input[autoBinAttr] === false) {\n    trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n    delete trace._input[autoBinAttr];\n    delete trace[autoBinAttr];\n  }\n  return [traceBinOptsCalc, pos0];\n}\n\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n  var fullLayout = gd._fullLayout;\n  var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n  var pastThisTrace = false;\n  var minSize = Infinity;\n  var singleValuedTraces = [trace];\n  var i, tracei, binOpts;\n\n  // first collect all the:\n  // - min bin size from all multi-valued traces\n  // - single-valued traces\n  for (i = 0; i < overlaidTraceGroup.length; i++) {\n    tracei = overlaidTraceGroup[i];\n    if (tracei === trace) {\n      pastThisTrace = true;\n    } else if (!pastThisTrace) {\n      // This trace has already had its autobins calculated, so either:\n      // - it is part of a bingroup\n      // - it is NOT a single-valued trace\n      binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n      minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n    } else {\n      var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n      var binSpeci = resulti[0];\n      var isSingleValued = resulti[2];\n\n      // so we can use this result when we get to tracei in the normal\n      // course of events, mark it as done and put _pos0 back\n      tracei['_' + mainData + 'autoBinFinished'] = 1;\n      tracei['_' + mainData + 'pos0'] = resulti[1];\n      if (isSingleValued) {\n        singleValuedTraces.push(tracei);\n      } else {\n        minSize = Math.min(minSize, binSpeci.size);\n      }\n    }\n  }\n\n  // find the real data values for each single-valued trace\n  // hunt through pos0 for the first valid value\n  var dataVals = new Array(singleValuedTraces.length);\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n    for (var j = 0; j < pos0.length; j++) {\n      if (pos0[j] !== undefined) {\n        dataVals[i] = pos0[j];\n        break;\n      }\n    }\n  }\n\n  // are ALL traces are single-valued? use the min difference between\n  // all of their values (which defaults to 1 if there's still only one)\n  if (!isFinite(minSize)) {\n    minSize = Lib.distinctVals(dataVals).minDiff;\n  }\n\n  // now apply the min size we found to all single-valued traces\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    tracei = singleValuedTraces[i];\n    var calendar = tracei[mainData + 'calendar'];\n    var newBins = {\n      start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n      end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n      size: minSize\n    };\n    tracei._input[binAttr] = tracei[binAttr] = newBins;\n    binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n    if (binOpts) Lib.extendFlat(binOpts, newBins);\n  }\n  return trace[binAttr];\n}\n\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\nfunction getConnectedHistograms(gd, trace) {\n  var xid = trace.xaxis;\n  var yid = trace.yaxis;\n  var orientation = trace.orientation;\n  var out = [];\n  var fullData = gd._fullData;\n  for (var i = 0; i < fullData.length; i++) {\n    var tracei = fullData[i];\n    if (tracei.type === 'histogram' && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {\n      out.push(tracei);\n    }\n  }\n  return out;\n}\nfunction cdf(size, direction, currentBin) {\n  var i, vi, prevSum;\n  function firstHalfPoint(i) {\n    prevSum = size[i];\n    size[i] /= 2;\n  }\n  function nextHalfPoint(i) {\n    vi = size[i];\n    size[i] = prevSum + vi / 2;\n    prevSum += vi;\n  }\n  if (currentBin === 'half') {\n    if (direction === 'increasing') {\n      firstHalfPoint(0);\n      for (i = 1; i < size.length; i++) {\n        nextHalfPoint(i);\n      }\n    } else {\n      firstHalfPoint(size.length - 1);\n      for (i = size.length - 2; i >= 0; i--) {\n        nextHalfPoint(i);\n      }\n    }\n  } else if (direction === 'increasing') {\n    for (i = 1; i < size.length; i++) {\n      size[i] += size[i - 1];\n    }\n\n    // 'exclude' is identical to 'include' just shifted one bin over\n    if (currentBin === 'exclude') {\n      size.unshift(0);\n      size.pop();\n    }\n  } else {\n    for (i = size.length - 2; i >= 0; i--) {\n      size[i] += size[i + 1];\n    }\n    if (currentBin === 'exclude') {\n      size.push(0);\n      size.shift();\n    }\n  }\n}\nmodule.exports = {\n  calc: calc,\n  calcAllAutoBins: calcAllAutoBins\n};","map":{"version":3,"names":["isNumeric","require","Lib","Registry","Axes","arraysToCalcdata","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","calc","gd","trace","pos","size","isHorizontal","orientation","pa","getFromId","yaxis","xaxis","mainData","counterData","x","y","calendar","cumulativeSpec","cumulative","i","binsAndPos","calcAllAutoBins","binSpec","pos0","nonuniformBins","binEdges","bins","inc","counts","inputPoints","total","norm","histnorm","func","histfunc","densityNorm","indexOf","i2","binEnd","n","enabled","replace","extremeFunc","sizeInit","binFunc","count","normFunc","isAvg","pr2c","v","r2c","rawCounterData","isArrayOrTypedArray","start","end","tickIncrement","length","push","type","_fullLayout","_roundFnOpts","groupName","roundFnOpts","leftGap","Infinity","rightGap","nMax","uniqueValsPerBin","ptNumber2cdIndex","posi","findBin","Math","min","roundFn","isRightEdge","cdf","direction","currentbin","seriesLen","cd","firstNonzero","lastNonzero","cdi","p","s","b","pts","ph0","ph1","_computePh","width1","selectedpoints","tagSelected","_overlayEdgeCase","binAttr","fullLayout","binOpts","_histogramBinOpts","isOverlay","barmode","traces","tracei","autoVals","c2r","cleanBound","cleanDate","Number","setBound","attr","newBins","nestedProperty","set","allPos","isFirstVisible","has2dMap","hasHist2dContour","visible","mainDatai","dirs","makeCalcdata","concat","_autoBin","traceIs","newBinSpec","autoBin","nbins","sizeFound","undefined","_dataSpan","bingroup","xbins","handleSingleValueOverlays","traceInputBins","_input","traceBinOptsCalc","extendFlat","mainStart","startIn","r2l","hasStart","startFound","traceStart","aggNums","dummyAx","dtick","tick0","range","map","l2r","newStart","tickFirst","mainEnd","endIn","hasEnd","endFound","traceEnd","max","autoBinAttr","overlaidTraceGroup","getConnectedHistograms","pastThisTrace","minSize","singleValuedTraces","resulti","binSpeci","isSingleValued","dataVals","Array","j","isFinite","distinctVals","minDiff","xid","yid","out","fullData","_fullData","currentBin","vi","prevSum","firstHalfPoint","nextHalfPoint","unshift","pop","shift","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/histogram/calc.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar binFunctions = require('./bin_functions');\nvar normFunctions = require('./norm_functions');\nvar doAvg = require('./average');\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nfunction calc(gd, trace) {\n    var pos = [];\n    var size = [];\n    var isHorizontal = trace.orientation === 'h';\n    var pa = Axes.getFromId(gd, isHorizontal ? trace.yaxis : trace.xaxis);\n    var mainData = isHorizontal ? 'y' : 'x';\n    var counterData = {x: 'y', y: 'x'}[mainData];\n    var calendar = trace[mainData + 'calendar'];\n    var cumulativeSpec = trace.cumulative;\n    var i;\n\n    var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n    var binSpec = binsAndPos[0];\n    var pos0 = binsAndPos[1];\n\n    var nonuniformBins = typeof binSpec.size === 'string';\n    var binEdges = [];\n    var bins = nonuniformBins ? binEdges : binSpec;\n    // make the empty bin array\n    var inc = [];\n    var counts = [];\n    var inputPoints = [];\n    var total = 0;\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densityNorm = norm.indexOf('density') !== -1;\n    var i2, binEnd, n;\n\n    if(cumulativeSpec.enabled && densityNorm) {\n        // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n        // which in the end means it's the same as without \"density\"\n        norm = norm.replace(/ ?density$/, '');\n        densityNorm = false;\n    }\n\n    var extremeFunc = func === 'max' || func === 'min';\n    var sizeInit = extremeFunc ? null : 0;\n    var binFunc = binFunctions.count;\n    var normFunc = normFunctions[norm];\n    var isAvg = false;\n    var pr2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var rawCounterData;\n\n    if(Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n        rawCounterData = trace[counterData];\n        isAvg = func === 'avg';\n        binFunc = binFunctions[func];\n    }\n\n    // create the bins (and any extra arrays needed)\n    // assume more than 1e6 bins is an error, so we don't crash the browser\n    i = pr2c(binSpec.start);\n\n    // decrease end a little in case of rounding errors\n    binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n    while(i < binEnd && pos.length < 1e6) {\n        i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n        pos.push((i + i2) / 2);\n        size.push(sizeInit);\n        inputPoints.push([]);\n        // nonuniform bins (like months) we need to search,\n        // rather than straight calculate the bin we're in\n        binEdges.push(i);\n        // nonuniform bins also need nonuniform normalization factors\n        if(densityNorm) inc.push(1 / (i2 - i));\n        if(isAvg) counts.push(0);\n        // break to avoid infinite loops\n        if(i2 <= i) break;\n        i = i2;\n    }\n    binEdges.push(i);\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBins && pa.type === 'date') {\n        bins = {\n            start: pr2c(bins.start),\n            end: pr2c(bins.end),\n            size: bins.size\n        };\n    }\n\n    // stash left and right gaps by group\n    if(!gd._fullLayout._roundFnOpts) gd._fullLayout._roundFnOpts = {};\n    var groupName = trace['_' + mainData + 'bingroup'];\n    var roundFnOpts = {leftGap: Infinity, rightGap: Infinity};\n    if(groupName) {\n        if(!gd._fullLayout._roundFnOpts[groupName]) gd._fullLayout._roundFnOpts[groupName] = roundFnOpts;\n        roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n    }\n\n    // bin the data\n    // and make histogram-specific pt-number-to-cd-index map object\n    var nMax = size.length;\n    var uniqueValsPerBin = true;\n    var leftGap = roundFnOpts.leftGap;\n    var rightGap = roundFnOpts.rightGap;\n    var ptNumber2cdIndex = {};\n    for(i = 0; i < pos0.length; i++) {\n        var posi = pos0[i];\n        n = Lib.findBin(posi, bins);\n        if(n >= 0 && n < nMax) {\n            total += binFunc(n, i, size, rawCounterData, counts);\n            if(uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n                uniqueValsPerBin = false;\n            }\n            inputPoints[n].push(i);\n            ptNumber2cdIndex[i] = n;\n\n            leftGap = Math.min(leftGap, posi - binEdges[n]);\n            rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n        }\n    }\n    roundFnOpts.leftGap = leftGap;\n    roundFnOpts.rightGap = rightGap;\n\n    var roundFn;\n    if(!uniqueValsPerBin) {\n        roundFn = function(v, isRightEdge) {\n            return function() {\n                var roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n                return getBinSpanLabelRound(\n                    roundFnOpts.leftGap,\n                    roundFnOpts.rightGap,\n                    binEdges, pa, calendar\n                )(v, isRightEdge);\n            };\n        };\n    }\n\n    // average and/or normalize the data, if needed\n    if(isAvg) total = doAvg(size, counts);\n    if(normFunc) normFunc(size, total, inc);\n\n    // after all normalization etc, now we can accumulate if desired\n    if(cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n\n    var seriesLen = Math.min(pos.length, size.length);\n    var cd = [];\n    var firstNonzero = 0;\n    var lastNonzero = seriesLen - 1;\n\n    // look for empty bins at the ends to remove, so autoscale omits them\n    for(i = 0; i < seriesLen; i++) {\n        if(size[i]) {\n            firstNonzero = i;\n            break;\n        }\n    }\n    for(i = seriesLen - 1; i >= firstNonzero; i--) {\n        if(size[i]) {\n            lastNonzero = i;\n            break;\n        }\n    }\n\n    // create the \"calculated data\" to plot\n    for(i = firstNonzero; i <= lastNonzero; i++) {\n        if((isNumeric(pos[i]) && isNumeric(size[i]))) {\n            var cdi = {\n                p: pos[i],\n                s: size[i],\n                b: 0\n            };\n\n            // setup hover and event data fields,\n            // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n            // for cumulative distributions\n            if(!cumulativeSpec.enabled) {\n                cdi.pts = inputPoints[i];\n                if(uniqueValsPerBin) {\n                    cdi.ph0 = cdi.ph1 = (inputPoints[i].length) ? pos0[inputPoints[i][0]] : pos[i];\n                } else {\n                    // Defer evaluation of ph(0|1) in crossTraceCalc\n                    trace._computePh = true;\n                    cdi.ph0 = roundFn(binEdges[i]);\n                    cdi.ph1 = roundFn(binEdges[i + 1], true);\n                }\n            }\n            cd.push(cdi);\n        }\n    }\n\n    if(cd.length === 1) {\n        // when we collapse to a single bin, calcdata no longer describes bin size\n        // so we need to explicitly specify it\n        cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n    }\n\n    arraysToCalcdata(cd, trace);\n\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n    }\n\n    return cd;\n}\n\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n    var binAttr = mainData + 'bins';\n    var fullLayout = gd._fullLayout;\n    var groupName = trace['_' + mainData + 'bingroup'];\n    var binOpts = fullLayout._histogramBinOpts[groupName];\n    var isOverlay = fullLayout.barmode === 'overlay';\n    var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n    var r2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var c2r = function(v) { return pa.c2r(v, 0, calendar); };\n\n    var cleanBound = pa.type === 'date' ?\n        function(v) { return (v || v === 0) ? Lib.cleanDate(v, null, calendar) : null; } :\n        function(v) { return isNumeric(v) ? Number(v) : null; };\n\n    function setBound(attr, bins, newBins) {\n        if(bins[attr + 'Found']) {\n            bins[attr] = cleanBound(bins[attr]);\n            if(bins[attr] === null) bins[attr] = newBins[attr];\n        } else {\n            autoVals[attr] = bins[attr] = newBins[attr];\n            Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n        }\n    }\n\n    // all but the first trace in this group has already been marked finished\n    // clear this flag, so next time we run calc we will run autobin again\n    if(trace['_' + mainData + 'autoBinFinished']) {\n        delete trace['_' + mainData + 'autoBinFinished'];\n    } else {\n        traces = binOpts.traces;\n        var allPos = [];\n\n        // Note: we're including `legendonly` traces here for autobin purposes,\n        // so that showing & hiding from the legend won't affect bins.\n        // But this complicates things a bit since those traces don't `calc`,\n        // hence `isFirstVisible`.\n        var isFirstVisible = true;\n        var has2dMap = false;\n        var hasHist2dContour = false;\n        for(i = 0; i < traces.length; i++) {\n            tracei = traces[i];\n\n            if(tracei.visible) {\n                var mainDatai = binOpts.dirs[i];\n                pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n\n                allPos = Lib.concat(allPos, pos0);\n                delete tracei['_' + mainData + 'autoBinFinished'];\n\n                if(trace.visible === true) {\n                    if(isFirstVisible) {\n                        isFirstVisible = false;\n                    } else {\n                        delete tracei._autoBin;\n                        tracei['_' + mainData + 'autoBinFinished'] = 1;\n                    }\n                    if(Registry.traceIs(tracei, '2dMap')) {\n                        has2dMap = true;\n                    }\n                    if(tracei.type === 'histogram2dcontour') {\n                        hasHist2dContour = true;\n                    }\n                }\n            }\n        }\n\n        calendar = traces[0][mainData + 'calendar'];\n        var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n\n        var autoBin = traces[0]._autoBin = {};\n        autoVals = autoBin[binOpts.dirs[0]] = {};\n\n        if(hasHist2dContour) {\n            // the \"true\" 2nd argument reverses the tick direction (which we can't\n            // just do with a minus sign because of month bins)\n            if(!binOpts.size) {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            }\n            if(binOpts.end === undefined) {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n\n        // Edge case: single-valued histogram overlaying others\n        // Use them all together to calculate the bin size for the single-valued one\n        // Don't re-calculate bin width if user manually specified it (checing in bingroup=='' or xbins is defined)\n        if(isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 &&\n        pa.type !== 'category' && pa.type !== 'multicategory' &&\n        trace.bingroup === '' && (typeof trace.xbins === 'undefined')) {\n            // Several single-valued histograms! Stop infinite recursion,\n            // just return an extra flag that tells handleSingleValueOverlays\n            // to sort out this trace too\n            if(_overlayEdgeCase) return [newBinSpec, pos0, true];\n\n            newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n        }\n\n        // adjust for CDF edge cases\n        cumulativeSpec = tracei.cumulative || {};\n        if(cumulativeSpec.enabled && (cumulativeSpec.currentbin !== 'include')) {\n            if(cumulativeSpec.direction === 'decreasing') {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            } else {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n\n        binOpts.size = newBinSpec.size;\n        if(!binOpts.sizeFound) {\n            autoVals.size = newBinSpec.size;\n            Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n        }\n\n        setBound('start', binOpts, newBinSpec);\n        setBound('end', binOpts, newBinSpec);\n    }\n\n    pos0 = trace['_' + mainData + 'pos0'];\n    delete trace['_' + mainData + 'pos0'];\n\n    // Each trace can specify its own start/end, or if omitted\n    // we ensure they're beyond the bounds of this trace's data,\n    // and we need to make sure start is aligned with the main start\n    var traceInputBins = trace._input[binAttr] || {};\n    var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n    var mainStart = binOpts.start;\n    var startIn = pa.r2l(traceInputBins.start);\n    var hasStart = startIn !== undefined;\n    if((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n        // We have an explicit start to reconcile across traces\n        // if this trace has an explicit start, shift it down to a bin edge\n        // if another trace had an explicit start, shift it down to a\n        // bin edge past our data\n        var traceStart = hasStart ?\n            startIn :\n            Lib.aggNums(Math.min, null, pos0);\n\n        var dummyAx = {\n            type: (pa.type === 'category' || pa.type === 'multicategory') ? 'linear' : pa.type,\n            r2l: pa.r2l,\n            dtick: binOpts.size,\n            tick0: mainStart,\n            calendar: calendar,\n            range: ([traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)]).map(pa.l2r)\n        };\n        var newStart = Axes.tickFirst(dummyAx);\n        if(newStart > pa.r2l(traceStart)) {\n            newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n        }\n        traceBinOptsCalc.start = pa.l2r(newStart);\n        if(!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n    }\n\n    var mainEnd = binOpts.end;\n    var endIn = pa.r2l(traceInputBins.end);\n    var hasEnd = endIn !== undefined;\n    if((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n        // Reconciling an explicit end is easier, as it doesn't need to\n        // match bin edges\n        var traceEnd = hasEnd ?\n            endIn :\n            Lib.aggNums(Math.max, null, pos0);\n\n        traceBinOptsCalc.end = pa.l2r(traceEnd);\n        if(!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n    }\n\n    // Backward compatibility for one-time autobinning.\n    // autobin: true is handled in cleanData, but autobin: false\n    // needs to be here where we have determined the values.\n    var autoBinAttr = 'autobin' + mainData;\n    if(trace._input[autoBinAttr] === false) {\n        trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n        delete trace._input[autoBinAttr];\n        delete trace[autoBinAttr];\n    }\n\n    return [traceBinOptsCalc, pos0];\n}\n\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n    var fullLayout = gd._fullLayout;\n    var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n    var pastThisTrace = false;\n    var minSize = Infinity;\n    var singleValuedTraces = [trace];\n    var i, tracei, binOpts;\n\n    // first collect all the:\n    // - min bin size from all multi-valued traces\n    // - single-valued traces\n    for(i = 0; i < overlaidTraceGroup.length; i++) {\n        tracei = overlaidTraceGroup[i];\n\n        if(tracei === trace) {\n            pastThisTrace = true;\n        } else if(!pastThisTrace) {\n            // This trace has already had its autobins calculated, so either:\n            // - it is part of a bingroup\n            // - it is NOT a single-valued trace\n            binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n            minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n        } else {\n            var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n            var binSpeci = resulti[0];\n            var isSingleValued = resulti[2];\n\n            // so we can use this result when we get to tracei in the normal\n            // course of events, mark it as done and put _pos0 back\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n            tracei['_' + mainData + 'pos0'] = resulti[1];\n\n            if(isSingleValued) {\n                singleValuedTraces.push(tracei);\n            } else {\n                minSize = Math.min(minSize, binSpeci.size);\n            }\n        }\n    }\n\n    // find the real data values for each single-valued trace\n    // hunt through pos0 for the first valid value\n    var dataVals = new Array(singleValuedTraces.length);\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n        for(var j = 0; j < pos0.length; j++) {\n            if(pos0[j] !== undefined) {\n                dataVals[i] = pos0[j];\n                break;\n            }\n        }\n    }\n\n    // are ALL traces are single-valued? use the min difference between\n    // all of their values (which defaults to 1 if there's still only one)\n    if(!isFinite(minSize)) {\n        minSize = Lib.distinctVals(dataVals).minDiff;\n    }\n\n    // now apply the min size we found to all single-valued traces\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        tracei = singleValuedTraces[i];\n        var calendar = tracei[mainData + 'calendar'];\n\n        var newBins = {\n            start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n            end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n            size: minSize\n        };\n\n        tracei._input[binAttr] = tracei[binAttr] = newBins;\n\n        binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n        if(binOpts) Lib.extendFlat(binOpts, newBins);\n    }\n\n    return trace[binAttr];\n}\n\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\nfunction getConnectedHistograms(gd, trace) {\n    var xid = trace.xaxis;\n    var yid = trace.yaxis;\n    var orientation = trace.orientation;\n\n    var out = [];\n    var fullData = gd._fullData;\n    for(var i = 0; i < fullData.length; i++) {\n        var tracei = fullData[i];\n        if(tracei.type === 'histogram' &&\n            tracei.visible === true &&\n            tracei.orientation === orientation &&\n            tracei.xaxis === xid && tracei.yaxis === yid\n        ) {\n            out.push(tracei);\n        }\n    }\n\n    return out;\n}\n\nfunction cdf(size, direction, currentBin) {\n    var i, vi, prevSum;\n\n    function firstHalfPoint(i) {\n        prevSum = size[i];\n        size[i] /= 2;\n    }\n\n    function nextHalfPoint(i) {\n        vi = size[i];\n        size[i] = prevSum + vi / 2;\n        prevSum += vi;\n    }\n\n    if(currentBin === 'half') {\n        if(direction === 'increasing') {\n            firstHalfPoint(0);\n            for(i = 1; i < size.length; i++) {\n                nextHalfPoint(i);\n            }\n        } else {\n            firstHalfPoint(size.length - 1);\n            for(i = size.length - 2; i >= 0; i--) {\n                nextHalfPoint(i);\n            }\n        }\n    } else if(direction === 'increasing') {\n        for(i = 1; i < size.length; i++) {\n            size[i] += size[i - 1];\n        }\n\n        // 'exclude' is identical to 'include' just shifted one bin over\n        if(currentBin === 'exclude') {\n            size.unshift(0);\n            size.pop();\n        }\n    } else {\n        for(i = size.length - 2; i >= 0; i--) {\n            size[i] += size[i + 1];\n        }\n\n        if(currentBin === 'exclude') {\n            size.push(0);\n            size.shift();\n        }\n    }\n}\n\nmodule.exports = {\n    calc: calc,\n    calcAllAutoBins: calcAllAutoBins\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAEzC,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIE,QAAQ,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACxC,IAAIG,IAAI,GAAGH,OAAO,CAAC,4BAA4B,CAAC;AAEhD,IAAII,gBAAgB,GAAGJ,OAAO,CAAC,2BAA2B,CAAC;AAC3D,IAAIK,YAAY,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AAC7C,IAAIM,aAAa,GAAGN,OAAO,CAAC,kBAAkB,CAAC;AAC/C,IAAIO,KAAK,GAAGP,OAAO,CAAC,WAAW,CAAC;AAChC,IAAIQ,oBAAoB,GAAGR,OAAO,CAAC,kBAAkB,CAAC;AAEtD,SAASS,IAAIA,CAACC,EAAE,EAAEC,KAAK,EAAE;EACrB,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAIC,IAAI,GAAG,EAAE;EACb,IAAIC,YAAY,GAAGH,KAAK,CAACI,WAAW,KAAK,GAAG;EAC5C,IAAIC,EAAE,GAAGb,IAAI,CAACc,SAAS,CAACP,EAAE,EAAEI,YAAY,GAAGH,KAAK,CAACO,KAAK,GAAGP,KAAK,CAACQ,KAAK,CAAC;EACrE,IAAIC,QAAQ,GAAGN,YAAY,GAAG,GAAG,GAAG,GAAG;EACvC,IAAIO,WAAW,GAAG;IAACC,CAAC,EAAE,GAAG;IAAEC,CAAC,EAAE;EAAG,CAAC,CAACH,QAAQ,CAAC;EAC5C,IAAII,QAAQ,GAAGb,KAAK,CAACS,QAAQ,GAAG,UAAU,CAAC;EAC3C,IAAIK,cAAc,GAAGd,KAAK,CAACe,UAAU;EACrC,IAAIC,CAAC;EAEL,IAAIC,UAAU,GAAGC,eAAe,CAACnB,EAAE,EAAEC,KAAK,EAAEK,EAAE,EAAEI,QAAQ,CAAC;EACzD,IAAIU,OAAO,GAAGF,UAAU,CAAC,CAAC,CAAC;EAC3B,IAAIG,IAAI,GAAGH,UAAU,CAAC,CAAC,CAAC;EAExB,IAAII,cAAc,GAAG,OAAOF,OAAO,CAACjB,IAAI,KAAK,QAAQ;EACrD,IAAIoB,QAAQ,GAAG,EAAE;EACjB,IAAIC,IAAI,GAAGF,cAAc,GAAGC,QAAQ,GAAGH,OAAO;EAC9C;EACA,IAAIK,GAAG,GAAG,EAAE;EACZ,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,IAAI,GAAG5B,KAAK,CAAC6B,QAAQ;EACzB,IAAIC,IAAI,GAAG9B,KAAK,CAAC+B,QAAQ;EACzB,IAAIC,WAAW,GAAGJ,IAAI,CAACK,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAChD,IAAIC,EAAE,EAAEC,MAAM,EAAEC,CAAC;EAEjB,IAAGtB,cAAc,CAACuB,OAAO,IAAIL,WAAW,EAAE;IACtC;IACA;IACAJ,IAAI,GAAGA,IAAI,CAACU,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;IACrCN,WAAW,GAAG,KAAK;EACvB;EAEA,IAAIO,WAAW,GAAGT,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK;EAClD,IAAIU,QAAQ,GAAGD,WAAW,GAAG,IAAI,GAAG,CAAC;EACrC,IAAIE,OAAO,GAAG/C,YAAY,CAACgD,KAAK;EAChC,IAAIC,QAAQ,GAAGhD,aAAa,CAACiC,IAAI,CAAC;EAClC,IAAIgB,KAAK,GAAG,KAAK;EACjB,IAAIC,IAAI,GAAG,SAAAA,CAASC,CAAC,EAAE;IAAE,OAAOzC,EAAE,CAAC0C,GAAG,CAACD,CAAC,EAAE,CAAC,EAAEjC,QAAQ,CAAC;EAAE,CAAC;EACzD,IAAImC,cAAc;EAElB,IAAG1D,GAAG,CAAC2D,mBAAmB,CAACjD,KAAK,CAACU,WAAW,CAAC,CAAC,IAAIoB,IAAI,KAAK,OAAO,EAAE;IAChEkB,cAAc,GAAGhD,KAAK,CAACU,WAAW,CAAC;IACnCkC,KAAK,GAAGd,IAAI,KAAK,KAAK;IACtBW,OAAO,GAAG/C,YAAY,CAACoC,IAAI,CAAC;EAChC;;EAEA;EACA;EACAd,CAAC,GAAG6B,IAAI,CAAC1B,OAAO,CAAC+B,KAAK,CAAC;;EAEvB;EACAf,MAAM,GAAGU,IAAI,CAAC1B,OAAO,CAACgC,GAAG,CAAC,GAAG,CAACnC,CAAC,GAAGxB,IAAI,CAAC4D,aAAa,CAACpC,CAAC,EAAEG,OAAO,CAACjB,IAAI,EAAE,KAAK,EAAEW,QAAQ,CAAC,IAAI,GAAG;EAE7F,OAAMG,CAAC,GAAGmB,MAAM,IAAIlC,GAAG,CAACoD,MAAM,GAAG,GAAG,EAAE;IAClCnB,EAAE,GAAG1C,IAAI,CAAC4D,aAAa,CAACpC,CAAC,EAAEG,OAAO,CAACjB,IAAI,EAAE,KAAK,EAAEW,QAAQ,CAAC;IACzDZ,GAAG,CAACqD,IAAI,CAAC,CAACtC,CAAC,GAAGkB,EAAE,IAAI,CAAC,CAAC;IACtBhC,IAAI,CAACoD,IAAI,CAACd,QAAQ,CAAC;IACnBd,WAAW,CAAC4B,IAAI,CAAC,EAAE,CAAC;IACpB;IACA;IACAhC,QAAQ,CAACgC,IAAI,CAACtC,CAAC,CAAC;IAChB;IACA,IAAGgB,WAAW,EAAER,GAAG,CAAC8B,IAAI,CAAC,CAAC,IAAIpB,EAAE,GAAGlB,CAAC,CAAC,CAAC;IACtC,IAAG4B,KAAK,EAAEnB,MAAM,CAAC6B,IAAI,CAAC,CAAC,CAAC;IACxB;IACA,IAAGpB,EAAE,IAAIlB,CAAC,EAAE;IACZA,CAAC,GAAGkB,EAAE;EACV;EACAZ,QAAQ,CAACgC,IAAI,CAACtC,CAAC,CAAC;;EAEhB;EACA;EACA,IAAG,CAACK,cAAc,IAAIhB,EAAE,CAACkD,IAAI,KAAK,MAAM,EAAE;IACtChC,IAAI,GAAG;MACH2B,KAAK,EAAEL,IAAI,CAACtB,IAAI,CAAC2B,KAAK,CAAC;MACvBC,GAAG,EAAEN,IAAI,CAACtB,IAAI,CAAC4B,GAAG,CAAC;MACnBjD,IAAI,EAAEqB,IAAI,CAACrB;IACf,CAAC;EACL;;EAEA;EACA,IAAG,CAACH,EAAE,CAACyD,WAAW,CAACC,YAAY,EAAE1D,EAAE,CAACyD,WAAW,CAACC,YAAY,GAAG,CAAC,CAAC;EACjE,IAAIC,SAAS,GAAG1D,KAAK,CAAC,GAAG,GAAGS,QAAQ,GAAG,UAAU,CAAC;EAClD,IAAIkD,WAAW,GAAG;IAACC,OAAO,EAAEC,QAAQ;IAAEC,QAAQ,EAAED;EAAQ,CAAC;EACzD,IAAGH,SAAS,EAAE;IACV,IAAG,CAAC3D,EAAE,CAACyD,WAAW,CAACC,YAAY,CAACC,SAAS,CAAC,EAAE3D,EAAE,CAACyD,WAAW,CAACC,YAAY,CAACC,SAAS,CAAC,GAAGC,WAAW;IAChGA,WAAW,GAAG5D,EAAE,CAACyD,WAAW,CAACC,YAAY,CAACC,SAAS,CAAC;EACxD;;EAEA;EACA;EACA,IAAIK,IAAI,GAAG7D,IAAI,CAACmD,MAAM;EACtB,IAAIW,gBAAgB,GAAG,IAAI;EAC3B,IAAIJ,OAAO,GAAGD,WAAW,CAACC,OAAO;EACjC,IAAIE,QAAQ,GAAGH,WAAW,CAACG,QAAQ;EACnC,IAAIG,gBAAgB,GAAG,CAAC,CAAC;EACzB,KAAIjD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,IAAI,CAACiC,MAAM,EAAErC,CAAC,EAAE,EAAE;IAC7B,IAAIkD,IAAI,GAAG9C,IAAI,CAACJ,CAAC,CAAC;IAClBoB,CAAC,GAAG9C,GAAG,CAAC6E,OAAO,CAACD,IAAI,EAAE3C,IAAI,CAAC;IAC3B,IAAGa,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAG2B,IAAI,EAAE;MACnBpC,KAAK,IAAIc,OAAO,CAACL,CAAC,EAAEpB,CAAC,EAAEd,IAAI,EAAE8C,cAAc,EAAEvB,MAAM,CAAC;MACpD,IAAGuC,gBAAgB,IAAItC,WAAW,CAACU,CAAC,CAAC,CAACiB,MAAM,IAAIa,IAAI,KAAK9C,IAAI,CAACM,WAAW,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;QAC9E4B,gBAAgB,GAAG,KAAK;MAC5B;MACAtC,WAAW,CAACU,CAAC,CAAC,CAACkB,IAAI,CAACtC,CAAC,CAAC;MACtBiD,gBAAgB,CAACjD,CAAC,CAAC,GAAGoB,CAAC;MAEvBwB,OAAO,GAAGQ,IAAI,CAACC,GAAG,CAACT,OAAO,EAAEM,IAAI,GAAG5C,QAAQ,CAACc,CAAC,CAAC,CAAC;MAC/C0B,QAAQ,GAAGM,IAAI,CAACC,GAAG,CAACP,QAAQ,EAAExC,QAAQ,CAACc,CAAC,GAAG,CAAC,CAAC,GAAG8B,IAAI,CAAC;IACzD;EACJ;EACAP,WAAW,CAACC,OAAO,GAAGA,OAAO;EAC7BD,WAAW,CAACG,QAAQ,GAAGA,QAAQ;EAE/B,IAAIQ,OAAO;EACX,IAAG,CAACN,gBAAgB,EAAE;IAClBM,OAAO,GAAG,SAAAA,CAASxB,CAAC,EAAEyB,WAAW,EAAE;MAC/B,OAAO,YAAW;QACd,IAAIZ,WAAW,GAAG5D,EAAE,CAACyD,WAAW,CAACC,YAAY,CAACC,SAAS,CAAC;QACxD,OAAO7D,oBAAoB,CACvB8D,WAAW,CAACC,OAAO,EACnBD,WAAW,CAACG,QAAQ,EACpBxC,QAAQ,EAAEjB,EAAE,EAAEQ,QAClB,CAAC,CAACiC,CAAC,EAAEyB,WAAW,CAAC;MACrB,CAAC;IACL,CAAC;EACL;;EAEA;EACA,IAAG3B,KAAK,EAAEjB,KAAK,GAAG/B,KAAK,CAACM,IAAI,EAAEuB,MAAM,CAAC;EACrC,IAAGkB,QAAQ,EAAEA,QAAQ,CAACzC,IAAI,EAAEyB,KAAK,EAAEH,GAAG,CAAC;;EAEvC;EACA,IAAGV,cAAc,CAACuB,OAAO,EAAEmC,GAAG,CAACtE,IAAI,EAAEY,cAAc,CAAC2D,SAAS,EAAE3D,cAAc,CAAC4D,UAAU,CAAC;EAEzF,IAAIC,SAAS,GAAGP,IAAI,CAACC,GAAG,CAACpE,GAAG,CAACoD,MAAM,EAAEnD,IAAI,CAACmD,MAAM,CAAC;EACjD,IAAIuB,EAAE,GAAG,EAAE;EACX,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,WAAW,GAAGH,SAAS,GAAG,CAAC;;EAE/B;EACA,KAAI3D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2D,SAAS,EAAE3D,CAAC,EAAE,EAAE;IAC3B,IAAGd,IAAI,CAACc,CAAC,CAAC,EAAE;MACR6D,YAAY,GAAG7D,CAAC;MAChB;IACJ;EACJ;EACA,KAAIA,CAAC,GAAG2D,SAAS,GAAG,CAAC,EAAE3D,CAAC,IAAI6D,YAAY,EAAE7D,CAAC,EAAE,EAAE;IAC3C,IAAGd,IAAI,CAACc,CAAC,CAAC,EAAE;MACR8D,WAAW,GAAG9D,CAAC;MACf;IACJ;EACJ;;EAEA;EACA,KAAIA,CAAC,GAAG6D,YAAY,EAAE7D,CAAC,IAAI8D,WAAW,EAAE9D,CAAC,EAAE,EAAE;IACzC,IAAI5B,SAAS,CAACa,GAAG,CAACe,CAAC,CAAC,CAAC,IAAI5B,SAAS,CAACc,IAAI,CAACc,CAAC,CAAC,CAAC,EAAG;MAC1C,IAAI+D,GAAG,GAAG;QACNC,CAAC,EAAE/E,GAAG,CAACe,CAAC,CAAC;QACTiE,CAAC,EAAE/E,IAAI,CAACc,CAAC,CAAC;QACVkE,CAAC,EAAE;MACP,CAAC;;MAED;MACA;MACA;MACA,IAAG,CAACpE,cAAc,CAACuB,OAAO,EAAE;QACxB0C,GAAG,CAACI,GAAG,GAAGzD,WAAW,CAACV,CAAC,CAAC;QACxB,IAAGgD,gBAAgB,EAAE;UACjBe,GAAG,CAACK,GAAG,GAAGL,GAAG,CAACM,GAAG,GAAI3D,WAAW,CAACV,CAAC,CAAC,CAACqC,MAAM,GAAIjC,IAAI,CAACM,WAAW,CAACV,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGf,GAAG,CAACe,CAAC,CAAC;QAClF,CAAC,MAAM;UACH;UACAhB,KAAK,CAACsF,UAAU,GAAG,IAAI;UACvBP,GAAG,CAACK,GAAG,GAAGd,OAAO,CAAChD,QAAQ,CAACN,CAAC,CAAC,CAAC;UAC9B+D,GAAG,CAACM,GAAG,GAAGf,OAAO,CAAChD,QAAQ,CAACN,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC;QAC5C;MACJ;MACA4D,EAAE,CAACtB,IAAI,CAACyB,GAAG,CAAC;IAChB;EACJ;EAEA,IAAGH,EAAE,CAACvB,MAAM,KAAK,CAAC,EAAE;IAChB;IACA;IACAuB,EAAE,CAAC,CAAC,CAAC,CAACW,MAAM,GAAG/F,IAAI,CAAC4D,aAAa,CAACwB,EAAE,CAAC,CAAC,CAAC,CAACI,CAAC,EAAE7D,OAAO,CAACjB,IAAI,EAAE,KAAK,EAAEW,QAAQ,CAAC,GAAG+D,EAAE,CAAC,CAAC,CAAC,CAACI,CAAC;EACvF;EAEAvF,gBAAgB,CAACmF,EAAE,EAAE5E,KAAK,CAAC;EAE3B,IAAGV,GAAG,CAAC2D,mBAAmB,CAACjD,KAAK,CAACwF,cAAc,CAAC,EAAE;IAC9ClG,GAAG,CAACmG,WAAW,CAACb,EAAE,EAAE5E,KAAK,EAAEiE,gBAAgB,CAAC;EAChD;EAEA,OAAOW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1D,eAAeA,CAACnB,EAAE,EAAEC,KAAK,EAAEK,EAAE,EAAEI,QAAQ,EAAEiF,gBAAgB,EAAE;EAChE,IAAIC,OAAO,GAAGlF,QAAQ,GAAG,MAAM;EAC/B,IAAImF,UAAU,GAAG7F,EAAE,CAACyD,WAAW;EAC/B,IAAIE,SAAS,GAAG1D,KAAK,CAAC,GAAG,GAAGS,QAAQ,GAAG,UAAU,CAAC;EAClD,IAAIoF,OAAO,GAAGD,UAAU,CAACE,iBAAiB,CAACpC,SAAS,CAAC;EACrD,IAAIqC,SAAS,GAAGH,UAAU,CAACI,OAAO,KAAK,SAAS;EAChD,IAAIhF,CAAC,EAAEiF,MAAM,EAAEC,MAAM,EAAErF,QAAQ,EAAEO,IAAI,EAAE+E,QAAQ,EAAErF,cAAc;EAE/D,IAAIiC,GAAG,GAAG,SAAAA,CAASD,CAAC,EAAE;IAAE,OAAOzC,EAAE,CAAC0C,GAAG,CAACD,CAAC,EAAE,CAAC,EAAEjC,QAAQ,CAAC;EAAE,CAAC;EACxD,IAAIuF,GAAG,GAAG,SAAAA,CAAStD,CAAC,EAAE;IAAE,OAAOzC,EAAE,CAAC+F,GAAG,CAACtD,CAAC,EAAE,CAAC,EAAEjC,QAAQ,CAAC;EAAE,CAAC;EAExD,IAAIwF,UAAU,GAAGhG,EAAE,CAACkD,IAAI,KAAK,MAAM,GAC/B,UAAST,CAAC,EAAE;IAAE,OAAQA,CAAC,IAAIA,CAAC,KAAK,CAAC,GAAIxD,GAAG,CAACgH,SAAS,CAACxD,CAAC,EAAE,IAAI,EAAEjC,QAAQ,CAAC,GAAG,IAAI;EAAE,CAAC,GAChF,UAASiC,CAAC,EAAE;IAAE,OAAO1D,SAAS,CAAC0D,CAAC,CAAC,GAAGyD,MAAM,CAACzD,CAAC,CAAC,GAAG,IAAI;EAAE,CAAC;EAE3D,SAAS0D,QAAQA,CAACC,IAAI,EAAElF,IAAI,EAAEmF,OAAO,EAAE;IACnC,IAAGnF,IAAI,CAACkF,IAAI,GAAG,OAAO,CAAC,EAAE;MACrBlF,IAAI,CAACkF,IAAI,CAAC,GAAGJ,UAAU,CAAC9E,IAAI,CAACkF,IAAI,CAAC,CAAC;MACnC,IAAGlF,IAAI,CAACkF,IAAI,CAAC,KAAK,IAAI,EAAElF,IAAI,CAACkF,IAAI,CAAC,GAAGC,OAAO,CAACD,IAAI,CAAC;IACtD,CAAC,MAAM;MACHN,QAAQ,CAACM,IAAI,CAAC,GAAGlF,IAAI,CAACkF,IAAI,CAAC,GAAGC,OAAO,CAACD,IAAI,CAAC;MAC3CnH,GAAG,CAACqH,cAAc,CAACV,MAAM,CAAC,CAAC,CAAC,EAAEN,OAAO,GAAG,GAAG,GAAGc,IAAI,CAAC,CAACG,GAAG,CAACF,OAAO,CAACD,IAAI,CAAC,CAAC;IAC1E;EACJ;;EAEA;EACA;EACA,IAAGzG,KAAK,CAAC,GAAG,GAAGS,QAAQ,GAAG,iBAAiB,CAAC,EAAE;IAC1C,OAAOT,KAAK,CAAC,GAAG,GAAGS,QAAQ,GAAG,iBAAiB,CAAC;EACpD,CAAC,MAAM;IACHwF,MAAM,GAAGJ,OAAO,CAACI,MAAM;IACvB,IAAIY,MAAM,GAAG,EAAE;;IAEf;IACA;IACA;IACA;IACA,IAAIC,cAAc,GAAG,IAAI;IACzB,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,KAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiF,MAAM,CAAC5C,MAAM,EAAErC,CAAC,EAAE,EAAE;MAC/BkF,MAAM,GAAGD,MAAM,CAACjF,CAAC,CAAC;MAElB,IAAGkF,MAAM,CAACe,OAAO,EAAE;QACf,IAAIC,SAAS,GAAGrB,OAAO,CAACsB,IAAI,CAACnG,CAAC,CAAC;QAC/BI,IAAI,GAAG8E,MAAM,CAAC,GAAG,GAAGgB,SAAS,GAAG,MAAM,CAAC,GAAG7G,EAAE,CAAC+G,YAAY,CAAClB,MAAM,EAAEgB,SAAS,CAAC;QAE5EL,MAAM,GAAGvH,GAAG,CAAC+H,MAAM,CAACR,MAAM,EAAEzF,IAAI,CAAC;QACjC,OAAO8E,MAAM,CAAC,GAAG,GAAGzF,QAAQ,GAAG,iBAAiB,CAAC;QAEjD,IAAGT,KAAK,CAACiH,OAAO,KAAK,IAAI,EAAE;UACvB,IAAGH,cAAc,EAAE;YACfA,cAAc,GAAG,KAAK;UAC1B,CAAC,MAAM;YACH,OAAOZ,MAAM,CAACoB,QAAQ;YACtBpB,MAAM,CAAC,GAAG,GAAGzF,QAAQ,GAAG,iBAAiB,CAAC,GAAG,CAAC;UAClD;UACA,IAAGlB,QAAQ,CAACgI,OAAO,CAACrB,MAAM,EAAE,OAAO,CAAC,EAAE;YAClCa,QAAQ,GAAG,IAAI;UACnB;UACA,IAAGb,MAAM,CAAC3C,IAAI,KAAK,oBAAoB,EAAE;YACrCyD,gBAAgB,GAAG,IAAI;UAC3B;QACJ;MACJ;IACJ;IAEAnG,QAAQ,GAAGoF,MAAM,CAAC,CAAC,CAAC,CAACxF,QAAQ,GAAG,UAAU,CAAC;IAC3C,IAAI+G,UAAU,GAAGhI,IAAI,CAACiI,OAAO,CAACZ,MAAM,EAAExG,EAAE,EAAEwF,OAAO,CAAC6B,KAAK,EAAEX,QAAQ,EAAElG,QAAQ,EAAEgF,OAAO,CAAC8B,SAAS,IAAI9B,OAAO,CAAC3F,IAAI,CAAC;IAE/G,IAAIuH,OAAO,GAAGxB,MAAM,CAAC,CAAC,CAAC,CAACqB,QAAQ,GAAG,CAAC,CAAC;IACrCnB,QAAQ,GAAGsB,OAAO,CAAC5B,OAAO,CAACsB,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAExC,IAAGH,gBAAgB,EAAE;MACjB;MACA;MACA,IAAG,CAACnB,OAAO,CAAC3F,IAAI,EAAE;QACdsH,UAAU,CAACtE,KAAK,GAAGkD,GAAG,CAAC5G,IAAI,CAAC4D,aAAa,CACrCL,GAAG,CAACyE,UAAU,CAACtE,KAAK,CAAC,EAAEsE,UAAU,CAACtH,IAAI,EAAE,IAAI,EAAEW,QAAQ,CAAC,CAAC;MAChE;MACA,IAAGgF,OAAO,CAAC1C,GAAG,KAAKyE,SAAS,EAAE;QAC1BJ,UAAU,CAACrE,GAAG,GAAGiD,GAAG,CAAC5G,IAAI,CAAC4D,aAAa,CACnCL,GAAG,CAACyE,UAAU,CAACrE,GAAG,CAAC,EAAEqE,UAAU,CAACtH,IAAI,EAAE,KAAK,EAAEW,QAAQ,CAAC,CAAC;MAC/D;IACJ;;IAEA;IACA;IACA;IACA,IAAGkF,SAAS,IAAI,CAACxG,QAAQ,CAACgI,OAAO,CAACvH,KAAK,EAAE,OAAO,CAAC,IAAIwH,UAAU,CAACK,SAAS,KAAK,CAAC,IAC/ExH,EAAE,CAACkD,IAAI,KAAK,UAAU,IAAIlD,EAAE,CAACkD,IAAI,KAAK,eAAe,IACrDvD,KAAK,CAAC8H,QAAQ,KAAK,EAAE,IAAK,OAAO9H,KAAK,CAAC+H,KAAK,KAAK,WAAY,EAAE;MAC3D;MACA;MACA;MACA,IAAGrC,gBAAgB,EAAE,OAAO,CAAC8B,UAAU,EAAEpG,IAAI,EAAE,IAAI,CAAC;MAEpDoG,UAAU,GAAGQ,yBAAyB,CAACjI,EAAE,EAAEC,KAAK,EAAEK,EAAE,EAAEI,QAAQ,EAAEkF,OAAO,CAAC;IAC5E;;IAEA;IACA7E,cAAc,GAAGoF,MAAM,CAACnF,UAAU,IAAI,CAAC,CAAC;IACxC,IAAGD,cAAc,CAACuB,OAAO,IAAKvB,cAAc,CAAC4D,UAAU,KAAK,SAAU,EAAE;MACpE,IAAG5D,cAAc,CAAC2D,SAAS,KAAK,YAAY,EAAE;QAC1C+C,UAAU,CAACtE,KAAK,GAAGkD,GAAG,CAAC5G,IAAI,CAAC4D,aAAa,CACrCL,GAAG,CAACyE,UAAU,CAACtE,KAAK,CAAC,EAAEsE,UAAU,CAACtH,IAAI,EAAE,IAAI,EAAEW,QAAQ,CAAC,CAAC;MAChE,CAAC,MAAM;QACH2G,UAAU,CAACrE,GAAG,GAAGiD,GAAG,CAAC5G,IAAI,CAAC4D,aAAa,CACnCL,GAAG,CAACyE,UAAU,CAACrE,GAAG,CAAC,EAAEqE,UAAU,CAACtH,IAAI,EAAE,KAAK,EAAEW,QAAQ,CAAC,CAAC;MAC/D;IACJ;IAEAgF,OAAO,CAAC3F,IAAI,GAAGsH,UAAU,CAACtH,IAAI;IAC9B,IAAG,CAAC2F,OAAO,CAAC8B,SAAS,EAAE;MACnBxB,QAAQ,CAACjG,IAAI,GAAGsH,UAAU,CAACtH,IAAI;MAC/BZ,GAAG,CAACqH,cAAc,CAACV,MAAM,CAAC,CAAC,CAAC,EAAEN,OAAO,GAAG,OAAO,CAAC,CAACiB,GAAG,CAACY,UAAU,CAACtH,IAAI,CAAC;IACzE;IAEAsG,QAAQ,CAAC,OAAO,EAAEX,OAAO,EAAE2B,UAAU,CAAC;IACtChB,QAAQ,CAAC,KAAK,EAAEX,OAAO,EAAE2B,UAAU,CAAC;EACxC;EAEApG,IAAI,GAAGpB,KAAK,CAAC,GAAG,GAAGS,QAAQ,GAAG,MAAM,CAAC;EACrC,OAAOT,KAAK,CAAC,GAAG,GAAGS,QAAQ,GAAG,MAAM,CAAC;;EAErC;EACA;EACA;EACA,IAAIwH,cAAc,GAAGjI,KAAK,CAACkI,MAAM,CAACvC,OAAO,CAAC,IAAI,CAAC,CAAC;EAChD,IAAIwC,gBAAgB,GAAG7I,GAAG,CAAC8I,UAAU,CAAC,CAAC,CAAC,EAAEvC,OAAO,CAAC;EAClD,IAAIwC,SAAS,GAAGxC,OAAO,CAAC3C,KAAK;EAC7B,IAAIoF,OAAO,GAAGjI,EAAE,CAACkI,GAAG,CAACN,cAAc,CAAC/E,KAAK,CAAC;EAC1C,IAAIsF,QAAQ,GAAGF,OAAO,KAAKV,SAAS;EACpC,IAAG,CAAC/B,OAAO,CAAC4C,UAAU,IAAID,QAAQ,KAAKF,OAAO,KAAKjI,EAAE,CAACkI,GAAG,CAACF,SAAS,CAAC,EAAE;IAClE;IACA;IACA;IACA;IACA,IAAIK,UAAU,GAAGF,QAAQ,GACrBF,OAAO,GACPhJ,GAAG,CAACqJ,OAAO,CAACvE,IAAI,CAACC,GAAG,EAAE,IAAI,EAAEjD,IAAI,CAAC;IAErC,IAAIwH,OAAO,GAAG;MACVrF,IAAI,EAAGlD,EAAE,CAACkD,IAAI,KAAK,UAAU,IAAIlD,EAAE,CAACkD,IAAI,KAAK,eAAe,GAAI,QAAQ,GAAGlD,EAAE,CAACkD,IAAI;MAClFgF,GAAG,EAAElI,EAAE,CAACkI,GAAG;MACXM,KAAK,EAAEhD,OAAO,CAAC3F,IAAI;MACnB4I,KAAK,EAAET,SAAS;MAChBxH,QAAQ,EAAEA,QAAQ;MAClBkI,KAAK,EAAG,CAACL,UAAU,EAAElJ,IAAI,CAAC4D,aAAa,CAACsF,UAAU,EAAE7C,OAAO,CAAC3F,IAAI,EAAE,KAAK,EAAEW,QAAQ,CAAC,CAAC,CAAEmI,GAAG,CAAC3I,EAAE,CAAC4I,GAAG;IACnG,CAAC;IACD,IAAIC,QAAQ,GAAG1J,IAAI,CAAC2J,SAAS,CAACP,OAAO,CAAC;IACtC,IAAGM,QAAQ,GAAG7I,EAAE,CAACkI,GAAG,CAACG,UAAU,CAAC,EAAE;MAC9BQ,QAAQ,GAAG1J,IAAI,CAAC4D,aAAa,CAAC8F,QAAQ,EAAErD,OAAO,CAAC3F,IAAI,EAAE,IAAI,EAAEW,QAAQ,CAAC;IACzE;IACAsH,gBAAgB,CAACjF,KAAK,GAAG7C,EAAE,CAAC4I,GAAG,CAACC,QAAQ,CAAC;IACzC,IAAG,CAACV,QAAQ,EAAElJ,GAAG,CAACqH,cAAc,CAAC3G,KAAK,EAAE2F,OAAO,GAAG,QAAQ,CAAC,CAACiB,GAAG,CAACuB,gBAAgB,CAACjF,KAAK,CAAC;EAC3F;EAEA,IAAIkG,OAAO,GAAGvD,OAAO,CAAC1C,GAAG;EACzB,IAAIkG,KAAK,GAAGhJ,EAAE,CAACkI,GAAG,CAACN,cAAc,CAAC9E,GAAG,CAAC;EACtC,IAAImG,MAAM,GAAGD,KAAK,KAAKzB,SAAS;EAChC,IAAG,CAAC/B,OAAO,CAAC0D,QAAQ,IAAID,MAAM,KAAKD,KAAK,KAAKhJ,EAAE,CAACkI,GAAG,CAACa,OAAO,CAAC,EAAE;IAC1D;IACA;IACA,IAAII,QAAQ,GAAGF,MAAM,GACjBD,KAAK,GACL/J,GAAG,CAACqJ,OAAO,CAACvE,IAAI,CAACqF,GAAG,EAAE,IAAI,EAAErI,IAAI,CAAC;IAErC+G,gBAAgB,CAAChF,GAAG,GAAG9C,EAAE,CAAC4I,GAAG,CAACO,QAAQ,CAAC;IACvC,IAAG,CAACF,MAAM,EAAEhK,GAAG,CAACqH,cAAc,CAAC3G,KAAK,EAAE2F,OAAO,GAAG,QAAQ,CAAC,CAACiB,GAAG,CAACuB,gBAAgB,CAAChF,GAAG,CAAC;EACvF;;EAEA;EACA;EACA;EACA,IAAIuG,WAAW,GAAG,SAAS,GAAGjJ,QAAQ;EACtC,IAAGT,KAAK,CAACkI,MAAM,CAACwB,WAAW,CAAC,KAAK,KAAK,EAAE;IACpC1J,KAAK,CAACkI,MAAM,CAACvC,OAAO,CAAC,GAAGrG,GAAG,CAAC8I,UAAU,CAAC,CAAC,CAAC,EAAEpI,KAAK,CAAC2F,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IAChE,OAAO3F,KAAK,CAACkI,MAAM,CAACwB,WAAW,CAAC;IAChC,OAAO1J,KAAK,CAAC0J,WAAW,CAAC;EAC7B;EAEA,OAAO,CAACvB,gBAAgB,EAAE/G,IAAI,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4G,yBAAyBA,CAACjI,EAAE,EAAEC,KAAK,EAAEK,EAAE,EAAEI,QAAQ,EAAEkF,OAAO,EAAE;EACjE,IAAIC,UAAU,GAAG7F,EAAE,CAACyD,WAAW;EAC/B,IAAImG,kBAAkB,GAAGC,sBAAsB,CAAC7J,EAAE,EAAEC,KAAK,CAAC;EAC1D,IAAI6J,aAAa,GAAG,KAAK;EACzB,IAAIC,OAAO,GAAGjG,QAAQ;EACtB,IAAIkG,kBAAkB,GAAG,CAAC/J,KAAK,CAAC;EAChC,IAAIgB,CAAC,EAAEkF,MAAM,EAAEL,OAAO;;EAEtB;EACA;EACA;EACA,KAAI7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2I,kBAAkB,CAACtG,MAAM,EAAErC,CAAC,EAAE,EAAE;IAC3CkF,MAAM,GAAGyD,kBAAkB,CAAC3I,CAAC,CAAC;IAE9B,IAAGkF,MAAM,KAAKlG,KAAK,EAAE;MACjB6J,aAAa,GAAG,IAAI;IACxB,CAAC,MAAM,IAAG,CAACA,aAAa,EAAE;MACtB;MACA;MACA;MACAhE,OAAO,GAAGD,UAAU,CAACE,iBAAiB,CAACI,MAAM,CAAC,GAAG,GAAGzF,QAAQ,GAAG,UAAU,CAAC,CAAC;MAC3EqJ,OAAO,GAAG1F,IAAI,CAACC,GAAG,CAACyF,OAAO,EAAEjE,OAAO,CAAC3F,IAAI,IAAIgG,MAAM,CAACP,OAAO,CAAC,CAACzF,IAAI,CAAC;IACrE,CAAC,MAAM;MACH,IAAI8J,OAAO,GAAG9I,eAAe,CAACnB,EAAE,EAAEmG,MAAM,EAAE7F,EAAE,EAAEI,QAAQ,EAAE,IAAI,CAAC;MAC7D,IAAIwJ,QAAQ,GAAGD,OAAO,CAAC,CAAC,CAAC;MACzB,IAAIE,cAAc,GAAGF,OAAO,CAAC,CAAC,CAAC;;MAE/B;MACA;MACA9D,MAAM,CAAC,GAAG,GAAGzF,QAAQ,GAAG,iBAAiB,CAAC,GAAG,CAAC;MAC9CyF,MAAM,CAAC,GAAG,GAAGzF,QAAQ,GAAG,MAAM,CAAC,GAAGuJ,OAAO,CAAC,CAAC,CAAC;MAE5C,IAAGE,cAAc,EAAE;QACfH,kBAAkB,CAACzG,IAAI,CAAC4C,MAAM,CAAC;MACnC,CAAC,MAAM;QACH4D,OAAO,GAAG1F,IAAI,CAACC,GAAG,CAACyF,OAAO,EAAEG,QAAQ,CAAC/J,IAAI,CAAC;MAC9C;IACJ;EACJ;;EAEA;EACA;EACA,IAAIiK,QAAQ,GAAG,IAAIC,KAAK,CAACL,kBAAkB,CAAC1G,MAAM,CAAC;EACnD,KAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+I,kBAAkB,CAAC1G,MAAM,EAAErC,CAAC,EAAE,EAAE;IAC3C,IAAII,IAAI,GAAG2I,kBAAkB,CAAC/I,CAAC,CAAC,CAAC,GAAG,GAAGP,QAAQ,GAAG,MAAM,CAAC;IACzD,KAAI,IAAI4J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjJ,IAAI,CAACiC,MAAM,EAAEgH,CAAC,EAAE,EAAE;MACjC,IAAGjJ,IAAI,CAACiJ,CAAC,CAAC,KAAKzC,SAAS,EAAE;QACtBuC,QAAQ,CAACnJ,CAAC,CAAC,GAAGI,IAAI,CAACiJ,CAAC,CAAC;QACrB;MACJ;IACJ;EACJ;;EAEA;EACA;EACA,IAAG,CAACC,QAAQ,CAACR,OAAO,CAAC,EAAE;IACnBA,OAAO,GAAGxK,GAAG,CAACiL,YAAY,CAACJ,QAAQ,CAAC,CAACK,OAAO;EAChD;;EAEA;EACA,KAAIxJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+I,kBAAkB,CAAC1G,MAAM,EAAErC,CAAC,EAAE,EAAE;IAC3CkF,MAAM,GAAG6D,kBAAkB,CAAC/I,CAAC,CAAC;IAC9B,IAAIH,QAAQ,GAAGqF,MAAM,CAACzF,QAAQ,GAAG,UAAU,CAAC;IAE5C,IAAIiG,OAAO,GAAG;MACVxD,KAAK,EAAE7C,EAAE,CAAC+F,GAAG,CAAC+D,QAAQ,CAACnJ,CAAC,CAAC,GAAG8I,OAAO,GAAG,CAAC,EAAE,CAAC,EAAEjJ,QAAQ,CAAC;MACrDsC,GAAG,EAAE9C,EAAE,CAAC+F,GAAG,CAAC+D,QAAQ,CAACnJ,CAAC,CAAC,GAAG8I,OAAO,GAAG,CAAC,EAAE,CAAC,EAAEjJ,QAAQ,CAAC;MACnDX,IAAI,EAAE4J;IACV,CAAC;IAED5D,MAAM,CAACgC,MAAM,CAACvC,OAAO,CAAC,GAAGO,MAAM,CAACP,OAAO,CAAC,GAAGe,OAAO;IAElDb,OAAO,GAAGD,UAAU,CAACE,iBAAiB,CAACI,MAAM,CAAC,GAAG,GAAGzF,QAAQ,GAAG,UAAU,CAAC,CAAC;IAC3E,IAAGoF,OAAO,EAAEvG,GAAG,CAAC8I,UAAU,CAACvC,OAAO,EAAEa,OAAO,CAAC;EAChD;EAEA,OAAO1G,KAAK,CAAC2F,OAAO,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiE,sBAAsBA,CAAC7J,EAAE,EAAEC,KAAK,EAAE;EACvC,IAAIyK,GAAG,GAAGzK,KAAK,CAACQ,KAAK;EACrB,IAAIkK,GAAG,GAAG1K,KAAK,CAACO,KAAK;EACrB,IAAIH,WAAW,GAAGJ,KAAK,CAACI,WAAW;EAEnC,IAAIuK,GAAG,GAAG,EAAE;EACZ,IAAIC,QAAQ,GAAG7K,EAAE,CAAC8K,SAAS;EAC3B,KAAI,IAAI7J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4J,QAAQ,CAACvH,MAAM,EAAErC,CAAC,EAAE,EAAE;IACrC,IAAIkF,MAAM,GAAG0E,QAAQ,CAAC5J,CAAC,CAAC;IACxB,IAAGkF,MAAM,CAAC3C,IAAI,KAAK,WAAW,IAC1B2C,MAAM,CAACe,OAAO,KAAK,IAAI,IACvBf,MAAM,CAAC9F,WAAW,KAAKA,WAAW,IAClC8F,MAAM,CAAC1F,KAAK,KAAKiK,GAAG,IAAIvE,MAAM,CAAC3F,KAAK,KAAKmK,GAAG,EAC9C;MACEC,GAAG,CAACrH,IAAI,CAAC4C,MAAM,CAAC;IACpB;EACJ;EAEA,OAAOyE,GAAG;AACd;AAEA,SAASnG,GAAGA,CAACtE,IAAI,EAAEuE,SAAS,EAAEqG,UAAU,EAAE;EACtC,IAAI9J,CAAC,EAAE+J,EAAE,EAAEC,OAAO;EAElB,SAASC,cAAcA,CAACjK,CAAC,EAAE;IACvBgK,OAAO,GAAG9K,IAAI,CAACc,CAAC,CAAC;IACjBd,IAAI,CAACc,CAAC,CAAC,IAAI,CAAC;EAChB;EAEA,SAASkK,aAAaA,CAAClK,CAAC,EAAE;IACtB+J,EAAE,GAAG7K,IAAI,CAACc,CAAC,CAAC;IACZd,IAAI,CAACc,CAAC,CAAC,GAAGgK,OAAO,GAAGD,EAAE,GAAG,CAAC;IAC1BC,OAAO,IAAID,EAAE;EACjB;EAEA,IAAGD,UAAU,KAAK,MAAM,EAAE;IACtB,IAAGrG,SAAS,KAAK,YAAY,EAAE;MAC3BwG,cAAc,CAAC,CAAC,CAAC;MACjB,KAAIjK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACmD,MAAM,EAAErC,CAAC,EAAE,EAAE;QAC7BkK,aAAa,CAAClK,CAAC,CAAC;MACpB;IACJ,CAAC,MAAM;MACHiK,cAAc,CAAC/K,IAAI,CAACmD,MAAM,GAAG,CAAC,CAAC;MAC/B,KAAIrC,CAAC,GAAGd,IAAI,CAACmD,MAAM,GAAG,CAAC,EAAErC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAClCkK,aAAa,CAAClK,CAAC,CAAC;MACpB;IACJ;EACJ,CAAC,MAAM,IAAGyD,SAAS,KAAK,YAAY,EAAE;IAClC,KAAIzD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACmD,MAAM,EAAErC,CAAC,EAAE,EAAE;MAC7Bd,IAAI,CAACc,CAAC,CAAC,IAAId,IAAI,CAACc,CAAC,GAAG,CAAC,CAAC;IAC1B;;IAEA;IACA,IAAG8J,UAAU,KAAK,SAAS,EAAE;MACzB5K,IAAI,CAACiL,OAAO,CAAC,CAAC,CAAC;MACfjL,IAAI,CAACkL,GAAG,CAAC,CAAC;IACd;EACJ,CAAC,MAAM;IACH,KAAIpK,CAAC,GAAGd,IAAI,CAACmD,MAAM,GAAG,CAAC,EAAErC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAClCd,IAAI,CAACc,CAAC,CAAC,IAAId,IAAI,CAACc,CAAC,GAAG,CAAC,CAAC;IAC1B;IAEA,IAAG8J,UAAU,KAAK,SAAS,EAAE;MACzB5K,IAAI,CAACoD,IAAI,CAAC,CAAC,CAAC;MACZpD,IAAI,CAACmL,KAAK,CAAC,CAAC;IAChB;EACJ;AACJ;AAEAC,MAAM,CAACC,OAAO,GAAG;EACbzL,IAAI,EAAEA,IAAI;EACVoB,eAAe,EAAEA;AACrB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}