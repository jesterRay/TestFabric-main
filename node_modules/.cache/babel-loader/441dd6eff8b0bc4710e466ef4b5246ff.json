{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\nvar constants = require('./constants');\nvar layoutAttributes = require('./layout_attributes');\nvar axesNames = constants.axesNames;\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: 'geo',\n    attributes: layoutAttributes,\n    handleDefaults: handleGeoDefaults,\n    fullData: fullData,\n    partition: 'y'\n  });\n};\nfunction handleGeoDefaults(geoLayoutIn, geoLayoutOut, coerce, opts) {\n  var subplotData = getSubplotData(opts.fullData, 'geo', opts.id);\n  var traceIndices = subplotData.map(function (t) {\n    return t._expandedIndex;\n  });\n  var resolution = coerce('resolution');\n  var scope = coerce('scope');\n  var scopeParams = constants.scopeDefaults[scope];\n  var projType = coerce('projection.type', scopeParams.projType);\n  var isAlbersUsa = geoLayoutOut._isAlbersUsa = projType === 'albers usa';\n\n  // no other scopes are allowed for 'albers usa' projection\n  if (isAlbersUsa) scope = geoLayoutOut.scope = 'usa';\n  var isScoped = geoLayoutOut._isScoped = scope !== 'world';\n  var isSatellite = geoLayoutOut._isSatellite = projType === 'satellite';\n  var isConic = geoLayoutOut._isConic = projType.indexOf('conic') !== -1 || projType === 'albers';\n  var isClipped = geoLayoutOut._isClipped = !!constants.lonaxisSpan[projType];\n  if (geoLayoutIn.visible === false) {\n    // should override template.layout.geo.show* - see issue 4482\n\n    // make a copy\n    var newTemplate = Lib.extendDeep({}, geoLayoutOut._template);\n\n    // override show*\n    newTemplate.showcoastlines = false;\n    newTemplate.showcountries = false;\n    newTemplate.showframe = false;\n    newTemplate.showlakes = false;\n    newTemplate.showland = false;\n    newTemplate.showocean = false;\n    newTemplate.showrivers = false;\n    newTemplate.showsubunits = false;\n    if (newTemplate.lonaxis) newTemplate.lonaxis.showgrid = false;\n    if (newTemplate.lataxis) newTemplate.lataxis.showgrid = false;\n\n    // set ref to copy\n    geoLayoutOut._template = newTemplate;\n  }\n  var visible = coerce('visible');\n  var show;\n  for (var i = 0; i < axesNames.length; i++) {\n    var axisName = axesNames[i];\n    var dtickDflt = [30, 10][i];\n    var rangeDflt;\n    if (isScoped) {\n      rangeDflt = scopeParams[axisName + 'Range'];\n    } else {\n      var dfltSpans = constants[axisName + 'Span'];\n      var hSpan = (dfltSpans[projType] || dfltSpans['*']) / 2;\n      var rot = coerce('projection.rotation.' + axisName.substr(0, 3), scopeParams.projRotate[i]);\n      rangeDflt = [rot - hSpan, rot + hSpan];\n    }\n    var range = coerce(axisName + '.range', rangeDflt);\n    coerce(axisName + '.tick0');\n    coerce(axisName + '.dtick', dtickDflt);\n    show = coerce(axisName + '.showgrid', !visible ? false : undefined);\n    if (show) {\n      coerce(axisName + '.gridcolor');\n      coerce(axisName + '.gridwidth');\n      coerce(axisName + '.griddash');\n    }\n\n    // mock axis for autorange computations\n    geoLayoutOut[axisName]._ax = {\n      type: 'linear',\n      _id: axisName.slice(0, 3),\n      _traceIndices: traceIndices,\n      setScale: Lib.identity,\n      c2l: Lib.identity,\n      r2l: Lib.identity,\n      autorange: true,\n      range: range.slice(),\n      _m: 1,\n      _input: {}\n    };\n  }\n  var lonRange = geoLayoutOut.lonaxis.range;\n  var latRange = geoLayoutOut.lataxis.range;\n\n  // to cross antimeridian w/o ambiguity\n  var lon0 = lonRange[0];\n  var lon1 = lonRange[1];\n  if (lon0 > 0 && lon1 < 0) lon1 += 360;\n  var centerLon = (lon0 + lon1) / 2;\n  var projLon;\n  if (!isAlbersUsa) {\n    var dfltProjRotate = isScoped ? scopeParams.projRotate : [centerLon, 0, 0];\n    projLon = coerce('projection.rotation.lon', dfltProjRotate[0]);\n    coerce('projection.rotation.lat', dfltProjRotate[1]);\n    coerce('projection.rotation.roll', dfltProjRotate[2]);\n    show = coerce('showcoastlines', !isScoped && visible);\n    if (show) {\n      coerce('coastlinecolor');\n      coerce('coastlinewidth');\n    }\n    show = coerce('showocean', !visible ? false : undefined);\n    if (show) coerce('oceancolor');\n  }\n  var centerLonDflt;\n  var centerLatDflt;\n  if (isAlbersUsa) {\n    // 'albers usa' does not have a 'center',\n    // these values were found using via:\n    //   projection.invert([geoLayout.center.lon, geoLayoutIn.center.lat])\n    centerLonDflt = -96.6;\n    centerLatDflt = 38.7;\n  } else {\n    centerLonDflt = isScoped ? centerLon : projLon;\n    centerLatDflt = (latRange[0] + latRange[1]) / 2;\n  }\n  coerce('center.lon', centerLonDflt);\n  coerce('center.lat', centerLatDflt);\n  if (isSatellite) {\n    coerce('projection.tilt');\n    coerce('projection.distance');\n  }\n  if (isConic) {\n    var dfltProjParallels = scopeParams.projParallels || [0, 60];\n    coerce('projection.parallels', dfltProjParallels);\n  }\n  coerce('projection.scale');\n  show = coerce('showland', !visible ? false : undefined);\n  if (show) coerce('landcolor');\n  show = coerce('showlakes', !visible ? false : undefined);\n  if (show) coerce('lakecolor');\n  show = coerce('showrivers', !visible ? false : undefined);\n  if (show) {\n    coerce('rivercolor');\n    coerce('riverwidth');\n  }\n  show = coerce('showcountries', isScoped && scope !== 'usa' && visible);\n  if (show) {\n    coerce('countrycolor');\n    coerce('countrywidth');\n  }\n  if (scope === 'usa' || scope === 'north america' && resolution === 50) {\n    // Only works for:\n    //   USA states at 110m\n    //   USA states + Canada provinces at 50m\n    coerce('showsubunits', visible);\n    coerce('subunitcolor');\n    coerce('subunitwidth');\n  }\n  if (!isScoped) {\n    // Does not work in non-world scopes\n    show = coerce('showframe', visible);\n    if (show) {\n      coerce('framecolor');\n      coerce('framewidth');\n    }\n  }\n  coerce('bgcolor');\n  var fitBounds = coerce('fitbounds');\n\n  // clear attributes that will get auto-filled later\n  if (fitBounds) {\n    delete geoLayoutOut.projection.scale;\n    if (isScoped) {\n      delete geoLayoutOut.center.lon;\n      delete geoLayoutOut.center.lat;\n    } else if (isClipped) {\n      delete geoLayoutOut.center.lon;\n      delete geoLayoutOut.center.lat;\n      delete geoLayoutOut.projection.rotation.lon;\n      delete geoLayoutOut.projection.rotation.lat;\n      delete geoLayoutOut.lonaxis.range;\n      delete geoLayoutOut.lataxis.range;\n    } else {\n      delete geoLayoutOut.center.lon;\n      delete geoLayoutOut.center.lat;\n      delete geoLayoutOut.projection.rotation.lon;\n    }\n  }\n}","map":{"version":3,"names":["Lib","require","handleSubplotDefaults","getSubplotData","constants","layoutAttributes","axesNames","module","exports","supplyLayoutDefaults","layoutIn","layoutOut","fullData","type","attributes","handleDefaults","handleGeoDefaults","partition","geoLayoutIn","geoLayoutOut","coerce","opts","subplotData","id","traceIndices","map","t","_expandedIndex","resolution","scope","scopeParams","scopeDefaults","projType","isAlbersUsa","_isAlbersUsa","isScoped","_isScoped","isSatellite","_isSatellite","isConic","_isConic","indexOf","isClipped","_isClipped","lonaxisSpan","visible","newTemplate","extendDeep","_template","showcoastlines","showcountries","showframe","showlakes","showland","showocean","showrivers","showsubunits","lonaxis","showgrid","lataxis","show","i","length","axisName","dtickDflt","rangeDflt","dfltSpans","hSpan","rot","substr","projRotate","range","undefined","_ax","_id","slice","_traceIndices","setScale","identity","c2l","r2l","autorange","_m","_input","lonRange","latRange","lon0","lon1","centerLon","projLon","dfltProjRotate","centerLonDflt","centerLatDflt","dfltProjParallels","projParallels","fitBounds","projection","scale","center","lon","lat","rotation"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/geo/layout_defaults.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar constants = require('./constants');\nvar layoutAttributes = require('./layout_attributes');\n\nvar axesNames = constants.axesNames;\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n        type: 'geo',\n        attributes: layoutAttributes,\n        handleDefaults: handleGeoDefaults,\n        fullData: fullData,\n        partition: 'y'\n    });\n};\n\nfunction handleGeoDefaults(geoLayoutIn, geoLayoutOut, coerce, opts) {\n    var subplotData = getSubplotData(opts.fullData, 'geo', opts.id);\n    var traceIndices = subplotData.map(function(t) { return t._expandedIndex; });\n\n    var resolution = coerce('resolution');\n    var scope = coerce('scope');\n    var scopeParams = constants.scopeDefaults[scope];\n\n    var projType = coerce('projection.type', scopeParams.projType);\n    var isAlbersUsa = geoLayoutOut._isAlbersUsa = projType === 'albers usa';\n\n    // no other scopes are allowed for 'albers usa' projection\n    if(isAlbersUsa) scope = geoLayoutOut.scope = 'usa';\n\n    var isScoped = geoLayoutOut._isScoped = (scope !== 'world');\n    var isSatellite = geoLayoutOut._isSatellite = projType === 'satellite';\n    var isConic = geoLayoutOut._isConic = projType.indexOf('conic') !== -1 || projType === 'albers';\n    var isClipped = geoLayoutOut._isClipped = !!constants.lonaxisSpan[projType];\n\n    if(geoLayoutIn.visible === false) {\n        // should override template.layout.geo.show* - see issue 4482\n\n        // make a copy\n        var newTemplate = Lib.extendDeep({}, geoLayoutOut._template);\n\n        // override show*\n        newTemplate.showcoastlines = false;\n        newTemplate.showcountries = false;\n        newTemplate.showframe = false;\n        newTemplate.showlakes = false;\n        newTemplate.showland = false;\n        newTemplate.showocean = false;\n        newTemplate.showrivers = false;\n        newTemplate.showsubunits = false;\n        if(newTemplate.lonaxis) newTemplate.lonaxis.showgrid = false;\n        if(newTemplate.lataxis) newTemplate.lataxis.showgrid = false;\n\n        // set ref to copy\n        geoLayoutOut._template = newTemplate;\n    }\n    var visible = coerce('visible');\n\n    var show;\n    for(var i = 0; i < axesNames.length; i++) {\n        var axisName = axesNames[i];\n        var dtickDflt = [30, 10][i];\n        var rangeDflt;\n\n        if(isScoped) {\n            rangeDflt = scopeParams[axisName + 'Range'];\n        } else {\n            var dfltSpans = constants[axisName + 'Span'];\n            var hSpan = (dfltSpans[projType] || dfltSpans['*']) / 2;\n            var rot = coerce(\n                'projection.rotation.' + axisName.substr(0, 3),\n                scopeParams.projRotate[i]\n            );\n            rangeDflt = [rot - hSpan, rot + hSpan];\n        }\n\n        var range = coerce(axisName + '.range', rangeDflt);\n        coerce(axisName + '.tick0');\n        coerce(axisName + '.dtick', dtickDflt);\n\n        show = coerce(axisName + '.showgrid', !visible ? false : undefined);\n        if(show) {\n            coerce(axisName + '.gridcolor');\n            coerce(axisName + '.gridwidth');\n            coerce(axisName + '.griddash');\n        }\n\n        // mock axis for autorange computations\n        geoLayoutOut[axisName]._ax = {\n            type: 'linear',\n            _id: axisName.slice(0, 3),\n            _traceIndices: traceIndices,\n            setScale: Lib.identity,\n            c2l: Lib.identity,\n            r2l: Lib.identity,\n            autorange: true,\n            range: range.slice(),\n            _m: 1,\n            _input: {}\n        };\n    }\n\n    var lonRange = geoLayoutOut.lonaxis.range;\n    var latRange = geoLayoutOut.lataxis.range;\n\n    // to cross antimeridian w/o ambiguity\n    var lon0 = lonRange[0];\n    var lon1 = lonRange[1];\n    if(lon0 > 0 && lon1 < 0) lon1 += 360;\n\n    var centerLon = (lon0 + lon1) / 2;\n    var projLon;\n\n    if(!isAlbersUsa) {\n        var dfltProjRotate = isScoped ? scopeParams.projRotate : [centerLon, 0, 0];\n\n        projLon = coerce('projection.rotation.lon', dfltProjRotate[0]);\n        coerce('projection.rotation.lat', dfltProjRotate[1]);\n        coerce('projection.rotation.roll', dfltProjRotate[2]);\n\n        show = coerce('showcoastlines', !isScoped && visible);\n        if(show) {\n            coerce('coastlinecolor');\n            coerce('coastlinewidth');\n        }\n\n        show = coerce('showocean', !visible ? false : undefined);\n        if(show) coerce('oceancolor');\n    }\n\n    var centerLonDflt;\n    var centerLatDflt;\n\n    if(isAlbersUsa) {\n        // 'albers usa' does not have a 'center',\n        // these values were found using via:\n        //   projection.invert([geoLayout.center.lon, geoLayoutIn.center.lat])\n        centerLonDflt = -96.6;\n        centerLatDflt = 38.7;\n    } else {\n        centerLonDflt = isScoped ? centerLon : projLon;\n        centerLatDflt = (latRange[0] + latRange[1]) / 2;\n    }\n\n    coerce('center.lon', centerLonDflt);\n    coerce('center.lat', centerLatDflt);\n\n    if(isSatellite) {\n        coerce('projection.tilt');\n        coerce('projection.distance');\n    }\n\n    if(isConic) {\n        var dfltProjParallels = scopeParams.projParallels || [0, 60];\n        coerce('projection.parallels', dfltProjParallels);\n    }\n\n    coerce('projection.scale');\n\n    show = coerce('showland', !visible ? false : undefined);\n    if(show) coerce('landcolor');\n\n    show = coerce('showlakes', !visible ? false : undefined);\n    if(show) coerce('lakecolor');\n\n    show = coerce('showrivers', !visible ? false : undefined);\n    if(show) {\n        coerce('rivercolor');\n        coerce('riverwidth');\n    }\n\n    show = coerce('showcountries', isScoped && scope !== 'usa' && visible);\n    if(show) {\n        coerce('countrycolor');\n        coerce('countrywidth');\n    }\n\n    if(scope === 'usa' || (scope === 'north america' && resolution === 50)) {\n        // Only works for:\n        //   USA states at 110m\n        //   USA states + Canada provinces at 50m\n        coerce('showsubunits', visible);\n        coerce('subunitcolor');\n        coerce('subunitwidth');\n    }\n\n    if(!isScoped) {\n        // Does not work in non-world scopes\n        show = coerce('showframe', visible);\n        if(show) {\n            coerce('framecolor');\n            coerce('framewidth');\n        }\n    }\n\n    coerce('bgcolor');\n\n    var fitBounds = coerce('fitbounds');\n\n    // clear attributes that will get auto-filled later\n    if(fitBounds) {\n        delete geoLayoutOut.projection.scale;\n\n        if(isScoped) {\n            delete geoLayoutOut.center.lon;\n            delete geoLayoutOut.center.lat;\n        } else if(isClipped) {\n            delete geoLayoutOut.center.lon;\n            delete geoLayoutOut.center.lat;\n            delete geoLayoutOut.projection.rotation.lon;\n            delete geoLayoutOut.projection.rotation.lat;\n            delete geoLayoutOut.lonaxis.range;\n            delete geoLayoutOut.lataxis.range;\n        } else {\n            delete geoLayoutOut.center.lon;\n            delete geoLayoutOut.center.lat;\n            delete geoLayoutOut.projection.rotation.lon;\n        }\n    }\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIC,qBAAqB,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC1D,IAAIE,cAAc,GAAGF,OAAO,CAAC,aAAa,CAAC,CAACE,cAAc;AAE1D,IAAIC,SAAS,GAAGH,OAAO,CAAC,aAAa,CAAC;AACtC,IAAII,gBAAgB,GAAGJ,OAAO,CAAC,qBAAqB,CAAC;AAErD,IAAIK,SAAS,GAAGF,SAAS,CAACE,SAAS;AAEnCC,MAAM,CAACC,OAAO,GAAG,SAASC,oBAAoBA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,EAAE;EAC1EV,qBAAqB,CAACQ,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,EAAE;IACjDC,IAAI,EAAE,KAAK;IACXC,UAAU,EAAET,gBAAgB;IAC5BU,cAAc,EAAEC,iBAAiB;IACjCJ,QAAQ,EAAEA,QAAQ;IAClBK,SAAS,EAAE;EACf,CAAC,CAAC;AACN,CAAC;AAED,SAASD,iBAAiBA,CAACE,WAAW,EAAEC,YAAY,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAChE,IAAIC,WAAW,GAAGnB,cAAc,CAACkB,IAAI,CAACT,QAAQ,EAAE,KAAK,EAAES,IAAI,CAACE,EAAE,CAAC;EAC/D,IAAIC,YAAY,GAAGF,WAAW,CAACG,GAAG,CAAC,UAASC,CAAC,EAAE;IAAE,OAAOA,CAAC,CAACC,cAAc;EAAE,CAAC,CAAC;EAE5E,IAAIC,UAAU,GAAGR,MAAM,CAAC,YAAY,CAAC;EACrC,IAAIS,KAAK,GAAGT,MAAM,CAAC,OAAO,CAAC;EAC3B,IAAIU,WAAW,GAAG1B,SAAS,CAAC2B,aAAa,CAACF,KAAK,CAAC;EAEhD,IAAIG,QAAQ,GAAGZ,MAAM,CAAC,iBAAiB,EAAEU,WAAW,CAACE,QAAQ,CAAC;EAC9D,IAAIC,WAAW,GAAGd,YAAY,CAACe,YAAY,GAAGF,QAAQ,KAAK,YAAY;;EAEvE;EACA,IAAGC,WAAW,EAAEJ,KAAK,GAAGV,YAAY,CAACU,KAAK,GAAG,KAAK;EAElD,IAAIM,QAAQ,GAAGhB,YAAY,CAACiB,SAAS,GAAIP,KAAK,KAAK,OAAQ;EAC3D,IAAIQ,WAAW,GAAGlB,YAAY,CAACmB,YAAY,GAAGN,QAAQ,KAAK,WAAW;EACtE,IAAIO,OAAO,GAAGpB,YAAY,CAACqB,QAAQ,GAAGR,QAAQ,CAACS,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,IAAIT,QAAQ,KAAK,QAAQ;EAC/F,IAAIU,SAAS,GAAGvB,YAAY,CAACwB,UAAU,GAAG,CAAC,CAACvC,SAAS,CAACwC,WAAW,CAACZ,QAAQ,CAAC;EAE3E,IAAGd,WAAW,CAAC2B,OAAO,KAAK,KAAK,EAAE;IAC9B;;IAEA;IACA,IAAIC,WAAW,GAAG9C,GAAG,CAAC+C,UAAU,CAAC,CAAC,CAAC,EAAE5B,YAAY,CAAC6B,SAAS,CAAC;;IAE5D;IACAF,WAAW,CAACG,cAAc,GAAG,KAAK;IAClCH,WAAW,CAACI,aAAa,GAAG,KAAK;IACjCJ,WAAW,CAACK,SAAS,GAAG,KAAK;IAC7BL,WAAW,CAACM,SAAS,GAAG,KAAK;IAC7BN,WAAW,CAACO,QAAQ,GAAG,KAAK;IAC5BP,WAAW,CAACQ,SAAS,GAAG,KAAK;IAC7BR,WAAW,CAACS,UAAU,GAAG,KAAK;IAC9BT,WAAW,CAACU,YAAY,GAAG,KAAK;IAChC,IAAGV,WAAW,CAACW,OAAO,EAAEX,WAAW,CAACW,OAAO,CAACC,QAAQ,GAAG,KAAK;IAC5D,IAAGZ,WAAW,CAACa,OAAO,EAAEb,WAAW,CAACa,OAAO,CAACD,QAAQ,GAAG,KAAK;;IAE5D;IACAvC,YAAY,CAAC6B,SAAS,GAAGF,WAAW;EACxC;EACA,IAAID,OAAO,GAAGzB,MAAM,CAAC,SAAS,CAAC;EAE/B,IAAIwC,IAAI;EACR,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvD,SAAS,CAACwD,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,IAAIE,QAAQ,GAAGzD,SAAS,CAACuD,CAAC,CAAC;IAC3B,IAAIG,SAAS,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAACH,CAAC,CAAC;IAC3B,IAAII,SAAS;IAEb,IAAG9B,QAAQ,EAAE;MACT8B,SAAS,GAAGnC,WAAW,CAACiC,QAAQ,GAAG,OAAO,CAAC;IAC/C,CAAC,MAAM;MACH,IAAIG,SAAS,GAAG9D,SAAS,CAAC2D,QAAQ,GAAG,MAAM,CAAC;MAC5C,IAAII,KAAK,GAAG,CAACD,SAAS,CAAClC,QAAQ,CAAC,IAAIkC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC;MACvD,IAAIE,GAAG,GAAGhD,MAAM,CACZ,sBAAsB,GAAG2C,QAAQ,CAACM,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAC9CvC,WAAW,CAACwC,UAAU,CAACT,CAAC,CAC5B,CAAC;MACDI,SAAS,GAAG,CAACG,GAAG,GAAGD,KAAK,EAAEC,GAAG,GAAGD,KAAK,CAAC;IAC1C;IAEA,IAAII,KAAK,GAAGnD,MAAM,CAAC2C,QAAQ,GAAG,QAAQ,EAAEE,SAAS,CAAC;IAClD7C,MAAM,CAAC2C,QAAQ,GAAG,QAAQ,CAAC;IAC3B3C,MAAM,CAAC2C,QAAQ,GAAG,QAAQ,EAAEC,SAAS,CAAC;IAEtCJ,IAAI,GAAGxC,MAAM,CAAC2C,QAAQ,GAAG,WAAW,EAAE,CAAClB,OAAO,GAAG,KAAK,GAAG2B,SAAS,CAAC;IACnE,IAAGZ,IAAI,EAAE;MACLxC,MAAM,CAAC2C,QAAQ,GAAG,YAAY,CAAC;MAC/B3C,MAAM,CAAC2C,QAAQ,GAAG,YAAY,CAAC;MAC/B3C,MAAM,CAAC2C,QAAQ,GAAG,WAAW,CAAC;IAClC;;IAEA;IACA5C,YAAY,CAAC4C,QAAQ,CAAC,CAACU,GAAG,GAAG;MACzB5D,IAAI,EAAE,QAAQ;MACd6D,GAAG,EAAEX,QAAQ,CAACY,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;MACzBC,aAAa,EAAEpD,YAAY;MAC3BqD,QAAQ,EAAE7E,GAAG,CAAC8E,QAAQ;MACtBC,GAAG,EAAE/E,GAAG,CAAC8E,QAAQ;MACjBE,GAAG,EAAEhF,GAAG,CAAC8E,QAAQ;MACjBG,SAAS,EAAE,IAAI;MACfV,KAAK,EAAEA,KAAK,CAACI,KAAK,CAAC,CAAC;MACpBO,EAAE,EAAE,CAAC;MACLC,MAAM,EAAE,CAAC;IACb,CAAC;EACL;EAEA,IAAIC,QAAQ,GAAGjE,YAAY,CAACsC,OAAO,CAACc,KAAK;EACzC,IAAIc,QAAQ,GAAGlE,YAAY,CAACwC,OAAO,CAACY,KAAK;;EAEzC;EACA,IAAIe,IAAI,GAAGF,QAAQ,CAAC,CAAC,CAAC;EACtB,IAAIG,IAAI,GAAGH,QAAQ,CAAC,CAAC,CAAC;EACtB,IAAGE,IAAI,GAAG,CAAC,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAI,GAAG;EAEpC,IAAIC,SAAS,GAAG,CAACF,IAAI,GAAGC,IAAI,IAAI,CAAC;EACjC,IAAIE,OAAO;EAEX,IAAG,CAACxD,WAAW,EAAE;IACb,IAAIyD,cAAc,GAAGvD,QAAQ,GAAGL,WAAW,CAACwC,UAAU,GAAG,CAACkB,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;IAE1EC,OAAO,GAAGrE,MAAM,CAAC,yBAAyB,EAAEsE,cAAc,CAAC,CAAC,CAAC,CAAC;IAC9DtE,MAAM,CAAC,yBAAyB,EAAEsE,cAAc,CAAC,CAAC,CAAC,CAAC;IACpDtE,MAAM,CAAC,0BAA0B,EAAEsE,cAAc,CAAC,CAAC,CAAC,CAAC;IAErD9B,IAAI,GAAGxC,MAAM,CAAC,gBAAgB,EAAE,CAACe,QAAQ,IAAIU,OAAO,CAAC;IACrD,IAAGe,IAAI,EAAE;MACLxC,MAAM,CAAC,gBAAgB,CAAC;MACxBA,MAAM,CAAC,gBAAgB,CAAC;IAC5B;IAEAwC,IAAI,GAAGxC,MAAM,CAAC,WAAW,EAAE,CAACyB,OAAO,GAAG,KAAK,GAAG2B,SAAS,CAAC;IACxD,IAAGZ,IAAI,EAAExC,MAAM,CAAC,YAAY,CAAC;EACjC;EAEA,IAAIuE,aAAa;EACjB,IAAIC,aAAa;EAEjB,IAAG3D,WAAW,EAAE;IACZ;IACA;IACA;IACA0D,aAAa,GAAG,CAAC,IAAI;IACrBC,aAAa,GAAG,IAAI;EACxB,CAAC,MAAM;IACHD,aAAa,GAAGxD,QAAQ,GAAGqD,SAAS,GAAGC,OAAO;IAC9CG,aAAa,GAAG,CAACP,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC;EACnD;EAEAjE,MAAM,CAAC,YAAY,EAAEuE,aAAa,CAAC;EACnCvE,MAAM,CAAC,YAAY,EAAEwE,aAAa,CAAC;EAEnC,IAAGvD,WAAW,EAAE;IACZjB,MAAM,CAAC,iBAAiB,CAAC;IACzBA,MAAM,CAAC,qBAAqB,CAAC;EACjC;EAEA,IAAGmB,OAAO,EAAE;IACR,IAAIsD,iBAAiB,GAAG/D,WAAW,CAACgE,aAAa,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC;IAC5D1E,MAAM,CAAC,sBAAsB,EAAEyE,iBAAiB,CAAC;EACrD;EAEAzE,MAAM,CAAC,kBAAkB,CAAC;EAE1BwC,IAAI,GAAGxC,MAAM,CAAC,UAAU,EAAE,CAACyB,OAAO,GAAG,KAAK,GAAG2B,SAAS,CAAC;EACvD,IAAGZ,IAAI,EAAExC,MAAM,CAAC,WAAW,CAAC;EAE5BwC,IAAI,GAAGxC,MAAM,CAAC,WAAW,EAAE,CAACyB,OAAO,GAAG,KAAK,GAAG2B,SAAS,CAAC;EACxD,IAAGZ,IAAI,EAAExC,MAAM,CAAC,WAAW,CAAC;EAE5BwC,IAAI,GAAGxC,MAAM,CAAC,YAAY,EAAE,CAACyB,OAAO,GAAG,KAAK,GAAG2B,SAAS,CAAC;EACzD,IAAGZ,IAAI,EAAE;IACLxC,MAAM,CAAC,YAAY,CAAC;IACpBA,MAAM,CAAC,YAAY,CAAC;EACxB;EAEAwC,IAAI,GAAGxC,MAAM,CAAC,eAAe,EAAEe,QAAQ,IAAIN,KAAK,KAAK,KAAK,IAAIgB,OAAO,CAAC;EACtE,IAAGe,IAAI,EAAE;IACLxC,MAAM,CAAC,cAAc,CAAC;IACtBA,MAAM,CAAC,cAAc,CAAC;EAC1B;EAEA,IAAGS,KAAK,KAAK,KAAK,IAAKA,KAAK,KAAK,eAAe,IAAID,UAAU,KAAK,EAAG,EAAE;IACpE;IACA;IACA;IACAR,MAAM,CAAC,cAAc,EAAEyB,OAAO,CAAC;IAC/BzB,MAAM,CAAC,cAAc,CAAC;IACtBA,MAAM,CAAC,cAAc,CAAC;EAC1B;EAEA,IAAG,CAACe,QAAQ,EAAE;IACV;IACAyB,IAAI,GAAGxC,MAAM,CAAC,WAAW,EAAEyB,OAAO,CAAC;IACnC,IAAGe,IAAI,EAAE;MACLxC,MAAM,CAAC,YAAY,CAAC;MACpBA,MAAM,CAAC,YAAY,CAAC;IACxB;EACJ;EAEAA,MAAM,CAAC,SAAS,CAAC;EAEjB,IAAI2E,SAAS,GAAG3E,MAAM,CAAC,WAAW,CAAC;;EAEnC;EACA,IAAG2E,SAAS,EAAE;IACV,OAAO5E,YAAY,CAAC6E,UAAU,CAACC,KAAK;IAEpC,IAAG9D,QAAQ,EAAE;MACT,OAAOhB,YAAY,CAAC+E,MAAM,CAACC,GAAG;MAC9B,OAAOhF,YAAY,CAAC+E,MAAM,CAACE,GAAG;IAClC,CAAC,MAAM,IAAG1D,SAAS,EAAE;MACjB,OAAOvB,YAAY,CAAC+E,MAAM,CAACC,GAAG;MAC9B,OAAOhF,YAAY,CAAC+E,MAAM,CAACE,GAAG;MAC9B,OAAOjF,YAAY,CAAC6E,UAAU,CAACK,QAAQ,CAACF,GAAG;MAC3C,OAAOhF,YAAY,CAAC6E,UAAU,CAACK,QAAQ,CAACD,GAAG;MAC3C,OAAOjF,YAAY,CAACsC,OAAO,CAACc,KAAK;MACjC,OAAOpD,YAAY,CAACwC,OAAO,CAACY,KAAK;IACrC,CAAC,MAAM;MACH,OAAOpD,YAAY,CAAC+E,MAAM,CAACC,GAAG;MAC9B,OAAOhF,YAAY,CAAC+E,MAAM,CAACE,GAAG;MAC9B,OAAOjF,YAAY,CAAC6E,UAAU,CAACK,QAAQ,CAACF,GAAG;IAC/C;EACJ;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script"}