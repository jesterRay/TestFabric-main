{"ast":null,"code":"'use strict';\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar rgba = require('color-normalize');\nvar getBounds = require('array-bounds');\nvar colorId = require('color-id');\nvar cluster = require('@plotly/point-cluster');\nvar extend = require('object-assign');\nvar glslify = require('glslify');\nvar pick = require('pick-by-alias');\nvar updateDiff = require('update-diff');\nvar flatten = require('flatten-vertex-data');\nvar ie = require('is-iexplorer');\nvar f32 = require('to-float32');\nvar parseRect = require('parse-rect');\nvar scatter = Scatter;\nfunction Scatter(regl, options) {\n  var _this = this;\n  if (!(this instanceof Scatter)) return new Scatter(regl, options);\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n    regl = null;\n  }\n  if (options && options.length) options.positions = options;\n  regl = options.regl;\n\n  // persistent variables\n  var gl = regl._gl,\n    paletteTexture,\n    palette = [],\n    paletteIds = {},\n    // state\n    groups = [],\n    // textures for marker keys\n    markerTextures = [null],\n    markerCache = [null];\n  var maxColors = 255,\n    maxSize = 100;\n\n  // direct color buffer mode\n  // IE does not support palette anyways\n  this.tooManyColors = ie;\n\n  // texture with color palette\n  paletteTexture = regl.texture({\n    data: new Uint8Array(maxColors * 4),\n    width: maxColors,\n    height: 1,\n    type: 'uint8',\n    format: 'rgba',\n    wrapS: 'clamp',\n    wrapT: 'clamp',\n    mag: 'nearest',\n    min: 'nearest'\n  });\n  extend(this, {\n    regl: regl,\n    gl: gl,\n    groups: groups,\n    markerCache: markerCache,\n    markerTextures: markerTextures,\n    palette: palette,\n    paletteIds: paletteIds,\n    paletteTexture: paletteTexture,\n    maxColors: maxColors,\n    maxSize: maxSize,\n    canvas: gl.canvas\n  });\n  this.update(options);\n\n  // common shader options\n  var shaderOptions = {\n    uniforms: {\n      constPointSize: !!options.constPointSize,\n      opacity: regl.prop('opacity'),\n      paletteSize: function paletteSize(ctx, prop) {\n        return [_this.tooManyColors ? 0 : maxColors, paletteTexture.height];\n      },\n      pixelRatio: regl.context('pixelRatio'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translate: regl.prop('translate'),\n      translateFract: regl.prop('translateFract'),\n      markerTexture: regl.prop('markerTexture'),\n      paletteTexture: paletteTexture\n    },\n    attributes: {\n      // FIXME: optimize these parts\n      x: function x(ctx, prop) {\n        return prop.xAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      y: function y(ctx, prop) {\n        return prop.yAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      xFract: function xFract(ctx, prop) {\n        return prop.xAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      yFract: function yFract(ctx, prop) {\n        return prop.yAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      size: function size(ctx, prop) {\n        return prop.size.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 0\n        } : {\n          constant: [Math.round(prop.size * 255 / _this.maxSize)]\n        };\n      },\n      borderSize: function borderSize(ctx, prop) {\n        return prop.borderSize.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 1\n        } : {\n          constant: [Math.round(prop.borderSize * 255 / _this.maxSize)]\n        };\n      },\n      colorId: function colorId(ctx, prop) {\n        return prop.color.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: 0\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [prop.color]\n        };\n      },\n      borderColorId: function borderColorId(ctx, prop) {\n        return prop.borderColor.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: _this.tooManyColors ? 4 : 2\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [prop.borderColor]\n        };\n      },\n      isActive: function isActive(ctx, prop) {\n        return prop.activation === true ? {\n          constant: [1]\n        } : prop.activation ? prop.activation : {\n          constant: [0]\n        };\n      }\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      // photoshop blending\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    elements: regl.prop('elements'),\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    primitive: 'points'\n  };\n\n  // draw sdf-marker\n  var markerOptions = extend({}, shaderOptions);\n  markerOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float opacity;\\nuniform sampler2D markerTexture;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat smoothStep(float x, float y) {\\n  return 1.0 / (1.0 + exp(50.0*(x - y)));\\n}\\n\\nvoid main() {\\n  float dist = texture2D(markerTexture, gl_PointCoord).r, delta = fragWidth;\\n\\n  // max-distance alpha\\n  if (dist < 0.003) discard;\\n\\n  // null-border case\\n  if (fragBorderColorLevel == fragColorLevel || fragBorderColor.a == 0.) {\\n    float colorAmt = smoothstep(.5 - delta, .5 + delta, dist);\\n    gl_FragColor = vec4(fragColor.rgb, colorAmt * fragColor.a * opacity);\\n  }\\n  else {\\n    float borderColorAmt = smoothstep(fragBorderColorLevel - delta, fragBorderColorLevel + delta, dist);\\n    float colorAmt = smoothstep(fragColorLevel - delta, fragColorLevel + delta, dist);\\n\\n    vec4 color = fragBorderColor;\\n    color.a *= borderColorAmt;\\n    color = mix(color, fragColor, colorAmt);\\n    color.a *= opacity;\\n\\n    gl_FragColor = color;\\n  }\\n\\n}\\n\"]);\n  markerOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\n// `invariant` effectively turns off optimizations for the position.\\n// We need this because -fast-math on M1 Macs is re-ordering\\n// floating point operations in a way that causes floating point\\n// precision limits to put points in the wrong locations.\\ninvariant gl_Position;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 scale, scaleFract, translate, translateFract, paletteSize;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\nconst float borderLevel = .5;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragPointSize, fragBorderRadius, fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = 2. * size * pointSizeScale;\\n  fragPointSize = size * pixelRatio;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragColor = color;\\n  fragBorderColor = borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n\\n  fragBorderColorLevel = clamp(borderLevel - borderLevel * borderSize / size, 0., 1.);\\n  fragColorLevel = clamp(borderLevel + (1. - borderLevel) * borderSize / size, 0., 1.);\\n}\\n\"]);\n  this.drawMarker = regl(markerOptions);\n\n  // draw circle\n  var circleOptions = extend({}, shaderOptions);\n  circleOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nuniform float opacity;\\n\\nfloat smoothStep(float edge0, float edge1, float x) {\\n\\tfloat t;\\n\\tt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\treturn t * t * (3.0 - 2.0 * t);\\n}\\n\\nvoid main() {\\n\\tfloat radius, alpha = 1.0, delta = fragWidth;\\n\\n\\tradius = length(2.0 * gl_PointCoord.xy - 1.0);\\n\\n\\tif (radius > 1.0 + delta) {\\n\\t\\tdiscard;\\n\\t}\\n\\n\\talpha -= smoothstep(1.0 - delta, 1.0 + delta, radius);\\n\\n\\tfloat borderRadius = fragBorderRadius;\\n\\tfloat ratio = smoothstep(borderRadius - delta, borderRadius + delta, radius);\\n\\tvec4 color = mix(fragColor, fragBorderColor, ratio);\\n\\tcolor.a *= alpha * opacity;\\n\\tgl_FragColor = color;\\n}\\n\"]);\n  circleOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\n// `invariant` effectively turns off optimizations for the position.\\n// We need this because -fast-math on M1 Macs is re-ordering\\n// floating point operations in a way that causes floating point\\n// precision limits to put points in the wrong locations.\\ninvariant gl_Position;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 paletteSize, scale, scaleFract, translate, translateFract;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = (size + borderSize) * pointSizeScale;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragBorderRadius = 1. - 2. * borderSize / (size + borderSize);\\n  fragColor = color;\\n  fragBorderColor = borderColor.a == 0. || borderSize == 0. ? vec4(color.rgb, 0.) : borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n}\\n\"]);\n\n  // polyfill IE\n  if (ie) {\n    circleOptions.frag = circleOptions.frag.replace('smoothstep', 'smoothStep');\n    markerOptions.frag = markerOptions.frag.replace('smoothstep', 'smoothStep');\n  }\n  this.drawCircle = regl(circleOptions);\n}\n\n// single pass defaults\nScatter.defaults = {\n  color: 'black',\n  borderColor: 'transparent',\n  borderSize: 0,\n  size: 12,\n  opacity: 1,\n  marker: undefined,\n  viewport: null,\n  range: null,\n  pixelSize: null,\n  count: 0,\n  offset: 0,\n  bounds: null,\n  positions: [],\n  snap: 1e4\n};\n\n// update & redraw\nScatter.prototype.render = function () {\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n  this.draw();\n  return this;\n};\n\n// draw all groups or only indicated ones\nScatter.prototype.draw = function () {\n  var _this2 = this;\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var groups = this.groups;\n\n  // if directly array passed - treat as passes\n  if (args.length === 1 && Array.isArray(args[0]) && (args[0][0] === null || Array.isArray(args[0][0]))) {\n    args = args[0];\n  }\n\n  // FIXME: remove once https://github.com/regl-project/regl/issues/474 resolved\n  this.regl._refresh();\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      this.drawItem(i, args[i]);\n    }\n  }\n  // draw all passes\n  else {\n    groups.forEach(function (group, i) {\n      _this2.drawItem(i);\n    });\n  }\n  return this;\n};\n\n// draw specific scatter group\nScatter.prototype.drawItem = function (id, els) {\n  var groups = this.groups;\n  var group = groups[id];\n\n  // debug viewport\n  // let { viewport } = group\n  // gl.enable(gl.SCISSOR_TEST);\n  // gl.scissor(viewport.x, viewport.y, viewport.width, viewport.height);\n  // gl.clearColor(0, 0, 0, .5);\n  // gl.clear(gl.COLOR_BUFFER_BIT);\n\n  if (typeof els === 'number') {\n    id = els;\n    group = groups[els];\n    els = null;\n  }\n  if (!(group && group.count && group.opacity)) return;\n\n  // draw circles\n  if (group.activation[0]) {\n    // TODO: optimize this performance by making groups and regl.this props\n    this.drawCircle(this.getMarkerDrawOptions(0, group, els));\n  }\n\n  // draw all other available markers\n  var batch = [];\n  for (var i = 1; i < group.activation.length; i++) {\n    if (!group.activation[i] || group.activation[i] !== true && !group.activation[i].data.length) continue;\n    batch.push.apply(batch, _toConsumableArray(this.getMarkerDrawOptions(i, group, els)));\n  }\n  if (batch.length) {\n    this.drawMarker(batch);\n  }\n};\n\n// get options for the marker ids\nScatter.prototype.getMarkerDrawOptions = function (markerId, group, elements) {\n  var range = group.range,\n    tree = group.tree,\n    viewport = group.viewport,\n    activation = group.activation,\n    selectionBuffer = group.selectionBuffer,\n    count = group.count;\n  var regl = this.regl;\n\n  // direct points\n  if (!tree) {\n    // if elements array - draw unclustered points\n    if (elements) {\n      return [extend({}, group, {\n        markerTexture: this.markerTextures[markerId],\n        activation: activation[markerId],\n        count: elements.length,\n        elements: elements,\n        offset: 0\n      })];\n    }\n    return [extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: activation[markerId],\n      offset: 0\n    })];\n  }\n\n  // clustered points\n  var batch = [];\n  var lod = tree.range(range, {\n    lod: true,\n    px: [(range[2] - range[0]) / viewport.width, (range[3] - range[1]) / viewport.height]\n  });\n\n  // enable elements by using selection buffer\n  if (elements) {\n    var markerActivation = activation[markerId];\n    var mask = markerActivation.data;\n    var data = new Uint8Array(count);\n    for (var i = 0; i < elements.length; i++) {\n      var id = elements[i];\n      data[id] = mask ? mask[id] : 1;\n    }\n    selectionBuffer.subdata(data);\n  }\n  for (var l = lod.length; l--;) {\n    var _lod$l = _slicedToArray(lod[l], 2),\n      from = _lod$l[0],\n      to = _lod$l[1];\n    batch.push(extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: elements ? selectionBuffer : activation[markerId],\n      offset: from,\n      count: to - from\n    }));\n  }\n  return batch;\n};\n\n// update groups options\nScatter.prototype.update = function () {\n  var _this3 = this;\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  if (!args.length) return;\n\n  // passes are as single array\n  if (args.length === 1 && Array.isArray(args[0])) args = args[0];\n  var groups = this.groups,\n    gl = this.gl,\n    regl = this.regl,\n    maxSize = this.maxSize,\n    maxColors = this.maxColors,\n    palette = this.palette;\n  this.groups = groups = args.map(function (options, i) {\n    var group = groups[i];\n    if (options === undefined) return group;\n    if (options === null) options = {\n      positions: null\n    };else if (typeof options === 'function') options = {\n      ondraw: options\n    };else if (typeof options[0] === 'number') options = {\n      positions: options\n    };\n\n    // copy options to avoid mutation & handle aliases\n    options = pick(options, {\n      positions: 'positions data points',\n      snap: 'snap cluster lod tree',\n      size: 'sizes size radius',\n      borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n      color: 'colors color fill fill-color fillColor',\n      borderColor: 'borderColors borderColor stroke stroke-color strokeColor',\n      marker: 'markers marker shape',\n      range: 'range dataBox databox',\n      viewport: 'viewport viewPort viewBox viewbox',\n      opacity: 'opacity alpha transparency',\n      bounds: 'bound bounds boundaries limits',\n      tooManyColors: 'tooManyColors palette paletteMode optimizePalette enablePalette'\n    });\n    if (options.positions === null) options.positions = [];\n    if (options.tooManyColors != null) _this3.tooManyColors = options.tooManyColors;\n    if (!group) {\n      groups[i] = group = {\n        id: i,\n        scale: null,\n        translate: null,\n        scaleFract: null,\n        translateFract: null,\n        // buffers for active markers\n        activation: [],\n        // buffer for filtered markers\n        selectionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'stream',\n          type: 'uint8'\n        }),\n        // buffers with data: it is faster to switch them per-pass\n        // than provide one congregate buffer\n        sizeBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        colorBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        positionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        }),\n        positionFractBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        })\n      };\n      options = extend({}, Scatter.defaults, options);\n    }\n\n    // force update triggers\n    if (options.positions && !('marker' in options)) {\n      options.marker = group.marker;\n      delete group.marker;\n    }\n\n    // updating markers cause recalculating snapping\n    if (options.marker && !('positions' in options)) {\n      options.positions = group.positions;\n      delete group.positions;\n    }\n\n    // global count of points\n    var hasSize = 0,\n      hasColor = 0;\n    updateDiff(group, options, [{\n      snap: true,\n      size: function size(s, group) {\n        if (s == null) s = Scatter.defaults.size;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      borderSize: function borderSize(s, group) {\n        if (s == null) s = Scatter.defaults.borderSize;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      opacity: parseFloat,\n      // add colors to palette, save references\n      color: function color(c, group) {\n        if (c == null) c = Scatter.defaults.color;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      borderColor: function borderColor(c, group) {\n        if (c == null) c = Scatter.defaults.borderColor;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      bounds: function bounds(_bounds, group, options) {\n        if (!('range' in options)) options.range = null;\n        return _bounds;\n      },\n      positions: function positions(_positions, group, options) {\n        var snap = group.snap;\n        var positionBuffer = group.positionBuffer,\n          positionFractBuffer = group.positionFractBuffer,\n          selectionBuffer = group.selectionBuffer;\n\n        // separate buffers for x/y coordinates\n        if (_positions.x || _positions.y) {\n          if (_positions.x.length) {\n            group.xAttr = {\n              buffer: regl.buffer(_positions.x),\n              offset: 0,\n              stride: 4,\n              count: _positions.x.length\n            };\n          } else {\n            group.xAttr = {\n              buffer: _positions.x.buffer,\n              offset: _positions.x.offset * 4 || 0,\n              stride: (_positions.x.stride || 1) * 4,\n              count: _positions.x.count\n            };\n          }\n          if (_positions.y.length) {\n            group.yAttr = {\n              buffer: regl.buffer(_positions.y),\n              offset: 0,\n              stride: 4,\n              count: _positions.y.length\n            };\n          } else {\n            group.yAttr = {\n              buffer: _positions.y.buffer,\n              offset: _positions.y.offset * 4 || 0,\n              stride: (_positions.y.stride || 1) * 4,\n              count: _positions.y.count\n            };\n          }\n          group.count = Math.max(group.xAttr.count, group.yAttr.count);\n          return _positions;\n        }\n        _positions = flatten(_positions, 'float64');\n        var count = group.count = Math.floor(_positions.length / 2);\n        var bounds = group.bounds = count ? getBounds(_positions, 2) : null;\n\n        // if range is not provided updated - recalc it\n        if (!options.range && !group.range) {\n          delete group.range;\n          options.range = bounds;\n        }\n\n        // reset marker\n        if (!options.marker && !group.marker) {\n          delete group.marker;\n          options.marker = null;\n        }\n\n        // build cluster tree if required\n        if (snap && (snap === true || count > snap)) {\n          group.tree = cluster(_positions, {\n            bounds: bounds\n          });\n        }\n        // existing tree instance\n        else if (snap && snap.length) {\n          group.tree = snap;\n        }\n        if (group.tree) {\n          var opts = {\n            primitive: 'points',\n            usage: 'static',\n            data: group.tree,\n            type: 'uint32'\n          };\n          if (group.elements) group.elements(opts);else group.elements = regl.elements(opts);\n        }\n\n        // update position buffers\n        var float_data = f32.float32(_positions);\n        positionBuffer({\n          data: float_data,\n          usage: 'dynamic'\n        });\n        var frac_data = f32.fract32(_positions, float_data);\n        positionFractBuffer({\n          data: frac_data,\n          usage: 'dynamic'\n        });\n\n        // expand selectionBuffer\n        selectionBuffer({\n          data: new Uint8Array(count),\n          type: 'uint8',\n          usage: 'stream'\n        });\n        return _positions;\n      }\n    }, {\n      // create marker ids corresponding to known marker textures\n      marker: function marker(markers, group, options) {\n        var activation = group.activation;\n\n        // reset marker elements\n        activation.forEach(function (buffer) {\n          return buffer && buffer.destroy && buffer.destroy();\n        });\n        activation.length = 0;\n\n        // single sdf marker\n        if (!markers || typeof markers[0] === 'number') {\n          var id = _this3.addMarker(markers);\n          activation[id] = true;\n        }\n\n        // per-point markers use mask buffers to enable markers in vert shader\n        else {\n          var markerMasks = [];\n          for (var _i = 0, l = Math.min(markers.length, group.count); _i < l; _i++) {\n            var _id = _this3.addMarker(markers[_i]);\n            if (!markerMasks[_id]) markerMasks[_id] = new Uint8Array(group.count);\n\n            // enable marker by default\n            markerMasks[_id][_i] = 1;\n          }\n          for (var _id2 = 0; _id2 < markerMasks.length; _id2++) {\n            if (!markerMasks[_id2]) continue;\n            var opts = {\n              data: markerMasks[_id2],\n              type: 'uint8',\n              usage: 'static'\n            };\n            if (!activation[_id2]) {\n              activation[_id2] = regl.buffer(opts);\n            } else {\n              activation[_id2](opts);\n            }\n            activation[_id2].data = markerMasks[_id2];\n          }\n        }\n        return markers;\n      },\n      range: function range(_range, group, options) {\n        var bounds = group.bounds;\n\n        // FIXME: why do we need this?\n        if (!bounds) return;\n        if (!_range) _range = bounds;\n        group.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];\n        group.translate = [-_range[0], -_range[1]];\n        group.scaleFract = f32.fract(group.scale);\n        group.translateFract = f32.fract(group.translate);\n        return _range;\n      },\n      viewport: function viewport(vp) {\n        var rect = parseRect(vp || [gl.drawingBufferWidth, gl.drawingBufferHeight]);\n\n        // normalize viewport to the canvas coordinates\n        // rect.y = gl.drawingBufferHeight - rect.height - rect.y\n\n        return rect;\n      }\n    }]);\n\n    // update size buffer, if needed\n    if (hasSize) {\n      var _group = group,\n        count = _group.count,\n        size = _group.size,\n        borderSize = _group.borderSize,\n        sizeBuffer = _group.sizeBuffer;\n      var sizes = new Uint8Array(count * 2);\n      if (size.length || borderSize.length) {\n        for (var _i2 = 0; _i2 < count; _i2++) {\n          // we downscale size to allow for fractions\n          sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);\n          sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);\n        }\n      }\n      sizeBuffer({\n        data: sizes,\n        usage: 'dynamic'\n      });\n    }\n\n    // update color buffer if needed\n    if (hasColor) {\n      var _group2 = group,\n        _count = _group2.count,\n        color = _group2.color,\n        borderColor = _group2.borderColor,\n        colorBuffer = _group2.colorBuffer;\n      var colors;\n\n      // if too many colors - put colors to buffer directly\n      if (_this3.tooManyColors) {\n        if (color.length || borderColor.length) {\n          colors = new Uint8Array(_count * 8);\n          for (var _i3 = 0; _i3 < _count; _i3++) {\n            var _colorId = color[_i3];\n            colors[_i3 * 8] = palette[_colorId * 4];\n            colors[_i3 * 8 + 1] = palette[_colorId * 4 + 1];\n            colors[_i3 * 8 + 2] = palette[_colorId * 4 + 2];\n            colors[_i3 * 8 + 3] = palette[_colorId * 4 + 3];\n            var borderColorId = borderColor[_i3];\n            colors[_i3 * 8 + 4] = palette[borderColorId * 4];\n            colors[_i3 * 8 + 5] = palette[borderColorId * 4 + 1];\n            colors[_i3 * 8 + 6] = palette[borderColorId * 4 + 2];\n            colors[_i3 * 8 + 7] = palette[borderColorId * 4 + 3];\n          }\n        }\n      }\n\n      // if limited amount of colors - keep palette color picking\n      // that saves significant memory\n      else {\n        if (color.length || borderColor.length) {\n          // we need slight data increase by 2 due to vec4 borderId in shader\n          colors = new Uint8Array(_count * 4 + 2);\n          for (var _i4 = 0; _i4 < _count; _i4++) {\n            // put color coords in palette texture\n            if (color[_i4] != null) {\n              colors[_i4 * 4] = color[_i4] % maxColors;\n              colors[_i4 * 4 + 1] = Math.floor(color[_i4] / maxColors);\n            }\n            if (borderColor[_i4] != null) {\n              colors[_i4 * 4 + 2] = borderColor[_i4] % maxColors;\n              colors[_i4 * 4 + 3] = Math.floor(borderColor[_i4] / maxColors);\n            }\n          }\n        }\n      }\n      colorBuffer({\n        data: colors || new Uint8Array(0),\n        type: 'uint8',\n        usage: 'dynamic'\n      });\n    }\n    return group;\n  });\n};\n\n// get (and create) marker texture id\nScatter.prototype.addMarker = function (sdf) {\n  var markerTextures = this.markerTextures,\n    regl = this.regl,\n    markerCache = this.markerCache;\n  var pos = sdf == null ? 0 : markerCache.indexOf(sdf);\n  if (pos >= 0) return pos;\n\n  // convert sdf to 0..255 range\n  var distArr;\n  if (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {\n    distArr = sdf;\n  } else {\n    distArr = new Uint8Array(sdf.length);\n    for (var i = 0, l = sdf.length; i < l; i++) {\n      distArr[i] = sdf[i] * 255;\n    }\n  }\n  var radius = Math.floor(Math.sqrt(distArr.length));\n  pos = markerTextures.length;\n  markerCache.push(sdf);\n  markerTextures.push(regl.texture({\n    channels: 1,\n    data: distArr,\n    radius: radius,\n    mag: 'linear',\n    min: 'linear'\n  }));\n  return pos;\n};\n\n// register color to palette, return it's index or list of indexes\nScatter.prototype.updateColor = function (colors) {\n  var paletteIds = this.paletteIds,\n    palette = this.palette,\n    maxColors = this.maxColors;\n  if (!Array.isArray(colors)) {\n    colors = [colors];\n  }\n  var idx = [];\n\n  // if color groups - flatten them\n  if (typeof colors[0] === 'number') {\n    var grouped = [];\n    if (Array.isArray(colors)) {\n      for (var i = 0; i < colors.length; i += 4) {\n        grouped.push(colors.slice(i, i + 4));\n      }\n    } else {\n      for (var _i5 = 0; _i5 < colors.length; _i5 += 4) {\n        grouped.push(colors.subarray(_i5, _i5 + 4));\n      }\n    }\n    colors = grouped;\n  }\n  for (var _i6 = 0; _i6 < colors.length; _i6++) {\n    var color = colors[_i6];\n    color = rgba(color, 'uint8');\n    var id = colorId(color, false);\n\n    // if new color - save it\n    if (paletteIds[id] == null) {\n      var pos = palette.length;\n      paletteIds[id] = Math.floor(pos / 4);\n      palette[pos] = color[0];\n      palette[pos + 1] = color[1];\n      palette[pos + 2] = color[2];\n      palette[pos + 3] = color[3];\n    }\n    idx[_i6] = paletteIds[id];\n  }\n\n  // detect if too many colors in palette\n  if (!this.tooManyColors && palette.length > maxColors * 4) this.tooManyColors = true;\n\n  // limit max color\n  this.updatePalette(palette);\n\n  // keep static index for single-color property\n  return idx.length === 1 ? idx[0] : idx;\n};\nScatter.prototype.updatePalette = function (palette) {\n  if (this.tooManyColors) return;\n  var maxColors = this.maxColors,\n    paletteTexture = this.paletteTexture;\n  var requiredHeight = Math.ceil(palette.length * .25 / maxColors);\n\n  // pad data\n  if (requiredHeight > 1) {\n    palette = palette.slice();\n    for (var i = palette.length * .25 % maxColors; i < requiredHeight * maxColors; i++) {\n      palette.push(0, 0, 0, 0);\n    }\n  }\n\n  // ensure height\n  if (paletteTexture.height < requiredHeight) {\n    paletteTexture.resize(maxColors, requiredHeight);\n  }\n\n  // update full data\n  paletteTexture.subimage({\n    width: Math.min(palette.length * .25, maxColors),\n    height: requiredHeight,\n    data: palette\n  }, 0, 0);\n};\n\n// remove unused stuff\nScatter.prototype.destroy = function () {\n  this.groups.forEach(function (group) {\n    group.sizeBuffer.destroy();\n    group.positionBuffer.destroy();\n    group.positionFractBuffer.destroy();\n    group.colorBuffer.destroy();\n    group.activation.forEach(function (b) {\n      return b && b.destroy && b.destroy();\n    });\n    group.selectionBuffer.destroy();\n    if (group.elements) group.elements.destroy();\n  });\n  this.groups.length = 0;\n  this.paletteTexture.destroy();\n  this.markerTextures.forEach(function (txt) {\n    return txt && txt.destroy && txt.destroy();\n  });\n  return this;\n};\nvar extend$1 = require('object-assign');\nvar reglScatter2d = function reglScatter2d(regl, options) {\n  var scatter$1 = new scatter(regl, options);\n  var render = scatter$1.render.bind(scatter$1);\n\n  // expose API\n  extend$1(render, {\n    render: render,\n    update: scatter$1.update.bind(scatter$1),\n    draw: scatter$1.draw.bind(scatter$1),\n    destroy: scatter$1.destroy.bind(scatter$1),\n    regl: scatter$1.regl,\n    gl: scatter$1.gl,\n    canvas: scatter$1.gl.canvas,\n    groups: scatter$1.groups,\n    markers: scatter$1.markerCache,\n    palette: scatter$1.palette\n  });\n  return render;\n};\nmodule.exports = reglScatter2d;","map":{"version":3,"names":["_iterableToArrayLimit","arr","i","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","call","next","Object","done","push","value","length","err","return","_slicedToArray","_arrayWithHoles","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","prototype","toString","slice","constructor","name","test","len","arr2","TypeError","rgba","require","getBounds","colorId","cluster","extend","glslify","pick","updateDiff","flatten","ie","f32","parseRect","scatter","Scatter","regl","options","_this","positions","gl","_gl","paletteTexture","palette","paletteIds","groups","markerTextures","markerCache","maxColors","maxSize","tooManyColors","texture","data","Uint8Array","width","height","type","format","wrapS","wrapT","mag","min","canvas","update","shaderOptions","uniforms","constPointSize","opacity","prop","paletteSize","ctx","pixelRatio","context","scale","scaleFract","translate","translateFract","markerTexture","attributes","x","xAttr","buffer","positionBuffer","stride","offset","y","yAttr","xFract","constant","positionFractBuffer","yFract","size","sizeBuffer","Math","round","borderSize","color","colorBuffer","borderColorId","borderColor","isActive","activation","blend","enable","func","srcRGB","dstRGB","srcAlpha","dstAlpha","scissor","box","viewport","stencil","depth","elements","count","primitive","markerOptions","frag","vert","drawMarker","circleOptions","replace","drawCircle","defaults","marker","undefined","range","pixelSize","bounds","snap","render","arguments","apply","draw","_this2","_len","args","_key","_refresh","drawItem","forEach","group","id","els","getMarkerDrawOptions","batch","markerId","tree","selectionBuffer","lod","px","markerActivation","mask","subdata","l","_lod$l","to","_this3","_len2","_key2","map","ondraw","usage","hasSize","hasColor","s","parseFloat","c","updateColor","_bounds","_positions","max","floor","opts","float_data","float32","frac_data","fract32","markers","destroy","addMarker","markerMasks","_id","_id2","_range","fract","vp","rect","drawingBufferWidth","drawingBufferHeight","_group","sizes","_i2","_group2","_count","colors","_i3","_colorId","_i4","sdf","pos","indexOf","distArr","Uint8ClampedArray","radius","sqrt","channels","idx","grouped","_i5","subarray","_i6","updatePalette","requiredHeight","ceil","resize","subimage","b","txt","extend$1","reglScatter2d","scatter$1","bind","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/regl-scatter2d/bundle.js"],"sourcesContent":["'use strict';\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar rgba = require('color-normalize');\nvar getBounds = require('array-bounds');\nvar colorId = require('color-id');\nvar cluster = require('@plotly/point-cluster');\nvar extend = require('object-assign');\nvar glslify = require('glslify');\nvar pick = require('pick-by-alias');\nvar updateDiff = require('update-diff');\nvar flatten = require('flatten-vertex-data');\nvar ie = require('is-iexplorer');\nvar f32 = require('to-float32');\nvar parseRect = require('parse-rect');\nvar scatter = Scatter;\nfunction Scatter(regl, options) {\n  var _this = this;\n  if (!(this instanceof Scatter)) return new Scatter(regl, options);\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n    regl = null;\n  }\n  if (options && options.length) options.positions = options;\n  regl = options.regl;\n\n  // persistent variables\n  var gl = regl._gl,\n    paletteTexture,\n    palette = [],\n    paletteIds = {},\n    // state\n    groups = [],\n    // textures for marker keys\n    markerTextures = [null],\n    markerCache = [null];\n  var maxColors = 255,\n    maxSize = 100;\n\n  // direct color buffer mode\n  // IE does not support palette anyways\n  this.tooManyColors = ie;\n\n  // texture with color palette\n  paletteTexture = regl.texture({\n    data: new Uint8Array(maxColors * 4),\n    width: maxColors,\n    height: 1,\n    type: 'uint8',\n    format: 'rgba',\n    wrapS: 'clamp',\n    wrapT: 'clamp',\n    mag: 'nearest',\n    min: 'nearest'\n  });\n  extend(this, {\n    regl: regl,\n    gl: gl,\n    groups: groups,\n    markerCache: markerCache,\n    markerTextures: markerTextures,\n    palette: palette,\n    paletteIds: paletteIds,\n    paletteTexture: paletteTexture,\n    maxColors: maxColors,\n    maxSize: maxSize,\n    canvas: gl.canvas\n  });\n  this.update(options);\n\n  // common shader options\n  var shaderOptions = {\n    uniforms: {\n      constPointSize: !!options.constPointSize,\n      opacity: regl.prop('opacity'),\n      paletteSize: function paletteSize(ctx, prop) {\n        return [_this.tooManyColors ? 0 : maxColors, paletteTexture.height];\n      },\n      pixelRatio: regl.context('pixelRatio'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translate: regl.prop('translate'),\n      translateFract: regl.prop('translateFract'),\n      markerTexture: regl.prop('markerTexture'),\n      paletteTexture: paletteTexture\n    },\n    attributes: {\n      // FIXME: optimize these parts\n      x: function x(ctx, prop) {\n        return prop.xAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      y: function y(ctx, prop) {\n        return prop.yAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      xFract: function xFract(ctx, prop) {\n        return prop.xAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      yFract: function yFract(ctx, prop) {\n        return prop.yAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      size: function size(ctx, prop) {\n        return prop.size.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 0\n        } : {\n          constant: [Math.round(prop.size * 255 / _this.maxSize)]\n        };\n      },\n      borderSize: function borderSize(ctx, prop) {\n        return prop.borderSize.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 1\n        } : {\n          constant: [Math.round(prop.borderSize * 255 / _this.maxSize)]\n        };\n      },\n      colorId: function colorId(ctx, prop) {\n        return prop.color.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: 0\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [prop.color]\n        };\n      },\n      borderColorId: function borderColorId(ctx, prop) {\n        return prop.borderColor.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: _this.tooManyColors ? 4 : 2\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [prop.borderColor]\n        };\n      },\n      isActive: function isActive(ctx, prop) {\n        return prop.activation === true ? {\n          constant: [1]\n        } : prop.activation ? prop.activation : {\n          constant: [0]\n        };\n      }\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      // photoshop blending\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    elements: regl.prop('elements'),\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    primitive: 'points'\n  };\n\n  // draw sdf-marker\n  var markerOptions = extend({}, shaderOptions);\n  markerOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float opacity;\\nuniform sampler2D markerTexture;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat smoothStep(float x, float y) {\\n  return 1.0 / (1.0 + exp(50.0*(x - y)));\\n}\\n\\nvoid main() {\\n  float dist = texture2D(markerTexture, gl_PointCoord).r, delta = fragWidth;\\n\\n  // max-distance alpha\\n  if (dist < 0.003) discard;\\n\\n  // null-border case\\n  if (fragBorderColorLevel == fragColorLevel || fragBorderColor.a == 0.) {\\n    float colorAmt = smoothstep(.5 - delta, .5 + delta, dist);\\n    gl_FragColor = vec4(fragColor.rgb, colorAmt * fragColor.a * opacity);\\n  }\\n  else {\\n    float borderColorAmt = smoothstep(fragBorderColorLevel - delta, fragBorderColorLevel + delta, dist);\\n    float colorAmt = smoothstep(fragColorLevel - delta, fragColorLevel + delta, dist);\\n\\n    vec4 color = fragBorderColor;\\n    color.a *= borderColorAmt;\\n    color = mix(color, fragColor, colorAmt);\\n    color.a *= opacity;\\n\\n    gl_FragColor = color;\\n  }\\n\\n}\\n\"]);\n  markerOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\n// `invariant` effectively turns off optimizations for the position.\\n// We need this because -fast-math on M1 Macs is re-ordering\\n// floating point operations in a way that causes floating point\\n// precision limits to put points in the wrong locations.\\ninvariant gl_Position;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 scale, scaleFract, translate, translateFract, paletteSize;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\nconst float borderLevel = .5;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragPointSize, fragBorderRadius, fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = 2. * size * pointSizeScale;\\n  fragPointSize = size * pixelRatio;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragColor = color;\\n  fragBorderColor = borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n\\n  fragBorderColorLevel = clamp(borderLevel - borderLevel * borderSize / size, 0., 1.);\\n  fragColorLevel = clamp(borderLevel + (1. - borderLevel) * borderSize / size, 0., 1.);\\n}\\n\"]);\n  this.drawMarker = regl(markerOptions);\n\n  // draw circle\n  var circleOptions = extend({}, shaderOptions);\n  circleOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nuniform float opacity;\\n\\nfloat smoothStep(float edge0, float edge1, float x) {\\n\\tfloat t;\\n\\tt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\treturn t * t * (3.0 - 2.0 * t);\\n}\\n\\nvoid main() {\\n\\tfloat radius, alpha = 1.0, delta = fragWidth;\\n\\n\\tradius = length(2.0 * gl_PointCoord.xy - 1.0);\\n\\n\\tif (radius > 1.0 + delta) {\\n\\t\\tdiscard;\\n\\t}\\n\\n\\talpha -= smoothstep(1.0 - delta, 1.0 + delta, radius);\\n\\n\\tfloat borderRadius = fragBorderRadius;\\n\\tfloat ratio = smoothstep(borderRadius - delta, borderRadius + delta, radius);\\n\\tvec4 color = mix(fragColor, fragBorderColor, ratio);\\n\\tcolor.a *= alpha * opacity;\\n\\tgl_FragColor = color;\\n}\\n\"]);\n  circleOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\n// `invariant` effectively turns off optimizations for the position.\\n// We need this because -fast-math on M1 Macs is re-ordering\\n// floating point operations in a way that causes floating point\\n// precision limits to put points in the wrong locations.\\ninvariant gl_Position;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 paletteSize, scale, scaleFract, translate, translateFract;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = (size + borderSize) * pointSizeScale;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragBorderRadius = 1. - 2. * borderSize / (size + borderSize);\\n  fragColor = color;\\n  fragBorderColor = borderColor.a == 0. || borderSize == 0. ? vec4(color.rgb, 0.) : borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n}\\n\"]);\n\n  // polyfill IE\n  if (ie) {\n    circleOptions.frag = circleOptions.frag.replace('smoothstep', 'smoothStep');\n    markerOptions.frag = markerOptions.frag.replace('smoothstep', 'smoothStep');\n  }\n  this.drawCircle = regl(circleOptions);\n}\n\n// single pass defaults\nScatter.defaults = {\n  color: 'black',\n  borderColor: 'transparent',\n  borderSize: 0,\n  size: 12,\n  opacity: 1,\n  marker: undefined,\n  viewport: null,\n  range: null,\n  pixelSize: null,\n  count: 0,\n  offset: 0,\n  bounds: null,\n  positions: [],\n  snap: 1e4\n};\n\n// update & redraw\nScatter.prototype.render = function () {\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n  this.draw();\n  return this;\n};\n\n// draw all groups or only indicated ones\nScatter.prototype.draw = function () {\n  var _this2 = this;\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var groups = this.groups;\n\n  // if directly array passed - treat as passes\n  if (args.length === 1 && Array.isArray(args[0]) && (args[0][0] === null || Array.isArray(args[0][0]))) {\n    args = args[0];\n  }\n\n  // FIXME: remove once https://github.com/regl-project/regl/issues/474 resolved\n  this.regl._refresh();\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      this.drawItem(i, args[i]);\n    }\n  }\n  // draw all passes\n  else {\n    groups.forEach(function (group, i) {\n      _this2.drawItem(i);\n    });\n  }\n  return this;\n};\n\n// draw specific scatter group\nScatter.prototype.drawItem = function (id, els) {\n  var groups = this.groups;\n  var group = groups[id];\n\n  // debug viewport\n  // let { viewport } = group\n  // gl.enable(gl.SCISSOR_TEST);\n  // gl.scissor(viewport.x, viewport.y, viewport.width, viewport.height);\n  // gl.clearColor(0, 0, 0, .5);\n  // gl.clear(gl.COLOR_BUFFER_BIT);\n\n  if (typeof els === 'number') {\n    id = els;\n    group = groups[els];\n    els = null;\n  }\n  if (!(group && group.count && group.opacity)) return;\n\n  // draw circles\n  if (group.activation[0]) {\n    // TODO: optimize this performance by making groups and regl.this props\n    this.drawCircle(this.getMarkerDrawOptions(0, group, els));\n  }\n\n  // draw all other available markers\n  var batch = [];\n  for (var i = 1; i < group.activation.length; i++) {\n    if (!group.activation[i] || group.activation[i] !== true && !group.activation[i].data.length) continue;\n    batch.push.apply(batch, _toConsumableArray(this.getMarkerDrawOptions(i, group, els)));\n  }\n  if (batch.length) {\n    this.drawMarker(batch);\n  }\n};\n\n// get options for the marker ids\nScatter.prototype.getMarkerDrawOptions = function (markerId, group, elements) {\n  var range = group.range,\n    tree = group.tree,\n    viewport = group.viewport,\n    activation = group.activation,\n    selectionBuffer = group.selectionBuffer,\n    count = group.count;\n  var regl = this.regl;\n\n  // direct points\n  if (!tree) {\n    // if elements array - draw unclustered points\n    if (elements) {\n      return [extend({}, group, {\n        markerTexture: this.markerTextures[markerId],\n        activation: activation[markerId],\n        count: elements.length,\n        elements: elements,\n        offset: 0\n      })];\n    }\n    return [extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: activation[markerId],\n      offset: 0\n    })];\n  }\n\n  // clustered points\n  var batch = [];\n  var lod = tree.range(range, {\n    lod: true,\n    px: [(range[2] - range[0]) / viewport.width, (range[3] - range[1]) / viewport.height]\n  });\n\n  // enable elements by using selection buffer\n  if (elements) {\n    var markerActivation = activation[markerId];\n    var mask = markerActivation.data;\n    var data = new Uint8Array(count);\n    for (var i = 0; i < elements.length; i++) {\n      var id = elements[i];\n      data[id] = mask ? mask[id] : 1;\n    }\n    selectionBuffer.subdata(data);\n  }\n  for (var l = lod.length; l--;) {\n    var _lod$l = _slicedToArray(lod[l], 2),\n      from = _lod$l[0],\n      to = _lod$l[1];\n    batch.push(extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: elements ? selectionBuffer : activation[markerId],\n      offset: from,\n      count: to - from\n    }));\n  }\n  return batch;\n};\n\n// update groups options\nScatter.prototype.update = function () {\n  var _this3 = this;\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  if (!args.length) return;\n\n  // passes are as single array\n  if (args.length === 1 && Array.isArray(args[0])) args = args[0];\n  var groups = this.groups,\n    gl = this.gl,\n    regl = this.regl,\n    maxSize = this.maxSize,\n    maxColors = this.maxColors,\n    palette = this.palette;\n  this.groups = groups = args.map(function (options, i) {\n    var group = groups[i];\n    if (options === undefined) return group;\n    if (options === null) options = {\n      positions: null\n    };else if (typeof options === 'function') options = {\n      ondraw: options\n    };else if (typeof options[0] === 'number') options = {\n      positions: options\n    };\n\n    // copy options to avoid mutation & handle aliases\n    options = pick(options, {\n      positions: 'positions data points',\n      snap: 'snap cluster lod tree',\n      size: 'sizes size radius',\n      borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n      color: 'colors color fill fill-color fillColor',\n      borderColor: 'borderColors borderColor stroke stroke-color strokeColor',\n      marker: 'markers marker shape',\n      range: 'range dataBox databox',\n      viewport: 'viewport viewPort viewBox viewbox',\n      opacity: 'opacity alpha transparency',\n      bounds: 'bound bounds boundaries limits',\n      tooManyColors: 'tooManyColors palette paletteMode optimizePalette enablePalette'\n    });\n    if (options.positions === null) options.positions = [];\n    if (options.tooManyColors != null) _this3.tooManyColors = options.tooManyColors;\n    if (!group) {\n      groups[i] = group = {\n        id: i,\n        scale: null,\n        translate: null,\n        scaleFract: null,\n        translateFract: null,\n        // buffers for active markers\n        activation: [],\n        // buffer for filtered markers\n        selectionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'stream',\n          type: 'uint8'\n        }),\n        // buffers with data: it is faster to switch them per-pass\n        // than provide one congregate buffer\n        sizeBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        colorBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        positionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        }),\n        positionFractBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        })\n      };\n      options = extend({}, Scatter.defaults, options);\n    }\n\n    // force update triggers\n    if (options.positions && !('marker' in options)) {\n      options.marker = group.marker;\n      delete group.marker;\n    }\n\n    // updating markers cause recalculating snapping\n    if (options.marker && !('positions' in options)) {\n      options.positions = group.positions;\n      delete group.positions;\n    }\n\n    // global count of points\n    var hasSize = 0,\n      hasColor = 0;\n    updateDiff(group, options, [{\n      snap: true,\n      size: function size(s, group) {\n        if (s == null) s = Scatter.defaults.size;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      borderSize: function borderSize(s, group) {\n        if (s == null) s = Scatter.defaults.borderSize;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      opacity: parseFloat,\n      // add colors to palette, save references\n      color: function color(c, group) {\n        if (c == null) c = Scatter.defaults.color;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      borderColor: function borderColor(c, group) {\n        if (c == null) c = Scatter.defaults.borderColor;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      bounds: function bounds(_bounds, group, options) {\n        if (!('range' in options)) options.range = null;\n        return _bounds;\n      },\n      positions: function positions(_positions, group, options) {\n        var snap = group.snap;\n        var positionBuffer = group.positionBuffer,\n          positionFractBuffer = group.positionFractBuffer,\n          selectionBuffer = group.selectionBuffer;\n\n        // separate buffers for x/y coordinates\n        if (_positions.x || _positions.y) {\n          if (_positions.x.length) {\n            group.xAttr = {\n              buffer: regl.buffer(_positions.x),\n              offset: 0,\n              stride: 4,\n              count: _positions.x.length\n            };\n          } else {\n            group.xAttr = {\n              buffer: _positions.x.buffer,\n              offset: _positions.x.offset * 4 || 0,\n              stride: (_positions.x.stride || 1) * 4,\n              count: _positions.x.count\n            };\n          }\n          if (_positions.y.length) {\n            group.yAttr = {\n              buffer: regl.buffer(_positions.y),\n              offset: 0,\n              stride: 4,\n              count: _positions.y.length\n            };\n          } else {\n            group.yAttr = {\n              buffer: _positions.y.buffer,\n              offset: _positions.y.offset * 4 || 0,\n              stride: (_positions.y.stride || 1) * 4,\n              count: _positions.y.count\n            };\n          }\n          group.count = Math.max(group.xAttr.count, group.yAttr.count);\n          return _positions;\n        }\n        _positions = flatten(_positions, 'float64');\n        var count = group.count = Math.floor(_positions.length / 2);\n        var bounds = group.bounds = count ? getBounds(_positions, 2) : null;\n\n        // if range is not provided updated - recalc it\n        if (!options.range && !group.range) {\n          delete group.range;\n          options.range = bounds;\n        }\n\n        // reset marker\n        if (!options.marker && !group.marker) {\n          delete group.marker;\n          options.marker = null;\n        }\n\n        // build cluster tree if required\n        if (snap && (snap === true || count > snap)) {\n          group.tree = cluster(_positions, {\n            bounds: bounds\n          });\n        }\n        // existing tree instance\n        else if (snap && snap.length) {\n          group.tree = snap;\n        }\n        if (group.tree) {\n          var opts = {\n            primitive: 'points',\n            usage: 'static',\n            data: group.tree,\n            type: 'uint32'\n          };\n          if (group.elements) group.elements(opts);else group.elements = regl.elements(opts);\n        }\n\n        // update position buffers\n        var float_data = f32.float32(_positions);\n        positionBuffer({\n          data: float_data,\n          usage: 'dynamic'\n        });\n        var frac_data = f32.fract32(_positions, float_data);\n        positionFractBuffer({\n          data: frac_data,\n          usage: 'dynamic'\n        });\n\n        // expand selectionBuffer\n        selectionBuffer({\n          data: new Uint8Array(count),\n          type: 'uint8',\n          usage: 'stream'\n        });\n        return _positions;\n      }\n    }, {\n      // create marker ids corresponding to known marker textures\n      marker: function marker(markers, group, options) {\n        var activation = group.activation;\n\n        // reset marker elements\n        activation.forEach(function (buffer) {\n          return buffer && buffer.destroy && buffer.destroy();\n        });\n        activation.length = 0;\n\n        // single sdf marker\n        if (!markers || typeof markers[0] === 'number') {\n          var id = _this3.addMarker(markers);\n          activation[id] = true;\n        }\n\n        // per-point markers use mask buffers to enable markers in vert shader\n        else {\n          var markerMasks = [];\n          for (var _i = 0, l = Math.min(markers.length, group.count); _i < l; _i++) {\n            var _id = _this3.addMarker(markers[_i]);\n            if (!markerMasks[_id]) markerMasks[_id] = new Uint8Array(group.count);\n\n            // enable marker by default\n            markerMasks[_id][_i] = 1;\n          }\n          for (var _id2 = 0; _id2 < markerMasks.length; _id2++) {\n            if (!markerMasks[_id2]) continue;\n            var opts = {\n              data: markerMasks[_id2],\n              type: 'uint8',\n              usage: 'static'\n            };\n            if (!activation[_id2]) {\n              activation[_id2] = regl.buffer(opts);\n            } else {\n              activation[_id2](opts);\n            }\n            activation[_id2].data = markerMasks[_id2];\n          }\n        }\n        return markers;\n      },\n      range: function range(_range, group, options) {\n        var bounds = group.bounds;\n\n        // FIXME: why do we need this?\n        if (!bounds) return;\n        if (!_range) _range = bounds;\n        group.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];\n        group.translate = [-_range[0], -_range[1]];\n        group.scaleFract = f32.fract(group.scale);\n        group.translateFract = f32.fract(group.translate);\n        return _range;\n      },\n      viewport: function viewport(vp) {\n        var rect = parseRect(vp || [gl.drawingBufferWidth, gl.drawingBufferHeight]);\n\n        // normalize viewport to the canvas coordinates\n        // rect.y = gl.drawingBufferHeight - rect.height - rect.y\n\n        return rect;\n      }\n    }]);\n\n    // update size buffer, if needed\n    if (hasSize) {\n      var _group = group,\n        count = _group.count,\n        size = _group.size,\n        borderSize = _group.borderSize,\n        sizeBuffer = _group.sizeBuffer;\n      var sizes = new Uint8Array(count * 2);\n      if (size.length || borderSize.length) {\n        for (var _i2 = 0; _i2 < count; _i2++) {\n          // we downscale size to allow for fractions\n          sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);\n          sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);\n        }\n      }\n      sizeBuffer({\n        data: sizes,\n        usage: 'dynamic'\n      });\n    }\n\n    // update color buffer if needed\n    if (hasColor) {\n      var _group2 = group,\n        _count = _group2.count,\n        color = _group2.color,\n        borderColor = _group2.borderColor,\n        colorBuffer = _group2.colorBuffer;\n      var colors;\n\n      // if too many colors - put colors to buffer directly\n      if (_this3.tooManyColors) {\n        if (color.length || borderColor.length) {\n          colors = new Uint8Array(_count * 8);\n          for (var _i3 = 0; _i3 < _count; _i3++) {\n            var _colorId = color[_i3];\n            colors[_i3 * 8] = palette[_colorId * 4];\n            colors[_i3 * 8 + 1] = palette[_colorId * 4 + 1];\n            colors[_i3 * 8 + 2] = palette[_colorId * 4 + 2];\n            colors[_i3 * 8 + 3] = palette[_colorId * 4 + 3];\n            var borderColorId = borderColor[_i3];\n            colors[_i3 * 8 + 4] = palette[borderColorId * 4];\n            colors[_i3 * 8 + 5] = palette[borderColorId * 4 + 1];\n            colors[_i3 * 8 + 6] = palette[borderColorId * 4 + 2];\n            colors[_i3 * 8 + 7] = palette[borderColorId * 4 + 3];\n          }\n        }\n      }\n\n      // if limited amount of colors - keep palette color picking\n      // that saves significant memory\n      else {\n        if (color.length || borderColor.length) {\n          // we need slight data increase by 2 due to vec4 borderId in shader\n          colors = new Uint8Array(_count * 4 + 2);\n          for (var _i4 = 0; _i4 < _count; _i4++) {\n            // put color coords in palette texture\n            if (color[_i4] != null) {\n              colors[_i4 * 4] = color[_i4] % maxColors;\n              colors[_i4 * 4 + 1] = Math.floor(color[_i4] / maxColors);\n            }\n            if (borderColor[_i4] != null) {\n              colors[_i4 * 4 + 2] = borderColor[_i4] % maxColors;\n              colors[_i4 * 4 + 3] = Math.floor(borderColor[_i4] / maxColors);\n            }\n          }\n        }\n      }\n      colorBuffer({\n        data: colors || new Uint8Array(0),\n        type: 'uint8',\n        usage: 'dynamic'\n      });\n    }\n    return group;\n  });\n};\n\n// get (and create) marker texture id\nScatter.prototype.addMarker = function (sdf) {\n  var markerTextures = this.markerTextures,\n    regl = this.regl,\n    markerCache = this.markerCache;\n  var pos = sdf == null ? 0 : markerCache.indexOf(sdf);\n  if (pos >= 0) return pos;\n\n  // convert sdf to 0..255 range\n  var distArr;\n  if (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {\n    distArr = sdf;\n  } else {\n    distArr = new Uint8Array(sdf.length);\n    for (var i = 0, l = sdf.length; i < l; i++) {\n      distArr[i] = sdf[i] * 255;\n    }\n  }\n  var radius = Math.floor(Math.sqrt(distArr.length));\n  pos = markerTextures.length;\n  markerCache.push(sdf);\n  markerTextures.push(regl.texture({\n    channels: 1,\n    data: distArr,\n    radius: radius,\n    mag: 'linear',\n    min: 'linear'\n  }));\n  return pos;\n};\n\n// register color to palette, return it's index or list of indexes\nScatter.prototype.updateColor = function (colors) {\n  var paletteIds = this.paletteIds,\n    palette = this.palette,\n    maxColors = this.maxColors;\n  if (!Array.isArray(colors)) {\n    colors = [colors];\n  }\n  var idx = [];\n\n  // if color groups - flatten them\n  if (typeof colors[0] === 'number') {\n    var grouped = [];\n    if (Array.isArray(colors)) {\n      for (var i = 0; i < colors.length; i += 4) {\n        grouped.push(colors.slice(i, i + 4));\n      }\n    } else {\n      for (var _i5 = 0; _i5 < colors.length; _i5 += 4) {\n        grouped.push(colors.subarray(_i5, _i5 + 4));\n      }\n    }\n    colors = grouped;\n  }\n  for (var _i6 = 0; _i6 < colors.length; _i6++) {\n    var color = colors[_i6];\n    color = rgba(color, 'uint8');\n    var id = colorId(color, false);\n\n    // if new color - save it\n    if (paletteIds[id] == null) {\n      var pos = palette.length;\n      paletteIds[id] = Math.floor(pos / 4);\n      palette[pos] = color[0];\n      palette[pos + 1] = color[1];\n      palette[pos + 2] = color[2];\n      palette[pos + 3] = color[3];\n    }\n    idx[_i6] = paletteIds[id];\n  }\n\n  // detect if too many colors in palette\n  if (!this.tooManyColors && palette.length > maxColors * 4) this.tooManyColors = true;\n\n  // limit max color\n  this.updatePalette(palette);\n\n  // keep static index for single-color property\n  return idx.length === 1 ? idx[0] : idx;\n};\nScatter.prototype.updatePalette = function (palette) {\n  if (this.tooManyColors) return;\n  var maxColors = this.maxColors,\n    paletteTexture = this.paletteTexture;\n  var requiredHeight = Math.ceil(palette.length * .25 / maxColors);\n\n  // pad data\n  if (requiredHeight > 1) {\n    palette = palette.slice();\n    for (var i = palette.length * .25 % maxColors; i < requiredHeight * maxColors; i++) {\n      palette.push(0, 0, 0, 0);\n    }\n  }\n\n  // ensure height\n  if (paletteTexture.height < requiredHeight) {\n    paletteTexture.resize(maxColors, requiredHeight);\n  }\n\n  // update full data\n  paletteTexture.subimage({\n    width: Math.min(palette.length * .25, maxColors),\n    height: requiredHeight,\n    data: palette\n  }, 0, 0);\n};\n\n// remove unused stuff\nScatter.prototype.destroy = function () {\n  this.groups.forEach(function (group) {\n    group.sizeBuffer.destroy();\n    group.positionBuffer.destroy();\n    group.positionFractBuffer.destroy();\n    group.colorBuffer.destroy();\n    group.activation.forEach(function (b) {\n      return b && b.destroy && b.destroy();\n    });\n    group.selectionBuffer.destroy();\n    if (group.elements) group.elements.destroy();\n  });\n  this.groups.length = 0;\n  this.paletteTexture.destroy();\n  this.markerTextures.forEach(function (txt) {\n    return txt && txt.destroy && txt.destroy();\n  });\n  return this;\n};\n\nvar extend$1 = require('object-assign');\nvar reglScatter2d = function reglScatter2d(regl, options) {\n  var scatter$1 = new scatter(regl, options);\n  var render = scatter$1.render.bind(scatter$1);\n\n  // expose API\n  extend$1(render, {\n    render: render,\n    update: scatter$1.update.bind(scatter$1),\n    draw: scatter$1.draw.bind(scatter$1),\n    destroy: scatter$1.destroy.bind(scatter$1),\n    regl: scatter$1.regl,\n    gl: scatter$1.gl,\n    canvas: scatter$1.gl.canvas,\n    groups: scatter$1.groups,\n    markers: scatter$1.markerCache,\n    palette: scatter$1.palette\n  });\n  return render;\n};\n\nmodule.exports = reglScatter2d;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}