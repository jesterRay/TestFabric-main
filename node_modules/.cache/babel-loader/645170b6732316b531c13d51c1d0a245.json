{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var hoveron = trace.hoveron;\n  var closeBoxData = [];\n  var closePtData;\n  if (hoveron.indexOf('boxes') !== -1) {\n    closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n  }\n  if (hoveron.indexOf('points') !== -1) {\n    closePtData = hoverOnPoints(pointData, xval, yval);\n  }\n\n  // If there's a point in range and hoveron has points, show the best single point only.\n  // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n  if (hovermode === 'closest') {\n    if (closePtData) return [closePtData];\n    return closeBoxData;\n  }\n\n  // Otherwise in compare mode, allow a point AND the box stats to be labeled\n  // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n  if (closePtData) {\n    closeBoxData.push(closePtData);\n    return closeBoxData;\n  }\n  return closeBoxData;\n}\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isViolin = trace.type === 'violin';\n  var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos, hoverPseudoDistance, spikePseudoDistance;\n  var boxDelta = t.bdPos;\n  var boxDeltaPos, boxDeltaNeg;\n  var posAcceptance = t.wHover;\n  var shiftPos = function (di) {\n    return pAxis.c2l(di.pos) + t.bPos - pAxis.c2l(pVal);\n  };\n  if (isViolin && trace.side !== 'both') {\n    if (trace.side === 'positive') {\n      dPos = function (di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n      };\n      boxDeltaPos = boxDelta;\n      boxDeltaNeg = 0;\n    }\n    if (trace.side === 'negative') {\n      dPos = function (di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n      };\n      boxDeltaPos = 0;\n      boxDeltaNeg = boxDelta;\n    }\n  } else {\n    dPos = function (di) {\n      var pos = shiftPos(di);\n      return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n    };\n    boxDeltaPos = boxDeltaNeg = boxDelta;\n  }\n  var dVal;\n  if (isViolin) {\n    dVal = function (di) {\n      return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n    };\n  } else {\n    dVal = function (di) {\n      return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n    };\n  }\n  if (trace.orientation === 'h') {\n    vVal = xval;\n    pVal = yval;\n    dx = dVal;\n    dy = dPos;\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    vVal = yval;\n    pVal = xval;\n    dx = dPos;\n    dy = dVal;\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  }\n\n  // if two boxes are overlaying, let the narrowest one win\n  var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n  hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n  spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData);\n\n  // skip the rest (for this trace) if we didn't find a close point\n  // and create the item(s) in closedata for this point\n  if (pointData.index === false) return [];\n  var di = cd[pointData.index];\n  var lc = trace.line.color;\n  var mc = (trace.marker || {}).color;\n  if (Color.opacity(lc) && trace.line.width) pointData.color = lc;else if (Color.opacity(mc) && trace.boxpoints) pointData.color = mc;else pointData.color = trace.fillcolor;\n  pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDeltaNeg, true);\n  pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDeltaPos, true);\n  pointData[pLetter + 'LabelVal'] = di.orig_p !== undefined ? di.orig_p : di.pos;\n  var spikePosAttr = pLetter + 'Spike';\n  pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n  pointData[spikePosAttr] = pAxis.c2p(di.pos, true);\n  var hasMean = trace.boxmean || trace.sizemode === 'sd' || (trace.meanline || {}).visible;\n  var hasFences = trace.boxpoints || trace.points;\n\n  // labels with equal values (e.g. when min === q1) should still be presented in the order they have when they're unequal\n  var attrs = hasFences && hasMean ? ['max', 'uf', 'q3', 'med', 'mean', 'q1', 'lf', 'min'] : hasFences && !hasMean ? ['max', 'uf', 'q3', 'med', 'q1', 'lf', 'min'] : !hasFences && hasMean ? ['max', 'q3', 'med', 'mean', 'q1', 'min'] : ['max', 'q3', 'med', 'q1', 'min'];\n  var rev = vAxis.range[1] < vAxis.range[0];\n  if (trace.orientation === (rev ? 'v' : 'h')) {\n    attrs.reverse();\n  }\n  var spikeDistance = pointData.spikeDistance;\n  var spikePosition = pointData[spikePosAttr];\n  var closeBoxData = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!(attr in di)) continue;\n\n    // copy out to a new object for each value to label\n    var val = di[attr];\n    var valPx = vAxis.c2p(val, true);\n    var pointData2 = Lib.extendFlat({}, pointData);\n    pointData2.attr = attr;\n    pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n    pointData2[vLetter + 'LabelVal'] = val;\n    pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val, trace[vLetter + 'hoverformat']);\n\n    // Note: introduced to be able to distinguish a\n    // clicked point from a box during click-to-select\n    pointData2.hoverOnBox = true;\n    if (attr === 'mean' && 'sd' in di && (trace.boxmean === 'sd' || trace.sizemode === 'sd')) {\n      pointData2[vLetter + 'err'] = di.sd;\n    }\n\n    // no hovertemplate support yet\n    pointData2.hovertemplate = false;\n    closeBoxData.push(pointData2);\n  }\n\n  // only keep name and spikes on the median\n  pointData.name = '';\n  pointData.spikeDistance = undefined;\n  pointData[spikePosAttr] = undefined;\n  for (var k = 0; k < closeBoxData.length; k++) {\n    if (closeBoxData[k].attr !== 'med') {\n      closeBoxData[k].name = '';\n      closeBoxData[k].spikeDistance = undefined;\n      closeBoxData[k][spikePosAttr] = undefined;\n    } else {\n      closeBoxData[k].spikeDistance = spikeDistance;\n      closeBoxData[k][spikePosAttr] = spikePosition;\n    }\n  }\n  return closeBoxData;\n}\nfunction hoverOnPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var xPx = xa.c2p(xval);\n  var yPx = ya.c2p(yval);\n  var closePtData;\n  var dx = function (di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n  };\n  var dy = function (di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n  };\n  var distfn = Fx.quadrature(dx, dy);\n\n  // show one point per trace\n  var ijClosest = false;\n  var di, pt;\n  for (var i = 0; i < cd.length; i++) {\n    di = cd[i];\n    for (var j = 0; j < (di.pts || []).length; j++) {\n      pt = di.pts[j];\n      var newDistance = distfn(pt);\n      if (newDistance <= pointData.distance) {\n        pointData.distance = newDistance;\n        ijClosest = [i, j];\n      }\n    }\n  }\n  if (!ijClosest) return false;\n  di = cd[ijClosest[0]];\n  pt = di.pts[ijClosest[1]];\n  var xc = xa.c2p(pt.x, true);\n  var yc = ya.c2p(pt.y, true);\n  var rad = pt.mrc || 1;\n  closePtData = Lib.extendFlat({}, pointData, {\n    // corresponds to index in x/y input data array\n    index: pt.i,\n    color: (trace.marker || {}).color,\n    name: trace.name,\n    x0: xc - rad,\n    x1: xc + rad,\n    y0: yc - rad,\n    y1: yc + rad,\n    spikeDistance: pointData.distance,\n    hovertemplate: trace.hovertemplate\n  });\n  var origPos = di.orig_p;\n  var pos = origPos !== undefined ? origPos : di.pos;\n  var pa;\n  if (trace.orientation === 'h') {\n    pa = ya;\n    closePtData.xLabelVal = pt.x;\n    closePtData.yLabelVal = pos;\n  } else {\n    pa = xa;\n    closePtData.xLabelVal = pos;\n    closePtData.yLabelVal = pt.y;\n  }\n  var pLetter = pa._id.charAt(0);\n  closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n  fillText(pt, trace, closePtData);\n  return closePtData;\n}\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBoxes: hoverOnBoxes,\n  hoverOnPoints: hoverOnPoints\n};","map":{"version":3,"names":["Axes","require","Lib","Fx","Color","fillText","hoverPoints","pointData","xval","yval","hovermode","cd","trace","hoveron","closeBoxData","closePtData","indexOf","concat","hoverOnBoxes","hoverOnPoints","push","xa","ya","t","isViolin","type","pLetter","vLetter","pAxis","vAxis","vVal","pVal","dx","dy","dPos","hoverPseudoDistance","spikePseudoDistance","boxDelta","bdPos","boxDeltaPos","boxDeltaNeg","posAcceptance","wHover","shiftPos","di","c2l","pos","bPos","side","inbox","dVal","span","min","max","orientation","pseudoDistance","Math","abs","r2c","range","maxHoverDistance","maxSpikeDistance","dxy","distfn","getDistanceFunction","getClosest","index","lc","line","color","mc","marker","opacity","width","boxpoints","fillcolor","c2p","orig_p","undefined","spikePosAttr","spikeDistance","hasMean","boxmean","sizemode","meanline","visible","hasFences","points","attrs","rev","reverse","spikePosition","i","length","attr","val","valPx","pointData2","extendFlat","labels","hoverLabelText","hoverOnBox","sd","hovertemplate","name","k","xPx","yPx","rad","mrc","x","y","quadrature","ijClosest","pt","j","pts","newDistance","distance","xc","yc","x0","x1","y0","y1","origPos","pa","xLabelVal","yLabelVal","_id","charAt","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/box/hover.js"],"sourcesContent":["'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var hoveron = trace.hoveron;\n    var closeBoxData = [];\n    var closePtData;\n\n    if(hoveron.indexOf('boxes') !== -1) {\n        closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n    }\n\n    if(hoveron.indexOf('points') !== -1) {\n        closePtData = hoverOnPoints(pointData, xval, yval);\n    }\n\n    // If there's a point in range and hoveron has points, show the best single point only.\n    // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n    if(hovermode === 'closest') {\n        if(closePtData) return [closePtData];\n        return closeBoxData;\n    }\n\n    // Otherwise in compare mode, allow a point AND the box stats to be labeled\n    // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n    if(closePtData) {\n        closeBoxData.push(closePtData);\n        return closeBoxData;\n    }\n    return closeBoxData;\n}\n\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isViolin = trace.type === 'violin';\n\n    var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos,\n        hoverPseudoDistance, spikePseudoDistance;\n\n    var boxDelta = t.bdPos;\n    var boxDeltaPos, boxDeltaNeg;\n    var posAcceptance = t.wHover;\n    var shiftPos = function(di) { return pAxis.c2l(di.pos) + t.bPos - pAxis.c2l(pVal); };\n\n    if(isViolin && trace.side !== 'both') {\n        if(trace.side === 'positive') {\n            dPos = function(di) {\n                var pos = shiftPos(di);\n                return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n            };\n            boxDeltaPos = boxDelta;\n            boxDeltaNeg = 0;\n        }\n        if(trace.side === 'negative') {\n            dPos = function(di) {\n                var pos = shiftPos(di);\n                return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n            };\n            boxDeltaPos = 0;\n            boxDeltaNeg = boxDelta;\n        }\n    } else {\n        dPos = function(di) {\n            var pos = shiftPos(di);\n            return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n        };\n        boxDeltaPos = boxDeltaNeg = boxDelta;\n    }\n\n    var dVal;\n\n    if(isViolin) {\n        dVal = function(di) {\n            return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n        };\n    } else {\n        dVal = function(di) {\n            return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n        };\n    }\n\n    if(trace.orientation === 'h') {\n        vVal = xval;\n        pVal = yval;\n        dx = dVal;\n        dy = dPos;\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n    } else {\n        vVal = yval;\n        pVal = xval;\n        dx = dPos;\n        dy = dVal;\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n    }\n\n    // if two boxes are overlaying, let the narrowest one win\n    var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n    hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n    spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    // and create the item(s) in closedata for this point\n    if(pointData.index === false) return [];\n\n    var di = cd[pointData.index];\n    var lc = trace.line.color;\n    var mc = (trace.marker || {}).color;\n\n    if(Color.opacity(lc) && trace.line.width) pointData.color = lc;\n    else if(Color.opacity(mc) && trace.boxpoints) pointData.color = mc;\n    else pointData.color = trace.fillcolor;\n\n    pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDeltaNeg, true);\n    pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDeltaPos, true);\n\n    pointData[pLetter + 'LabelVal'] = di.orig_p !== undefined ? di.orig_p : di.pos;\n\n    var spikePosAttr = pLetter + 'Spike';\n    pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n    pointData[spikePosAttr] = pAxis.c2p(di.pos, true);\n\n    var hasMean = trace.boxmean || (trace.sizemode === 'sd') || (trace.meanline || {}).visible;\n    var hasFences = trace.boxpoints || trace.points;\n\n    // labels with equal values (e.g. when min === q1) should still be presented in the order they have when they're unequal\n    var attrs =\n        (hasFences && hasMean) ? ['max', 'uf', 'q3', 'med', 'mean', 'q1', 'lf', 'min'] :\n        (hasFences && !hasMean) ? ['max', 'uf', 'q3', 'med', 'q1', 'lf', 'min'] :\n        (!hasFences && hasMean) ? ['max', 'q3', 'med', 'mean', 'q1', 'min'] :\n        ['max', 'q3', 'med', 'q1', 'min'];\n\n    var rev = vAxis.range[1] < vAxis.range[0];\n\n    if(trace.orientation === (rev ? 'v' : 'h')) {\n        attrs.reverse();\n    }\n\n    var spikeDistance = pointData.spikeDistance;\n    var spikePosition = pointData[spikePosAttr];\n\n    var closeBoxData = [];\n    for(var i = 0; i < attrs.length; i++) {\n        var attr = attrs[i];\n\n        if(!(attr in di)) continue;\n\n        // copy out to a new object for each value to label\n        var val = di[attr];\n        var valPx = vAxis.c2p(val, true);\n        var pointData2 = Lib.extendFlat({}, pointData);\n\n        pointData2.attr = attr;\n        pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n        pointData2[vLetter + 'LabelVal'] = val;\n        pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val, trace[vLetter + 'hoverformat']);\n\n        // Note: introduced to be able to distinguish a\n        // clicked point from a box during click-to-select\n        pointData2.hoverOnBox = true;\n\n        if(attr === 'mean' && ('sd' in di) && ((trace.boxmean === 'sd') || (trace.sizemode === 'sd'))) {\n            pointData2[vLetter + 'err'] = di.sd;\n        }\n\n        // no hovertemplate support yet\n        pointData2.hovertemplate = false;\n\n        closeBoxData.push(pointData2);\n    }\n\n    // only keep name and spikes on the median\n    pointData.name = '';\n    pointData.spikeDistance = undefined;\n    pointData[spikePosAttr] = undefined;\n    for(var k = 0; k < closeBoxData.length; k++) {\n        if(closeBoxData[k].attr !== 'med') {\n            closeBoxData[k].name = '';\n            closeBoxData[k].spikeDistance = undefined;\n            closeBoxData[k][spikePosAttr] = undefined;\n        } else {\n            closeBoxData[k].spikeDistance = spikeDistance;\n            closeBoxData[k][spikePosAttr] = spikePosition;\n        }\n    }\n\n    return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var xPx = xa.c2p(xval);\n    var yPx = ya.c2p(yval);\n    var closePtData;\n\n    var dx = function(di) {\n        var rad = Math.max(3, di.mrc || 0);\n        return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n    };\n    var dy = function(di) {\n        var rad = Math.max(3, di.mrc || 0);\n        return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n    };\n    var distfn = Fx.quadrature(dx, dy);\n\n    // show one point per trace\n    var ijClosest = false;\n    var di, pt;\n\n    for(var i = 0; i < cd.length; i++) {\n        di = cd[i];\n\n        for(var j = 0; j < (di.pts || []).length; j++) {\n            pt = di.pts[j];\n\n            var newDistance = distfn(pt);\n            if(newDistance <= pointData.distance) {\n                pointData.distance = newDistance;\n                ijClosest = [i, j];\n            }\n        }\n    }\n\n    if(!ijClosest) return false;\n\n    di = cd[ijClosest[0]];\n    pt = di.pts[ijClosest[1]];\n\n    var xc = xa.c2p(pt.x, true);\n    var yc = ya.c2p(pt.y, true);\n    var rad = pt.mrc || 1;\n\n    closePtData = Lib.extendFlat({}, pointData, {\n        // corresponds to index in x/y input data array\n        index: pt.i,\n        color: (trace.marker || {}).color,\n        name: trace.name,\n        x0: xc - rad,\n        x1: xc + rad,\n        y0: yc - rad,\n        y1: yc + rad,\n        spikeDistance: pointData.distance,\n        hovertemplate: trace.hovertemplate\n    });\n\n    var origPos = di.orig_p;\n    var pos = origPos !== undefined ? origPos : di.pos;\n    var pa;\n    if(trace.orientation === 'h') {\n        pa = ya;\n        closePtData.xLabelVal = pt.x;\n        closePtData.yLabelVal = pos;\n    } else {\n        pa = xa;\n        closePtData.xLabelVal = pos;\n        closePtData.yLabelVal = pt.y;\n    }\n\n    var pLetter = pa._id.charAt(0);\n    closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n\n    fillText(pt, trace, closePtData);\n\n    return closePtData;\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    hoverOnBoxes: hoverOnBoxes,\n    hoverOnPoints: hoverOnPoints\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}