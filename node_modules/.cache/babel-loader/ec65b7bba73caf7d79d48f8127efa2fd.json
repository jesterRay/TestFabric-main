{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorz = [];\n  var calcTracesVert = [];\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorz.push(calcTraces[i]);\n      } else {\n        calcTracesVert.push(calcTraces[i]);\n      }\n      if (fullTrace._computePh) {\n        var cd = gd.calcdata[i];\n        for (var j = 0; j < cd.length; j++) {\n          if (typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n          if (typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n        }\n      }\n    }\n  }\n  var opts = {\n    xCat: xa.type === 'category' || xa.type === 'multicategory',\n    yCat: ya.type === 'category' || ya.type === 'multicategory',\n    mode: fullLayout.barmode,\n    norm: fullLayout.barnorm,\n    gap: fullLayout.bargap,\n    groupgap: fullLayout.bargroupgap\n  };\n  setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n  if (!calcTraces.length) return;\n  var excluded;\n  var included;\n  var i, calcTrace, fullTrace;\n  initBase(sa, calcTraces);\n  switch (opts.mode) {\n    case 'overlay':\n      setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n      break;\n    case 'group':\n      // exclude from the group those traces for which the user set an offset\n      excluded = [];\n      included = [];\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n      if (included.length) {\n        setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n      }\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n      break;\n    case 'stack':\n    case 'relative':\n      // exclude from the stack those traces for which the user set a base\n      excluded = [];\n      included = [];\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      // If any trace in `included` has a cornerradius, set cornerradius of all bars\n      // in `included` to match the first trace which has a cornerradius\n      standardizeCornerradius(included);\n      if (included.length) {\n        setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n      }\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n      break;\n  }\n  setCornerradius(calcTraces);\n  collectExtents(calcTraces, pa);\n}\n\n// Set cornerradiusvalue and cornerradiusform in calcTraces[0].t\nfunction setCornerradius(calcTraces) {\n  var i, calcTrace, fullTrace, t, cr, crValue, crForm;\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    t = calcTrace[0].t;\n    if (t.cornerradiusvalue === undefined) {\n      cr = fullTrace.marker ? fullTrace.marker.cornerradius : undefined;\n      if (cr !== undefined) {\n        crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);\n        crForm = isNumeric(cr) ? 'px' : '%';\n        t.cornerradiusvalue = crValue;\n        t.cornerradiusform = crForm;\n      }\n    }\n  }\n}\n\n// Make sure all traces in a stack use the same cornerradius\nfunction standardizeCornerradius(calcTraces) {\n  if (calcTraces.length < 2) return;\n  var i, calcTrace, fullTrace, t;\n  var cr, crValue, crForm;\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    cr = fullTrace.marker ? fullTrace.marker.cornerradius : undefined;\n    if (cr !== undefined) break;\n  }\n  // If any trace has cornerradius, store first cornerradius\n  // in calcTrace[0].t so that all traces in stack use same cornerradius\n  if (cr !== undefined) {\n    crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);\n    crForm = isNumeric(cr) ? 'px' : '%';\n    for (i = 0; i < calcTraces.length; i++) {\n      calcTrace = calcTraces[i];\n      t = calcTrace[0].t;\n      t.cornerradiusvalue = crValue;\n      t.cornerradiusform = crForm;\n    }\n  }\n}\nfunction initBase(sa, calcTraces) {\n  var i, j;\n  for (i = 0; i < calcTraces.length; i++) {\n    var cd = calcTraces[i];\n    var trace = cd[0].trace;\n    var base = trace.type === 'funnel' ? trace._base : trace.base;\n    var b;\n\n    // not sure if it really makes sense to have dates for bar size data...\n    // ideally if we want to make gantt charts or something we'd treat\n    // the actual size (trace.x or y) as time delta but base as absolute\n    // time. But included here for completeness.\n    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n    // 'base' on categorical axes makes no sense\n    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {\n      return null;\n    } : sa.d2c;\n    if (isArrayOrTypedArray(base)) {\n      for (j = 0; j < Math.min(base.length, cd.length); j++) {\n        b = d2c(base[j], 0, scalendar);\n        if (isNumeric(b)) {\n          cd[j].b = +b;\n          cd[j].hasB = 1;\n        } else cd[j].b = 0;\n      }\n      for (; j < cd.length; j++) {\n        cd[j].b = 0;\n      }\n    } else {\n      b = d2c(base, 0, scalendar);\n      var hasBase = isNumeric(b);\n      b = hasBase ? b : 0;\n      for (j = 0; j < cd.length; j++) {\n        cd[j].b = b;\n        if (hasBase) cd[j].hasB = 1;\n      }\n    }\n  }\n}\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n  // update position axis and set bar offsets and widths\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var sieve = new Sieve([calcTrace], {\n      posAxis: pa,\n      sepNegVal: false,\n      overlapNoMerge: !opts.norm\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(pa, sieve, opts);\n\n    // set bar bases and sizes, and update size axis\n    //\n    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n    // is defined, because this function is also invoked for traces that\n    // can't be grouped or stacked)\n    if (opts.norm) {\n      sieveBars(sieve);\n      normalizeBars(sa, sieve, opts);\n    } else {\n      setBaseAndTop(sa, sieve);\n    }\n  }\n}\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: false,\n    overlapNoMerge: !opts.norm\n  });\n\n  // set bar offsets and widths, and update position axis\n  setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);\n\n  // relative-stack bars within the same trace that would otherwise\n  // be hidden\n  unhideBarsWithinTrace(sieve, pa);\n\n  // set bar bases and sizes, and update size axis\n  if (opts.norm) {\n    sieveBars(sieve);\n    normalizeBars(sa, sieve, opts);\n  } else {\n    setBaseAndTop(sa, sieve);\n  }\n}\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: opts.mode === 'relative',\n    overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n  });\n\n  // set bar offsets and widths, and update position axis\n  setOffsetAndWidth(pa, sieve, opts);\n\n  // set bar bases and sizes, and update size axis\n  stackBars(sa, sieve, opts);\n\n  // flag the outmost bar (for text display purposes)\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);\n        if (isOutmostBar) bar._outmost = true;\n      }\n    }\n  }\n\n  // Note that marking the outmost bars has to be done\n  // before `normalizeBars` changes `bar.b` and `bar.s`.\n  if (opts.norm) normalizeBars(sa, sieve, opts);\n}\nfunction setOffsetAndWidth(pa, sieve, opts) {\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n\n  // set bar offsets and widths\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var barWidthPlusGap = barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n  // computer bar group center and bar offset\n  var offsetFromCenter = -barWidth / 2;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n\n    // store bar width and offset for this trace\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  }\n\n  // stack bars that only differ by rounding\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n  // if defined, apply trace offset and width\n  applyAttributes(sieve);\n\n  // store the bar center in each calcdata item\n  setBarCenterAndWidth(pa, sieve);\n\n  // update position axes\n  updatePositionAxis(pa, sieve);\n}\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n  var fullLayout = gd._fullLayout;\n  var positions = sieve.positions;\n  var distinctPositions = sieve.distinctPositions;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n  var nTraces = calcTraces.length;\n\n  // if there aren't any overlapping positions,\n  // let them have full width even if mode is group\n  var overlap = positions.length !== distinctPositions.length;\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n  var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n  for (var i = 0; i < nTraces; i++) {\n    var calcTrace = calcTraces[i];\n    var trace = calcTrace[0].trace;\n    var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n    var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n    var barWidthPlusGap;\n    if (nOffsetGroups) {\n      barWidthPlusGap = barGroupWidth / nOffsetGroups;\n    } else {\n      barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n    }\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n    var offsetFromCenter;\n    if (nOffsetGroups) {\n      offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n    } else {\n      offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;\n    }\n    var t = calcTrace[0].t;\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  }\n\n  // stack bars that only differ by rounding\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n  // if defined, apply trace width\n  applyAttributes(sieve);\n\n  // store the bar center in each calcdata item\n  setBarCenterAndWidth(pa, sieve);\n\n  // update position axes\n  updatePositionAxis(pa, sieve, overlap);\n}\nfunction applyAttributes(sieve) {\n  var calcTraces = sieve.traces;\n  var i, j;\n  for (i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var t = calcTrace0.t;\n    var offset = fullTrace._offset || fullTrace.offset;\n    var initialPoffset = t.poffset;\n    var newPoffset;\n    if (isArrayOrTypedArray(offset)) {\n      // if offset is an array, then clone it into t.poffset.\n      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n      // guard against non-numeric items\n      for (j = 0; j < newPoffset.length; j++) {\n        if (!isNumeric(newPoffset[j])) {\n          newPoffset[j] = initialPoffset;\n        }\n      }\n\n      // if the length of the array is too short,\n      // then extend it with the initial value of t.poffset\n      for (j = newPoffset.length; j < calcTrace.length; j++) {\n        newPoffset.push(initialPoffset);\n      }\n      t.poffset = newPoffset;\n    } else if (offset !== undefined) {\n      t.poffset = offset;\n    }\n    var width = fullTrace._width || fullTrace.width;\n    var initialBarwidth = t.barwidth;\n    if (isArrayOrTypedArray(width)) {\n      // if width is an array, then clone it into t.barwidth.\n      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n      // guard against non-numeric items\n      for (j = 0; j < newBarwidth.length; j++) {\n        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n      }\n\n      // if the length of the array is too short,\n      // then extend it with the initial value of t.barwidth\n      for (j = newBarwidth.length; j < calcTrace.length; j++) {\n        newBarwidth.push(initialBarwidth);\n      }\n      t.barwidth = newBarwidth;\n\n      // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n      if (offset === undefined) {\n        newPoffset = [];\n        for (j = 0; j < calcTrace.length; j++) {\n          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);\n        }\n        t.poffset = newPoffset;\n      }\n    } else if (width !== undefined) {\n      t.barwidth = width;\n\n      // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n      if (offset === undefined) {\n        t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n      }\n    }\n  }\n}\nfunction setBarCenterAndWidth(pa, sieve) {\n  var calcTraces = sieve.traces;\n  var pLetter = getAxisLetter(pa);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n    var poffset = t.poffset;\n    var poffsetIsArray = isArrayOrTypedArray(poffset);\n    var barwidth = t.barwidth;\n    var barwidthIsArray = isArrayOrTypedArray(barwidth);\n    for (var j = 0; j < calcTrace.length; j++) {\n      var calcBar = calcTrace[j];\n\n      // store the actual bar width and position, for use by hover\n      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n      if (calcBar.p === undefined) {\n        calcBar.p = calcBar[pLetter];\n        calcBar['orig_' + pLetter] = calcBar[pLetter];\n      }\n      var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n      calcBar[pLetter] = calcBar.p + delta;\n    }\n  }\n}\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n  var calcTraces = sieve.traces;\n  var minDiff = sieve.minDiff;\n  var vpad = minDiff / 2;\n  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var pts = [];\n    var bar, l, r, j;\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      l = bar.p - vpad;\n      r = bar.p + vpad;\n      pts.push(l, r);\n    }\n    if (fullTrace.width || fullTrace.offset) {\n      var t = calcTrace0.t;\n      var poffset = t.poffset;\n      var barwidth = t.barwidth;\n      var poffsetIsArray = isArrayOrTypedArray(poffset);\n      var barwidthIsArray = isArrayOrTypedArray(barwidth);\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n        l = bar.p + calcBarOffset;\n        r = l + calcBarWidth;\n        pts.push(l, r);\n      }\n    }\n    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {\n      padded: false\n    });\n  }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(sa, sieve) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var isScatter = fullTrace.type === 'scatter';\n    var isVertical = fullTrace.orientation === 'v';\n    var pts = [];\n    var tozero = false;\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var base = isScatter ? 0 : bar.b;\n      var top = isScatter ? isVertical ? bar.y : bar.x : base + bar.s;\n      bar[sLetter] = top;\n      pts.push(top);\n      if (bar.hasB) pts.push(base);\n      if (!bar.hasB || !bar.b) {\n        tozero = true;\n      }\n    }\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: true\n    });\n  }\n}\nfunction stackBars(sa, sieve, opts) {\n  var sLetter = getAxisLetter(sa);\n  var calcTraces = sieve.traces;\n  var calcTrace;\n  var fullTrace;\n  var isFunnel;\n  var i, j;\n  var bar;\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    if (fullTrace.type === 'funnel') {\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        if (bar.s !== BADNUM) {\n          // create base of funnels\n          sieve.put(bar.p, -0.5 * bar.s);\n        }\n      }\n    }\n  }\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    isFunnel = fullTrace.type === 'funnel';\n    var pts = [];\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        // stack current bar and get previous sum\n        var value;\n        if (isFunnel) {\n          value = bar.s;\n        } else {\n          value = bar.s + bar.b;\n        }\n        var base = sieve.put(bar.p, value);\n        var top = base + value;\n\n        // store the bar base and top in each calcdata item\n        bar.b = base;\n        bar[sLetter] = top;\n        if (!opts.norm) {\n          pts.push(top);\n          if (bar.hasB) {\n            pts.push(base);\n          }\n        }\n      }\n    }\n\n    // if barnorm is set, let normalizeBars update the axis range\n    if (!opts.norm) {\n      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n        // N.B. we don't stack base with 'base',\n        // so set tozero:true always!\n        tozero: true,\n        padded: true\n      });\n    }\n  }\n}\nfunction sieveBars(sieve) {\n  var calcTraces = sieve.traces;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        sieve.put(bar.p, bar.b + bar.s);\n      }\n    }\n  }\n}\nfunction unhideBarsWithinTrace(sieve, pa) {\n  var calcTraces = sieve.traces;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    if (fullTrace.base === undefined) {\n      var inTraceSieve = new Sieve([calcTrace], {\n        posAxis: pa,\n        sepNegVal: true,\n        overlapNoMerge: true\n      });\n      for (var j = 0; j < calcTrace.length; j++) {\n        var bar = calcTrace[j];\n        if (bar.p !== BADNUM) {\n          // stack current bar and get previous sum\n          var base = inTraceSieve.put(bar.p, bar.b + bar.s);\n\n          // if previous sum if non-zero, this means:\n          // multiple bars have same starting point are potentially hidden,\n          // shift them vertically so that all bars are visible by default\n          if (base) bar.b = base;\n        }\n      }\n    }\n  }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(sa, sieve, opts) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  var sTop = opts.norm === 'fraction' ? 1 : 100;\n  var sTiny = sTop / 1e9; // in case of rounding error in sum\n  var sMin = sa.l2c(sa.c2l(0));\n  var sMax = opts.mode === 'stack' ? sTop : sMin;\n  function needsPadding(v) {\n    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));\n  }\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n    var padded = false;\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n        bar.b *= scale;\n        bar.s *= scale;\n        var base = bar.b;\n        var top = base + bar.s;\n        bar[sLetter] = top;\n        pts.push(top);\n        padded = padded || needsPadding(top);\n        if (bar.hasB) {\n          pts.push(base);\n          padded = padded || needsPadding(base);\n        }\n        if (!bar.hasB || !bar.b) {\n          tozero = true;\n        }\n      }\n    }\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: padded\n    });\n  }\n}\n\n// Add an `_sMin` and `_sMax` value for each bar representing the min and max size value\n// across all bars sharing the same position as that bar. These values are used for rounded\n// bar corners, to carry rounding down to lower bars in the stack as needed.\nfunction setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa) {\n  var pLetter = getAxisLetter(pa);\n  // Set `_sMin` and `_sMax` value for each bar\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var pos = bar[pLetter];\n      bar._sMin = sMinByPos[pos];\n      bar._sMax = sMaxByPos[pos];\n    }\n  }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n  var pLetter = getAxisLetter(pa);\n  var extents = {};\n  var i, j, cd;\n  var pMin = Infinity;\n  var pMax = -Infinity;\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    for (j = 0; j < cd.length; j++) {\n      var p = cd[j].p;\n      if (isNumeric(p)) {\n        pMin = Math.min(pMin, p);\n        pMax = Math.max(pMax, p);\n      }\n    }\n  }\n\n  // this is just for positioning of hover labels, and nobody will care if\n  // the label is 1px too far out; so round positions to 1/10K in case\n  // position values don't exactly match from trace to trace\n  var roundFactor = 10000 / (pMax - pMin);\n  var round = extents.round = function (p) {\n    return String(Math.round(roundFactor * (p - pMin)));\n  };\n\n  // Find min and max size axis extent for each position\n  // This is used for rounded bar corners, to carry rounding\n  // down to lower bars in the case of stacked bars\n  var sMinByPos = {};\n  var sMaxByPos = {};\n\n  // Check whether any trace has rounded corners\n  var anyTraceHasCornerradius = calcTraces.some(function (x) {\n    var trace = x[0].trace;\n    return 'marker' in trace && trace.marker.cornerradius;\n  });\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    cd[0].t.extents = extents;\n    var poffset = cd[0].t.poffset;\n    var poffsetIsArray = isArrayOrTypedArray(poffset);\n    for (j = 0; j < cd.length; j++) {\n      var di = cd[j];\n      var p0 = di[pLetter] - di.w / 2;\n      if (isNumeric(p0)) {\n        var p1 = di[pLetter] + di.w / 2;\n        var pVal = round(di.p);\n        if (extents[pVal]) {\n          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n        } else {\n          extents[pVal] = [p0, p1];\n        }\n      }\n      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n      di.p1 = di.p0 + di.w;\n      di.s0 = di.b;\n      di.s1 = di.s0 + di.s;\n      if (anyTraceHasCornerradius) {\n        var sMin = Math.min(di.s0, di.s1) || 0;\n        var sMax = Math.max(di.s0, di.s1) || 0;\n        var pos = di[pLetter];\n        sMinByPos[pos] = pos in sMinByPos ? Math.min(sMinByPos[pos], sMin) : sMin;\n        sMaxByPos[pos] = pos in sMaxByPos ? Math.max(sMaxByPos[pos], sMax) : sMax;\n      }\n    }\n  }\n  if (anyTraceHasCornerradius) {\n    setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa);\n  }\n}\nfunction getAxisLetter(ax) {\n  return ax._id.charAt(0);\n}\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setGroupPositions: setGroupPositions\n};","map":{"version":3,"names":["isNumeric","require","isArrayOrTypedArray","BADNUM","Registry","Axes","getAxisGroup","Sieve","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","fullLayout","_fullLayout","fullTraces","_fullData","calcTraces","calcdata","calcTracesHorz","calcTracesVert","i","length","fullTrace","visible","traceIs","_id","orientation","push","_computePh","cd","j","ph0","ph1","opts","xCat","type","yCat","mode","barmode","norm","barnorm","gap","bargap","groupgap","bargroupgap","setGroupPositions","pa","sa","excluded","included","calcTrace","initBase","setGroupPositionsInOverlayMode","trace","offset","undefined","setGroupPositionsInGroupMode","base","standardizeCornerradius","setGroupPositionsInStackOrRelativeMode","setCornerradius","collectExtents","t","cr","crValue","crForm","cornerradiusvalue","marker","cornerradius","slice","cornerradiusform","_base","b","scalendar","xcalendar","ycalendar","d2c","Math","min","hasB","hasBase","sieve","posAxis","sepNegVal","overlapNoMerge","setOffsetAndWidth","sieveBars","normalizeBars","setBaseAndTop","setOffsetAndWidthInGroupMode","unhideBarsWithinTrace","stackBars","bar","s","isOutmostBar","get","p","_outmost","minDiff","traces","barGroupWidth","barWidthPlusGap","barWidth","offsetFromCenter","barwidth","poffset","bargroupwidth","bardelta","binWidth","applyAttributes","setBarCenterAndWidth","updatePositionAxis","positions","distinctPositions","nTraces","overlap","groupId","alignmentGroups","_alignmentOpts","alignmentGroupOpts","alignmentgroup","nOffsetGroups","Object","keys","offsetGroups","_offsetIndex","calcTrace0","_offset","initialPoffset","newPoffset","Array","prototype","call","width","_width","initialBarwidth","newBarwidth","pLetter","getAxisLetter","poffsetIsArray","barwidthIsArray","calcBar","w","delta","allowMinDtick","vpad","minDtick","pts","l","r","calcBarOffset","calcBarWidth","_extremes","findExtremes","padded","sLetter","isScatter","isVertical","tozero","top","y","x","isFunnel","put","value","inTraceSieve","sTop","sTiny","sMin","l2c","c2l","sMax","needsPadding","v","scale","abs","setHelperValuesForRoundedCorners","sMinByPos","sMaxByPos","pos","_sMin","_sMax","extents","pMin","Infinity","pMax","max","roundFactor","round","String","anyTraceHasCornerradius","some","di","p0","p1","pVal","s0","s1","ax","charAt","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/bar/cross_trace_calc.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var fullTraces = gd._fullData;\n    var calcTraces = gd.calcdata;\n    var calcTracesHorz = [];\n    var calcTracesVert = [];\n\n    for(var i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorz.push(calcTraces[i]);\n            } else {\n                calcTracesVert.push(calcTraces[i]);\n            }\n\n            if(fullTrace._computePh) {\n                var cd = gd.calcdata[i];\n                for(var j = 0; j < cd.length; j++) {\n                    if(typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n                    if(typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n                }\n            }\n        }\n    }\n\n    var opts = {\n        xCat: xa.type === 'category' || xa.type === 'multicategory',\n        yCat: ya.type === 'category' || ya.type === 'multicategory',\n\n        mode: fullLayout.barmode,\n        norm: fullLayout.barnorm,\n        gap: fullLayout.bargap,\n        groupgap: fullLayout.bargroupgap\n    };\n\n    setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n    setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n    if(!calcTraces.length) return;\n\n    var excluded;\n    var included;\n    var i, calcTrace, fullTrace;\n\n    initBase(sa, calcTraces);\n\n    switch(opts.mode) {\n        case 'overlay':\n            setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n            break;\n\n        case 'group':\n            // exclude from the group those traces for which the user set an offset\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.offset === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n\n        case 'stack':\n        case 'relative':\n            // exclude from the stack those traces for which the user set a base\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.base === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            // If any trace in `included` has a cornerradius, set cornerradius of all bars\n            // in `included` to match the first trace which has a cornerradius\n            standardizeCornerradius(included);\n\n            if(included.length) {\n                setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n    }\n    setCornerradius(calcTraces);\n    collectExtents(calcTraces, pa);\n}\n\n// Set cornerradiusvalue and cornerradiusform in calcTraces[0].t\nfunction setCornerradius(calcTraces) {\n    var i, calcTrace, fullTrace, t, cr, crValue, crForm;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        t = calcTrace[0].t;\n\n        if(t.cornerradiusvalue === undefined) {\n            cr = fullTrace.marker ? fullTrace.marker.cornerradius : undefined;\n            if(cr !== undefined) {\n                crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);\n                crForm = isNumeric(cr) ? 'px' : '%';\n                t.cornerradiusvalue = crValue;\n                t.cornerradiusform = crForm;\n            }\n        }\n    }\n}\n\n// Make sure all traces in a stack use the same cornerradius\nfunction standardizeCornerradius(calcTraces) {\n    if(calcTraces.length < 2) return;\n    var i, calcTrace, fullTrace, t;\n    var cr, crValue, crForm;\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        cr = fullTrace.marker ? fullTrace.marker.cornerradius : undefined;\n        if(cr !== undefined) break;\n    }\n    // If any trace has cornerradius, store first cornerradius\n    // in calcTrace[0].t so that all traces in stack use same cornerradius\n    if(cr !== undefined) {\n        crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);\n        crForm = isNumeric(cr) ? 'px' : '%';\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            t = calcTrace[0].t;\n\n            t.cornerradiusvalue = crValue;\n            t.cornerradiusform = crForm;\n        }\n    }\n}\n\nfunction initBase(sa, calcTraces) {\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var cd = calcTraces[i];\n        var trace = cd[0].trace;\n        var base = (trace.type === 'funnel') ? trace._base : trace.base;\n        var b;\n\n        // not sure if it really makes sense to have dates for bar size data...\n        // ideally if we want to make gantt charts or something we'd treat\n        // the actual size (trace.x or y) as time delta but base as absolute\n        // time. But included here for completeness.\n        var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n        // 'base' on categorical axes makes no sense\n        var d2c = sa.type === 'category' || sa.type === 'multicategory' ?\n            function() { return null; } :\n            sa.d2c;\n\n        if(isArrayOrTypedArray(base)) {\n            for(j = 0; j < Math.min(base.length, cd.length); j++) {\n                b = d2c(base[j], 0, scalendar);\n                if(isNumeric(b)) {\n                    cd[j].b = +b;\n                    cd[j].hasB = 1;\n                } else cd[j].b = 0;\n            }\n            for(; j < cd.length; j++) {\n                cd[j].b = 0;\n            }\n        } else {\n            b = d2c(base, 0, scalendar);\n            var hasBase = isNumeric(b);\n            b = hasBase ? b : 0;\n            for(j = 0; j < cd.length; j++) {\n                cd[j].b = b;\n                if(hasBase) cd[j].hasB = 1;\n            }\n        }\n    }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        var sieve = new Sieve([calcTrace], {\n            posAxis: pa,\n            sepNegVal: false,\n            overlapNoMerge: !opts.norm\n        });\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(pa, sieve, opts);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(opts.norm) {\n            sieveBars(sieve);\n            normalizeBars(sa, sieve, opts);\n        } else {\n            setBaseAndTop(sa, sieve);\n        }\n    }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        posAxis: pa,\n        sepNegVal: false,\n        overlapNoMerge: !opts.norm\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);\n\n    // relative-stack bars within the same trace that would otherwise\n    // be hidden\n    unhideBarsWithinTrace(sieve, pa);\n\n    // set bar bases and sizes, and update size axis\n    if(opts.norm) {\n        sieveBars(sieve);\n        normalizeBars(sa, sieve, opts);\n    } else {\n        setBaseAndTop(sa, sieve);\n    }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        posAxis: pa,\n        sepNegVal: opts.mode === 'relative',\n        overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(pa, sieve, opts);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(sa, sieve, opts);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n                if(isOutmostBar) bar._outmost = true;\n            }\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - opts.gap);\n    var barWidthPlusGap = barGroupWidth;\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n\n        // store bar width and offset for this trace\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n    var fullLayout = gd._fullLayout;\n    var positions = sieve.positions;\n    var distinctPositions = sieve.distinctPositions;\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n    var nTraces = calcTraces.length;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n    var barGroupWidth = minDiff * (1 - opts.gap);\n\n    var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n    var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n    for(var i = 0; i < nTraces; i++) {\n        var calcTrace = calcTraces[i];\n        var trace = calcTrace[0].trace;\n\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n\n        var barWidthPlusGap;\n        if(nOffsetGroups) {\n            barWidthPlusGap = barGroupWidth / nOffsetGroups;\n        } else {\n            barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n        }\n\n        var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n        var offsetFromCenter;\n        if(nOffsetGroups) {\n            offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n        } else {\n            offsetFromCenter = overlap ?\n                ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n                -barWidth / 2;\n        }\n\n        var t = calcTrace[0].t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces;\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var t = calcTrace0.t;\n        var offset = fullTrace._offset || fullTrace.offset;\n        var initialPoffset = t.poffset;\n        var newPoffset;\n\n        if(isArrayOrTypedArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        } else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace._width || fullTrace.width;\n        var initialBarwidth = t.barwidth;\n\n        if(isArrayOrTypedArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        } else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n    var calcTraces = sieve.traces;\n    var pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n        var poffset = t.poffset;\n        var poffsetIsArray = isArrayOrTypedArray(poffset);\n        var barwidth = t.barwidth;\n        var barwidthIsArray = isArrayOrTypedArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n\n            if(calcBar.p === undefined) {\n                calcBar.p = calcBar[pLetter];\n                calcBar['orig_' + pLetter] = calcBar[pLetter];\n            }\n\n            var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n            calcBar[pLetter] = calcBar.p + delta;\n        }\n    }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces;\n    var minDiff = sieve.minDiff;\n    var vpad = minDiff / 2;\n\n    Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var pts = [];\n        var bar, l, r, j;\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n            l = bar.p - vpad;\n            r = bar.p + vpad;\n            pts.push(l, r);\n        }\n\n        if(fullTrace.width || fullTrace.offset) {\n            var t = calcTrace0.t;\n            var poffset = t.poffset;\n            var barwidth = t.barwidth;\n            var poffsetIsArray = isArrayOrTypedArray(poffset);\n            var barwidthIsArray = isArrayOrTypedArray(barwidth);\n\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n                var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n                var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n                l = bar.p + calcBarOffset;\n                r = l + calcBarWidth;\n                pts.push(l, r);\n            }\n        }\n\n        fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {padded: false});\n    }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(sa, sieve) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var isScatter = fullTrace.type === 'scatter';\n        var isVertical = fullTrace.orientation === 'v';\n        var pts = [];\n        var tozero = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n            var base = isScatter ? 0 : bar.b;\n            var top = isScatter ? (\n                isVertical ? bar.y : bar.x\n            ) : base + bar.s;\n\n            bar[sLetter] = top;\n            pts.push(top);\n            if(bar.hasB) pts.push(base);\n\n            if(!bar.hasB || !bar.b) {\n                tozero = true;\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: true\n        });\n    }\n}\n\nfunction stackBars(sa, sieve, opts) {\n    var sLetter = getAxisLetter(sa);\n    var calcTraces = sieve.traces;\n    var calcTrace;\n    var fullTrace;\n    var isFunnel;\n    var i, j;\n    var bar;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.type === 'funnel') {\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n\n                if(bar.s !== BADNUM) {\n                    // create base of funnels\n                    sieve.put(bar.p, -0.5 * bar.s);\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        isFunnel = (fullTrace.type === 'funnel');\n\n        var pts = [];\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                // stack current bar and get previous sum\n                var value;\n                if(isFunnel) {\n                    value = bar.s;\n                } else {\n                    value = bar.s + bar.b;\n                }\n\n                var base = sieve.put(bar.p, value);\n\n                var top = base + value;\n\n                // store the bar base and top in each calcdata item\n                bar.b = base;\n                bar[sLetter] = top;\n\n                if(!opts.norm) {\n                    pts.push(top);\n                    if(bar.hasB) {\n                        pts.push(base);\n                    }\n                }\n            }\n        }\n\n        // if barnorm is set, let normalizeBars update the axis range\n        if(!opts.norm) {\n            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n                // N.B. we don't stack base with 'base',\n                // so set tozero:true always!\n                tozero: true,\n                padded: true\n            });\n        }\n    }\n}\n\nfunction sieveBars(sieve) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                sieve.put(bar.p, bar.b + bar.s);\n            }\n        }\n    }\n}\n\nfunction unhideBarsWithinTrace(sieve, pa) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.base === undefined) {\n            var inTraceSieve = new Sieve([calcTrace], {\n                posAxis: pa,\n                sepNegVal: true,\n                overlapNoMerge: true\n            });\n\n            for(var j = 0; j < calcTrace.length; j++) {\n                var bar = calcTrace[j];\n\n                if(bar.p !== BADNUM) {\n                    // stack current bar and get previous sum\n                    var base = inTraceSieve.put(bar.p, bar.b + bar.s);\n\n                    // if previous sum if non-zero, this means:\n                    // multiple bars have same starting point are potentially hidden,\n                    // shift them vertically so that all bars are visible by default\n                    if(base) bar.b = base;\n                }\n            }\n        }\n    }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(sa, sieve, opts) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n    var sTop = opts.norm === 'fraction' ? 1 : 100;\n    var sTiny = sTop / 1e9; // in case of rounding error in sum\n    var sMin = sa.l2c(sa.c2l(0));\n    var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n    function needsPadding(v) {\n        return (\n            isNumeric(sa.c2l(v)) &&\n            ((v < sMin - sTiny) || (v > sMax + sTiny) || !isNumeric(sMin))\n        );\n    }\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var tozero = false;\n        var padded = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n                bar.b *= scale;\n                bar.s *= scale;\n\n                var base = bar.b;\n                var top = base + bar.s;\n\n                bar[sLetter] = top;\n                pts.push(top);\n                padded = padded || needsPadding(top);\n\n                if(bar.hasB) {\n                    pts.push(base);\n                    padded = padded || needsPadding(base);\n                }\n\n                if(!bar.hasB || !bar.b) {\n                    tozero = true;\n                }\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: padded\n        });\n    }\n}\n\n// Add an `_sMin` and `_sMax` value for each bar representing the min and max size value\n// across all bars sharing the same position as that bar. These values are used for rounded\n// bar corners, to carry rounding down to lower bars in the stack as needed.\nfunction setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa) {\n    var pLetter = getAxisLetter(pa);\n    // Set `_sMin` and `_sMax` value for each bar\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n            var pos = bar[pLetter];\n            bar._sMin = sMinByPos[pos];\n            bar._sMax = sMaxByPos[pos];\n        }\n    }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n    var pLetter = getAxisLetter(pa);\n    var extents = {};\n    var i, j, cd;\n\n    var pMin = Infinity;\n    var pMax = -Infinity;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        for(j = 0; j < cd.length; j++) {\n            var p = cd[j].p;\n            if(isNumeric(p)) {\n                pMin = Math.min(pMin, p);\n                pMax = Math.max(pMax, p);\n            }\n        }\n    }\n\n    // this is just for positioning of hover labels, and nobody will care if\n    // the label is 1px too far out; so round positions to 1/10K in case\n    // position values don't exactly match from trace to trace\n    var roundFactor = 10000 / (pMax - pMin);\n    var round = extents.round = function(p) {\n        return String(Math.round(roundFactor * (p - pMin)));\n    };\n\n    // Find min and max size axis extent for each position\n    // This is used for rounded bar corners, to carry rounding\n    // down to lower bars in the case of stacked bars\n    var sMinByPos = {};\n    var sMaxByPos = {};\n\n    // Check whether any trace has rounded corners\n    var anyTraceHasCornerradius = calcTraces.some(function(x) {\n        var trace = x[0].trace;\n        return 'marker' in trace && trace.marker.cornerradius;\n    });\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        cd[0].t.extents = extents;\n\n        var poffset = cd[0].t.poffset;\n        var poffsetIsArray = isArrayOrTypedArray(poffset);\n\n        for(j = 0; j < cd.length; j++) {\n            var di = cd[j];\n            var p0 = di[pLetter] - di.w / 2;\n\n            if(isNumeric(p0)) {\n                var p1 = di[pLetter] + di.w / 2;\n                var pVal = round(di.p);\n                if(extents[pVal]) {\n                    extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n                } else {\n                    extents[pVal] = [p0, p1];\n                }\n            }\n\n            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n            di.p1 = di.p0 + di.w;\n            di.s0 = di.b;\n            di.s1 = di.s0 + di.s;\n\n            if(anyTraceHasCornerradius) {\n                var sMin = Math.min(di.s0, di.s1) || 0;\n                var sMax = Math.max(di.s0, di.s1) || 0;\n                var pos = di[pLetter];\n                sMinByPos[pos] = (pos in sMinByPos) ? Math.min(sMinByPos[pos], sMin) : sMin;\n                sMaxByPos[pos] = (pos in sMaxByPos) ? Math.max(sMaxByPos[pos], sMax) : sMax;\n            }\n        }\n    }\n    if(anyTraceHasCornerradius) {\n        setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa);\n    }\n}\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setGroupPositions: setGroupPositions\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}