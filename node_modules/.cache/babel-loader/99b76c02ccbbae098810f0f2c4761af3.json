{"ast":null,"code":"'use strict';\n\nmodule.exports = Sieve;\nvar distinctVals = require('../../lib').distinctVals;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n *\n * @param {Array} traces\n*   Array of calculated traces\n * @param {object} opts\n *  - @param {boolean} [sepNegVal]\n *      If true, then split data at the same position into a bar\n *      for positive values and another for negative values\n *  - @param {boolean} [overlapNoMerge]\n *     If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, opts) {\n  this.traces = traces;\n  this.sepNegVal = opts.sepNegVal;\n  this.overlapNoMerge = opts.overlapNoMerge;\n\n  // for single-bin histograms - see histogram/calc\n  var width1 = Infinity;\n  var axLetter = opts.posAxis._id.charAt(0);\n  var positions = [];\n  for (var i = 0; i < traces.length; i++) {\n    var trace = traces[i];\n    for (var j = 0; j < trace.length; j++) {\n      var bar = trace[j];\n      var pos = bar.p;\n      if (pos === undefined) {\n        pos = bar[axLetter];\n      }\n      if (pos !== undefined) positions.push(pos);\n    }\n    if (trace[0] && trace[0].width1) {\n      width1 = Math.min(trace[0].width1, width1);\n    }\n  }\n  this.positions = positions;\n  var dv = distinctVals(positions);\n  this.distinctPositions = dv.vals;\n  if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;else this.minDiff = Math.min(dv.minDiff, width1);\n  var type = (opts.posAxis || {}).type;\n  if (type === 'category' || type === 'multicategory') {\n    this.minDiff = 1;\n  }\n  this.binWidth = this.minDiff;\n  this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n  var label = this.getLabel(position, value);\n  var oldValue = this.bins[label] || 0;\n  this.bins[label] = oldValue + value;\n  return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function get(position, value) {\n  var label = this.getLabel(position, value);\n  return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n  var prefix = value < 0 && this.sepNegVal ? 'v' : '^';\n  var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);\n  return prefix + label;\n};","map":{"version":3,"names":["module","exports","Sieve","distinctVals","require","traces","opts","sepNegVal","overlapNoMerge","width1","Infinity","axLetter","posAxis","_id","charAt","positions","i","length","trace","j","bar","pos","p","undefined","push","Math","min","dv","distinctPositions","vals","minDiff","type","binWidth","bins","prototype","put","position","value","label","getLabel","oldValue","get","prefix","round"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/bar/sieve.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Sieve;\n\nvar distinctVals = require('../../lib').distinctVals;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n *\n * @param {Array} traces\n*   Array of calculated traces\n * @param {object} opts\n *  - @param {boolean} [sepNegVal]\n *      If true, then split data at the same position into a bar\n *      for positive values and another for negative values\n *  - @param {boolean} [overlapNoMerge]\n *     If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, opts) {\n    this.traces = traces;\n    this.sepNegVal = opts.sepNegVal;\n    this.overlapNoMerge = opts.overlapNoMerge;\n\n    // for single-bin histograms - see histogram/calc\n    var width1 = Infinity;\n\n    var axLetter = opts.posAxis._id.charAt(0);\n\n    var positions = [];\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n            var pos = bar.p;\n            if(pos === undefined) {\n                pos = bar[axLetter];\n            }\n            if(pos !== undefined) positions.push(pos);\n        }\n        if(trace[0] && trace[0].width1) {\n            width1 = Math.min(trace[0].width1, width1);\n        }\n    }\n    this.positions = positions;\n\n    var dv = distinctVals(positions);\n\n    this.distinctPositions = dv.vals;\n    if(dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;\n    else this.minDiff = Math.min(dv.minDiff, width1);\n\n    var type = (opts.posAxis || {}).type;\n    if(type === 'category' || type === 'multicategory') {\n        this.minDiff = 1;\n    }\n\n    this.binWidth = this.minDiff;\n\n    this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n    var label = this.getLabel(position, value);\n    var oldValue = this.bins[label] || 0;\n\n    this.bins[label] = oldValue + value;\n\n    return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function get(position, value) {\n    var label = this.getLabel(position, value);\n    return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n    var prefix = (value < 0 && this.sepNegVal) ? 'v' : '^';\n    var label = (this.overlapNoMerge) ?\n        position :\n        Math.round(position / this.binWidth);\n    return prefix + label;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}