{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Lib = require('../../lib');\nvar pushUnique = Lib.pushUnique;\nvar strTranslate = Lib.strTranslate;\nvar strRotate = Lib.strRotate;\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar dragElement = require('../dragelement');\nvar Axes = require('../../plots/cartesian/axes');\nvar zindexSeparator = require('../../plots/cartesian/constants').zindexSeparator;\nvar Registry = require('../../registry');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar legendSupplyDefaults = require('../legend/defaults');\nvar legendDraw = require('../legend/draw');\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180;\n\n// expansion of projected height\nvar YFACTOR = 1 / Math.sin(YA_RADIANS);\n\n// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS);\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\nvar multipleHoverPoints = {\n  box: true,\n  ohlc: true,\n  violin: true,\n  candlestick: true\n};\nvar cartesianScatterPoints = {\n  scatter: true,\n  scattergl: true,\n  splom: true\n};\nfunction distanceSort(a, b) {\n  return a.distance - b.distance;\n}\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n  gd = Lib.getGraphDiv(gd);\n  // The 'target' property changes when bubbling out of Shadow DOM.\n  // Throttling can delay reading the target, so we save the current value.\n  var eventTarget = evt.target;\n  Lib.throttle(gd._fullLayout._uid + constants.HOVERID, constants.HOVERMINTIME, function () {\n    _hover(gd, evt, subplot, noHoverEvent, eventTarget);\n  });\n};\n\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\nexports.loneHover = function loneHover(hoverItems, opts) {\n  var multiHover = true;\n  if (!Array.isArray(hoverItems)) {\n    multiHover = false;\n    hoverItems = [hoverItems];\n  }\n  var gd = opts.gd;\n  var gTop = getTopOffset(gd);\n  var gLeft = getLeftOffset(gd);\n  var pointsData = hoverItems.map(function (hoverItem) {\n    var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;\n    var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;\n    var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;\n    var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;\n    var eventData = hoverItem.eventData;\n    if (eventData) {\n      var x0 = Math.min(_x0, _x1);\n      var x1 = Math.max(_x0, _x1);\n      var y0 = Math.min(_y0, _y1);\n      var y1 = Math.max(_y0, _y1);\n      var trace = hoverItem.trace;\n      if (Registry.traceIs(trace, 'gl3d')) {\n        var container = gd._fullLayout[trace.scene]._scene.container;\n        var dx = container.offsetLeft;\n        var dy = container.offsetTop;\n        x0 += dx;\n        x1 += dx;\n        y0 += dy;\n        y1 += dy;\n      } // TODO: handle heatmapgl\n\n      eventData.bbox = {\n        x0: x0 + gLeft,\n        x1: x1 + gLeft,\n        y0: y0 + gTop,\n        y1: y1 + gTop\n      };\n      if (opts.inOut_bbox) {\n        opts.inOut_bbox.push(eventData.bbox);\n      }\n    } else {\n      eventData = false;\n    }\n    return {\n      color: hoverItem.color || Color.defaultLine,\n      x0: hoverItem.x0 || hoverItem.x || 0,\n      x1: hoverItem.x1 || hoverItem.x || 0,\n      y0: hoverItem.y0 || hoverItem.y || 0,\n      y1: hoverItem.y1 || hoverItem.y || 0,\n      xLabel: hoverItem.xLabel,\n      yLabel: hoverItem.yLabel,\n      zLabel: hoverItem.zLabel,\n      text: hoverItem.text,\n      name: hoverItem.name,\n      idealAlign: hoverItem.idealAlign,\n      // optional extra bits of styling\n      borderColor: hoverItem.borderColor,\n      fontFamily: hoverItem.fontFamily,\n      fontSize: hoverItem.fontSize,\n      fontColor: hoverItem.fontColor,\n      fontWeight: hoverItem.fontWeight,\n      fontStyle: hoverItem.fontStyle,\n      fontVariant: hoverItem.fontVariant,\n      nameLength: hoverItem.nameLength,\n      textAlign: hoverItem.textAlign,\n      // filler to make createHoverText happy\n      trace: hoverItem.trace || {\n        index: 0,\n        hoverinfo: ''\n      },\n      xa: {\n        _offset: 0\n      },\n      ya: {\n        _offset: 0\n      },\n      index: 0,\n      hovertemplate: hoverItem.hovertemplate || false,\n      hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n      eventData: eventData\n    };\n  });\n  var rotateLabels = false;\n  var hoverText = createHoverText(pointsData, {\n    gd: gd,\n    hovermode: 'closest',\n    rotateLabels: rotateLabels,\n    bgColor: opts.bgColor || Color.background,\n    container: d3.select(opts.container),\n    outerContainer: opts.outerContainer || opts.container\n  });\n  var hoverLabel = hoverText.hoverLabels;\n\n  // Fix vertical overlap\n  var tooltipSpacing = 5;\n  var lastBottomY = 0;\n  var anchor = 0;\n  hoverLabel.sort(function (a, b) {\n    return a.y0 - b.y0;\n  }).each(function (d, i) {\n    var topY = d.y0 - d.by / 2;\n    if (topY - tooltipSpacing < lastBottomY) {\n      d.offset = lastBottomY - topY + tooltipSpacing;\n    } else {\n      d.offset = 0;\n    }\n    lastBottomY = topY + d.by + d.offset;\n    if (i === opts.anchorIndex || 0) anchor = d.offset;\n  }).each(function (d) {\n    d.offset -= anchor;\n  });\n  var scaleX = gd._fullLayout._invScaleX;\n  var scaleY = gd._fullLayout._invScaleY;\n  alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);\n  return multiHover ? hoverLabel : hoverLabel.node();\n};\n\n// The actual implementation is here:\nfunction _hover(gd, evt, subplot, noHoverEvent, eventTarget) {\n  if (!subplot) subplot = 'xy';\n  if (typeof subplot === 'string') {\n    // drop zindex from subplot id\n    subplot = subplot.split(zindexSeparator)[0];\n  }\n\n  // if the user passed in an array of subplots,\n  // use those instead of finding overlayed plots\n  var subplots = Array.isArray(subplot) ? subplot : [subplot];\n  var spId;\n  var fullLayout = gd._fullLayout;\n  var hoversubplots = fullLayout.hoversubplots;\n  var plots = fullLayout._plots || [];\n  var plotinfo = plots[subplot];\n  var hasCartesian = fullLayout._has('cartesian');\n  var hovermode = evt.hovermode || fullLayout.hovermode;\n  var hovermodeHasX = (hovermode || '').charAt(0) === 'x';\n  var hovermodeHasY = (hovermode || '').charAt(0) === 'y';\n  var firstXaxis;\n  var firstYaxis;\n  if (hasCartesian && (hovermodeHasX || hovermodeHasY) && hoversubplots === 'axis') {\n    var subplotsLength = subplots.length;\n    for (var p = 0; p < subplotsLength; p++) {\n      spId = subplots[p];\n      if (plots[spId]) {\n        // 'cartesian' case\n\n        firstXaxis = Axes.getFromId(gd, spId, 'x');\n        firstYaxis = Axes.getFromId(gd, spId, 'y');\n        var subplotsWith = (hovermodeHasX ? firstXaxis : firstYaxis)._subplotsWith;\n        if (subplotsWith && subplotsWith.length) {\n          for (var q = 0; q < subplotsWith.length; q++) {\n            pushUnique(subplots, subplotsWith[q]);\n          }\n        }\n      }\n    }\n  }\n\n  // list of all overlaid subplots to look at\n  if (plotinfo && hoversubplots !== 'single') {\n    var overlayedSubplots = plotinfo.overlays.map(function (pi) {\n      return pi.id;\n    });\n    subplots = subplots.concat(overlayedSubplots);\n  }\n  var len = subplots.length;\n  var xaArray = new Array(len);\n  var yaArray = new Array(len);\n  var supportsCompare = false;\n  for (var i = 0; i < len; i++) {\n    spId = subplots[i];\n    if (plots[spId]) {\n      // 'cartesian' case\n      supportsCompare = true;\n      xaArray[i] = plots[spId].xaxis;\n      yaArray[i] = plots[spId].yaxis;\n    } else if (fullLayout[spId] && fullLayout[spId]._subplot) {\n      // other subplot types\n      var _subplot = fullLayout[spId]._subplot;\n      xaArray[i] = _subplot.xaxis;\n      yaArray[i] = _subplot.yaxis;\n    } else {\n      Lib.warn('Unrecognized subplot: ' + spId);\n      return;\n    }\n  }\n  if (hovermode && !supportsCompare) hovermode = 'closest';\n  if (['x', 'y', 'closest', 'x unified', 'y unified'].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector('.zoombox') || gd._dragging) {\n    return dragElement.unhoverRaw(gd, evt);\n  }\n  var hoverdistance = fullLayout.hoverdistance;\n  if (hoverdistance === -1) hoverdistance = Infinity;\n  var spikedistance = fullLayout.spikedistance;\n  if (spikedistance === -1) spikedistance = Infinity;\n\n  // hoverData: the set of candidate points we've found to highlight\n  var hoverData = [];\n\n  // searchData: the data to search in. Mostly this is just a copy of\n  // gd.calcdata, filtered to the subplot and overlays we're on\n  // but if a point array is supplied it will be a mapping\n  // of indicated curves\n  var searchData = [];\n\n  // [x|y]valArray: the axis values of the hover event\n  // mapped onto each of the currently selected overlaid subplots\n  var xvalArray, yvalArray;\n  var itemnum, curvenum, cd, trace, subplotId, subploti, _mode, xval, yval, pointData, closedataPreviousLength;\n\n  // spikePoints: the set of candidate points we've found to draw spikes to\n  var spikePoints = {\n    hLinePoint: null,\n    vLinePoint: null\n  };\n\n  // does subplot have one (or more) horizontal traces?\n  // This is used to determine whether we rotate the labels or not\n  var hasOneHorizontalTrace = false;\n\n  // Figure out what we're hovering on:\n  // mouse location or user-supplied data\n\n  if (Array.isArray(evt)) {\n    // user specified an array of points to highlight\n    hovermode = 'array';\n    for (itemnum = 0; itemnum < evt.length; itemnum++) {\n      cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n      if (cd) {\n        trace = cd[0].trace;\n        if (cd[0].trace.hoverinfo !== 'skip') {\n          searchData.push(cd);\n          if (trace.orientation === 'h') {\n            hasOneHorizontalTrace = true;\n          }\n        }\n      }\n    }\n  } else {\n    // take into account zorder\n    var zorderedCalcdata = gd.calcdata.slice();\n    zorderedCalcdata.sort(function (a, b) {\n      var aZorder = a[0].trace.zorder || 0;\n      var bZorder = b[0].trace.zorder || 0;\n      return aZorder - bZorder;\n    });\n    for (curvenum = 0; curvenum < zorderedCalcdata.length; curvenum++) {\n      cd = zorderedCalcdata[curvenum];\n      trace = cd[0].trace;\n      if (trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n        searchData.push(cd);\n        if (trace.orientation === 'h') {\n          hasOneHorizontalTrace = true;\n        }\n      }\n    }\n\n    // [x|y]px: the pixels (from top left) of the mouse location\n    // on the currently selected plot area\n    // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n    var hasUserCalledHover = !eventTarget;\n    var xpx, ypx;\n    if (hasUserCalledHover) {\n      if ('xpx' in evt) xpx = evt.xpx;else xpx = xaArray[0]._length / 2;\n      if ('ypx' in evt) ypx = evt.ypx;else ypx = yaArray[0]._length / 2;\n    } else {\n      // fire the beforehover event and quit if it returns false\n      // note that we're only calling this on real mouse events, so\n      // manual calls to fx.hover will always run.\n      if (Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n        return;\n      }\n      var dbb = eventTarget.getBoundingClientRect();\n      xpx = evt.clientX - dbb.left;\n      ypx = evt.clientY - dbb.top;\n      fullLayout._calcInverseTransform(gd);\n      var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);\n      xpx = transformedCoords[0];\n      ypx = transformedCoords[1];\n\n      // in case hover was called from mouseout into hovertext,\n      // it's possible you're not actually over the plot anymore\n      if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n        return dragElement.unhoverRaw(gd, evt);\n      }\n    }\n    evt.pointerX = xpx + xaArray[0]._offset;\n    evt.pointerY = ypx + yaArray[0]._offset;\n    if ('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);else xvalArray = helpers.p2c(xaArray, xpx);\n    if ('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);else yvalArray = helpers.p2c(yaArray, ypx);\n    if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n      Lib.warn('Fx.hover failed', evt, gd);\n      return dragElement.unhoverRaw(gd, evt);\n    }\n  }\n\n  // the pixel distance to beat as a matching point\n  // in 'x' or 'y' mode this resets for each trace\n  var distance = Infinity;\n\n  // find the closest point in each trace\n  // this is minimum dx and/or dy, depending on mode\n  // and the pixel position for the label (labelXpx, labelYpx)\n  function findHoverPoints(customXVal, customYVal) {\n    for (curvenum = 0; curvenum < searchData.length; curvenum++) {\n      cd = searchData[curvenum];\n\n      // filter out invisible or broken data\n      if (!cd || !cd[0] || !cd[0].trace) continue;\n      trace = cd[0].trace;\n      if (trace.visible !== true || trace._length === 0) continue;\n\n      // Explicitly bail out for these two. I don't know how to otherwise prevent\n      // the rest of this function from running and failing\n      if (['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n      // within one trace mode can sometimes be overridden\n      _mode = hovermode;\n      if (helpers.isUnifiedHover(_mode)) {\n        _mode = _mode.charAt(0);\n      }\n      if (trace.type === 'splom') {\n        // splom traces do not generate overlay subplots,\n        // it is safe to assume here splom traces correspond to the 0th subplot\n        subploti = 0;\n        subplotId = subplots[subploti];\n      } else {\n        subplotId = helpers.getSubplot(trace);\n        subploti = subplots.indexOf(subplotId);\n      }\n\n      // container for new point, also used to pass info into module.hoverPoints\n      pointData = {\n        // trace properties\n        cd: cd,\n        trace: trace,\n        xa: xaArray[subploti],\n        ya: yaArray[subploti],\n        // max distances for hover and spikes - for points that want to show but do not\n        // want to override other points, set distance/spikeDistance equal to max*Distance\n        // and it will not get filtered out but it will be guaranteed to have a greater\n        // distance than any point that calculated a real distance.\n        maxHoverDistance: hoverdistance,\n        maxSpikeDistance: spikedistance,\n        // point properties - override all of these\n        index: false,\n        // point index in trace - only used by plotly.js hoverdata consumers\n        distance: Math.min(distance, hoverdistance),\n        // pixel distance or pseudo-distance\n\n        // distance/pseudo-distance for spikes. This distance should always be calculated\n        // as if in \"closest\" mode, and should only be set if this point should\n        // generate a spike.\n        spikeDistance: Infinity,\n        // in some cases the spikes have different positioning from the hover label\n        // they don't need x0/x1, just one position\n        xSpike: undefined,\n        ySpike: undefined,\n        // where and how to display the hover label\n        color: Color.defaultLine,\n        // trace color\n        name: trace.name,\n        x0: undefined,\n        x1: undefined,\n        y0: undefined,\n        y1: undefined,\n        xLabelVal: undefined,\n        yLabelVal: undefined,\n        zLabelVal: undefined,\n        text: undefined\n      };\n\n      // add ref to subplot object (non-cartesian case)\n      if (fullLayout[subplotId]) {\n        pointData.subplot = fullLayout[subplotId]._subplot;\n      }\n      // add ref to splom scene\n      if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n        pointData.scene = fullLayout._splomScenes[trace.uid];\n      }\n\n      // for a highlighting array, figure out what\n      // we're searching for with this element\n      if (_mode === 'array') {\n        var selection = evt[curvenum];\n        if ('pointNumber' in selection) {\n          pointData.index = selection.pointNumber;\n          _mode = 'closest';\n        } else {\n          _mode = '';\n          if ('xval' in selection) {\n            xval = selection.xval;\n            _mode = 'x';\n          }\n          if ('yval' in selection) {\n            yval = selection.yval;\n            _mode = _mode ? 'closest' : 'y';\n          }\n        }\n      } else if (customXVal !== undefined && customYVal !== undefined) {\n        xval = customXVal;\n        yval = customYVal;\n      } else {\n        xval = xvalArray[subploti];\n        yval = yvalArray[subploti];\n      }\n      closedataPreviousLength = hoverData.length;\n\n      // Now if there is range to look in, find the points to hover.\n      if (hoverdistance !== 0) {\n        if (trace._module && trace._module.hoverPoints) {\n          var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {\n            finiteRange: true,\n            hoverLayer: fullLayout._hoverlayer,\n            // options for splom when hovering on same axis\n            hoversubplots: hoversubplots,\n            gd: gd\n          });\n          if (newPoints) {\n            var newPoint;\n            for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n              newPoint = newPoints[newPointNum];\n              if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                hoverData.push(cleanPoint(newPoint, hovermode));\n              }\n            }\n          }\n        } else {\n          Lib.log('Unrecognized trace type in hover:', trace);\n        }\n      }\n\n      // in closest mode, remove any existing (farther) points\n      // and don't look any farther than this latest point (or points, some\n      // traces like box & violin make multiple hover labels at once)\n      if (hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n        hoverData.splice(0, closedataPreviousLength);\n        distance = hoverData[0].distance;\n      }\n\n      // Now if there is range to look in, find the points to draw the spikelines\n      // Do it only if there is no hoverData\n      if (hasCartesian && spikedistance !== 0) {\n        if (hoverData.length === 0) {\n          pointData.distance = spikedistance;\n          pointData.index = false;\n          var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', {\n            hoverLayer: fullLayout._hoverlayer\n          });\n          if (closestPoints) {\n            closestPoints = closestPoints.filter(function (point) {\n              // some hover points, like scatter fills, do not allow spikes,\n              // so will generate a hover point but without a valid spikeDistance\n              return point.spikeDistance <= spikedistance;\n            });\n          }\n          if (closestPoints && closestPoints.length) {\n            var tmpPoint;\n            var closestVPoints = closestPoints.filter(function (point) {\n              return point.xa.showspikes && point.xa.spikesnap !== 'hovered data';\n            });\n            if (closestVPoints.length) {\n              var closestVPt = closestVPoints[0];\n              if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n                tmpPoint = fillSpikePoint(closestVPt);\n                if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                  spikePoints.vLinePoint = tmpPoint;\n                }\n              }\n            }\n            var closestHPoints = closestPoints.filter(function (point) {\n              return point.ya.showspikes && point.ya.spikesnap !== 'hovered data';\n            });\n            if (closestHPoints.length) {\n              var closestHPt = closestHPoints[0];\n              if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n                tmpPoint = fillSpikePoint(closestHPt);\n                if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                  spikePoints.hLinePoint = tmpPoint;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  findHoverPoints();\n  function selectClosestPoint(pointsData, spikedistance, spikeOnWinning) {\n    var resultPoint = null;\n    var minDistance = Infinity;\n    var thisSpikeDistance;\n    for (var i = 0; i < pointsData.length; i++) {\n      if (firstXaxis && firstXaxis._id !== pointsData[i].xa._id) continue;\n      if (firstYaxis && firstYaxis._id !== pointsData[i].ya._id) continue;\n      thisSpikeDistance = pointsData[i].spikeDistance;\n      if (spikeOnWinning && i === 0) thisSpikeDistance = -Infinity;\n      if (thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance) {\n        resultPoint = pointsData[i];\n        minDistance = thisSpikeDistance;\n      }\n    }\n    return resultPoint;\n  }\n  function fillSpikePoint(point) {\n    if (!point) return null;\n    return {\n      xa: point.xa,\n      ya: point.ya,\n      x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n      y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n      distance: point.distance,\n      spikeDistance: point.spikeDistance,\n      curveNumber: point.trace.index,\n      color: point.color,\n      pointNumber: point.index\n    };\n  }\n  var spikelineOpts = {\n    fullLayout: fullLayout,\n    container: fullLayout._hoverlayer,\n    event: evt\n  };\n  var oldspikepoints = gd._spikepoints;\n  var newspikepoints = {\n    vLinePoint: spikePoints.vLinePoint,\n    hLinePoint: spikePoints.hLinePoint\n  };\n  gd._spikepoints = newspikepoints;\n  var sortHoverData = function () {\n    // When sorting keep the points in the main subplot at the top\n    // then add points in other subplots\n\n    var hoverDataInSubplot = hoverData.filter(function (a) {\n      return firstXaxis && firstXaxis._id === a.xa._id && firstYaxis && firstYaxis._id === a.ya._id;\n    });\n    var hoverDataOutSubplot = hoverData.filter(function (a) {\n      return !(firstXaxis && firstXaxis._id === a.xa._id && firstYaxis && firstYaxis._id === a.ya._id);\n    });\n    hoverDataInSubplot.sort(distanceSort);\n    hoverDataOutSubplot.sort(distanceSort);\n    hoverData = hoverDataInSubplot.concat(hoverDataOutSubplot);\n\n    // move period positioned points and box/bar-like traces to the end of the list\n    hoverData = orderRangePoints(hoverData, hovermode);\n  };\n  sortHoverData();\n  var axLetter = hovermode.charAt(0);\n  var spikeOnWinning = (axLetter === 'x' || axLetter === 'y') && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];\n\n  // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n  if (hasCartesian && spikedistance !== 0) {\n    if (hoverData.length !== 0) {\n      var tmpHPointData = hoverData.filter(function (point) {\n        return point.ya.showspikes;\n      });\n      var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);\n      spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n      var tmpVPointData = hoverData.filter(function (point) {\n        return point.xa.showspikes;\n      });\n      var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);\n      spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n    }\n  }\n\n  // if hoverData is empty check for the spikes to draw and quit if there are none\n  if (hoverData.length === 0) {\n    var result = dragElement.unhoverRaw(gd, evt);\n    if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {\n      if (spikesChanged(oldspikepoints)) {\n        createSpikelines(gd, spikePoints, spikelineOpts);\n      }\n    }\n    return result;\n  }\n  if (hasCartesian) {\n    if (spikesChanged(oldspikepoints)) {\n      createSpikelines(gd, spikePoints, spikelineOpts);\n    }\n  }\n  if (helpers.isXYhover(_mode) && hoverData[0].length !== 0 && hoverData[0].trace.type !== 'splom' // TODO: add support for splom\n  ) {\n    // pick winning point\n    var winningPoint = hoverData[0];\n    // discard other points\n    if (multipleHoverPoints[winningPoint.trace.type]) {\n      hoverData = hoverData.filter(function (d) {\n        return d.trace.index === winningPoint.trace.index;\n      });\n    } else {\n      hoverData = [winningPoint];\n    }\n    var initLen = hoverData.length;\n    var winX = getCoord('x', winningPoint, fullLayout);\n    var winY = getCoord('y', winningPoint, fullLayout);\n\n    // in compare mode, select every point at position\n    findHoverPoints(winX, winY);\n    var finalPoints = [];\n    var seen = {};\n    var id = 0;\n    var insert = function (newHd) {\n      var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;\n      if (!seen[key]) {\n        id++;\n        seen[key] = id;\n        finalPoints.push(newHd);\n      } else {\n        var oldId = seen[key] - 1;\n        var oldHd = finalPoints[oldId];\n        if (oldId > 0 && Math.abs(newHd.distance) < Math.abs(oldHd.distance)) {\n          // replace with closest\n          finalPoints[oldId] = newHd;\n        }\n      }\n    };\n    var k;\n    // insert the winnig point(s) first\n    for (k = 0; k < initLen; k++) {\n      insert(hoverData[k]);\n    }\n    // override from the end\n    for (k = hoverData.length - 1; k > initLen - 1; k--) {\n      insert(hoverData[k]);\n    }\n    hoverData = finalPoints;\n    sortHoverData();\n  }\n\n  // lastly, emit custom hover/unhover events\n  var oldhoverdata = gd._hoverdata;\n  var newhoverdata = [];\n  var gTop = getTopOffset(gd);\n  var gLeft = getLeftOffset(gd);\n\n  // pull out just the data that's useful to\n  // other people and send it to the event\n  for (itemnum = 0; itemnum < hoverData.length; itemnum++) {\n    var pt = hoverData[itemnum];\n    var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n    if (pt.hovertemplate !== false) {\n      var ht = false;\n      if (pt.cd[pt.index] && pt.cd[pt.index].ht) {\n        ht = pt.cd[pt.index].ht;\n      }\n      pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n    }\n    if (pt.xa && pt.ya) {\n      var _x0 = pt.x0 + pt.xa._offset;\n      var _x1 = pt.x1 + pt.xa._offset;\n      var _y0 = pt.y0 + pt.ya._offset;\n      var _y1 = pt.y1 + pt.ya._offset;\n      var x0 = Math.min(_x0, _x1);\n      var x1 = Math.max(_x0, _x1);\n      var y0 = Math.min(_y0, _y1);\n      var y1 = Math.max(_y0, _y1);\n      eventData.bbox = {\n        x0: x0 + gLeft,\n        x1: x1 + gLeft,\n        y0: y0 + gTop,\n        y1: y1 + gTop\n      };\n    }\n    pt.eventData = [eventData];\n    newhoverdata.push(eventData);\n  }\n  gd._hoverdata = newhoverdata;\n  var rotateLabels = hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1) || hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1;\n  var bgColor = Color.combine(fullLayout.plot_bgcolor || Color.background, fullLayout.paper_bgcolor);\n  var hoverText = createHoverText(hoverData, {\n    gd: gd,\n    hovermode: hovermode,\n    rotateLabels: rotateLabels,\n    bgColor: bgColor,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paper.node(),\n    commonLabelOpts: fullLayout.hoverlabel,\n    hoverdistance: fullLayout.hoverdistance\n  });\n  var hoverLabels = hoverText.hoverLabels;\n  if (!helpers.isUnifiedHover(hovermode)) {\n    hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, hoverText.commonLabelBoundingBox);\n    alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);\n  } // TODO: tagName hack is needed to appease geo.js's hack of using eventTarget=true\n  // we should improve the \"fx\" API so other plots can use it without these hack.\n  if (eventTarget && eventTarget.tagName) {\n    var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n    overrideCursor(d3.select(eventTarget), hasClickToShow ? 'pointer' : '');\n  }\n\n  // don't emit events if called manually\n  if (!eventTarget || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n  if (oldhoverdata) {\n    gd.emit('plotly_unhover', {\n      event: evt,\n      points: oldhoverdata\n    });\n  }\n  gd.emit('plotly_hover', {\n    event: evt,\n    points: gd._hoverdata,\n    xaxes: xaArray,\n    yaxes: yaArray,\n    xvals: xvalArray,\n    yvals: yvalArray\n  });\n}\nfunction hoverDataKey(d) {\n  return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : '', d.ya ? d.ya._id : ''].join(',');\n}\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\nfunction createHoverText(hoverData, opts) {\n  var gd = opts.gd;\n  var fullLayout = gd._fullLayout;\n  var hovermode = opts.hovermode;\n  var rotateLabels = opts.rotateLabels;\n  var bgColor = opts.bgColor;\n  var container = opts.container;\n  var outerContainer = opts.outerContainer;\n  var commonLabelOpts = opts.commonLabelOpts || {};\n  // Early exit if no labels are drawn\n  if (hoverData.length === 0) return [[]];\n\n  // opts.fontFamily/Size are used for the common label\n  // and as defaults for each hover label, though the individual labels\n  // can override this.\n  var fontFamily = opts.fontFamily || constants.HOVERFONT;\n  var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n  var fontWeight = opts.fontWeight || fullLayout.font.weight;\n  var fontStyle = opts.fontStyle || fullLayout.font.style;\n  var fontVariant = opts.fontVariant || fullLayout.font.variant;\n  var fontTextcase = opts.fontTextcase || fullLayout.font.textcase;\n  var fontLineposition = opts.fontLineposition || fullLayout.font.lineposition;\n  var fontShadow = opts.fontShadow || fullLayout.font.shadow;\n  var c0 = hoverData[0];\n  var xa = c0.xa;\n  var ya = c0.ya;\n  var axLetter = hovermode.charAt(0);\n  var axLabel = axLetter + 'Label';\n  var t0 = c0[axLabel];\n\n  // search in array for the label\n  if (t0 === undefined && xa.type === 'multicategory') {\n    for (var q = 0; q < hoverData.length; q++) {\n      t0 = hoverData[q][axLabel];\n      if (t0 !== undefined) break;\n    }\n  }\n  var outerContainerBB = getBoundingClientRect(gd, outerContainer);\n  var outerTop = outerContainerBB.top;\n  var outerWidth = outerContainerBB.width;\n  var outerHeight = outerContainerBB.height;\n\n  // show the common label, if any, on the axis\n  // never show a common label in array mode,\n  // even if sometimes there could be one\n  var showCommonLabel = t0 !== undefined && c0.distance <= opts.hoverdistance && (hovermode === 'x' || hovermode === 'y');\n\n  // all hover traces hoverinfo must contain the hovermode\n  // to have common labels\n  if (showCommonLabel) {\n    var allHaveZ = true;\n    var i, traceHoverinfo;\n    for (i = 0; i < hoverData.length; i++) {\n      if (allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n      traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n      if (traceHoverinfo) {\n        var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n        if (parts.indexOf('all') === -1 && parts.indexOf(hovermode) === -1) {\n          showCommonLabel = false;\n          break;\n        }\n      }\n    }\n\n    // xyz labels put all info in their main label, so have no need of a common label\n    if (allHaveZ) showCommonLabel = false;\n  }\n  var commonLabel = container.selectAll('g.axistext').data(showCommonLabel ? [0] : []);\n  commonLabel.enter().append('g').classed('axistext', true);\n  commonLabel.exit().remove();\n\n  // set rect (without arrow) behind label below for later collision detection\n  var commonLabelRect = {\n    minX: 0,\n    maxX: 0,\n    minY: 0,\n    maxY: 0\n  };\n  commonLabel.each(function () {\n    var label = d3.select(this);\n    var lpath = Lib.ensureSingle(label, 'path', '', function (s) {\n      s.style({\n        'stroke-width': '1px'\n      });\n    });\n    var ltext = Lib.ensureSingle(label, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n    var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n    var contrastColor = Color.contrast(commonBgColor);\n    var commonLabelOptsFont = commonLabelOpts.font;\n    var commonLabelFont = {\n      weight: commonLabelOptsFont.weight || fontWeight,\n      style: commonLabelOptsFont.style || fontStyle,\n      variant: commonLabelOptsFont.variant || fontVariant,\n      textcase: commonLabelOptsFont.textcase || fontTextcase,\n      lineposition: commonLabelOptsFont.lineposition || fontLineposition,\n      shadow: commonLabelOptsFont.shadow || fontShadow,\n      family: commonLabelOptsFont.family || fontFamily,\n      size: commonLabelOptsFont.size || fontSize,\n      color: commonLabelOptsFont.color || contrastColor\n    };\n    lpath.style({\n      fill: commonBgColor,\n      stroke: commonStroke\n    });\n    ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    label.attr('transform', '');\n    var tbb = getBoundingClientRect(gd, ltext.node());\n    var lx, ly;\n    if (hovermode === 'x') {\n      var topsign = xa.side === 'top' ? '-' : '';\n      ltext.attr('text-anchor', 'middle').call(svgTextUtils.positionText, 0, xa.side === 'top' ? outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD);\n      lx = xa._offset + (c0.x0 + c0.x1) / 2;\n      ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n      var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n      var tooltipMidX = lx;\n      if (lx < halfWidth) {\n        tooltipMidX = halfWidth;\n      } else if (lx > fullLayout.width - halfWidth) {\n        tooltipMidX = fullLayout.width - halfWidth;\n      }\n      lpath.attr('d', 'M' + (lx - tooltipMidX) + ',0' + 'L' + (lx - tooltipMidX + HOVERARROWSIZE) + ',' + topsign + HOVERARROWSIZE + 'H' + halfWidth + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H' + -halfWidth + 'V' + topsign + HOVERARROWSIZE + 'H' + (lx - tooltipMidX - HOVERARROWSIZE) + 'Z');\n      lx = tooltipMidX;\n      commonLabelRect.minX = lx - halfWidth;\n      commonLabelRect.maxX = lx + halfWidth;\n      if (xa.side === 'top') {\n        // label on negative y side\n        commonLabelRect.minY = ly - (HOVERTEXTPAD * 2 + tbb.height);\n        commonLabelRect.maxY = ly - HOVERTEXTPAD;\n      } else {\n        commonLabelRect.minY = ly + HOVERTEXTPAD;\n        commonLabelRect.maxY = ly + (HOVERTEXTPAD * 2 + tbb.height);\n      }\n    } else {\n      var anchor;\n      var sgn;\n      var leftsign;\n      if (ya.side === 'right') {\n        anchor = 'start';\n        sgn = 1;\n        leftsign = '';\n        lx = xa._offset + xa._length;\n      } else {\n        anchor = 'end';\n        sgn = -1;\n        leftsign = '-';\n        lx = xa._offset;\n      }\n      ly = ya._offset + (c0.y0 + c0.y1) / 2;\n      ltext.attr('text-anchor', anchor);\n      lpath.attr('d', 'M0,0' + 'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE + 'V' + (HOVERTEXTPAD + tbb.height / 2) + 'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) + 'V-' + (HOVERTEXTPAD + tbb.height / 2) + 'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n      commonLabelRect.minY = ly - (HOVERTEXTPAD + tbb.height / 2);\n      commonLabelRect.maxY = ly + (HOVERTEXTPAD + tbb.height / 2);\n      if (ya.side === 'right') {\n        commonLabelRect.minX = lx + HOVERARROWSIZE;\n        commonLabelRect.maxX = lx + HOVERARROWSIZE + (HOVERTEXTPAD * 2 + tbb.width);\n      } else {\n        // label on negative x side\n        commonLabelRect.minX = lx - HOVERARROWSIZE - (HOVERTEXTPAD * 2 + tbb.width);\n        commonLabelRect.maxX = lx - HOVERARROWSIZE;\n      }\n      var halfHeight = tbb.height / 2;\n      var lty = outerTop - tbb.top - halfHeight;\n      var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n      var clipPath;\n      if (lx < tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {\n        clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight + 'h-' + (tbb.width - HOVERTEXTPAD) + 'V' + halfHeight + 'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n        var ltx = tbb.width - lx + HOVERTEXTPAD;\n        svgTextUtils.positionText(ltext, ltx, lty);\n\n        // shift each line (except the longest) so that start-of-line\n        // is always visible\n        if (anchor === 'end') {\n          ltext.selectAll('tspan').each(function () {\n            var s = d3.select(this);\n            var dummy = Drawing.tester.append('text').text(s.text()).call(Drawing.font, commonLabelFont);\n            var dummyBB = getBoundingClientRect(gd, dummy.node());\n            if (Math.round(dummyBB.width) < Math.round(tbb.width)) {\n              s.attr('x', ltx - dummyBB.width);\n            }\n            dummy.remove();\n          });\n        }\n      } else {\n        svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n        clipPath = null;\n      }\n      var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n      textClip.enter().append('clipPath').attr('id', clipId).append('path');\n      textClip.exit().remove();\n      textClip.select('path').attr('d', clipPath);\n      Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n    }\n    label.attr('transform', strTranslate(lx, ly));\n  });\n\n  // Show a single hover label\n  if (helpers.isUnifiedHover(hovermode)) {\n    // Delete leftover hover labels from other hovermodes\n    container.selectAll('g.hovertext').remove();\n    var groupedHoverData = hoverData.filter(function (data) {\n      return data.hoverinfo !== 'none';\n    });\n    // Return early if nothing is hovered on\n    if (groupedHoverData.length === 0) return [];\n\n    // mock legend\n    var hoverlabel = fullLayout.hoverlabel;\n    var font = hoverlabel.font;\n    var mockLayoutIn = {\n      showlegend: true,\n      legend: {\n        title: {\n          text: t0,\n          font: font\n        },\n        font: font,\n        bgcolor: hoverlabel.bgcolor,\n        bordercolor: hoverlabel.bordercolor,\n        borderwidth: 1,\n        tracegroupgap: 7,\n        traceorder: fullLayout.legend ? fullLayout.legend.traceorder : undefined,\n        orientation: 'v'\n      }\n    };\n    var mockLayoutOut = {\n      font: font\n    };\n    legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);\n    var mockLegend = mockLayoutOut.legend;\n\n    // prepare items for the legend\n    mockLegend.entries = [];\n    for (var j = 0; j < groupedHoverData.length; j++) {\n      var pt = groupedHoverData[j];\n      if (pt.hoverinfo === 'none') continue;\n      var texts = getHoverLabelText(pt, true, hovermode, fullLayout, t0);\n      var text = texts[0];\n      var name = texts[1];\n      pt.name = name;\n      if (name !== '') {\n        pt.text = name + ' : ' + text;\n      } else {\n        pt.text = text;\n      }\n\n      // pass through marker's calcdata to style legend items\n      var cd = pt.cd[pt.index];\n      if (cd) {\n        if (cd.mc) pt.mc = cd.mc;\n        if (cd.mcc) pt.mc = cd.mcc;\n        if (cd.mlc) pt.mlc = cd.mlc;\n        if (cd.mlcc) pt.mlc = cd.mlcc;\n        if (cd.mlw) pt.mlw = cd.mlw;\n        if (cd.mrc) pt.mrc = cd.mrc;\n        if (cd.dir) pt.dir = cd.dir;\n      }\n      pt._distinct = true;\n      mockLegend.entries.push([pt]);\n    }\n    mockLegend.entries.sort(function (a, b) {\n      return a[0].trace.index - b[0].trace.index;\n    });\n    mockLegend.layer = container;\n\n    // Draw unified hover label\n    mockLegend._inHover = true;\n    mockLegend._groupTitleFont = hoverlabel.grouptitlefont;\n    legendDraw(gd, mockLegend);\n\n    // Position the hover\n    var legendContainer = container.select('g.legend');\n    var tbb = getBoundingClientRect(gd, legendContainer.node());\n    var tWidth = tbb.width + 2 * HOVERTEXTPAD;\n    var tHeight = tbb.height + 2 * HOVERTEXTPAD;\n    var winningPoint = groupedHoverData[0];\n    var avgX = (winningPoint.x0 + winningPoint.x1) / 2;\n    var avgY = (winningPoint.y0 + winningPoint.y1) / 2;\n    // When a scatter (or e.g. heatmap) point wins, it's OK for the hovelabel to occlude the bar and other points.\n    var pointWon = !(Registry.traceIs(winningPoint.trace, 'bar-like') || Registry.traceIs(winningPoint.trace, 'box-violin'));\n    var lyBottom, lyTop;\n    if (axLetter === 'y') {\n      if (pointWon) {\n        lyTop = avgY - HOVERTEXTPAD;\n        lyBottom = avgY + HOVERTEXTPAD;\n      } else {\n        lyTop = Math.min.apply(null, groupedHoverData.map(function (c) {\n          return Math.min(c.y0, c.y1);\n        }));\n        lyBottom = Math.max.apply(null, groupedHoverData.map(function (c) {\n          return Math.max(c.y0, c.y1);\n        }));\n      }\n    } else {\n      lyTop = lyBottom = Lib.mean(groupedHoverData.map(function (c) {\n        return (c.y0 + c.y1) / 2;\n      })) - tHeight / 2;\n    }\n    var lxRight, lxLeft;\n    if (axLetter === 'x') {\n      if (pointWon) {\n        lxRight = avgX + HOVERTEXTPAD;\n        lxLeft = avgX - HOVERTEXTPAD;\n      } else {\n        lxRight = Math.max.apply(null, groupedHoverData.map(function (c) {\n          return Math.max(c.x0, c.x1);\n        }));\n        lxLeft = Math.min.apply(null, groupedHoverData.map(function (c) {\n          return Math.min(c.x0, c.x1);\n        }));\n      }\n    } else {\n      lxRight = lxLeft = Lib.mean(groupedHoverData.map(function (c) {\n        return (c.x0 + c.x1) / 2;\n      })) - tWidth / 2;\n    }\n    var xOffset = xa._offset;\n    var yOffset = ya._offset;\n    lyBottom += yOffset;\n    lxRight += xOffset;\n    lxLeft += xOffset - tWidth;\n    lyTop += yOffset - tHeight;\n    var lx, ly; // top and left positions of the hover box\n\n    // horizontal alignment to end up on screen\n    if (lxRight + tWidth < outerWidth && lxRight >= 0) {\n      lx = lxRight;\n    } else if (lxLeft + tWidth < outerWidth && lxLeft >= 0) {\n      lx = lxLeft;\n    } else if (xOffset + tWidth < outerWidth) {\n      lx = xOffset; // subplot left corner\n    } else {\n      // closest left or right side of the paper\n      if (lxRight - avgX < avgX - lxLeft + tWidth) {\n        lx = outerWidth - tWidth;\n      } else {\n        lx = 0;\n      }\n    }\n    lx += HOVERTEXTPAD;\n\n    // vertical alignement to end up on screen\n    if (lyBottom + tHeight < outerHeight && lyBottom >= 0) {\n      ly = lyBottom;\n    } else if (lyTop + tHeight < outerHeight && lyTop >= 0) {\n      ly = lyTop;\n    } else if (yOffset + tHeight < outerHeight) {\n      ly = yOffset; // subplot top corner\n    } else {\n      // closest top or bottom side of the paper\n      if (lyBottom - avgY < avgY - lyTop + tHeight) {\n        ly = outerHeight - tHeight;\n      } else {\n        ly = 0;\n      }\n    }\n    ly += HOVERTEXTPAD;\n    legendContainer.attr('transform', strTranslate(lx - 1, ly - 1));\n    return legendContainer;\n  }\n\n  // show all the individual labels\n\n  // first create the objects\n  var hoverLabels = container.selectAll('g.hovertext').data(hoverData, function (d) {\n    // N.B. when multiple items have the same result key-function value,\n    // only the first of those items in hoverData gets rendered\n    return hoverDataKey(d);\n  });\n  hoverLabels.enter().append('g').classed('hovertext', true).each(function () {\n    var g = d3.select(this);\n    // trace name label (rect and text.name)\n    g.append('rect').call(Color.fill, Color.addOpacity(bgColor, 0.8));\n    g.append('text').classed('name', true);\n    // trace data label (path and text.nums)\n    g.append('path').style('stroke-width', '1px');\n    g.append('text').classed('nums', true).call(Drawing.font, {\n      weight: fontWeight,\n      style: fontStyle,\n      variant: fontVariant,\n      textcase: fontTextcase,\n      lineposition: fontLineposition,\n      shadow: fontShadow,\n      family: fontFamily,\n      size: fontSize\n    });\n  });\n  hoverLabels.exit().remove();\n\n  // then put the text in, position the pointer to the data,\n  // and figure out sizes\n  hoverLabels.each(function (d) {\n    var g = d3.select(this).attr('transform', '');\n    var dColor = d.color;\n    if (Array.isArray(dColor)) {\n      dColor = dColor[d.eventData[0].pointNumber];\n    }\n\n    // combine possible non-opaque trace color with bgColor\n    var color0 = d.bgcolor || dColor;\n    // color for 'nums' part of the label\n    var numsColor = Color.combine(Color.opacity(color0) ? color0 : Color.defaultLine, bgColor);\n    // color for 'name' part of the label\n    var nameColor = Color.combine(Color.opacity(dColor) ? dColor : Color.defaultLine, bgColor);\n    // find a contrasting color for border and text\n    var contrastColor = d.borderColor || Color.contrast(numsColor);\n    var texts = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);\n    var text = texts[0];\n    var name = texts[1];\n\n    // main label\n    var tx = g.select('text.nums').call(Drawing.font, {\n      family: d.fontFamily || fontFamily,\n      size: d.fontSize || fontSize,\n      color: d.fontColor || contrastColor,\n      weight: d.fontWeight || fontWeight,\n      style: d.fontStyle || fontStyle,\n      variant: d.fontVariant || fontVariant,\n      textcase: d.fontTextcase || fontTextcase,\n      lineposition: d.fontLineposition || fontLineposition,\n      shadow: d.fontShadow || fontShadow\n    }).text(text).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    var tx2 = g.select('text.name');\n    var tx2width = 0;\n    var tx2height = 0;\n\n    // secondary label for non-empty 'name'\n    if (name && name !== text) {\n      tx2.call(Drawing.font, {\n        family: d.fontFamily || fontFamily,\n        size: d.fontSize || fontSize,\n        color: nameColor,\n        weight: d.fontWeight || fontWeight,\n        style: d.fontStyle || fontStyle,\n        variant: d.fontVariant || fontVariant,\n        textcase: d.fontTextcase || fontTextcase,\n        lineposition: d.fontLineposition || fontLineposition,\n        shadow: d.fontShadow || fontShadow\n      }).text(name).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n      var t2bb = getBoundingClientRect(gd, tx2.node());\n      tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n      tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n    } else {\n      tx2.remove();\n      g.select('rect').remove();\n    }\n    g.select('path').style({\n      fill: numsColor,\n      stroke: contrastColor\n    });\n    var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n    var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n    var dx = Math.abs(d.x1 - d.x0);\n    var dy = Math.abs(d.y1 - d.y0);\n    var tbb = getBoundingClientRect(gd, tx.node());\n    var tbbWidth = tbb.width / fullLayout._invScaleX;\n    var tbbHeight = tbb.height / fullLayout._invScaleY;\n    d.ty0 = (outerTop - tbb.top) / fullLayout._invScaleY;\n    d.bx = tbbWidth + 2 * HOVERTEXTPAD;\n    d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);\n    d.anchor = 'start';\n    d.txwidth = tbbWidth;\n    d.tx2width = tx2width;\n    d.offset = 0;\n    var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;\n    var anchorStartOK, anchorEndOK;\n    if (rotateLabels) {\n      d.pos = htx;\n      anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n      anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n      if ((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n        hty -= dy / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        hty += dy / 2;\n        d.anchor = 'start';\n      } else {\n        d.anchor = 'middle';\n      }\n      d.crossPos = hty;\n    } else {\n      d.pos = hty;\n      anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n      anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n      if ((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n        htx -= dx / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        htx += dx / 2;\n        d.anchor = 'start';\n      } else {\n        d.anchor = 'middle';\n        var txHalfWidth = txTotalWidth / 2;\n        var overflowR = htx + txHalfWidth - outerWidth;\n        var overflowL = htx - txHalfWidth;\n        if (overflowR > 0) htx -= overflowR;\n        if (overflowL < 0) htx += -overflowL;\n      }\n      d.crossPos = htx;\n    }\n    tx.attr('text-anchor', d.anchor);\n    if (tx2width) tx2.attr('text-anchor', d.anchor);\n    g.attr('transform', strTranslate(htx, hty) + (rotateLabels ? strRotate(YANGLE) : ''));\n  });\n  return {\n    hoverLabels: hoverLabels,\n    commonLabelBoundingBox: commonLabelRect\n  };\n}\nfunction getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {\n  var name = '';\n  var text = '';\n  // to get custom 'name' labels pass cleanPoint\n  if (d.nameOverride !== undefined) d.name = d.nameOverride;\n  if (d.name) {\n    if (d.trace._meta) {\n      d.name = Lib.templateString(d.name, d.trace._meta);\n    }\n    name = plainText(d.name, d.nameLength);\n  }\n  var h0 = hovermode.charAt(0);\n  var h1 = h0 === 'x' ? 'y' : 'x';\n  if (d.zLabel !== undefined) {\n    if (d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n    if (d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n    if (d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox' && d.trace.type !== 'choroplethmap') {\n      text += (text ? 'z: ' : '') + d.zLabel;\n    }\n  } else if (showCommonLabel && d[h0 + 'Label'] === t0) {\n    text = d[h1 + 'Label'] || '';\n  } else if (d.xLabel === undefined) {\n    if (d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n      text = d.yLabel;\n    }\n  } else if (d.yLabel === undefined) text = d.xLabel;else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n  if ((d.text || d.text === 0) && !Array.isArray(d.text)) {\n    text += (text ? '<br>' : '') + d.text;\n  }\n\n  // used by other modules (initially just ternary) that\n  // manage their own hoverinfo independent of cleanPoint\n  // the rest of this will still apply, so such modules\n  // can still put things in (x|y|z)Label, text, and name\n  // and hoverinfo will still determine their visibility\n  if (d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;\n\n  // if 'text' is empty at this point,\n  // and hovertemplate is not defined,\n  // put 'name' in main label and don't show secondary label\n  if (g && text === '' && !d.hovertemplate) {\n    // if 'name' is also empty, remove entire label\n    if (name === '') g.remove();\n    text = name;\n  }\n\n  // hovertemplate\n  var hovertemplate = d.hovertemplate || false;\n  if (hovertemplate) {\n    var labels = d.hovertemplateLabels || d;\n    if (d[h0 + 'Label'] !== t0) {\n      labels[h0 + 'other'] = labels[h0 + 'Val'];\n      labels[h0 + 'otherLabel'] = labels[h0 + 'Label'];\n    }\n    text = Lib.hovertemplateString(hovertemplate, labels, fullLayout._d3locale, d.eventData[0] || {}, d.trace._meta);\n    text = text.replace(EXTRA_STRING_REGEX, function (match, extra) {\n      // assign name for secondary text label\n      name = plainText(extra, d.nameLength);\n      // remove from main text label\n      return '';\n    });\n  }\n  return [text, name];\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Incidentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, commonLabelBoundingBox) {\n  var axKey = rotateLabels ? 'xa' : 'ya';\n  var crossAxKey = rotateLabels ? 'ya' : 'xa';\n  var nummoves = 0;\n  var axSign = 1;\n  var nLabels = hoverLabels.size();\n\n  // make groups of touching points\n  var pointgroups = new Array(nLabels);\n  var k = 0;\n\n  // get extent of axis hover label\n  var axisLabelMinX = commonLabelBoundingBox.minX;\n  var axisLabelMaxX = commonLabelBoundingBox.maxX;\n  var axisLabelMinY = commonLabelBoundingBox.minY;\n  var axisLabelMaxY = commonLabelBoundingBox.maxY;\n  var pX = function (x) {\n    return x * fullLayout._invScaleX;\n  };\n  var pY = function (y) {\n    return y * fullLayout._invScaleY;\n  };\n  hoverLabels.each(function (d) {\n    var ax = d[axKey];\n    var crossAx = d[crossAxKey];\n    var axIsX = ax._id.charAt(0) === 'x';\n    var rng = ax.range;\n    if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {\n      axSign = -1;\n    }\n    var pmin = 0;\n    var pmax = axIsX ? fullLayout.width : fullLayout.height;\n    // in hovermode avoid overlap between hover labels and axis label\n    if (fullLayout.hovermode === 'x' || fullLayout.hovermode === 'y') {\n      // extent of rect behind hover label on cross axis:\n      var offsets = getHoverLabelOffsets(d, rotateLabels);\n      var anchor = d.anchor;\n      var horzSign = anchor === 'end' ? -1 : 1;\n      var labelMin;\n      var labelMax;\n      if (anchor === 'middle') {\n        // use extent of centered rect either on x or y axis depending on current axis\n        labelMin = d.crossPos + (axIsX ? pY(offsets.y - d.by / 2) : pX(d.bx / 2 + d.tx2width / 2));\n        labelMax = labelMin + (axIsX ? pY(d.by) : pX(d.bx));\n      } else {\n        // use extend of path (see alignHoverText function) without arrow\n        if (axIsX) {\n          labelMin = d.crossPos + pY(HOVERARROWSIZE + offsets.y) - pY(d.by / 2 - HOVERARROWSIZE);\n          labelMax = labelMin + pY(d.by);\n        } else {\n          var startX = pX(horzSign * HOVERARROWSIZE + offsets.x);\n          var endX = startX + pX(horzSign * d.bx);\n          labelMin = d.crossPos + Math.min(startX, endX);\n          labelMax = d.crossPos + Math.max(startX, endX);\n        }\n      }\n      if (axIsX) {\n        if (axisLabelMinY !== undefined && axisLabelMaxY !== undefined && Math.min(labelMax, axisLabelMaxY) - Math.max(labelMin, axisLabelMinY) > 1) {\n          // has at least 1 pixel overlap with axis label\n          if (crossAx.side === 'left') {\n            pmin = crossAx._mainLinePosition;\n            pmax = fullLayout.width;\n          } else {\n            pmax = crossAx._mainLinePosition;\n          }\n        }\n      } else {\n        if (axisLabelMinX !== undefined && axisLabelMaxX !== undefined && Math.min(labelMax, axisLabelMaxX) - Math.max(labelMin, axisLabelMinX) > 1) {\n          // has at least 1 pixel overlap with axis label\n          if (crossAx.side === 'top') {\n            pmin = crossAx._mainLinePosition;\n            pmax = fullLayout.height;\n          } else {\n            pmax = crossAx._mainLinePosition;\n          }\n        }\n      }\n    }\n    pointgroups[k++] = [{\n      datum: d,\n      traceIndex: d.trace.index,\n      dp: 0,\n      pos: d.pos,\n      posref: d.posref,\n      size: d.by * (axIsX ? YFACTOR : 1) / 2,\n      pmin: pmin,\n      pmax: pmax\n    }];\n  });\n  pointgroups.sort(function (a, b) {\n    return a[0].posref - b[0].posref ||\n    // for equal positions, sort trace indices increasing or decreasing\n    // depending on whether the axis is reversed or not... so stacked\n    // traces will generally keep their order even if one trace adds\n    // nothing to the stack.\n    axSign * (b[0].traceIndex - a[0].traceIndex);\n  });\n  var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n  function constrainGroup(grp) {\n    var minPt = grp[0];\n    var maxPt = grp[grp.length - 1];\n\n    // overlap with the top - positive vals are overlaps\n    topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n    // overlap with the bottom - positive vals are overlaps\n    bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n    // check for min overlap first, so that we always\n    // see the largest labels\n    // allow for .01px overlap, so we don't get an\n    // infinite loop from rounding errors\n    if (topOverlap > 0.01) {\n      for (j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n      donepositioning = false;\n    }\n    if (bottomOverlap < 0.01) return;\n    if (topOverlap < -0.01) {\n      // make sure we're not pushing back and forth\n      for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n      donepositioning = false;\n    }\n    if (!donepositioning) return;\n\n    // no room to fix positioning, delete off-screen points\n\n    // first see how many points we need to delete\n    var deleteCount = 0;\n    for (i = 0; i < grp.length; i++) {\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n    }\n\n    // start by deleting points whose data is off screen\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n      if (pti.pos > minPt.pmax - 1) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n    for (i = 0; i < grp.length; i++) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n      if (pti.pos < minPt.pmin + 1) {\n        pti.del = true;\n        deleteCount--;\n\n        // shift the whole group minus into this new space\n        bottomOverlap = pti.size * 2;\n        for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n      }\n    }\n    // then delete points that go off the bottom\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n  }\n\n  // loop through groups, combining them if they overlap,\n  // until nothing moves\n  while (!donepositioning && nummoves <= nLabels) {\n    // to avoid infinite loops, don't move more times\n    // than there are traces\n    nummoves++;\n\n    // assume nothing will move in this iteration,\n    // reverse this if it does\n    donepositioning = true;\n    i = 0;\n    while (i < pointgroups.length - 1) {\n      // the higher (g0) and lower (g1) point group\n      var g0 = pointgroups[i];\n      var g1 = pointgroups[i + 1];\n\n      // the lowest point in the higher group (p0)\n      // the highest point in the lower group (p1)\n      var p0 = g0[g0.length - 1];\n      var p1 = g1[0];\n      topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n      if (topOverlap > 0.01) {\n        // push the new point(s) added to this group out of the way\n        for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;\n\n        // add them to the group\n        g0.push.apply(g0, g1);\n        pointgroups.splice(i + 1, 1);\n\n        // adjust for minimum average movement\n        sumdp = 0;\n        for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n        bottomOverlap = sumdp / g0.length;\n        for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n        donepositioning = false;\n      } else i++;\n    }\n\n    // check if we're going off the plot on either side and fix\n    pointgroups.forEach(constrainGroup);\n  }\n\n  // now put these offsets into hoverData\n  for (i = pointgroups.length - 1; i >= 0; i--) {\n    var grp = pointgroups[i];\n    for (j = grp.length - 1; j >= 0; j--) {\n      var pt = grp[j];\n      var hoverPt = pt.datum;\n      hoverPt.offset = pt.dp;\n      hoverPt.del = pt.del;\n    }\n  }\n}\nfunction getHoverLabelOffsets(hoverLabel, rotateLabels) {\n  var offsetX = 0;\n  var offsetY = hoverLabel.offset;\n  if (rotateLabels) {\n    offsetY *= -YSHIFTY;\n    offsetX = hoverLabel.offset * YSHIFTX;\n  }\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\n\n/**\n * Calculate the shift in x for text and text2 elements\n */\nfunction getTextShiftX(hoverLabel) {\n  var alignShift = {\n    start: 1,\n    end: -1,\n    middle: 0\n  }[hoverLabel.anchor];\n  var textShiftX = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n  var text2ShiftX = textShiftX + alignShift * (hoverLabel.txwidth + HOVERTEXTPAD);\n  var isMiddle = hoverLabel.anchor === 'middle';\n  if (isMiddle) {\n    textShiftX -= hoverLabel.tx2width / 2;\n    text2ShiftX += hoverLabel.txwidth / 2 + HOVERTEXTPAD;\n  }\n  return {\n    alignShift: alignShift,\n    textShiftX: textShiftX,\n    text2ShiftX: text2ShiftX\n  };\n}\nfunction alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {\n  var pX = function (x) {\n    return x * scaleX;\n  };\n  var pY = function (y) {\n    return y * scaleY;\n  };\n\n  // finally set the text positioning relative to the data and draw the\n  // box around it\n  hoverLabels.each(function (d) {\n    var g = d3.select(this);\n    if (d.del) return g.remove();\n    var tx = g.select('text.nums');\n    var anchor = d.anchor;\n    var horzSign = anchor === 'end' ? -1 : 1;\n    var shiftX = getTextShiftX(d);\n    var offsets = getHoverLabelOffsets(d, rotateLabels);\n    var offsetX = offsets.x;\n    var offsetY = offsets.y;\n    var isMiddle = anchor === 'middle';\n    g.select('path').attr('d', isMiddle ?\n    // middle aligned: rect centered on data\n    'M-' + pX(d.bx / 2 + d.tx2width / 2) + ',' + pY(offsetY - d.by / 2) + 'h' + pX(d.bx) + 'v' + pY(d.by) + 'h-' + pX(d.bx) + 'Z' :\n    // left or right aligned: side rect with arrow to data\n    'M0,0L' + pX(horzSign * HOVERARROWSIZE + offsetX) + ',' + pY(HOVERARROWSIZE + offsetY) + 'v' + pY(d.by / 2 - HOVERARROWSIZE) + 'h' + pX(horzSign * d.bx) + 'v-' + pY(d.by) + 'H' + pX(horzSign * HOVERARROWSIZE + offsetX) + 'V' + pY(offsetY - HOVERARROWSIZE) + 'Z');\n    var posX = offsetX + shiftX.textShiftX;\n    var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n    var textAlign = d.textAlign || 'auto';\n    if (textAlign !== 'auto') {\n      if (textAlign === 'left' && anchor !== 'start') {\n        tx.attr('text-anchor', 'start');\n        posX = isMiddle ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;\n      } else if (textAlign === 'right' && anchor !== 'end') {\n        tx.attr('text-anchor', 'end');\n        posX = isMiddle ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;\n      }\n    }\n    tx.call(svgTextUtils.positionText, pX(posX), pY(posY));\n    if (d.tx2width) {\n      g.select('text.name').call(svgTextUtils.positionText, pX(shiftX.text2ShiftX + shiftX.alignShift * HOVERTEXTPAD + offsetX), pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD));\n      g.select('rect').call(Drawing.setRect, pX(shiftX.text2ShiftX + (shiftX.alignShift - 1) * d.tx2width / 2 + offsetX), pY(offsetY - d.by / 2 - 1), pX(d.tx2width), pY(d.by + 2));\n    }\n  });\n}\nfunction cleanPoint(d, hovermode) {\n  var index = d.index;\n  var trace = d.trace || {};\n  var cd0 = d.cd[0];\n  var cd = d.cd[index] || {};\n  function pass(v) {\n    return v || isNumeric(v) && v === 0;\n  }\n  var getVal = Array.isArray(index) ? function (calcKey, traceKey) {\n    var v = Lib.castOption(cd0, index, calcKey);\n    return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n  } : function (calcKey, traceKey) {\n    return Lib.extractOption(cd, trace, calcKey, traceKey);\n  };\n  function fill(key, calcKey, traceKey) {\n    var val = getVal(calcKey, traceKey);\n    if (pass(val)) d[key] = val;\n  }\n  fill('hoverinfo', 'hi', 'hoverinfo');\n  fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n  fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n  fill('fontFamily', 'htf', 'hoverlabel.font.family');\n  fill('fontSize', 'hts', 'hoverlabel.font.size');\n  fill('fontColor', 'htc', 'hoverlabel.font.color');\n  fill('fontWeight', 'htw', 'hoverlabel.font.weight');\n  fill('fontStyle', 'hty', 'hoverlabel.font.style');\n  fill('fontVariant', 'htv', 'hoverlabel.font.variant');\n  fill('nameLength', 'hnl', 'hoverlabel.namelength');\n  fill('textAlign', 'hta', 'hoverlabel.align');\n  d.posref = hovermode === 'y' || hovermode === 'closest' && trace.orientation === 'h' ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2;\n\n  // then constrain all the positions to be on the plot\n  d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n  d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n  d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n  d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n  // and convert the x and y label values into formatted text\n  if (d.xLabelVal !== undefined) {\n    d.xLabel = 'xLabel' in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);\n    d.xVal = d.xa.c2d(d.xLabelVal);\n  }\n  if (d.yLabelVal !== undefined) {\n    d.yLabel = 'yLabel' in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);\n    d.yVal = d.ya.c2d(d.yLabelVal);\n  }\n\n  // Traces like heatmaps generate the zLabel in their hoverPoints function\n  if (d.zLabelVal !== undefined && d.zLabel === undefined) {\n    d.zLabel = String(d.zLabelVal);\n  }\n\n  // for box means and error bars, add the range to the label\n  if (!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n    var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n    if (d.xerrneg !== undefined) {\n      d.xLabel += ' +' + xeText + ' / -' + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n    } else d.xLabel += ' ± ' + xeText;\n\n    // small distance penalty for error bars, so that if there are\n    // traces with errors and some without, the error bar label will\n    // hoist up to the point\n    if (hovermode === 'x') d.distance += 1;\n  }\n  if (!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n    var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n    if (d.yerrneg !== undefined) {\n      d.yLabel += ' +' + yeText + ' / -' + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n    } else d.yLabel += ' ± ' + yeText;\n    if (hovermode === 'y') d.distance += 1;\n  }\n  var infomode = d.hoverinfo || d.trace.hoverinfo;\n  if (infomode && infomode !== 'all') {\n    infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n    if (infomode.indexOf('x') === -1) d.xLabel = undefined;\n    if (infomode.indexOf('y') === -1) d.yLabel = undefined;\n    if (infomode.indexOf('z') === -1) d.zLabel = undefined;\n    if (infomode.indexOf('text') === -1) d.text = undefined;\n    if (infomode.indexOf('name') === -1) d.name = undefined;\n  }\n  return d;\n}\nfunction createSpikelines(gd, closestPoints, opts) {\n  var container = opts.container;\n  var fullLayout = opts.fullLayout;\n  var gs = fullLayout._size;\n  var evt = opts.event;\n  var showY = !!closestPoints.hLinePoint;\n  var showX = !!closestPoints.vLinePoint;\n  var xa, ya;\n\n  // Remove old spikeline items\n  container.selectAll('.spikeline').remove();\n  if (!(showX || showY)) return;\n  var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n\n  // Horizontal line (to y-axis)\n  if (showY) {\n    var hLinePoint = closestPoints.hLinePoint;\n    var hLinePointX, hLinePointY;\n    xa = hLinePoint && hLinePoint.xa;\n    ya = hLinePoint && hLinePoint.ya;\n    var ySnap = ya.spikesnap;\n    if (ySnap === 'cursor') {\n      hLinePointX = evt.pointerX;\n      hLinePointY = evt.pointerY;\n    } else {\n      hLinePointX = xa._offset + hLinePoint.x;\n      hLinePointY = ya._offset + hLinePoint.y;\n    }\n    var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;\n    var yMode = ya.spikemode;\n    var yThickness = ya.spikethickness;\n    var yColor = ya.spikecolor || dfltHLineColor;\n    var xEdge = Axes.getPxPosition(gd, ya);\n    var xBase, xEndSpike;\n    if (yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n      if (yMode.indexOf('toaxis') !== -1) {\n        xBase = xEdge;\n        xEndSpike = hLinePointX;\n      }\n      if (yMode.indexOf('across') !== -1) {\n        var xAcross0 = ya._counterDomainMin;\n        var xAcross1 = ya._counterDomainMax;\n        if (ya.anchor === 'free') {\n          xAcross0 = Math.min(xAcross0, ya.position);\n          xAcross1 = Math.max(xAcross1, ya.position);\n        }\n        xBase = gs.l + xAcross0 * gs.w;\n        xEndSpike = gs.l + xAcross1 * gs.w;\n      }\n\n      // Foreground horizontal line (to y-axis)\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness,\n        stroke: yColor,\n        'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n      }).classed('spikeline', true).classed('crisp', true);\n\n      // Background horizontal Line (to y-axis)\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    }\n    // Y axis marker\n    if (yMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n        cy: hLinePointY,\n        r: yThickness,\n        fill: yColor\n      }).classed('spikeline', true);\n    }\n  }\n  if (showX) {\n    var vLinePoint = closestPoints.vLinePoint;\n    var vLinePointX, vLinePointY;\n    xa = vLinePoint && vLinePoint.xa;\n    ya = vLinePoint && vLinePoint.ya;\n    var xSnap = xa.spikesnap;\n    if (xSnap === 'cursor') {\n      vLinePointX = evt.pointerX;\n      vLinePointY = evt.pointerY;\n    } else {\n      vLinePointX = xa._offset + vLinePoint.x;\n      vLinePointY = ya._offset + vLinePoint.y;\n    }\n    var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;\n    var xMode = xa.spikemode;\n    var xThickness = xa.spikethickness;\n    var xColor = xa.spikecolor || dfltVLineColor;\n    var yEdge = Axes.getPxPosition(gd, xa);\n    var yBase, yEndSpike;\n    if (xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n      if (xMode.indexOf('toaxis') !== -1) {\n        yBase = yEdge;\n        yEndSpike = vLinePointY;\n      }\n      if (xMode.indexOf('across') !== -1) {\n        var yAcross0 = xa._counterDomainMin;\n        var yAcross1 = xa._counterDomainMax;\n        if (xa.anchor === 'free') {\n          yAcross0 = Math.min(yAcross0, xa.position);\n          yAcross1 = Math.max(yAcross1, xa.position);\n        }\n        yBase = gs.t + (1 - yAcross1) * gs.h;\n        yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n      }\n\n      // Foreground vertical line (to x-axis)\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness,\n        stroke: xColor,\n        'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n      }).classed('spikeline', true).classed('crisp', true);\n\n      // Background vertical line (to x-axis)\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    }\n\n    // X axis marker\n    if (xMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: vLinePointX,\n        cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n        r: xThickness,\n        fill: xColor\n      }).classed('spikeline', true);\n    }\n  }\n}\nfunction hoverChanged(gd, evt, oldhoverdata) {\n  // don't emit any events if nothing changed\n  if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n  for (var i = oldhoverdata.length - 1; i >= 0; i--) {\n    var oldPt = oldhoverdata[i];\n    var newPt = gd._hoverdata[i];\n    if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction spikesChanged(gd, oldspikepoints) {\n  // don't relayout the plot because of new spikelines if spikelines points didn't change\n  if (!oldspikepoints) return true;\n  if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;\n  return false;\n}\nfunction plainText(s, len) {\n  return svgTextUtils.plainText(s || '', {\n    len: len,\n    allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em', 's', 'u']\n  });\n}\nfunction orderRangePoints(hoverData, hovermode) {\n  var axLetter = hovermode.charAt(0);\n  var first = [];\n  var second = [];\n  var last = [];\n  for (var i = 0; i < hoverData.length; i++) {\n    var d = hoverData[i];\n    if (Registry.traceIs(d.trace, 'bar-like') || Registry.traceIs(d.trace, 'box-violin')) {\n      last.push(d);\n    } else if (d.trace[axLetter + 'period']) {\n      second.push(d);\n    } else {\n      first.push(d);\n    }\n  }\n  return first.concat(second).concat(last);\n}\nfunction getCoord(axLetter, winningPoint, fullLayout) {\n  var ax = winningPoint[axLetter + 'a'];\n  var val = winningPoint[axLetter + 'Val'];\n  var cd0 = winningPoint.cd[0];\n  if (ax.type === 'category' || ax.type === 'multicategory') val = ax._categoriesMap[val];else if (ax.type === 'date') {\n    var periodalignment = winningPoint.trace[axLetter + 'periodalignment'];\n    if (periodalignment) {\n      var d = winningPoint.cd[winningPoint.index];\n      var start = d[axLetter + 'Start'];\n      if (start === undefined) start = d[axLetter];\n      var end = d[axLetter + 'End'];\n      if (end === undefined) end = d[axLetter];\n      var diff = end - start;\n      if (periodalignment === 'end') {\n        val += diff;\n      } else if (periodalignment === 'middle') {\n        val += diff / 2;\n      }\n    }\n    val = ax.d2c(val);\n  }\n  if (cd0 && cd0.t && cd0.t.posLetter === ax._id) {\n    if (fullLayout.boxmode === 'group' || fullLayout.violinmode === 'group') {\n      val += cd0.t.dPos;\n    }\n  }\n  return val;\n}\n\n// Top/left hover offsets relative to graph div. As long as hover content is\n// a sibling of the graph div, it will be positioned correctly relative to\n// the offset parent, whatever that may be.\nfunction getTopOffset(gd) {\n  return gd.offsetTop + gd.clientTop;\n}\nfunction getLeftOffset(gd) {\n  return gd.offsetLeft + gd.clientLeft;\n}\nfunction getBoundingClientRect(gd, node) {\n  var fullLayout = gd._fullLayout;\n  var rect = node.getBoundingClientRect();\n  var x0 = rect.left;\n  var y0 = rect.top;\n  var x1 = x0 + rect.width;\n  var y1 = y0 + rect.height;\n  var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);\n  var Ax = A[0];\n  var Ay = A[1];\n  var Bx = B[0];\n  var By = B[1];\n  return {\n    x: Ax,\n    y: Ay,\n    width: Bx - Ax,\n    height: By - Ay,\n    top: Math.min(Ay, By),\n    left: Math.min(Ax, Bx),\n    right: Math.max(Ax, Bx),\n    bottom: Math.max(Ay, By)\n  };\n}","map":{"version":3,"names":["d3","require","isNumeric","tinycolor","Lib","pushUnique","strTranslate","strRotate","Events","svgTextUtils","overrideCursor","Drawing","Color","dragElement","Axes","zindexSeparator","Registry","helpers","constants","legendSupplyDefaults","legendDraw","YANGLE","YA_RADIANS","Math","PI","YFACTOR","sin","YSHIFTX","cos","YSHIFTY","HOVERARROWSIZE","HOVERTEXTPAD","multipleHoverPoints","box","ohlc","violin","candlestick","cartesianScatterPoints","scatter","scattergl","splom","distanceSort","a","b","distance","exports","hover","gd","evt","subplot","noHoverEvent","getGraphDiv","eventTarget","target","throttle","_fullLayout","_uid","HOVERID","HOVERMINTIME","_hover","loneHover","hoverItems","opts","multiHover","Array","isArray","gTop","getTopOffset","gLeft","getLeftOffset","pointsData","map","hoverItem","_x0","x0","x","_x1","x1","_y0","y0","y","_y1","y1","eventData","min","max","trace","traceIs","container","scene","_scene","dx","offsetLeft","dy","offsetTop","bbox","inOut_bbox","push","color","defaultLine","xLabel","yLabel","zLabel","text","name","idealAlign","borderColor","fontFamily","fontSize","fontColor","fontWeight","fontStyle","fontVariant","nameLength","textAlign","index","hoverinfo","xa","_offset","ya","hovertemplate","hovertemplateLabels","rotateLabels","hoverText","createHoverText","hovermode","bgColor","background","select","outerContainer","hoverLabel","hoverLabels","tooltipSpacing","lastBottomY","anchor","sort","each","d","i","topY","by","offset","anchorIndex","scaleX","_invScaleX","scaleY","_invScaleY","alignHoverText","node","split","subplots","spId","fullLayout","hoversubplots","plots","_plots","plotinfo","hasCartesian","_has","hovermodeHasX","charAt","hovermodeHasY","firstXaxis","firstYaxis","subplotsLength","length","p","getFromId","subplotsWith","_subplotsWith","q","overlayedSubplots","overlays","pi","id","concat","len","xaArray","yaArray","supportsCompare","xaxis","yaxis","_subplot","warn","indexOf","calcdata","querySelector","_dragging","unhoverRaw","hoverdistance","Infinity","spikedistance","hoverData","searchData","xvalArray","yvalArray","itemnum","curvenum","cd","subplotId","subploti","_mode","xval","yval","pointData","closedataPreviousLength","spikePoints","hLinePoint","vLinePoint","hasOneHorizontalTrace","curveNumber","orientation","zorderedCalcdata","slice","aZorder","zorder","bZorder","isTraceInSubplots","hasUserCalledHover","xpx","ypx","_length","triggerHandler","dbb","getBoundingClientRect","clientX","left","clientY","top","_calcInverseTransform","transformedCoords","apply3DTransform","_invTransform","pointerX","pointerY","flat","p2c","findHoverPoints","customXVal","customYVal","visible","_module","isUnifiedHover","type","getSubplot","maxHoverDistance","maxSpikeDistance","spikeDistance","xSpike","undefined","ySpike","xLabelVal","yLabelVal","zLabelVal","_splomScenes","uid","selection","pointNumber","hoverPoints","newPoints","finiteRange","hoverLayer","_hoverlayer","newPoint","newPointNum","cleanPoint","log","splice","closestPoints","filter","point","tmpPoint","closestVPoints","showspikes","spikesnap","closestVPt","fillSpikePoint","closestHPoints","closestHPt","selectClosestPoint","spikeOnWinning","resultPoint","minDistance","thisSpikeDistance","_id","spikelineOpts","event","oldspikepoints","_spikepoints","newspikepoints","sortHoverData","hoverDataInSubplot","hoverDataOutSubplot","orderRangePoints","axLetter","tmpHPointData","tmpHPoint","tmpVPointData","tmpVPoint","result","spikesChanged","createSpikelines","isXYhover","winningPoint","initLen","winX","getCoord","winY","finalPoints","seen","insert","newHd","key","hoverDataKey","oldId","oldHd","abs","k","oldhoverdata","_hoverdata","newhoverdata","pt","makeEventData","ht","combine","plot_bgcolor","paper_bgcolor","_paper","commonLabelOpts","hoverlabel","hoverAvoidOverlaps","commonLabelBoundingBox","tagName","hasClickToShow","getComponentMethod","hoverChanged","emit","points","xaxes","yaxes","xvals","yvals","attr","join","EXTRA_STRING_REGEX","HOVERFONT","HOVERFONTSIZE","font","weight","style","variant","fontTextcase","textcase","fontLineposition","lineposition","fontShadow","shadow","c0","axLabel","t0","outerContainerBB","outerTop","outerWidth","width","outerHeight","height","showCommonLabel","allHaveZ","traceHoverinfo","parts","commonLabel","selectAll","data","enter","append","classed","exit","remove","commonLabelRect","minX","maxX","minY","maxY","label","lpath","ensureSingle","s","ltext","commonBgColor","bgcolor","commonStroke","bordercolor","contrast","contrastColor","commonLabelOptsFont","commonLabelFont","family","size","fill","stroke","call","positionText","convertToTspans","tbb","lx","ly","topsign","side","bottom","halfWidth","tooltipMidX","sgn","leftsign","halfHeight","lty","clipId","clipPath","ltx","dummy","tester","dummyBB","round","textClip","_topclips","setClipUrl","groupedHoverData","mockLayoutIn","showlegend","legend","title","borderwidth","tracegroupgap","traceorder","mockLayoutOut","_fullData","mockLegend","entries","j","texts","getHoverLabelText","mc","mcc","mlc","mlcc","mlw","mrc","dir","_distinct","layer","_inHover","_groupTitleFont","grouptitlefont","legendContainer","tWidth","tHeight","avgX","avgY","pointWon","lyBottom","lyTop","apply","c","mean","lxRight","lxLeft","xOffset","yOffset","g","addOpacity","dColor","color0","numsColor","opacity","nameColor","tx","tx2","tx2width","tx2height","t2bb","htx","hty","tbbWidth","tbbHeight","ty0","bx","txwidth","txTotalWidth","anchorStartOK","anchorEndOK","pos","crossPos","txHalfWidth","overflowR","overflowL","nameOverride","_meta","templateString","plainText","h0","h1","extraText","labels","hovertemplateString","_d3locale","replace","match","extra","axKey","crossAxKey","nummoves","axSign","nLabels","pointgroups","axisLabelMinX","axisLabelMaxX","axisLabelMinY","axisLabelMaxY","pX","pY","ax","crossAx","axIsX","rng","range","pmin","pmax","offsets","getHoverLabelOffsets","horzSign","labelMin","labelMax","startX","endX","_mainLinePosition","datum","traceIndex","dp","posref","donepositioning","topOverlap","bottomOverlap","pti","sumdp","constrainGroup","grp","minPt","maxPt","deleteCount","del","g0","g1","p0","p1","forEach","hoverPt","offsetX","offsetY","getTextShiftX","alignShift","start","end","middle","textShiftX","text2ShiftX","isMiddle","shiftX","posX","posY","setRect","cd0","pass","v","getVal","calcKey","traceKey","castOption","extractOption","val","constrain","hoverLabelText","xhoverformat","xVal","c2d","yhoverformat","yVal","String","isNaN","xerr","xeText","tickText","c2l","xerrneg","yerr","yeText","yerrneg","infomode","gs","_size","showY","showX","hLinePointX","hLinePointY","ySnap","dfltHLineColor","readability","yMode","spikemode","yThickness","spikethickness","yColor","spikecolor","xEdge","getPxPosition","xBase","xEndSpike","xAcross0","_counterDomainMin","xAcross1","_counterDomainMax","position","l","w","x2","y2","dashStyle","spikedash","cx","cy","r","vLinePointX","vLinePointY","xSnap","dfltVLineColor","xMode","xThickness","xColor","yEdge","yBase","yEndSpike","yAcross0","yAcross1","t","h","oldPt","newPt","pointNumbers","allowedTags","first","second","last","_categoriesMap","periodalignment","diff","d2c","posLetter","boxmode","violinmode","dPos","clientTop","clientLeft","rect","A","B","Ax","Ay","Bx","By","right"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/fx/hover.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\nvar pushUnique = Lib.pushUnique;\nvar strTranslate = Lib.strTranslate;\nvar strRotate = Lib.strRotate;\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar dragElement = require('../dragelement');\nvar Axes = require('../../plots/cartesian/axes');\nvar zindexSeparator = require('../../plots/cartesian/constants').zindexSeparator;\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\n\nvar legendSupplyDefaults = require('../legend/defaults');\nvar legendDraw = require('../legend/draw');\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180;\n\n// expansion of projected height\nvar YFACTOR = 1 / Math.sin(YA_RADIANS);\n\n// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS);\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\n\nvar multipleHoverPoints = {\n    box: true,\n    ohlc: true,\n    violin: true,\n    candlestick: true\n};\n\nvar cartesianScatterPoints = {\n    scatter: true,\n    scattergl: true,\n    splom: true\n};\n\nfunction distanceSort(a, b) {\n    return a.distance - b.distance;\n}\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n    gd = Lib.getGraphDiv(gd);\n    // The 'target' property changes when bubbling out of Shadow DOM.\n    // Throttling can delay reading the target, so we save the current value.\n    var eventTarget = evt.target;\n    Lib.throttle(\n        gd._fullLayout._uid + constants.HOVERID,\n        constants.HOVERMINTIME,\n        function() { _hover(gd, evt, subplot, noHoverEvent, eventTarget); }\n    );\n};\n\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\nexports.loneHover = function loneHover(hoverItems, opts) {\n    var multiHover = true;\n    if(!Array.isArray(hoverItems)) {\n        multiHover = false;\n        hoverItems = [hoverItems];\n    }\n\n    var gd = opts.gd;\n    var gTop = getTopOffset(gd);\n    var gLeft = getLeftOffset(gd);\n\n    var pointsData = hoverItems.map(function(hoverItem) {\n        var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;\n        var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;\n        var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;\n        var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;\n\n        var eventData = hoverItem.eventData;\n        if(eventData) {\n            var x0 = Math.min(_x0, _x1);\n            var x1 = Math.max(_x0, _x1);\n            var y0 = Math.min(_y0, _y1);\n            var y1 = Math.max(_y0, _y1);\n\n            var trace = hoverItem.trace;\n            if(Registry.traceIs(trace, 'gl3d')) {\n                var container = gd._fullLayout[trace.scene]._scene.container;\n                var dx = container.offsetLeft;\n                var dy = container.offsetTop;\n                x0 += dx;\n                x1 += dx;\n                y0 += dy;\n                y1 += dy;\n            } // TODO: handle heatmapgl\n\n            eventData.bbox = {\n                x0: x0 + gLeft,\n                x1: x1 + gLeft,\n                y0: y0 + gTop,\n                y1: y1 + gTop\n            };\n\n            if(opts.inOut_bbox) {\n                opts.inOut_bbox.push(eventData.bbox);\n            }\n        } else {\n            eventData = false;\n        }\n\n        return {\n            color: hoverItem.color || Color.defaultLine,\n            x0: hoverItem.x0 || hoverItem.x || 0,\n            x1: hoverItem.x1 || hoverItem.x || 0,\n            y0: hoverItem.y0 || hoverItem.y || 0,\n            y1: hoverItem.y1 || hoverItem.y || 0,\n            xLabel: hoverItem.xLabel,\n            yLabel: hoverItem.yLabel,\n            zLabel: hoverItem.zLabel,\n            text: hoverItem.text,\n            name: hoverItem.name,\n            idealAlign: hoverItem.idealAlign,\n\n            // optional extra bits of styling\n            borderColor: hoverItem.borderColor,\n            fontFamily: hoverItem.fontFamily,\n            fontSize: hoverItem.fontSize,\n            fontColor: hoverItem.fontColor,\n            fontWeight: hoverItem.fontWeight,\n            fontStyle: hoverItem.fontStyle,\n            fontVariant: hoverItem.fontVariant,\n            nameLength: hoverItem.nameLength,\n            textAlign: hoverItem.textAlign,\n\n            // filler to make createHoverText happy\n            trace: hoverItem.trace || {\n                index: 0,\n                hoverinfo: ''\n            },\n            xa: {_offset: 0},\n            ya: {_offset: 0},\n            index: 0,\n\n            hovertemplate: hoverItem.hovertemplate || false,\n            hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n\n            eventData: eventData\n        };\n    });\n\n    var rotateLabels = false;\n\n    var hoverText = createHoverText(pointsData, {\n        gd: gd,\n        hovermode: 'closest',\n        rotateLabels: rotateLabels,\n        bgColor: opts.bgColor || Color.background,\n        container: d3.select(opts.container),\n        outerContainer: opts.outerContainer || opts.container\n    });\n    var hoverLabel = hoverText.hoverLabels;\n\n    // Fix vertical overlap\n    var tooltipSpacing = 5;\n    var lastBottomY = 0;\n    var anchor = 0;\n    hoverLabel\n        .sort(function(a, b) {return a.y0 - b.y0;})\n        .each(function(d, i) {\n            var topY = d.y0 - d.by / 2;\n\n            if((topY - tooltipSpacing) < lastBottomY) {\n                d.offset = (lastBottomY - topY) + tooltipSpacing;\n            } else {\n                d.offset = 0;\n            }\n\n            lastBottomY = topY + d.by + d.offset;\n\n            if(i === opts.anchorIndex || 0) anchor = d.offset;\n        })\n        .each(function(d) {\n            d.offset -= anchor;\n        });\n\n    var scaleX = gd._fullLayout._invScaleX;\n    var scaleY = gd._fullLayout._invScaleY;\n    alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);\n\n    return multiHover ? hoverLabel : hoverLabel.node();\n};\n\n// The actual implementation is here:\nfunction _hover(gd, evt, subplot, noHoverEvent, eventTarget) {\n    if(!subplot) subplot = 'xy';\n\n    if(typeof subplot === 'string') {\n        // drop zindex from subplot id\n        subplot = subplot.split(zindexSeparator)[0];\n    }\n\n    // if the user passed in an array of subplots,\n    // use those instead of finding overlayed plots\n    var subplots = Array.isArray(subplot) ? subplot : [subplot];\n\n    var spId;\n\n    var fullLayout = gd._fullLayout;\n    var hoversubplots = fullLayout.hoversubplots;\n    var plots = fullLayout._plots || [];\n    var plotinfo = plots[subplot];\n    var hasCartesian = fullLayout._has('cartesian');\n\n    var hovermode = evt.hovermode || fullLayout.hovermode;\n    var hovermodeHasX = (hovermode || '').charAt(0) === 'x';\n    var hovermodeHasY = (hovermode || '').charAt(0) === 'y';\n\n    var firstXaxis;\n    var firstYaxis;\n\n    if(hasCartesian && (hovermodeHasX || hovermodeHasY) && hoversubplots === 'axis') {\n        var subplotsLength = subplots.length;\n        for(var p = 0; p < subplotsLength; p++) {\n            spId = subplots[p];\n            if(plots[spId]) {\n                // 'cartesian' case\n\n                firstXaxis = Axes.getFromId(gd, spId, 'x');\n                firstYaxis = Axes.getFromId(gd, spId, 'y');\n\n                var subplotsWith = (\n                    hovermodeHasX ? firstXaxis : firstYaxis\n                )._subplotsWith;\n\n                if(subplotsWith && subplotsWith.length) {\n                    for(var q = 0; q < subplotsWith.length; q++) {\n                        pushUnique(subplots, subplotsWith[q]);\n                    }\n                }\n            }\n        }\n    }\n\n    // list of all overlaid subplots to look at\n    if(plotinfo && hoversubplots !== 'single') {\n        var overlayedSubplots = plotinfo.overlays.map(function(pi) {\n            return pi.id;\n        });\n\n        subplots = subplots.concat(overlayedSubplots);\n    }\n\n    var len = subplots.length;\n    var xaArray = new Array(len);\n    var yaArray = new Array(len);\n    var supportsCompare = false;\n\n    for(var i = 0; i < len; i++) {\n        spId = subplots[i];\n\n        if(plots[spId]) {\n            // 'cartesian' case\n            supportsCompare = true;\n            xaArray[i] = plots[spId].xaxis;\n            yaArray[i] = plots[spId].yaxis;\n        } else if(fullLayout[spId] && fullLayout[spId]._subplot) {\n            // other subplot types\n            var _subplot = fullLayout[spId]._subplot;\n            xaArray[i] = _subplot.xaxis;\n            yaArray[i] = _subplot.yaxis;\n        } else {\n            Lib.warn('Unrecognized subplot: ' + spId);\n            return;\n        }\n    }\n\n    if(hovermode && !supportsCompare) hovermode = 'closest';\n\n    if(['x', 'y', 'closest', 'x unified', 'y unified'].indexOf(hovermode) === -1 || !gd.calcdata ||\n            gd.querySelector('.zoombox') || gd._dragging) {\n        return dragElement.unhoverRaw(gd, evt);\n    }\n\n    var hoverdistance = fullLayout.hoverdistance;\n    if(hoverdistance === -1) hoverdistance = Infinity;\n\n    var spikedistance = fullLayout.spikedistance;\n    if(spikedistance === -1) spikedistance = Infinity;\n\n    // hoverData: the set of candidate points we've found to highlight\n    var hoverData = [];\n\n    // searchData: the data to search in. Mostly this is just a copy of\n    // gd.calcdata, filtered to the subplot and overlays we're on\n    // but if a point array is supplied it will be a mapping\n    // of indicated curves\n    var searchData = [];\n\n    // [x|y]valArray: the axis values of the hover event\n    // mapped onto each of the currently selected overlaid subplots\n    var xvalArray, yvalArray;\n\n    var itemnum, curvenum, cd, trace, subplotId, subploti, _mode,\n        xval, yval, pointData, closedataPreviousLength;\n\n    // spikePoints: the set of candidate points we've found to draw spikes to\n    var spikePoints = {\n        hLinePoint: null,\n        vLinePoint: null\n    };\n\n    // does subplot have one (or more) horizontal traces?\n    // This is used to determine whether we rotate the labels or not\n    var hasOneHorizontalTrace = false;\n\n    // Figure out what we're hovering on:\n    // mouse location or user-supplied data\n\n    if(Array.isArray(evt)) {\n        // user specified an array of points to highlight\n        hovermode = 'array';\n        for(itemnum = 0; itemnum < evt.length; itemnum++) {\n            cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n            if(cd) {\n                trace = cd[0].trace;\n                if(cd[0].trace.hoverinfo !== 'skip') {\n                    searchData.push(cd);\n                    if(trace.orientation === 'h') {\n                        hasOneHorizontalTrace = true;\n                    }\n                }\n            }\n        }\n    } else {\n        // take into account zorder\n        var zorderedCalcdata = gd.calcdata.slice();\n        zorderedCalcdata.sort(function(a, b) {\n            var aZorder = a[0].trace.zorder || 0;\n            var bZorder = b[0].trace.zorder || 0;\n            return aZorder - bZorder;\n        });\n\n        for(curvenum = 0; curvenum < zorderedCalcdata.length; curvenum++) {\n            cd = zorderedCalcdata[curvenum];\n            trace = cd[0].trace;\n            if(trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n                searchData.push(cd);\n                if(trace.orientation === 'h') {\n                    hasOneHorizontalTrace = true;\n                }\n            }\n        }\n\n        // [x|y]px: the pixels (from top left) of the mouse location\n        // on the currently selected plot area\n        // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n        var hasUserCalledHover = !eventTarget;\n        var xpx, ypx;\n\n        if(hasUserCalledHover) {\n            if('xpx' in evt) xpx = evt.xpx;\n            else xpx = xaArray[0]._length / 2;\n\n            if('ypx' in evt) ypx = evt.ypx;\n            else ypx = yaArray[0]._length / 2;\n        } else {\n            // fire the beforehover event and quit if it returns false\n            // note that we're only calling this on real mouse events, so\n            // manual calls to fx.hover will always run.\n            if(Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n                return;\n            }\n\n            var dbb = eventTarget.getBoundingClientRect();\n\n            xpx = evt.clientX - dbb.left;\n            ypx = evt.clientY - dbb.top;\n\n            fullLayout._calcInverseTransform(gd);\n            var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);\n\n            xpx = transformedCoords[0];\n            ypx = transformedCoords[1];\n\n            // in case hover was called from mouseout into hovertext,\n            // it's possible you're not actually over the plot anymore\n            if(xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n                return dragElement.unhoverRaw(gd, evt);\n            }\n        }\n\n        evt.pointerX = xpx + xaArray[0]._offset;\n        evt.pointerY = ypx + yaArray[0]._offset;\n\n        if('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);\n        else xvalArray = helpers.p2c(xaArray, xpx);\n\n        if('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);\n        else yvalArray = helpers.p2c(yaArray, ypx);\n\n        if(!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n            Lib.warn('Fx.hover failed', evt, gd);\n            return dragElement.unhoverRaw(gd, evt);\n        }\n    }\n\n    // the pixel distance to beat as a matching point\n    // in 'x' or 'y' mode this resets for each trace\n    var distance = Infinity;\n\n    // find the closest point in each trace\n    // this is minimum dx and/or dy, depending on mode\n    // and the pixel position for the label (labelXpx, labelYpx)\n    function findHoverPoints(customXVal, customYVal) {\n        for(curvenum = 0; curvenum < searchData.length; curvenum++) {\n            cd = searchData[curvenum];\n\n            // filter out invisible or broken data\n            if(!cd || !cd[0] || !cd[0].trace) continue;\n\n            trace = cd[0].trace;\n\n            if(trace.visible !== true || trace._length === 0) continue;\n\n            // Explicitly bail out for these two. I don't know how to otherwise prevent\n            // the rest of this function from running and failing\n            if(['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n            // within one trace mode can sometimes be overridden\n            _mode = hovermode;\n            if(helpers.isUnifiedHover(_mode)) {\n                _mode = _mode.charAt(0);\n            }\n\n            if(trace.type === 'splom') {\n                // splom traces do not generate overlay subplots,\n                // it is safe to assume here splom traces correspond to the 0th subplot\n                subploti = 0;\n                subplotId = subplots[subploti];\n            } else {\n                subplotId = helpers.getSubplot(trace);\n                subploti = subplots.indexOf(subplotId);\n            }\n\n            // container for new point, also used to pass info into module.hoverPoints\n            pointData = {\n                // trace properties\n                cd: cd,\n                trace: trace,\n                xa: xaArray[subploti],\n                ya: yaArray[subploti],\n\n                // max distances for hover and spikes - for points that want to show but do not\n                // want to override other points, set distance/spikeDistance equal to max*Distance\n                // and it will not get filtered out but it will be guaranteed to have a greater\n                // distance than any point that calculated a real distance.\n                maxHoverDistance: hoverdistance,\n                maxSpikeDistance: spikedistance,\n\n                // point properties - override all of these\n                index: false, // point index in trace - only used by plotly.js hoverdata consumers\n                distance: Math.min(distance, hoverdistance), // pixel distance or pseudo-distance\n\n                // distance/pseudo-distance for spikes. This distance should always be calculated\n                // as if in \"closest\" mode, and should only be set if this point should\n                // generate a spike.\n                spikeDistance: Infinity,\n\n                // in some cases the spikes have different positioning from the hover label\n                // they don't need x0/x1, just one position\n                xSpike: undefined,\n                ySpike: undefined,\n\n                // where and how to display the hover label\n                color: Color.defaultLine, // trace color\n                name: trace.name,\n                x0: undefined,\n                x1: undefined,\n                y0: undefined,\n                y1: undefined,\n                xLabelVal: undefined,\n                yLabelVal: undefined,\n                zLabelVal: undefined,\n                text: undefined\n            };\n\n            // add ref to subplot object (non-cartesian case)\n            if(fullLayout[subplotId]) {\n                pointData.subplot = fullLayout[subplotId]._subplot;\n            }\n            // add ref to splom scene\n            if(fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n                pointData.scene = fullLayout._splomScenes[trace.uid];\n            }\n\n            // for a highlighting array, figure out what\n            // we're searching for with this element\n            if(_mode === 'array') {\n                var selection = evt[curvenum];\n                if('pointNumber' in selection) {\n                    pointData.index = selection.pointNumber;\n                    _mode = 'closest';\n                } else {\n                    _mode = '';\n                    if('xval' in selection) {\n                        xval = selection.xval;\n                        _mode = 'x';\n                    }\n                    if('yval' in selection) {\n                        yval = selection.yval;\n                        _mode = _mode ? 'closest' : 'y';\n                    }\n                }\n            } else if(customXVal !== undefined && customYVal !== undefined) {\n                xval = customXVal;\n                yval = customYVal;\n            } else {\n                xval = xvalArray[subploti];\n                yval = yvalArray[subploti];\n            }\n\n            closedataPreviousLength = hoverData.length;\n\n            // Now if there is range to look in, find the points to hover.\n            if(hoverdistance !== 0) {\n                if(trace._module && trace._module.hoverPoints) {\n                    var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {\n                        finiteRange: true,\n                        hoverLayer: fullLayout._hoverlayer,\n\n                        // options for splom when hovering on same axis\n                        hoversubplots: hoversubplots,\n                        gd: gd\n                    });\n\n                    if(newPoints) {\n                        var newPoint;\n                        for(var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n                            newPoint = newPoints[newPointNum];\n                            if(isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                                hoverData.push(cleanPoint(newPoint, hovermode));\n                            }\n                        }\n                    }\n                } else {\n                    Lib.log('Unrecognized trace type in hover:', trace);\n                }\n            }\n\n            // in closest mode, remove any existing (farther) points\n            // and don't look any farther than this latest point (or points, some\n            // traces like box & violin make multiple hover labels at once)\n            if(hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n                hoverData.splice(0, closedataPreviousLength);\n                distance = hoverData[0].distance;\n            }\n\n            // Now if there is range to look in, find the points to draw the spikelines\n            // Do it only if there is no hoverData\n            if(hasCartesian && (spikedistance !== 0)) {\n                if(hoverData.length === 0) {\n                    pointData.distance = spikedistance;\n                    pointData.index = false;\n                    var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', {\n                        hoverLayer: fullLayout._hoverlayer\n                    });\n                    if(closestPoints) {\n                        closestPoints = closestPoints.filter(function(point) {\n                            // some hover points, like scatter fills, do not allow spikes,\n                            // so will generate a hover point but without a valid spikeDistance\n                            return point.spikeDistance <= spikedistance;\n                        });\n                    }\n                    if(closestPoints && closestPoints.length) {\n                        var tmpPoint;\n                        var closestVPoints = closestPoints.filter(function(point) {\n                            return point.xa.showspikes && point.xa.spikesnap !== 'hovered data';\n                        });\n                        if(closestVPoints.length) {\n                            var closestVPt = closestVPoints[0];\n                            if(isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n                                tmpPoint = fillSpikePoint(closestVPt);\n                                if(!spikePoints.vLinePoint || (spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                    spikePoints.vLinePoint = tmpPoint;\n                                }\n                            }\n                        }\n\n                        var closestHPoints = closestPoints.filter(function(point) {\n                            return point.ya.showspikes && point.ya.spikesnap !== 'hovered data';\n                        });\n                        if(closestHPoints.length) {\n                            var closestHPt = closestHPoints[0];\n                            if(isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n                                tmpPoint = fillSpikePoint(closestHPt);\n                                if(!spikePoints.hLinePoint || (spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                    spikePoints.hLinePoint = tmpPoint;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    findHoverPoints();\n\n    function selectClosestPoint(pointsData, spikedistance, spikeOnWinning) {\n        var resultPoint = null;\n        var minDistance = Infinity;\n        var thisSpikeDistance;\n\n        for(var i = 0; i < pointsData.length; i++) {\n            if(firstXaxis && firstXaxis._id !== pointsData[i].xa._id) continue;\n            if(firstYaxis && firstYaxis._id !== pointsData[i].ya._id) continue;\n\n            thisSpikeDistance = pointsData[i].spikeDistance;\n            if(spikeOnWinning && i === 0) thisSpikeDistance = -Infinity;\n\n            if(thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance) {\n                resultPoint = pointsData[i];\n                minDistance = thisSpikeDistance;\n            }\n        }\n        return resultPoint;\n    }\n\n    function fillSpikePoint(point) {\n        if(!point) return null;\n        return {\n            xa: point.xa,\n            ya: point.ya,\n            x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n            y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n            distance: point.distance,\n            spikeDistance: point.spikeDistance,\n            curveNumber: point.trace.index,\n            color: point.color,\n            pointNumber: point.index\n        };\n    }\n\n    var spikelineOpts = {\n        fullLayout: fullLayout,\n        container: fullLayout._hoverlayer,\n        event: evt\n    };\n    var oldspikepoints = gd._spikepoints;\n    var newspikepoints = {\n        vLinePoint: spikePoints.vLinePoint,\n        hLinePoint: spikePoints.hLinePoint\n    };\n    gd._spikepoints = newspikepoints;\n\n    var sortHoverData = function() {\n        // When sorting keep the points in the main subplot at the top\n        // then add points in other subplots\n\n        var hoverDataInSubplot = hoverData.filter(function(a) {\n            return (\n                (firstXaxis && firstXaxis._id === a.xa._id) &&\n                (firstYaxis && firstYaxis._id === a.ya._id)\n            );\n        });\n\n        var hoverDataOutSubplot = hoverData.filter(function(a) {\n            return !(\n                (firstXaxis && firstXaxis._id === a.xa._id) &&\n                (firstYaxis && firstYaxis._id === a.ya._id)\n            );\n        });\n\n        hoverDataInSubplot.sort(distanceSort);\n        hoverDataOutSubplot.sort(distanceSort);\n        hoverData = hoverDataInSubplot.concat(hoverDataOutSubplot);\n\n        // move period positioned points and box/bar-like traces to the end of the list\n        hoverData = orderRangePoints(hoverData, hovermode);\n    };\n    sortHoverData();\n\n    var axLetter = hovermode.charAt(0);\n    var spikeOnWinning = (axLetter === 'x' || axLetter === 'y') && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];\n\n    // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n    if(hasCartesian && (spikedistance !== 0)) {\n        if(hoverData.length !== 0) {\n            var tmpHPointData = hoverData.filter(function(point) {\n                return point.ya.showspikes;\n            });\n            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);\n            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n\n            var tmpVPointData = hoverData.filter(function(point) {\n                return point.xa.showspikes;\n            });\n            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);\n            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n        }\n    }\n\n    // if hoverData is empty check for the spikes to draw and quit if there are none\n    if(hoverData.length === 0) {\n        var result = dragElement.unhoverRaw(gd, evt);\n        if(hasCartesian && ((spikePoints.hLinePoint !== null) || (spikePoints.vLinePoint !== null))) {\n            if(spikesChanged(oldspikepoints)) {\n                createSpikelines(gd, spikePoints, spikelineOpts);\n            }\n        }\n        return result;\n    }\n\n    if(hasCartesian) {\n        if(spikesChanged(oldspikepoints)) {\n            createSpikelines(gd, spikePoints, spikelineOpts);\n        }\n    }\n\n    if(\n        helpers.isXYhover(_mode) &&\n        hoverData[0].length !== 0 &&\n        hoverData[0].trace.type !== 'splom' // TODO: add support for splom\n    ) {\n        // pick winning point\n        var winningPoint = hoverData[0];\n        // discard other points\n        if(multipleHoverPoints[winningPoint.trace.type]) {\n            hoverData = hoverData.filter(function(d) {\n                return d.trace.index === winningPoint.trace.index;\n            });\n        } else {\n            hoverData = [winningPoint];\n        }\n        var initLen = hoverData.length;\n\n        var winX = getCoord('x', winningPoint, fullLayout);\n        var winY = getCoord('y', winningPoint, fullLayout);\n\n        // in compare mode, select every point at position\n        findHoverPoints(winX, winY);\n\n        var finalPoints = [];\n        var seen = {};\n        var id = 0;\n        var insert = function(newHd) {\n            var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;\n            if(!seen[key]) {\n                id++;\n                seen[key] = id;\n                finalPoints.push(newHd);\n            } else {\n                var oldId = seen[key] - 1;\n                var oldHd = finalPoints[oldId];\n                if(oldId > 0 &&\n                    Math.abs(newHd.distance) <\n                    Math.abs(oldHd.distance)\n                ) {\n                    // replace with closest\n                    finalPoints[oldId] = newHd;\n                }\n            }\n        };\n\n        var k;\n        // insert the winnig point(s) first\n        for(k = 0; k < initLen; k++) {\n            insert(hoverData[k]);\n        }\n        // override from the end\n        for(k = hoverData.length - 1; k > initLen - 1; k--) {\n            insert(hoverData[k]);\n        }\n        hoverData = finalPoints;\n        sortHoverData();\n    }\n\n    // lastly, emit custom hover/unhover events\n    var oldhoverdata = gd._hoverdata;\n    var newhoverdata = [];\n\n    var gTop = getTopOffset(gd);\n    var gLeft = getLeftOffset(gd);\n\n    // pull out just the data that's useful to\n    // other people and send it to the event\n    for(itemnum = 0; itemnum < hoverData.length; itemnum++) {\n        var pt = hoverData[itemnum];\n        var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n        if(pt.hovertemplate !== false) {\n            var ht = false;\n            if(pt.cd[pt.index] && pt.cd[pt.index].ht) {\n                ht = pt.cd[pt.index].ht;\n            }\n            pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n        }\n\n        if(pt.xa && pt.ya) {\n            var _x0 = pt.x0 + pt.xa._offset;\n            var _x1 = pt.x1 + pt.xa._offset;\n            var _y0 = pt.y0 + pt.ya._offset;\n            var _y1 = pt.y1 + pt.ya._offset;\n\n            var x0 = Math.min(_x0, _x1);\n            var x1 = Math.max(_x0, _x1);\n            var y0 = Math.min(_y0, _y1);\n            var y1 = Math.max(_y0, _y1);\n\n            eventData.bbox = {\n                x0: x0 + gLeft,\n                x1: x1 + gLeft,\n                y0: y0 + gTop,\n                y1: y1 + gTop\n            };\n        }\n\n        pt.eventData = [eventData];\n        newhoverdata.push(eventData);\n    }\n\n    gd._hoverdata = newhoverdata;\n\n    var rotateLabels = (\n        (hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1)) ||\n        (hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1)\n    );\n\n    var bgColor = Color.combine(\n        fullLayout.plot_bgcolor || Color.background,\n        fullLayout.paper_bgcolor\n    );\n\n    var hoverText = createHoverText(hoverData, {\n        gd: gd,\n        hovermode: hovermode,\n        rotateLabels: rotateLabels,\n        bgColor: bgColor,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paper.node(),\n        commonLabelOpts: fullLayout.hoverlabel,\n        hoverdistance: fullLayout.hoverdistance\n    });\n    var hoverLabels = hoverText.hoverLabels;\n\n    if(!helpers.isUnifiedHover(hovermode)) {\n        hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, hoverText.commonLabelBoundingBox);\n        alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);\n    }    // TODO: tagName hack is needed to appease geo.js's hack of using eventTarget=true\n    // we should improve the \"fx\" API so other plots can use it without these hack.\n    if(eventTarget && eventTarget.tagName) {\n        var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n        overrideCursor(d3.select(eventTarget), hasClickToShow ? 'pointer' : '');\n    }\n\n    // don't emit events if called manually\n    if(!eventTarget || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n    if(oldhoverdata) {\n        gd.emit('plotly_unhover', {\n            event: evt,\n            points: oldhoverdata\n        });\n    }\n\n    gd.emit('plotly_hover', {\n        event: evt,\n        points: gd._hoverdata,\n        xaxes: xaArray,\n        yaxes: yaArray,\n        xvals: xvalArray,\n        yvals: yvalArray\n    });\n}\n\nfunction hoverDataKey(d) {\n    return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : '', d.ya ? d.ya._id : ''].join(',');\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts) {\n    var gd = opts.gd;\n    var fullLayout = gd._fullLayout;\n    var hovermode = opts.hovermode;\n    var rotateLabels = opts.rotateLabels;\n    var bgColor = opts.bgColor;\n    var container = opts.container;\n    var outerContainer = opts.outerContainer;\n    var commonLabelOpts = opts.commonLabelOpts || {};\n    // Early exit if no labels are drawn\n    if(hoverData.length === 0) return [[]];\n\n    // opts.fontFamily/Size are used for the common label\n    // and as defaults for each hover label, though the individual labels\n    // can override this.\n    var fontFamily = opts.fontFamily || constants.HOVERFONT;\n    var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n    var fontWeight = opts.fontWeight || fullLayout.font.weight;\n    var fontStyle = opts.fontStyle || fullLayout.font.style;\n    var fontVariant = opts.fontVariant || fullLayout.font.variant;\n    var fontTextcase = opts.fontTextcase || fullLayout.font.textcase;\n    var fontLineposition = opts.fontLineposition || fullLayout.font.lineposition;\n    var fontShadow = opts.fontShadow || fullLayout.font.shadow;\n\n    var c0 = hoverData[0];\n    var xa = c0.xa;\n    var ya = c0.ya;\n    var axLetter = hovermode.charAt(0);\n    var axLabel = axLetter + 'Label';\n    var t0 = c0[axLabel];\n\n    // search in array for the label\n    if(t0 === undefined && xa.type === 'multicategory') {\n        for(var q = 0; q < hoverData.length; q++) {\n            t0 = hoverData[q][axLabel];\n            if(t0 !== undefined) break;\n        }\n    }\n\n    var outerContainerBB = getBoundingClientRect(gd, outerContainer);\n    var outerTop = outerContainerBB.top;\n    var outerWidth = outerContainerBB.width;\n    var outerHeight = outerContainerBB.height;\n\n    // show the common label, if any, on the axis\n    // never show a common label in array mode,\n    // even if sometimes there could be one\n    var showCommonLabel = (\n        (t0 !== undefined) &&\n        (c0.distance <= opts.hoverdistance) &&\n        (hovermode === 'x' || hovermode === 'y')\n    );\n\n    // all hover traces hoverinfo must contain the hovermode\n    // to have common labels\n    if(showCommonLabel) {\n        var allHaveZ = true;\n        var i, traceHoverinfo;\n        for(i = 0; i < hoverData.length; i++) {\n            if(allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n\n            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n            if(traceHoverinfo) {\n                var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n                if(parts.indexOf('all') === -1 &&\n                    parts.indexOf(hovermode) === -1) {\n                    showCommonLabel = false;\n                    break;\n                }\n            }\n        }\n\n        // xyz labels put all info in their main label, so have no need of a common label\n        if(allHaveZ) showCommonLabel = false;\n    }\n\n    var commonLabel = container.selectAll('g.axistext')\n        .data(showCommonLabel ? [0] : []);\n    commonLabel.enter().append('g')\n        .classed('axistext', true);\n    commonLabel.exit().remove();\n\n    // set rect (without arrow) behind label below for later collision detection\n    var commonLabelRect = {\n        minX: 0,\n        maxX: 0,\n        minY: 0,\n        maxY: 0\n    };\n    commonLabel.each(function() {\n        var label = d3.select(this);\n        var lpath = Lib.ensureSingle(label, 'path', '', function(s) {\n            s.style({'stroke-width': '1px'});\n        });\n        var ltext = Lib.ensureSingle(label, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n        var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n        var contrastColor = Color.contrast(commonBgColor);\n        var commonLabelOptsFont = commonLabelOpts.font;\n        var commonLabelFont = {\n            weight: commonLabelOptsFont.weight || fontWeight,\n            style: commonLabelOptsFont.style || fontStyle,\n            variant: commonLabelOptsFont.variant || fontVariant,\n            textcase: commonLabelOptsFont.textcase || fontTextcase,\n            lineposition: commonLabelOptsFont.lineposition || fontLineposition,\n            shadow: commonLabelOptsFont.shadow || fontShadow,\n            family: commonLabelOptsFont.family || fontFamily,\n            size: commonLabelOptsFont.size || fontSize,\n            color: commonLabelOptsFont.color || contrastColor\n        };\n\n        lpath.style({\n            fill: commonBgColor,\n            stroke: commonStroke\n        });\n\n        ltext.text(t0)\n            .call(Drawing.font, commonLabelFont)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        label.attr('transform', '');\n\n        var tbb = getBoundingClientRect(gd, ltext.node());\n        var lx, ly;\n\n        if(hovermode === 'x') {\n            var topsign = xa.side === 'top' ? '-' : '';\n\n            ltext.attr('text-anchor', 'middle')\n                .call(svgTextUtils.positionText, 0, (xa.side === 'top' ?\n                    (outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD) :\n                    (outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD)));\n\n            lx = xa._offset + (c0.x0 + c0.x1) / 2;\n            ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n\n            var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n\n            var tooltipMidX = lx;\n            if(lx < halfWidth) {\n                tooltipMidX = halfWidth;\n            } else if(lx > (fullLayout.width - halfWidth)) {\n                tooltipMidX = fullLayout.width - halfWidth;\n            }\n\n            lpath.attr('d', 'M' + (lx - tooltipMidX) + ',0' +\n                'L' + (lx - tooltipMidX + HOVERARROWSIZE) + ',' + topsign + HOVERARROWSIZE +\n                'H' + halfWidth +\n                'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                'H' + (-halfWidth) +\n                'V' + topsign + HOVERARROWSIZE +\n                'H' + (lx - tooltipMidX - HOVERARROWSIZE) +\n                'Z');\n\n            lx = tooltipMidX;\n            commonLabelRect.minX = lx - halfWidth;\n            commonLabelRect.maxX = lx + halfWidth;\n            if(xa.side === 'top') {\n                // label on negative y side\n                commonLabelRect.minY = ly - (HOVERTEXTPAD * 2 + tbb.height);\n                commonLabelRect.maxY = ly - HOVERTEXTPAD;\n            } else {\n                commonLabelRect.minY = ly + HOVERTEXTPAD;\n                commonLabelRect.maxY = ly + (HOVERTEXTPAD * 2 + tbb.height);\n            }\n        } else {\n            var anchor;\n            var sgn;\n            var leftsign;\n            if(ya.side === 'right') {\n                anchor = 'start';\n                sgn = 1;\n                leftsign = '';\n                lx = xa._offset + xa._length;\n            } else {\n                anchor = 'end';\n                sgn = -1;\n                leftsign = '-';\n                lx = xa._offset;\n            }\n\n            ly = ya._offset + (c0.y0 + c0.y1) / 2;\n\n            ltext.attr('text-anchor', anchor);\n\n            lpath.attr('d', 'M0,0' +\n                'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE +\n                'V' + (HOVERTEXTPAD + tbb.height / 2) +\n                'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) +\n                'V-' + (HOVERTEXTPAD + tbb.height / 2) +\n                'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n\n            commonLabelRect.minY = ly - (HOVERTEXTPAD + tbb.height / 2);\n            commonLabelRect.maxY = ly + (HOVERTEXTPAD + tbb.height / 2);\n            if(ya.side === 'right') {\n                commonLabelRect.minX = lx + HOVERARROWSIZE;\n                commonLabelRect.maxX = lx + HOVERARROWSIZE + (HOVERTEXTPAD * 2 + tbb.width);\n            } else {\n                // label on negative x side\n                commonLabelRect.minX = lx - HOVERARROWSIZE - (HOVERTEXTPAD * 2 + tbb.width);\n                commonLabelRect.maxX = lx - HOVERARROWSIZE;\n            }\n\n            var halfHeight = tbb.height / 2;\n            var lty = outerTop - tbb.top - halfHeight;\n            var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n            var clipPath;\n\n            if(lx < (tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE)) {\n                clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight +\n                    'h-' + (tbb.width - HOVERTEXTPAD) +\n                    'V' + halfHeight +\n                    'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n\n                var ltx = tbb.width - lx + HOVERTEXTPAD;\n                svgTextUtils.positionText(ltext, ltx, lty);\n\n                // shift each line (except the longest) so that start-of-line\n                // is always visible\n                if(anchor === 'end') {\n                    ltext.selectAll('tspan').each(function() {\n                        var s = d3.select(this);\n                        var dummy = Drawing.tester.append('text')\n                            .text(s.text())\n                            .call(Drawing.font, commonLabelFont);\n                        var dummyBB = getBoundingClientRect(gd, dummy.node());\n                        if(Math.round(dummyBB.width) < Math.round(tbb.width)) {\n                            s.attr('x', ltx - dummyBB.width);\n                        }\n                        dummy.remove();\n                    });\n                }\n            } else {\n                svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n                clipPath = null;\n            }\n\n            var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n            textClip.enter().append('clipPath').attr('id', clipId).append('path');\n            textClip.exit().remove();\n            textClip.select('path').attr('d', clipPath);\n            Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n        }\n\n        label.attr('transform', strTranslate(lx, ly));\n    });\n\n    // Show a single hover label\n    if(helpers.isUnifiedHover(hovermode)) {\n        // Delete leftover hover labels from other hovermodes\n        container.selectAll('g.hovertext').remove();\n        var groupedHoverData = hoverData.filter(function(data) {return data.hoverinfo !== 'none';});\n        // Return early if nothing is hovered on\n        if(groupedHoverData.length === 0) return [];\n\n        // mock legend\n        var hoverlabel = fullLayout.hoverlabel;\n        var font = hoverlabel.font;\n        var mockLayoutIn = {\n            showlegend: true,\n            legend: {\n                title: {text: t0, font: font},\n                font: font,\n                bgcolor: hoverlabel.bgcolor,\n                bordercolor: hoverlabel.bordercolor,\n                borderwidth: 1,\n                tracegroupgap: 7,\n                traceorder: fullLayout.legend ? fullLayout.legend.traceorder : undefined,\n                orientation: 'v'\n            }\n        };\n        var mockLayoutOut = {\n            font: font\n        };\n        legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);\n        var mockLegend = mockLayoutOut.legend;\n\n        // prepare items for the legend\n        mockLegend.entries = [];\n        for(var j = 0; j < groupedHoverData.length; j++) {\n            var pt = groupedHoverData[j];\n            if(pt.hoverinfo === 'none') continue;\n\n            var texts = getHoverLabelText(pt, true, hovermode, fullLayout, t0);\n            var text = texts[0];\n            var name = texts[1];\n\n            pt.name = name;\n            if(name !== '') {\n                pt.text = name + ' : ' + text;\n            } else {\n                pt.text = text;\n            }\n\n            // pass through marker's calcdata to style legend items\n            var cd = pt.cd[pt.index];\n            if(cd) {\n                if(cd.mc) pt.mc = cd.mc;\n                if(cd.mcc) pt.mc = cd.mcc;\n                if(cd.mlc) pt.mlc = cd.mlc;\n                if(cd.mlcc) pt.mlc = cd.mlcc;\n                if(cd.mlw) pt.mlw = cd.mlw;\n                if(cd.mrc) pt.mrc = cd.mrc;\n                if(cd.dir) pt.dir = cd.dir;\n            }\n            pt._distinct = true;\n\n            mockLegend.entries.push([pt]);\n        }\n        mockLegend.entries.sort(function(a, b) { return a[0].trace.index - b[0].trace.index;});\n        mockLegend.layer = container;\n\n        // Draw unified hover label\n        mockLegend._inHover = true;\n        mockLegend._groupTitleFont = hoverlabel.grouptitlefont;\n\n        legendDraw(gd, mockLegend);\n\n        // Position the hover\n        var legendContainer = container.select('g.legend');\n        var tbb = getBoundingClientRect(gd, legendContainer.node());\n        var tWidth = tbb.width + 2 * HOVERTEXTPAD;\n        var tHeight = tbb.height + 2 * HOVERTEXTPAD;\n        var winningPoint = groupedHoverData[0];\n        var avgX = (winningPoint.x0 + winningPoint.x1) / 2;\n        var avgY = (winningPoint.y0 + winningPoint.y1) / 2;\n        // When a scatter (or e.g. heatmap) point wins, it's OK for the hovelabel to occlude the bar and other points.\n        var pointWon = !(\n            Registry.traceIs(winningPoint.trace, 'bar-like') ||\n            Registry.traceIs(winningPoint.trace, 'box-violin')\n        );\n\n        var lyBottom, lyTop;\n        if(axLetter === 'y') {\n            if(pointWon) {\n                lyTop = avgY - HOVERTEXTPAD;\n                lyBottom = avgY + HOVERTEXTPAD;\n            } else {\n                lyTop = Math.min.apply(null, groupedHoverData.map(function(c) { return Math.min(c.y0, c.y1); }));\n                lyBottom = Math.max.apply(null, groupedHoverData.map(function(c) { return Math.max(c.y0, c.y1); }));\n            }\n        } else {\n            lyTop = lyBottom = Lib.mean(groupedHoverData.map(function(c) { return (c.y0 + c.y1) / 2; })) - tHeight / 2;\n        }\n\n        var lxRight, lxLeft;\n        if(axLetter === 'x') {\n            if(pointWon) {\n                lxRight = avgX + HOVERTEXTPAD;\n                lxLeft = avgX - HOVERTEXTPAD;\n            } else {\n                lxRight = Math.max.apply(null, groupedHoverData.map(function(c) { return Math.max(c.x0, c.x1); }));\n                lxLeft = Math.min.apply(null, groupedHoverData.map(function(c) { return Math.min(c.x0, c.x1); }));\n            }\n        } else {\n            lxRight = lxLeft = Lib.mean(groupedHoverData.map(function(c) { return (c.x0 + c.x1) / 2; })) - tWidth / 2;\n        }\n\n        var xOffset = xa._offset;\n        var yOffset = ya._offset;\n        lyBottom += yOffset;\n        lxRight += xOffset;\n        lxLeft += xOffset - tWidth;\n        lyTop += yOffset - tHeight;\n\n        var lx, ly; // top and left positions of the hover box\n\n        // horizontal alignment to end up on screen\n        if(lxRight + tWidth < outerWidth && lxRight >= 0) {\n            lx = lxRight;\n        } else if(lxLeft + tWidth < outerWidth && lxLeft >= 0) {\n            lx = lxLeft;\n        } else if(xOffset + tWidth < outerWidth) {\n            lx = xOffset; // subplot left corner\n        } else {\n            // closest left or right side of the paper\n            if(lxRight - avgX < avgX - lxLeft + tWidth) {\n                lx = outerWidth - tWidth;\n            } else {\n                lx = 0;\n            }\n        }\n        lx += HOVERTEXTPAD;\n\n        // vertical alignement to end up on screen\n        if(lyBottom + tHeight < outerHeight && lyBottom >= 0) {\n            ly = lyBottom;\n        } else if(lyTop + tHeight < outerHeight && lyTop >= 0) {\n            ly = lyTop;\n        } else if(yOffset + tHeight < outerHeight) {\n            ly = yOffset; // subplot top corner\n        } else {\n            // closest top or bottom side of the paper\n            if(lyBottom - avgY < avgY - lyTop + tHeight) {\n                ly = outerHeight - tHeight;\n            } else {\n                ly = 0;\n            }\n        }\n        ly += HOVERTEXTPAD;\n\n        legendContainer.attr('transform', strTranslate(lx - 1, ly - 1));\n        return legendContainer;\n    }\n\n    // show all the individual labels\n\n    // first create the objects\n    var hoverLabels = container.selectAll('g.hovertext')\n        .data(hoverData, function(d) {\n            // N.B. when multiple items have the same result key-function value,\n            // only the first of those items in hoverData gets rendered\n            return hoverDataKey(d);\n        });\n    hoverLabels.enter().append('g')\n        .classed('hovertext', true)\n        .each(function() {\n            var g = d3.select(this);\n            // trace name label (rect and text.name)\n            g.append('rect')\n                .call(Color.fill, Color.addOpacity(bgColor, 0.8));\n            g.append('text').classed('name', true);\n            // trace data label (path and text.nums)\n            g.append('path')\n                .style('stroke-width', '1px');\n            g.append('text').classed('nums', true)\n                .call(Drawing.font, {\n                    weight: fontWeight,\n                    style: fontStyle,\n                    variant: fontVariant,\n                    textcase: fontTextcase,\n                    lineposition: fontLineposition,\n                    shadow: fontShadow,\n                    family: fontFamily,\n                    size: fontSize\n                });\n        });\n    hoverLabels.exit().remove();\n\n    // then put the text in, position the pointer to the data,\n    // and figure out sizes\n    hoverLabels.each(function(d) {\n        var g = d3.select(this).attr('transform', '');\n\n        var dColor = d.color;\n        if(Array.isArray(dColor)) {\n            dColor = dColor[d.eventData[0].pointNumber];\n        }\n\n        // combine possible non-opaque trace color with bgColor\n        var color0 = d.bgcolor || dColor;\n        // color for 'nums' part of the label\n        var numsColor = Color.combine(\n            Color.opacity(color0) ? color0 : Color.defaultLine,\n            bgColor\n        );\n        // color for 'name' part of the label\n        var nameColor = Color.combine(\n            Color.opacity(dColor) ? dColor : Color.defaultLine,\n            bgColor\n        );\n        // find a contrasting color for border and text\n        var contrastColor = d.borderColor || Color.contrast(numsColor);\n\n        var texts = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);\n        var text = texts[0];\n        var name = texts[1];\n\n        // main label\n        var tx = g.select('text.nums')\n            .call(Drawing.font, {\n                family: d.fontFamily || fontFamily,\n                size: d.fontSize || fontSize,\n                color: d.fontColor || contrastColor,\n                weight: d.fontWeight || fontWeight,\n                style: d.fontStyle || fontStyle,\n                variant: d.fontVariant || fontVariant,\n                textcase: d.fontTextcase || fontTextcase,\n                lineposition: d.fontLineposition || fontLineposition,\n                shadow: d.fontShadow || fontShadow,\n            })\n            .text(text)\n            .attr('data-notex', 1)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        var tx2 = g.select('text.name');\n        var tx2width = 0;\n        var tx2height = 0;\n\n        // secondary label for non-empty 'name'\n        if(name && name !== text) {\n            tx2.call(Drawing.font, {\n                family: d.fontFamily || fontFamily,\n                size: d.fontSize || fontSize,\n                color: nameColor,\n                weight: d.fontWeight || fontWeight,\n                style: d.fontStyle || fontStyle,\n                variant: d.fontVariant || fontVariant,\n                textcase: d.fontTextcase || fontTextcase,\n                lineposition: d.fontLineposition || fontLineposition,\n                shadow: d.fontShadow || fontShadow,\n            }).text(name)\n                .attr('data-notex', 1)\n                .call(svgTextUtils.positionText, 0, 0)\n                .call(svgTextUtils.convertToTspans, gd);\n\n            var t2bb = getBoundingClientRect(gd, tx2.node());\n            tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n            tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n        } else {\n            tx2.remove();\n            g.select('rect').remove();\n        }\n\n        g.select('path').style({\n            fill: numsColor,\n            stroke: contrastColor\n        });\n\n        var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n        var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n        var dx = Math.abs(d.x1 - d.x0);\n        var dy = Math.abs(d.y1 - d.y0);\n\n        var tbb = getBoundingClientRect(gd, tx.node());\n        var tbbWidth = tbb.width / fullLayout._invScaleX;\n        var tbbHeight = tbb.height / fullLayout._invScaleY;\n\n        d.ty0 = (outerTop - tbb.top) / fullLayout._invScaleY;\n        d.bx = tbbWidth + 2 * HOVERTEXTPAD;\n        d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);\n        d.anchor = 'start';\n        d.txwidth = tbbWidth;\n        d.tx2width = tx2width;\n        d.offset = 0;\n\n        var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;\n        var anchorStartOK, anchorEndOK;\n\n        if(rotateLabels) {\n            d.pos = htx;\n            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n                hty -= dy / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                hty += dy / 2;\n                d.anchor = 'start';\n            } else {\n                d.anchor = 'middle';\n            }\n            d.crossPos = hty;\n        } else {\n            d.pos = hty;\n            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n\n            if((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n                htx -= dx / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                htx += dx / 2;\n                d.anchor = 'start';\n            } else {\n                d.anchor = 'middle';\n\n                var txHalfWidth = txTotalWidth / 2;\n                var overflowR = htx + txHalfWidth - outerWidth;\n                var overflowL = htx - txHalfWidth;\n                if(overflowR > 0) htx -= overflowR;\n                if(overflowL < 0) htx += -overflowL;\n            }\n            d.crossPos = htx;\n        }\n\n        tx.attr('text-anchor', d.anchor);\n        if(tx2width) tx2.attr('text-anchor', d.anchor);\n        g.attr('transform', strTranslate(htx, hty) +\n            (rotateLabels ? strRotate(YANGLE) : ''));\n    });\n\n    return {\n        hoverLabels: hoverLabels,\n        commonLabelBoundingBox: commonLabelRect\n    };\n}\n\nfunction getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {\n    var name = '';\n    var text = '';\n    // to get custom 'name' labels pass cleanPoint\n    if(d.nameOverride !== undefined) d.name = d.nameOverride;\n\n    if(d.name) {\n        if(d.trace._meta) {\n            d.name = Lib.templateString(d.name, d.trace._meta);\n        }\n        name = plainText(d.name, d.nameLength);\n    }\n\n    var h0 = hovermode.charAt(0);\n    var h1 = h0 === 'x' ? 'y' : 'x';\n\n    if(d.zLabel !== undefined) {\n        if(d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n        if(d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n        if(\n            d.trace.type !== 'choropleth' &&\n            d.trace.type !== 'choroplethmapbox' &&\n            d.trace.type !== 'choroplethmap'\n        ) {\n            text += (text ? 'z: ' : '') + d.zLabel;\n        }\n    } else if(showCommonLabel && d[h0 + 'Label'] === t0) {\n        text = d[h1 + 'Label'] || '';\n    } else if(d.xLabel === undefined) {\n        if(d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n            text = d.yLabel;\n        }\n    } else if(d.yLabel === undefined) text = d.xLabel;\n    else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n    if((d.text || d.text === 0) && !Array.isArray(d.text)) {\n        text += (text ? '<br>' : '') + d.text;\n    }\n\n    // used by other modules (initially just ternary) that\n    // manage their own hoverinfo independent of cleanPoint\n    // the rest of this will still apply, so such modules\n    // can still put things in (x|y|z)Label, text, and name\n    // and hoverinfo will still determine their visibility\n    if(d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;\n\n    // if 'text' is empty at this point,\n    // and hovertemplate is not defined,\n    // put 'name' in main label and don't show secondary label\n    if(g && text === '' && !d.hovertemplate) {\n        // if 'name' is also empty, remove entire label\n        if(name === '') g.remove();\n        text = name;\n    }\n\n    // hovertemplate\n    var hovertemplate = d.hovertemplate || false;\n    if(hovertemplate) {\n        var labels = d.hovertemplateLabels || d;\n\n        if(d[h0 + 'Label'] !== t0) {\n            labels[h0 + 'other'] = labels[h0 + 'Val'];\n            labels[h0 + 'otherLabel'] = labels[h0 + 'Label'];\n        }\n\n        text = Lib.hovertemplateString(\n            hovertemplate,\n            labels,\n            fullLayout._d3locale,\n            d.eventData[0] || {},\n            d.trace._meta\n        );\n\n        text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {\n            // assign name for secondary text label\n            name = plainText(extra, d.nameLength);\n            // remove from main text label\n            return '';\n        });\n    }\n    return [text, name];\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Incidentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, commonLabelBoundingBox) {\n    var axKey = rotateLabels ? 'xa' : 'ya';\n    var crossAxKey = rotateLabels ? 'ya' : 'xa';\n    var nummoves = 0;\n    var axSign = 1;\n    var nLabels = hoverLabels.size();\n\n    // make groups of touching points\n    var pointgroups = new Array(nLabels);\n    var k = 0;\n\n    // get extent of axis hover label\n    var axisLabelMinX = commonLabelBoundingBox.minX;\n    var axisLabelMaxX = commonLabelBoundingBox.maxX;\n    var axisLabelMinY = commonLabelBoundingBox.minY;\n    var axisLabelMaxY = commonLabelBoundingBox.maxY;\n\n    var pX = function(x) { return x * fullLayout._invScaleX; };\n    var pY = function(y) { return y * fullLayout._invScaleY; };\n\n    hoverLabels.each(function(d) {\n        var ax = d[axKey];\n        var crossAx = d[crossAxKey];\n        var axIsX = ax._id.charAt(0) === 'x';\n        var rng = ax.range;\n\n        if(k === 0 && rng && ((rng[0] > rng[1]) !== axIsX)) {\n            axSign = -1;\n        }\n        var pmin = 0;\n        var pmax = (axIsX ? fullLayout.width : fullLayout.height);\n        // in hovermode avoid overlap between hover labels and axis label\n        if(fullLayout.hovermode === 'x' || fullLayout.hovermode === 'y') {\n            // extent of rect behind hover label on cross axis:\n            var offsets = getHoverLabelOffsets(d, rotateLabels);\n            var anchor = d.anchor;\n            var horzSign = anchor === 'end' ? -1 : 1;\n            var labelMin;\n            var labelMax;\n            if(anchor === 'middle') {\n                // use extent of centered rect either on x or y axis depending on current axis\n                labelMin = d.crossPos + (axIsX ? pY(offsets.y - d.by / 2) : pX(d.bx / 2 + d.tx2width / 2));\n                labelMax = labelMin + (axIsX ? pY(d.by) : pX(d.bx));\n            } else {\n                // use extend of path (see alignHoverText function) without arrow\n                if(axIsX) {\n                    labelMin = d.crossPos + pY(HOVERARROWSIZE + offsets.y) - pY(d.by / 2 - HOVERARROWSIZE);\n                    labelMax = labelMin + pY(d.by);\n                } else {\n                    var startX = pX(horzSign * HOVERARROWSIZE + offsets.x);\n                    var endX = startX + pX(horzSign * d.bx);\n                    labelMin = d.crossPos + Math.min(startX, endX);\n                    labelMax = d.crossPos + Math.max(startX, endX);\n                }\n            }\n\n            if(axIsX) {\n                if(axisLabelMinY !== undefined && axisLabelMaxY !== undefined && Math.min(labelMax, axisLabelMaxY) - Math.max(labelMin, axisLabelMinY) > 1) {\n                    // has at least 1 pixel overlap with axis label\n                    if(crossAx.side === 'left') {\n                        pmin = crossAx._mainLinePosition;\n                        pmax = fullLayout.width;\n                    } else {\n                        pmax = crossAx._mainLinePosition;\n                    }\n                }\n            } else {\n                if(axisLabelMinX !== undefined && axisLabelMaxX !== undefined && Math.min(labelMax, axisLabelMaxX) - Math.max(labelMin, axisLabelMinX) > 1) {\n                    // has at least 1 pixel overlap with axis label\n                    if(crossAx.side === 'top') {\n                        pmin = crossAx._mainLinePosition;\n                        pmax = fullLayout.height;\n                    } else {\n                        pmax = crossAx._mainLinePosition;\n                    }\n                }\n            }\n        }\n\n        pointgroups[k++] = [{\n            datum: d,\n            traceIndex: d.trace.index,\n            dp: 0,\n            pos: d.pos,\n            posref: d.posref,\n            size: d.by * (axIsX ? YFACTOR : 1) / 2,\n            pmin: pmin,\n            pmax: pmax\n        }];\n    });\n\n    pointgroups.sort(function(a, b) {\n        return (a[0].posref - b[0].posref) ||\n            // for equal positions, sort trace indices increasing or decreasing\n            // depending on whether the axis is reversed or not... so stacked\n            // traces will generally keep their order even if one trace adds\n            // nothing to the stack.\n            (axSign * (b[0].traceIndex - a[0].traceIndex));\n    });\n\n    var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n    function constrainGroup(grp) {\n        var minPt = grp[0];\n        var maxPt = grp[grp.length - 1];\n\n        // overlap with the top - positive vals are overlaps\n        topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n        // overlap with the bottom - positive vals are overlaps\n        bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n        // check for min overlap first, so that we always\n        // see the largest labels\n        // allow for .01px overlap, so we don't get an\n        // infinite loop from rounding errors\n        if(topOverlap > 0.01) {\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n            donepositioning = false;\n        }\n        if(bottomOverlap < 0.01) return;\n        if(topOverlap < -0.01) {\n            // make sure we're not pushing back and forth\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            donepositioning = false;\n        }\n        if(!donepositioning) return;\n\n        // no room to fix positioning, delete off-screen points\n\n        // first see how many points we need to delete\n        var deleteCount = 0;\n        for(i = 0; i < grp.length; i++) {\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n        }\n\n        // start by deleting points whose data is off screen\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos > minPt.pmax - 1) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n        for(i = 0; i < grp.length; i++) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos < minPt.pmin + 1) {\n                pti.del = true;\n                deleteCount--;\n\n                // shift the whole group minus into this new space\n                bottomOverlap = pti.size * 2;\n                for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            }\n        }\n        // then delete points that go off the bottom\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n    }\n\n    // loop through groups, combining them if they overlap,\n    // until nothing moves\n    while(!donepositioning && nummoves <= nLabels) {\n        // to avoid infinite loops, don't move more times\n        // than there are traces\n        nummoves++;\n\n        // assume nothing will move in this iteration,\n        // reverse this if it does\n        donepositioning = true;\n        i = 0;\n        while(i < pointgroups.length - 1) {\n            // the higher (g0) and lower (g1) point group\n            var g0 = pointgroups[i];\n            var g1 = pointgroups[i + 1];\n\n            // the lowest point in the higher group (p0)\n            // the highest point in the lower group (p1)\n            var p0 = g0[g0.length - 1];\n            var p1 = g1[0];\n            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n\n            if(topOverlap > 0.01) {\n                // push the new point(s) added to this group out of the way\n                for(j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;\n\n                // add them to the group\n                g0.push.apply(g0, g1);\n                pointgroups.splice(i + 1, 1);\n\n                // adjust for minimum average movement\n                sumdp = 0;\n                for(j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n                bottomOverlap = sumdp / g0.length;\n                for(j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n                donepositioning = false;\n            } else i++;\n        }\n\n        // check if we're going off the plot on either side and fix\n        pointgroups.forEach(constrainGroup);\n    }\n\n    // now put these offsets into hoverData\n    for(i = pointgroups.length - 1; i >= 0; i--) {\n        var grp = pointgroups[i];\n        for(j = grp.length - 1; j >= 0; j--) {\n            var pt = grp[j];\n            var hoverPt = pt.datum;\n            hoverPt.offset = pt.dp;\n            hoverPt.del = pt.del;\n        }\n    }\n}\n\nfunction getHoverLabelOffsets(hoverLabel, rotateLabels) {\n    var offsetX = 0;\n    var offsetY = hoverLabel.offset;\n\n    if(rotateLabels) {\n        offsetY *= -YSHIFTY;\n        offsetX = hoverLabel.offset * YSHIFTX;\n    }\n\n    return {\n        x: offsetX,\n        y: offsetY\n    };\n}\n\n/**\n * Calculate the shift in x for text and text2 elements\n */\nfunction getTextShiftX(hoverLabel) {\n    var alignShift = {start: 1, end: -1, middle: 0}[hoverLabel.anchor];\n    var textShiftX = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n    var text2ShiftX = textShiftX + alignShift * (hoverLabel.txwidth + HOVERTEXTPAD);\n\n    var isMiddle = hoverLabel.anchor === 'middle';\n    if(isMiddle) {\n        textShiftX -= hoverLabel.tx2width / 2;\n        text2ShiftX += hoverLabel.txwidth / 2 + HOVERTEXTPAD;\n    }\n\n    return {\n        alignShift: alignShift,\n        textShiftX: textShiftX,\n        text2ShiftX: text2ShiftX\n    };\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {\n    var pX = function(x) { return x * scaleX; };\n    var pY = function(y) { return y * scaleY; };\n\n    // finally set the text positioning relative to the data and draw the\n    // box around it\n    hoverLabels.each(function(d) {\n        var g = d3.select(this);\n        if(d.del) return g.remove();\n\n        var tx = g.select('text.nums');\n        var anchor = d.anchor;\n        var horzSign = anchor === 'end' ? -1 : 1;\n        var shiftX = getTextShiftX(d);\n        var offsets = getHoverLabelOffsets(d, rotateLabels);\n        var offsetX = offsets.x;\n        var offsetY = offsets.y;\n\n        var isMiddle = anchor === 'middle';\n\n        g.select('path')\n            .attr('d', isMiddle ?\n            // middle aligned: rect centered on data\n            ('M-' + pX(d.bx / 2 + d.tx2width / 2) + ',' + pY(offsetY - d.by / 2) +\n              'h' + pX(d.bx) + 'v' + pY(d.by) + 'h-' + pX(d.bx) + 'Z') :\n            // left or right aligned: side rect with arrow to data\n            ('M0,0L' + pX(horzSign * HOVERARROWSIZE + offsetX) + ',' + pY(HOVERARROWSIZE + offsetY) +\n                'v' + pY(d.by / 2 - HOVERARROWSIZE) +\n                'h' + pX(horzSign * d.bx) +\n                'v-' + pY(d.by) +\n                'H' + pX(horzSign * HOVERARROWSIZE + offsetX) +\n                'V' + pY(offsetY - HOVERARROWSIZE) +\n                'Z'));\n\n        var posX = offsetX + shiftX.textShiftX;\n        var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n        var textAlign = d.textAlign || 'auto';\n\n        if(textAlign !== 'auto') {\n            if(textAlign === 'left' && anchor !== 'start') {\n                tx.attr('text-anchor', 'start');\n                posX = isMiddle ?\n                    -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD :\n                    -d.bx - HOVERTEXTPAD;\n            } else if(textAlign === 'right' && anchor !== 'end') {\n                tx.attr('text-anchor', 'end');\n                posX = isMiddle ?\n                    d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD :\n                    d.bx + HOVERTEXTPAD;\n            }\n        }\n\n        tx.call(svgTextUtils.positionText, pX(posX), pY(posY));\n\n        if(d.tx2width) {\n            g.select('text.name')\n                .call(svgTextUtils.positionText,\n                    pX(shiftX.text2ShiftX + shiftX.alignShift * HOVERTEXTPAD + offsetX),\n                    pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD));\n            g.select('rect')\n                .call(Drawing.setRect,\n                    pX(shiftX.text2ShiftX + (shiftX.alignShift - 1) * d.tx2width / 2 + offsetX),\n                    pY(offsetY - d.by / 2 - 1),\n                    pX(d.tx2width), pY(d.by + 2));\n        }\n    });\n}\n\nfunction cleanPoint(d, hovermode) {\n    var index = d.index;\n    var trace = d.trace || {};\n    var cd0 = d.cd[0];\n    var cd = d.cd[index] || {};\n\n    function pass(v) {\n        return v || (isNumeric(v) && v === 0);\n    }\n\n    var getVal = Array.isArray(index) ?\n        function(calcKey, traceKey) {\n            var v = Lib.castOption(cd0, index, calcKey);\n            return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n        } :\n        function(calcKey, traceKey) {\n            return Lib.extractOption(cd, trace, calcKey, traceKey);\n        };\n\n    function fill(key, calcKey, traceKey) {\n        var val = getVal(calcKey, traceKey);\n        if(pass(val)) d[key] = val;\n    }\n\n    fill('hoverinfo', 'hi', 'hoverinfo');\n    fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n    fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n    fill('fontFamily', 'htf', 'hoverlabel.font.family');\n    fill('fontSize', 'hts', 'hoverlabel.font.size');\n    fill('fontColor', 'htc', 'hoverlabel.font.color');\n    fill('fontWeight', 'htw', 'hoverlabel.font.weight');\n    fill('fontStyle', 'hty', 'hoverlabel.font.style');\n    fill('fontVariant', 'htv', 'hoverlabel.font.variant');\n    fill('nameLength', 'hnl', 'hoverlabel.namelength');\n    fill('textAlign', 'hta', 'hoverlabel.align');\n\n    d.posref = (hovermode === 'y' || (hovermode === 'closest' && trace.orientation === 'h')) ?\n        (d.xa._offset + (d.x0 + d.x1) / 2) :\n        (d.ya._offset + (d.y0 + d.y1) / 2);\n\n    // then constrain all the positions to be on the plot\n    d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n    d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n    d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n    d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n    // and convert the x and y label values into formatted text\n    if(d.xLabelVal !== undefined) {\n        d.xLabel = ('xLabel' in d) ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);\n        d.xVal = d.xa.c2d(d.xLabelVal);\n    }\n    if(d.yLabelVal !== undefined) {\n        d.yLabel = ('yLabel' in d) ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);\n        d.yVal = d.ya.c2d(d.yLabelVal);\n    }\n\n    // Traces like heatmaps generate the zLabel in their hoverPoints function\n    if(d.zLabelVal !== undefined && d.zLabel === undefined) {\n        d.zLabel = String(d.zLabelVal);\n    }\n\n    // for box means and error bars, add the range to the label\n    if(!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n        var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n        if(d.xerrneg !== undefined) {\n            d.xLabel += ' +' + xeText + ' / -' +\n                Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n        } else d.xLabel += ' ± ' + xeText;\n\n        // small distance penalty for error bars, so that if there are\n        // traces with errors and some without, the error bar label will\n        // hoist up to the point\n        if(hovermode === 'x') d.distance += 1;\n    }\n    if(!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n        var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n        if(d.yerrneg !== undefined) {\n            d.yLabel += ' +' + yeText + ' / -' +\n                Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n        } else d.yLabel += ' ± ' + yeText;\n\n        if(hovermode === 'y') d.distance += 1;\n    }\n\n    var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n    if(infomode && infomode !== 'all') {\n        infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n        if(infomode.indexOf('x') === -1) d.xLabel = undefined;\n        if(infomode.indexOf('y') === -1) d.yLabel = undefined;\n        if(infomode.indexOf('z') === -1) d.zLabel = undefined;\n        if(infomode.indexOf('text') === -1) d.text = undefined;\n        if(infomode.indexOf('name') === -1) d.name = undefined;\n    }\n\n    return d;\n}\n\nfunction createSpikelines(gd, closestPoints, opts) {\n    var container = opts.container;\n    var fullLayout = opts.fullLayout;\n    var gs = fullLayout._size;\n    var evt = opts.event;\n    var showY = !!closestPoints.hLinePoint;\n    var showX = !!closestPoints.vLinePoint;\n\n    var xa, ya;\n\n    // Remove old spikeline items\n    container.selectAll('.spikeline').remove();\n\n    if(!(showX || showY)) return;\n\n    var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n\n    // Horizontal line (to y-axis)\n    if(showY) {\n        var hLinePoint = closestPoints.hLinePoint;\n        var hLinePointX, hLinePointY;\n\n        xa = hLinePoint && hLinePoint.xa;\n        ya = hLinePoint && hLinePoint.ya;\n        var ySnap = ya.spikesnap;\n\n        if(ySnap === 'cursor') {\n            hLinePointX = evt.pointerX;\n            hLinePointY = evt.pointerY;\n        } else {\n            hLinePointX = xa._offset + hLinePoint.x;\n            hLinePointY = ya._offset + hLinePoint.y;\n        }\n        var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : hLinePoint.color;\n        var yMode = ya.spikemode;\n        var yThickness = ya.spikethickness;\n        var yColor = ya.spikecolor || dfltHLineColor;\n        var xEdge = Axes.getPxPosition(gd, ya);\n        var xBase, xEndSpike;\n\n        if(yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n            if(yMode.indexOf('toaxis') !== -1) {\n                xBase = xEdge;\n                xEndSpike = hLinePointX;\n            }\n            if(yMode.indexOf('across') !== -1) {\n                var xAcross0 = ya._counterDomainMin;\n                var xAcross1 = ya._counterDomainMax;\n                if(ya.anchor === 'free') {\n                    xAcross0 = Math.min(xAcross0, ya.position);\n                    xAcross1 = Math.max(xAcross1, ya.position);\n                }\n                xBase = gs.l + xAcross0 * gs.w;\n                xEndSpike = gs.l + xAcross1 * gs.w;\n            }\n\n            // Foreground horizontal line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness,\n                    stroke: yColor,\n                    'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background horizontal Line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n        // Y axis marker\n        if(yMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n                    cy: hLinePointY,\n                    r: yThickness,\n                    fill: yColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n\n    if(showX) {\n        var vLinePoint = closestPoints.vLinePoint;\n        var vLinePointX, vLinePointY;\n\n        xa = vLinePoint && vLinePoint.xa;\n        ya = vLinePoint && vLinePoint.ya;\n        var xSnap = xa.spikesnap;\n\n        if(xSnap === 'cursor') {\n            vLinePointX = evt.pointerX;\n            vLinePointY = evt.pointerY;\n        } else {\n            vLinePointX = xa._offset + vLinePoint.x;\n            vLinePointY = ya._offset + vLinePoint.y;\n        }\n        var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : vLinePoint.color;\n        var xMode = xa.spikemode;\n        var xThickness = xa.spikethickness;\n        var xColor = xa.spikecolor || dfltVLineColor;\n        var yEdge = Axes.getPxPosition(gd, xa);\n        var yBase, yEndSpike;\n\n        if(xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n            if(xMode.indexOf('toaxis') !== -1) {\n                yBase = yEdge;\n                yEndSpike = vLinePointY;\n            }\n            if(xMode.indexOf('across') !== -1) {\n                var yAcross0 = xa._counterDomainMin;\n                var yAcross1 = xa._counterDomainMax;\n                if(xa.anchor === 'free') {\n                    yAcross0 = Math.min(yAcross0, xa.position);\n                    yAcross1 = Math.max(yAcross1, xa.position);\n                }\n                yBase = gs.t + (1 - yAcross1) * gs.h;\n                yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n            }\n\n            // Foreground vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness,\n                    stroke: xColor,\n                    'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n\n        // X axis marker\n        if(xMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: vLinePointX,\n                    cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n                    r: xThickness,\n                    fill: xColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n    // don't emit any events if nothing changed\n    if(!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n    for(var i = oldhoverdata.length - 1; i >= 0; i--) {\n        var oldPt = oldhoverdata[i];\n        var newPt = gd._hoverdata[i];\n\n        if(oldPt.curveNumber !== newPt.curveNumber ||\n            String(oldPt.pointNumber) !== String(newPt.pointNumber) ||\n            String(oldPt.pointNumbers) !== String(newPt.pointNumbers)\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n    // don't relayout the plot because of new spikelines if spikelines points didn't change\n    if(!oldspikepoints) return true;\n    if(oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint ||\n        oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint\n    ) return true;\n    return false;\n}\n\nfunction plainText(s, len) {\n    return svgTextUtils.plainText(s || '', {\n        len: len,\n        allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em', 's', 'u']\n    });\n}\n\nfunction orderRangePoints(hoverData, hovermode) {\n    var axLetter = hovermode.charAt(0);\n\n    var first = [];\n    var second = [];\n    var last = [];\n\n    for(var i = 0; i < hoverData.length; i++) {\n        var d = hoverData[i];\n\n        if(\n            Registry.traceIs(d.trace, 'bar-like') ||\n            Registry.traceIs(d.trace, 'box-violin')\n        ) {\n            last.push(d);\n        } else if(d.trace[axLetter + 'period']) {\n            second.push(d);\n        } else {\n            first.push(d);\n        }\n    }\n\n    return first.concat(second).concat(last);\n}\n\nfunction getCoord(axLetter, winningPoint, fullLayout) {\n    var ax = winningPoint[axLetter + 'a'];\n    var val = winningPoint[axLetter + 'Val'];\n\n    var cd0 = winningPoint.cd[0];\n\n    if(ax.type === 'category' || ax.type === 'multicategory') val = ax._categoriesMap[val];\n    else if(ax.type === 'date') {\n        var periodalignment = winningPoint.trace[axLetter + 'periodalignment'];\n        if(periodalignment) {\n            var d = winningPoint.cd[winningPoint.index];\n\n            var start = d[axLetter + 'Start'];\n            if(start === undefined) start = d[axLetter];\n\n            var end = d[axLetter + 'End'];\n            if(end === undefined) end = d[axLetter];\n\n            var diff = end - start;\n\n            if(periodalignment === 'end') {\n                val += diff;\n            } else if(periodalignment === 'middle') {\n                val += diff / 2;\n            }\n        }\n\n        val = ax.d2c(val);\n    }\n\n    if(cd0 && cd0.t && cd0.t.posLetter === ax._id) {\n        if(\n            fullLayout.boxmode === 'group' ||\n            fullLayout.violinmode === 'group'\n        ) {\n            val += cd0.t.dPos;\n        }\n    }\n\n    return val;\n}\n\n// Top/left hover offsets relative to graph div. As long as hover content is\n// a sibling of the graph div, it will be positioned correctly relative to\n// the offset parent, whatever that may be.\nfunction getTopOffset(gd) { return gd.offsetTop + gd.clientTop; }\nfunction getLeftOffset(gd) { return gd.offsetLeft + gd.clientLeft; }\n\nfunction getBoundingClientRect(gd, node) {\n    var fullLayout = gd._fullLayout;\n\n    var rect = node.getBoundingClientRect();\n\n    var x0 = rect.left;\n    var y0 = rect.top;\n    var x1 = x0 + rect.width;\n    var y1 = y0 + rect.height;\n\n    var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);\n\n    var Ax = A[0];\n    var Ay = A[1];\n    var Bx = B[0];\n    var By = B[1];\n\n    return {\n        x: Ax,\n        y: Ay,\n        width: Bx - Ax,\n        height: By - Ay,\n        top: Math.min(Ay, By),\n        left: Math.min(Ax, Bx),\n        right: Math.max(Ax, Bx),\n        bottom: Math.max(Ay, By),\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}