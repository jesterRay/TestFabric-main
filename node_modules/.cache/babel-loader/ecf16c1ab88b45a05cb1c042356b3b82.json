{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\nvar Drawing = require('../../components/drawing');\nvar subTypes = require('./subtypes');\nvar linePoints = require('./line_points');\nvar linkTraces = require('./link_traces');\nvar polygonTester = require('../../lib/polygon').tester;\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n  var join, onComplete;\n\n  // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n  // Link traces so the z-order of fill layers is correct\n  var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n  join = scatterLayer.selectAll('g.trace').data(cdscatterSorted, function (d) {\n    return d[0].trace.uid;\n  });\n\n  // Append new traces:\n  join.enter().append('g').attr('class', function (d) {\n    return 'trace scatter trace' + d[0].trace.uid;\n  }).style('stroke-miterlimit', 2);\n  join.order();\n  createFills(gd, join, plotinfo);\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      scatterLayer.selectAll('g.trace').each(function (d, i) {\n        plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (d, i) {\n      plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n    });\n  }\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n\n  // remove paths that didn't get used\n  scatterLayer.selectAll('path:not([d])').remove();\n};\nfunction createFills(gd, traceJoin, plotinfo) {\n  traceJoin.each(function (d) {\n    var fills = ensureSingle(d3.select(this), 'g', 'fills');\n    Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n    var trace = d[0].trace;\n    var fillData = [];\n    if (trace._ownfill) fillData.push('_ownFill');\n    if (trace._nexttrace) fillData.push('_nextFill');\n    var fillJoin = fills.selectAll('g').data(fillData, identity);\n    fillJoin.enter().append('g');\n    fillJoin.exit().each(function (d) {\n      trace[d] = null;\n    }).remove();\n    fillJoin.order().each(function (d) {\n      // make a path element inside the fill group, just so\n      // we can give it its own data later on and the group can\n      // keep its simple '_*Fill' data\n      trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n    });\n  });\n}\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n  var isStatic = gd._context.staticPlot;\n  var i;\n\n  // Since this has been reorganized and we're executing this on individual traces,\n  // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n  // since it does an internal n^2 loop over comparisons with other traces:\n  selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n  function transition(selection) {\n    return hasTransition ? selection.transition() : selection;\n  }\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var trace = cdscatter[0].trace;\n  var line = trace.line;\n  var tr = d3.select(element);\n  var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n  var lines = ensureSingle(tr, 'g', 'lines');\n  var points = ensureSingle(tr, 'g', 'points');\n  var text = ensureSingle(tr, 'g', 'text');\n\n  // error bars are at the bottom\n  Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n  if (trace.visible !== true) return;\n  transition(tr).style('opacity', trace.opacity);\n\n  // BUILD LINES AND FILLS\n  var ownFillEl3, tonext;\n  var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n  if (ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';\n  var fillAxisIndex, fillAxisZero;\n  if (ownFillDir === 'y') {\n    fillAxisIndex = 1;\n    fillAxisZero = ya.c2p(0, true);\n  } else if (ownFillDir === 'x') {\n    fillAxisIndex = 0;\n    fillAxisZero = xa.c2p(0, true);\n  }\n\n  // store node for tweaking by selectPoints\n  cdscatter[0][plotinfo.isRangePlot ? 'nodeRangePlot3' : 'node3'] = tr;\n  var prevRevpath = '';\n  var prevPolygons = [];\n  var prevtrace = trace._prevtrace;\n  var prevFillsegments = null;\n  var prevFillElement = null;\n  if (prevtrace) {\n    prevRevpath = prevtrace._prevRevpath || '';\n    tonext = prevtrace._nextFill;\n    prevPolygons = prevtrace._ownPolygons;\n    prevFillsegments = prevtrace._fillsegments;\n    prevFillElement = prevtrace._fillElement;\n  }\n  var thispath;\n  var thisrevpath;\n  // fullpath is all paths for this curve, joined together straight\n  // across gaps, for filling\n  var fullpath = '';\n  // revpath is fullpath reversed, for fill-to-next\n  var revpath = '';\n  // functions for converting a point array to a path\n  var pathfn, revpathbase, revpathfn;\n  // variables used before and after the data join\n  var pt0, lastSegment, pt1;\n\n  // thisPolygons always contains only the polygons of this trace only\n  // whereas trace._polygons may be extended to include those of the previous\n  // trace as well for exclusion during hover detection\n  var thisPolygons = [];\n  trace._polygons = [];\n  var fillsegments = [];\n\n  // initialize line join data / method\n  var segments = [];\n  var makeUpdate = Lib.noop;\n  ownFillEl3 = trace._ownFill;\n  if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n    if (tonext) {\n      // This tells .style which trace to use for fill information:\n      tonext.datum(cdscatter);\n    }\n    if (['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n      pathfn = Drawing.steps(line.shape);\n      revpathbase = Drawing.steps(line.shape.split('').reverse().join(''));\n    } else if (line.shape === 'spline') {\n      pathfn = revpathbase = function (pts) {\n        var pLast = pts[pts.length - 1];\n        if (pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n          // identical start and end points: treat it as a\n          // closed curve so we don't get a kink\n          return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n        } else {\n          return Drawing.smoothopen(pts, line.smoothing);\n        }\n      };\n    } else {\n      pathfn = revpathbase = function (pts) {\n        return 'M' + pts.join('L');\n      };\n    }\n    revpathfn = function (pts) {\n      // note: this is destructive (reverses pts in place) so can't use pts after this\n      return revpathbase(pts.reverse());\n    };\n    segments = linePoints(cdscatter, {\n      xaxis: xa,\n      yaxis: ya,\n      trace: trace,\n      connectGaps: trace.connectgaps,\n      baseTolerance: Math.max(line.width || 1, 3) / 4,\n      shape: line.shape,\n      backoff: line.backoff,\n      simplify: line.simplify,\n      fill: trace.fill\n    });\n\n    // since we already have the pixel segments here, use them to make\n    // polygons for hover on fill; we first merge segments where the fill\n    // is connected into \"fillsegments\"; the actual polygon construction\n    // is deferred to later to distinguish between self and tonext/tozero fills.\n    // TODO: can we skip this if hoveron!=fills? That would mean we\n    // need to redraw when you change hoveron...\n    fillsegments = new Array(segments.length);\n    var fillsegmentCount = 0;\n    for (i = 0; i < segments.length; i++) {\n      var curpoints;\n      var pts = segments[i];\n      if (!curpoints || !ownFillDir) {\n        curpoints = pts.slice();\n        fillsegments[fillsegmentCount] = curpoints;\n        fillsegmentCount++;\n      } else {\n        curpoints.push.apply(curpoints, pts);\n      }\n    }\n    trace._fillElement = null;\n    trace._fillExclusionElement = prevFillElement;\n    trace._fillsegments = fillsegments.slice(0, fillsegmentCount);\n    fillsegments = trace._fillsegments;\n    if (segments.length) {\n      pt0 = segments[0][0].slice();\n      lastSegment = segments[segments.length - 1];\n      pt1 = lastSegment[lastSegment.length - 1].slice();\n    }\n    makeUpdate = function (isEnter) {\n      return function (pts) {\n        thispath = pathfn(pts);\n        thisrevpath = revpathfn(pts); // side-effect: reverses input\n        // calculate SVG path over all segments for fills\n        if (!fullpath) {\n          fullpath = thispath;\n          revpath = thisrevpath;\n        } else if (ownFillDir) {\n          // for fills with fill direction: ignore gaps\n          fullpath += 'L' + thispath.substr(1);\n          revpath = thisrevpath + ('L' + revpath.substr(1));\n        } else {\n          fullpath += 'Z' + thispath;\n          revpath = thisrevpath + 'Z' + revpath;\n        }\n\n        // actual lines get drawn here, with gaps between segments if requested\n        if (subTypes.hasLines(trace)) {\n          var el = d3.select(this);\n\n          // This makes the coloring work correctly:\n          el.datum(cdscatter);\n          if (isEnter) {\n            transition(el.style('opacity', 0).attr('d', thispath).call(Drawing.lineGroupStyle)).style('opacity', 1);\n          } else {\n            var sel = transition(el);\n            sel.attr('d', thispath);\n            Drawing.singleLineStyle(cdscatter, sel);\n          }\n        }\n      };\n    };\n  }\n  var lineJoin = lines.selectAll('.js-line').data(segments);\n  transition(lineJoin.exit()).style('opacity', 0).remove();\n  lineJoin.each(makeUpdate(false));\n  lineJoin.enter().append('path').classed('js-line', true).style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').call(Drawing.lineGroupStyle).each(makeUpdate(true));\n  Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n  function clearFill(selection) {\n    transition(selection).attr('d', 'M0,0Z');\n  }\n\n  // helper functions to create polygons for hoveron fill detection\n  var makeSelfPolygons = function () {\n    var polygons = new Array(fillsegments.length);\n    for (i = 0; i < fillsegments.length; i++) {\n      polygons[i] = polygonTester(fillsegments[i]);\n    }\n    return polygons;\n  };\n  var makePolygonsToPrevious = function (prevFillsegments) {\n    var polygons, i;\n    if (!prevFillsegments || prevFillsegments.length === 0) {\n      // if there are no fill segments of a previous trace, stretch the\n      // polygon to the relevant axis\n      polygons = new Array(fillsegments.length);\n      for (i = 0; i < fillsegments.length; i++) {\n        var pt0 = fillsegments[i][0].slice();\n        var pt1 = fillsegments[i][fillsegments[i].length - 1].slice();\n        pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;\n        var zeropoints = [pt1, pt0];\n        var polypoints = zeropoints.concat(fillsegments[i]);\n        polygons[i] = polygonTester(polypoints);\n      }\n    } else {\n      // if there are more than one previous fill segment, the\n      // way that fills work is to \"self\" fill all but the last segments\n      // of the previous and then fill from the new trace to the last\n      // segment of the previous.\n      polygons = new Array(prevFillsegments.length - 1 + fillsegments.length);\n      for (i = 0; i < prevFillsegments.length - 1; i++) {\n        polygons[i] = polygonTester(prevFillsegments[i]);\n      }\n      var reversedPrevFillsegment = prevFillsegments[prevFillsegments.length - 1].slice();\n      reversedPrevFillsegment.reverse();\n      for (i = 0; i < fillsegments.length; i++) {\n        polygons[prevFillsegments.length - 1 + i] = polygonTester(fillsegments[i].concat(reversedPrevFillsegment));\n      }\n    }\n    return polygons;\n  };\n\n  // draw fills and create hover detection polygons\n  if (segments.length) {\n    if (ownFillEl3) {\n      ownFillEl3.datum(cdscatter);\n      if (pt0 && pt1) {\n        // TODO(2023-12-10): this is always true if segments is not empty (?)\n        if (ownFillDir) {\n          pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;\n\n          // fill to zero: full trace path, plus extension of\n          // the endpoints to the appropriate axis\n          // For the sake of animations, wrap the points around so that\n          // the points on the axes are the first two points. Otherwise\n          // animations get a little crazy if the number of points changes.\n          transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1)).call(Drawing.singleFillStyle, gd);\n\n          // create hover polygons that extend to the axis as well.\n          thisPolygons = makePolygonsToPrevious(null); // polygon to axis\n        } else {\n          // fill to self: just join the path to itself\n          transition(ownFillEl3).attr('d', fullpath + 'Z').call(Drawing.singleFillStyle, gd);\n\n          // and simply emit hover polygons for each segment\n          thisPolygons = makeSelfPolygons();\n        }\n      }\n      trace._polygons = thisPolygons;\n      trace._fillElement = ownFillEl3;\n    } else if (tonext) {\n      if (trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n        // fill to next: full trace path, plus the previous path reversed\n        if (trace.fill === 'tonext') {\n          // tonext: for use by concentric shapes, like manually constructed\n          // contours, we just add the two paths closed on themselves.\n          // This makes strange results if one path is *not* entirely\n          // inside the other, but then that is a strange usage.\n          transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z').call(Drawing.singleFillStyle, gd);\n\n          // and simply emit hover polygons for each segment\n          thisPolygons = makeSelfPolygons();\n\n          // we add the polygons of the previous trace which causes hover\n          // detection to ignore points contained in them.\n          trace._polygons = thisPolygons.concat(prevPolygons); // this does not modify thisPolygons, on purpose\n        } else {\n          // tonextx/y: for now just connect endpoints with lines. This is\n          // the correct behavior if the endpoints are at the same value of\n          // y/x, but if they *aren't*, we should ideally do more complicated\n          // things depending on whether the new endpoint projects onto the\n          // existing curve or off the end of it\n          transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z').call(Drawing.singleFillStyle, gd);\n\n          // create hover polygons that extend to the previous trace.\n          thisPolygons = makePolygonsToPrevious(prevFillsegments);\n\n          // in this case our polygons do not cover that of previous traces,\n          // so must not include previous trace polygons for hover detection.\n          trace._polygons = thisPolygons;\n        }\n        trace._fillElement = tonext;\n      } else {\n        clearFill(tonext);\n      }\n    }\n    trace._prevRevpath = revpath;\n  } else {\n    if (ownFillEl3) clearFill(ownFillEl3);else if (tonext) clearFill(tonext);\n    trace._prevRevpath = null;\n  }\n  trace._ownPolygons = thisPolygons;\n  function visFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap && v.vis;\n    });\n  }\n  function visFilterWithGaps(d) {\n    return d.filter(function (v) {\n      return v.vis;\n    });\n  }\n  function gapFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap;\n    });\n  }\n  function keyFunc(d) {\n    return d.id;\n  }\n\n  // Returns a function if the trace is keyed, otherwise returns undefined\n  function getKeyFunc(trace) {\n    if (trace.ids) {\n      return keyFunc;\n    }\n  }\n  function hideFilter() {\n    return false;\n  }\n  function makePoints(points, text, cdscatter) {\n    var join, selection, hasNode;\n    var trace = cdscatter[0].trace;\n    var showMarkers = subTypes.hasMarkers(trace);\n    var showText = subTypes.hasText(trace);\n    var keyFunc = getKeyFunc(trace);\n    var markerFilter = hideFilter;\n    var textFilter = hideFilter;\n    if (showMarkers || showText) {\n      var showFilter = identity;\n      // if we're stacking, \"infer zero\" gap mode gets markers in the\n      // gap points - because we've inferred a zero there - but other\n      // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n      // we don't draw generated markers\n      var stackGroup = trace.stackgroup;\n      var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero';\n      if (trace.marker.maxdisplayed || trace._needsCull) {\n        showFilter = isInferZero ? visFilterWithGaps : visFilter;\n      } else if (stackGroup && !isInferZero) {\n        showFilter = gapFilter;\n      }\n      if (showMarkers) markerFilter = showFilter;\n      if (showText) textFilter = showFilter;\n    }\n\n    // marker points\n\n    selection = points.selectAll('path.point');\n    join = selection.data(markerFilter, keyFunc);\n    var enter = join.enter().append('path').classed('point', true);\n    if (hasTransition) {\n      enter.call(Drawing.pointStyle, trace, gd).call(Drawing.translatePoints, xa, ya).style('opacity', 0).transition().style('opacity', 1);\n    }\n    join.order();\n    var styleFns;\n    if (showMarkers) {\n      styleFns = Drawing.makePointStyleFns(trace);\n    }\n    join.each(function (d) {\n      var el = d3.select(this);\n      var sel = transition(el);\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n      if (hasNode) {\n        Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n        if (trace.customdata) {\n          el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n        }\n      } else {\n        sel.remove();\n      }\n    });\n    if (hasTransition) {\n      join.exit().transition().style('opacity', 0).remove();\n    } else {\n      join.exit().remove();\n    }\n\n    // text points\n    selection = text.selectAll('g');\n    join = selection.data(textFilter, keyFunc);\n\n    // each text needs to go in its own 'g' in case\n    // it gets converted to mathjax\n    join.enter().append('g').classed('textpoint', true).append('text');\n    join.order();\n    join.each(function (d) {\n      var g = d3.select(this);\n      var sel = transition(g.select('text'));\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n      if (hasNode) {\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n      } else {\n        g.remove();\n      }\n    });\n    join.selectAll('text').call(Drawing.textPointStyle, trace, gd).each(function (d) {\n      // This just *has* to be totally custom because of SVG text positioning :(\n      // It's obviously copied from translatePoint; we just can't use that\n      var x = xa.c2p(d.x);\n      var y = ya.c2p(d.y);\n      d3.select(this).selectAll('tspan.line').each(function () {\n        transition(d3.select(this)).attr({\n          x: x,\n          y: y\n        });\n      });\n    });\n    join.exit().remove();\n  }\n  points.datum(cdscatter);\n  text.datum(cdscatter);\n  makePoints(points, text, cdscatter);\n\n  // lastly, clip points groups of `cliponaxis !== false` traces\n  // on `plotinfo._hasClipOnAxisFalse === true` subplots\n  var hasClipOnAxisFalse = trace.cliponaxis === false;\n  var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n  Drawing.setClipUrl(points, clipUrl, gd);\n  Drawing.setClipUrl(text, clipUrl, gd);\n}\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n  var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n  var trace = cdscatter[0].trace;\n  if (!subTypes.hasMarkers(trace)) return;\n  // if marker.maxdisplayed is used, select a maximum of\n  // mnum markers to show, from the set that are in the viewport\n  var mnum = trace.marker.maxdisplayed;\n\n  // TODO: remove some as we get away from the viewport?\n  if (mnum === 0) return;\n  var cd = cdscatter.filter(function (v) {\n    return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n  });\n  var inc = Math.ceil(cd.length / mnum);\n  var tnum = 0;\n  cdscatterAll.forEach(function (cdj, j) {\n    var tracei = cdj[0].trace;\n    if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {\n      tnum++;\n    }\n  });\n\n  // if multiple traces use maxdisplayed, stagger which markers we\n  // display this formula offsets successive traces by 1/3 of the\n  // increment, adding an extra small amount after each triplet so\n  // it's not quite periodic\n  var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);\n\n  // for error bars: save in cd which markers to show\n  // so we don't have to repeat this\n  cdscatter.forEach(function (v) {\n    delete v.vis;\n  });\n  cd.forEach(function (v, i) {\n    if (Math.round((i + i0) % inc) === 0) v.vis = true;\n  });\n}","map":{"version":3,"names":["d3","require","Registry","Lib","ensureSingle","identity","Drawing","subTypes","linePoints","linkTraces","polygonTester","tester","module","exports","plot","gd","plotinfo","cdscatter","scatterLayer","transitionOpts","makeOnCompleteCallback","join","onComplete","isFullReplot","hasTransition","duration","cdscatterSorted","selectAll","data","d","trace","uid","enter","append","attr","style","order","createFills","transition","ease","easing","each","i","plotOne","exit","remove","traceJoin","fills","select","setClipUrl","layerClipId","fillData","_ownfill","push","_nexttrace","fillJoin","idx","cdscatterAll","element","isStatic","_context","staticPlot","selectMarkers","selection","xa","xaxis","ya","yaxis","line","tr","errorBarGroup","lines","points","text","getComponentMethod","visible","opacity","ownFillEl3","tonext","ownFillDir","fill","charAt","length","fillAxisIndex","fillAxisZero","c2p","isRangePlot","prevRevpath","prevPolygons","prevtrace","_prevtrace","prevFillsegments","prevFillElement","_prevRevpath","_nextFill","_ownPolygons","_fillsegments","_fillElement","thispath","thisrevpath","fullpath","revpath","pathfn","revpathbase","revpathfn","pt0","lastSegment","pt1","thisPolygons","_polygons","fillsegments","segments","makeUpdate","noop","_ownFill","hasLines","datum","indexOf","shape","steps","split","reverse","pts","pLast","smoothclosed","slice","smoothing","smoothopen","connectGaps","connectgaps","baseTolerance","Math","max","width","backoff","simplify","Array","fillsegmentCount","curpoints","apply","_fillExclusionElement","isEnter","substr","el","call","lineGroupStyle","sel","singleLineStyle","lineJoin","classed","clearFill","makeSelfPolygons","polygons","makePolygonsToPrevious","zeropoints","polypoints","concat","reversedPrevFillsegment","singleFillStyle","visFilter","filter","v","gap","vis","visFilterWithGaps","gapFilter","keyFunc","id","getKeyFunc","ids","hideFilter","makePoints","hasNode","showMarkers","hasMarkers","showText","hasText","markerFilter","textFilter","showFilter","stackGroup","stackgroup","isInferZero","_fullLayout","_scatterStackOpts","_id","stackgaps","marker","maxdisplayed","_needsCull","pointStyle","translatePoints","styleFns","makePointStyleFns","translatePoint","singlePointStyle","hideOutsideRangePoint","xcalendar","ycalendar","customdata","undefined","g","textPointStyle","x","y","hasClipOnAxisFalse","cliponaxis","clipUrl","xr","extent","simpleMap","range","r2c","yr","mnum","cd","inc","ceil","tnum","forEach","cdj","j","tracei","i0","round","floor"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scatter/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\nvar Drawing = require('../../components/drawing');\n\nvar subTypes = require('./subtypes');\nvar linePoints = require('./line_points');\nvar linkTraces = require('./link_traces');\nvar polygonTester = require('../../lib/polygon').tester;\n\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n    var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n    // Link traces so the z-order of fill layers is correct\n    var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n\n    join = scatterLayer.selectAll('g.trace')\n        .data(cdscatterSorted, function(d) { return d[0].trace.uid; });\n\n    // Append new traces:\n    join.enter().append('g')\n        .attr('class', function(d) {\n            return 'trace scatter trace' + d[0].trace.uid;\n        })\n        .style('stroke-miterlimit', 2);\n    join.order();\n\n    createFills(gd, join, plotinfo);\n\n    if(hasTransition) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() {\n                onComplete && onComplete();\n            })\n            .each('interrupt', function() {\n                onComplete && onComplete();\n            });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            scatterLayer.selectAll('g.trace').each(function(d, i) {\n                plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(d, i) {\n            plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n        });\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n\n    // remove paths that didn't get used\n    scatterLayer.selectAll('path:not([d])').remove();\n};\n\nfunction createFills(gd, traceJoin, plotinfo) {\n    traceJoin.each(function(d) {\n        var fills = ensureSingle(d3.select(this), 'g', 'fills');\n        Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n\n        var trace = d[0].trace;\n\n        var fillData = [];\n        if(trace._ownfill) fillData.push('_ownFill');\n        if(trace._nexttrace) fillData.push('_nextFill');\n\n        var fillJoin = fills.selectAll('g').data(fillData, identity);\n\n        fillJoin.enter().append('g');\n\n        fillJoin.exit()\n            .each(function(d) { trace[d] = null; })\n            .remove();\n\n        fillJoin.order().each(function(d) {\n            // make a path element inside the fill group, just so\n            // we can give it its own data later on and the group can\n            // keep its simple '_*Fill' data\n            trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n        });\n    });\n}\n\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n    var isStatic = gd._context.staticPlot;\n    var i;\n\n    // Since this has been reorganized and we're executing this on individual traces,\n    // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n    // since it does an internal n^2 loop over comparisons with other traces:\n    selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n\n    var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n    function transition(selection) {\n        return hasTransition ? selection.transition() : selection;\n    }\n\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var trace = cdscatter[0].trace;\n    var line = trace.line;\n    var tr = d3.select(element);\n\n    var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n    var lines = ensureSingle(tr, 'g', 'lines');\n    var points = ensureSingle(tr, 'g', 'points');\n    var text = ensureSingle(tr, 'g', 'text');\n\n    // error bars are at the bottom\n    Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n\n    if(trace.visible !== true) return;\n\n    transition(tr).style('opacity', trace.opacity);\n\n    // BUILD LINES AND FILLS\n    var ownFillEl3, tonext;\n    var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n    if(ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';\n\n    var fillAxisIndex, fillAxisZero;\n    if(ownFillDir === 'y') {\n        fillAxisIndex = 1;\n        fillAxisZero = ya.c2p(0, true);\n    } else if(ownFillDir === 'x') {\n        fillAxisIndex = 0;\n        fillAxisZero = xa.c2p(0, true);\n    }\n\n    // store node for tweaking by selectPoints\n    cdscatter[0][plotinfo.isRangePlot ? 'nodeRangePlot3' : 'node3'] = tr;\n\n    var prevRevpath = '';\n    var prevPolygons = [];\n    var prevtrace = trace._prevtrace;\n    var prevFillsegments = null;\n    var prevFillElement = null;\n\n    if(prevtrace) {\n        prevRevpath = prevtrace._prevRevpath || '';\n        tonext = prevtrace._nextFill;\n        prevPolygons = prevtrace._ownPolygons;\n        prevFillsegments = prevtrace._fillsegments;\n        prevFillElement = prevtrace._fillElement;\n    }\n\n    var thispath;\n    var thisrevpath;\n    // fullpath is all paths for this curve, joined together straight\n    // across gaps, for filling\n    var fullpath = '';\n    // revpath is fullpath reversed, for fill-to-next\n    var revpath = '';\n    // functions for converting a point array to a path\n    var pathfn, revpathbase, revpathfn;\n    // variables used before and after the data join\n    var pt0, lastSegment, pt1;\n\n    // thisPolygons always contains only the polygons of this trace only\n    // whereas trace._polygons may be extended to include those of the previous\n    // trace as well for exclusion during hover detection\n    var thisPolygons = [];\n    trace._polygons = [];\n\n    var fillsegments = [];\n\n    // initialize line join data / method\n    var segments = [];\n    var makeUpdate = Lib.noop;\n\n    ownFillEl3 = trace._ownFill;\n\n    if(subTypes.hasLines(trace) || trace.fill !== 'none') {\n        if(tonext) {\n            // This tells .style which trace to use for fill information:\n            tonext.datum(cdscatter);\n        }\n\n        if(['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n            pathfn = Drawing.steps(line.shape);\n            revpathbase = Drawing.steps(\n                line.shape.split('').reverse().join('')\n            );\n        } else if(line.shape === 'spline') {\n            pathfn = revpathbase = function(pts) {\n                var pLast = pts[pts.length - 1];\n                if(pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n                    // identical start and end points: treat it as a\n                    // closed curve so we don't get a kink\n                    return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n                } else {\n                    return Drawing.smoothopen(pts, line.smoothing);\n                }\n            };\n        } else {\n            pathfn = revpathbase = function(pts) {\n                return 'M' + pts.join('L');\n            };\n        }\n\n        revpathfn = function(pts) {\n            // note: this is destructive (reverses pts in place) so can't use pts after this\n            return revpathbase(pts.reverse());\n        };\n\n        segments = linePoints(cdscatter, {\n            xaxis: xa,\n            yaxis: ya,\n            trace: trace,\n            connectGaps: trace.connectgaps,\n            baseTolerance: Math.max(line.width || 1, 3) / 4,\n            shape: line.shape,\n            backoff: line.backoff,\n            simplify: line.simplify,\n            fill: trace.fill\n        });\n\n        // since we already have the pixel segments here, use them to make\n        // polygons for hover on fill; we first merge segments where the fill\n        // is connected into \"fillsegments\"; the actual polygon construction\n        // is deferred to later to distinguish between self and tonext/tozero fills.\n        // TODO: can we skip this if hoveron!=fills? That would mean we\n        // need to redraw when you change hoveron...\n        fillsegments = new Array(segments.length);\n        var fillsegmentCount = 0;\n        for(i = 0; i < segments.length; i++) {\n            var curpoints;\n            var pts = segments[i];\n            if(!curpoints || !ownFillDir) {\n                curpoints = pts.slice();\n                fillsegments[fillsegmentCount] = curpoints;\n                fillsegmentCount++;\n            } else {\n                curpoints.push.apply(curpoints, pts);\n            }\n        }\n\n        trace._fillElement = null;\n        trace._fillExclusionElement = prevFillElement;\n\n        trace._fillsegments = fillsegments.slice(0, fillsegmentCount);\n        fillsegments = trace._fillsegments;\n\n        if(segments.length) {\n            pt0 = segments[0][0].slice();\n            lastSegment = segments[segments.length - 1];\n            pt1 = lastSegment[lastSegment.length - 1].slice();\n        }\n\n        makeUpdate = function(isEnter) {\n            return function(pts) {\n                thispath = pathfn(pts);\n                thisrevpath = revpathfn(pts); // side-effect: reverses input\n                // calculate SVG path over all segments for fills\n                if(!fullpath) {\n                    fullpath = thispath;\n                    revpath = thisrevpath;\n                } else if(ownFillDir) {\n                    // for fills with fill direction: ignore gaps\n                    fullpath += 'L' + thispath.substr(1);\n                    revpath = thisrevpath + ('L' + revpath.substr(1));\n                } else {\n                    fullpath += 'Z' + thispath;\n                    revpath = thisrevpath + 'Z' + revpath;\n                }\n\n                // actual lines get drawn here, with gaps between segments if requested\n                if(subTypes.hasLines(trace)) {\n                    var el = d3.select(this);\n\n                    // This makes the coloring work correctly:\n                    el.datum(cdscatter);\n\n                    if(isEnter) {\n                        transition(el.style('opacity', 0)\n                            .attr('d', thispath)\n                            .call(Drawing.lineGroupStyle))\n                                .style('opacity', 1);\n                    } else {\n                        var sel = transition(el);\n                        sel.attr('d', thispath);\n                        Drawing.singleLineStyle(cdscatter, sel);\n                    }\n                }\n            };\n        };\n    }\n\n    var lineJoin = lines.selectAll('.js-line').data(segments);\n\n    transition(lineJoin.exit())\n        .style('opacity', 0)\n        .remove();\n\n    lineJoin.each(makeUpdate(false));\n\n    lineJoin.enter().append('path')\n        .classed('js-line', true)\n        .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke')\n        .call(Drawing.lineGroupStyle)\n        .each(makeUpdate(true));\n\n    Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n\n    function clearFill(selection) {\n        transition(selection).attr('d', 'M0,0Z');\n    }\n\n    // helper functions to create polygons for hoveron fill detection\n    var makeSelfPolygons = function() {\n        var polygons = new Array(fillsegments.length);\n        for(i = 0; i < fillsegments.length; i++) {\n            polygons[i] = polygonTester(fillsegments[i]);\n        }\n        return polygons;\n    };\n\n    var makePolygonsToPrevious = function(prevFillsegments) {\n        var polygons, i;\n        if(!prevFillsegments || prevFillsegments.length === 0) {\n            // if there are no fill segments of a previous trace, stretch the\n            // polygon to the relevant axis\n            polygons = new Array(fillsegments.length);\n            for(i = 0; i < fillsegments.length; i++) {\n                var pt0 = fillsegments[i][0].slice();\n                var pt1 = fillsegments[i][fillsegments[i].length - 1].slice();\n\n                pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;\n\n                var zeropoints = [pt1, pt0];\n                var polypoints = zeropoints.concat(fillsegments[i]);\n                polygons[i] = polygonTester(polypoints);\n            }\n        } else {\n            // if there are more than one previous fill segment, the\n            // way that fills work is to \"self\" fill all but the last segments\n            // of the previous and then fill from the new trace to the last\n            // segment of the previous.\n            polygons = new Array(prevFillsegments.length - 1 + fillsegments.length);\n            for(i = 0; i < prevFillsegments.length - 1; i++) {\n                polygons[i] = polygonTester(prevFillsegments[i]);\n            }\n\n            var reversedPrevFillsegment = prevFillsegments[prevFillsegments.length - 1].slice();\n            reversedPrevFillsegment.reverse();\n\n            for(i = 0; i < fillsegments.length; i++) {\n                polygons[prevFillsegments.length - 1 + i] = polygonTester(fillsegments[i].concat(reversedPrevFillsegment));\n            }\n        }\n        return polygons;\n    };\n\n    // draw fills and create hover detection polygons\n    if(segments.length) {\n        if(ownFillEl3) {\n            ownFillEl3.datum(cdscatter);\n            if(pt0 && pt1) { // TODO(2023-12-10): this is always true if segments is not empty (?)\n                if(ownFillDir) {\n                    pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;\n\n                    // fill to zero: full trace path, plus extension of\n                    // the endpoints to the appropriate axis\n                    // For the sake of animations, wrap the points around so that\n                    // the points on the axes are the first two points. Otherwise\n                    // animations get a little crazy if the number of points changes.\n                    transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1))\n                        .call(Drawing.singleFillStyle, gd);\n\n                    // create hover polygons that extend to the axis as well.\n                    thisPolygons = makePolygonsToPrevious(null); // polygon to axis\n                } else {\n                    // fill to self: just join the path to itself\n                    transition(ownFillEl3).attr('d', fullpath + 'Z')\n                        .call(Drawing.singleFillStyle, gd);\n\n                    // and simply emit hover polygons for each segment\n                    thisPolygons = makeSelfPolygons();\n                }\n            }\n            trace._polygons = thisPolygons;\n            trace._fillElement = ownFillEl3;\n        } else if(tonext) {\n            if(trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n                // fill to next: full trace path, plus the previous path reversed\n                if(trace.fill === 'tonext') {\n                    // tonext: for use by concentric shapes, like manually constructed\n                    // contours, we just add the two paths closed on themselves.\n                    // This makes strange results if one path is *not* entirely\n                    // inside the other, but then that is a strange usage.\n                    transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z')\n                        .call(Drawing.singleFillStyle, gd);\n\n                                            // and simply emit hover polygons for each segment\n                    thisPolygons = makeSelfPolygons();\n\n                    // we add the polygons of the previous trace which causes hover\n                    // detection to ignore points contained in them.\n                    trace._polygons = thisPolygons.concat(prevPolygons); // this does not modify thisPolygons, on purpose\n                } else {\n                    // tonextx/y: for now just connect endpoints with lines. This is\n                    // the correct behavior if the endpoints are at the same value of\n                    // y/x, but if they *aren't*, we should ideally do more complicated\n                    // things depending on whether the new endpoint projects onto the\n                    // existing curve or off the end of it\n                    transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z')\n                        .call(Drawing.singleFillStyle, gd);\n\n                    // create hover polygons that extend to the previous trace.\n                    thisPolygons = makePolygonsToPrevious(prevFillsegments);\n\n                    // in this case our polygons do not cover that of previous traces,\n                    // so must not include previous trace polygons for hover detection.\n                    trace._polygons = thisPolygons;\n                }\n                trace._fillElement = tonext;\n            } else {\n                clearFill(tonext);\n            }\n        }\n        trace._prevRevpath = revpath;\n    } else {\n        if(ownFillEl3) clearFill(ownFillEl3);\n        else if(tonext) clearFill(tonext);\n        trace._prevRevpath = null;\n    }\n    trace._ownPolygons = thisPolygons;\n\n\n    function visFilter(d) {\n        return d.filter(function(v) { return !v.gap && v.vis; });\n    }\n\n    function visFilterWithGaps(d) {\n        return d.filter(function(v) { return v.vis; });\n    }\n\n    function gapFilter(d) {\n        return d.filter(function(v) { return !v.gap; });\n    }\n\n    function keyFunc(d) {\n        return d.id;\n    }\n\n    // Returns a function if the trace is keyed, otherwise returns undefined\n    function getKeyFunc(trace) {\n        if(trace.ids) {\n            return keyFunc;\n        }\n    }\n\n    function hideFilter() {\n        return false;\n    }\n\n    function makePoints(points, text, cdscatter) {\n        var join, selection, hasNode;\n\n        var trace = cdscatter[0].trace;\n        var showMarkers = subTypes.hasMarkers(trace);\n        var showText = subTypes.hasText(trace);\n\n        var keyFunc = getKeyFunc(trace);\n        var markerFilter = hideFilter;\n        var textFilter = hideFilter;\n\n        if(showMarkers || showText) {\n            var showFilter = identity;\n            // if we're stacking, \"infer zero\" gap mode gets markers in the\n            // gap points - because we've inferred a zero there - but other\n            // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n            // we don't draw generated markers\n            var stackGroup = trace.stackgroup;\n            var isInferZero = stackGroup && (\n                gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero');\n            if(trace.marker.maxdisplayed || trace._needsCull) {\n                showFilter = isInferZero ? visFilterWithGaps : visFilter;\n            } else if(stackGroup && !isInferZero) {\n                showFilter = gapFilter;\n            }\n\n            if(showMarkers) markerFilter = showFilter;\n            if(showText) textFilter = showFilter;\n        }\n\n        // marker points\n\n        selection = points.selectAll('path.point');\n\n        join = selection.data(markerFilter, keyFunc);\n\n        var enter = join.enter().append('path')\n            .classed('point', true);\n\n        if(hasTransition) {\n            enter\n                .call(Drawing.pointStyle, trace, gd)\n                .call(Drawing.translatePoints, xa, ya)\n                .style('opacity', 0)\n                .transition()\n                .style('opacity', 1);\n        }\n\n        join.order();\n\n        var styleFns;\n        if(showMarkers) {\n            styleFns = Drawing.makePointStyleFns(trace);\n        }\n\n        join.each(function(d) {\n            var el = d3.select(this);\n            var sel = transition(el);\n            hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n            if(hasNode) {\n                Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n\n                if(plotinfo.layerClipId) {\n                    Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n                }\n\n                if(trace.customdata) {\n                    el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n                }\n            } else {\n                sel.remove();\n            }\n        });\n\n        if(hasTransition) {\n            join.exit().transition()\n                .style('opacity', 0)\n                .remove();\n        } else {\n            join.exit().remove();\n        }\n\n        // text points\n        selection = text.selectAll('g');\n        join = selection.data(textFilter, keyFunc);\n\n        // each text needs to go in its own 'g' in case\n        // it gets converted to mathjax\n        join.enter().append('g').classed('textpoint', true).append('text');\n\n        join.order();\n\n        join.each(function(d) {\n            var g = d3.select(this);\n            var sel = transition(g.select('text'));\n            hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n            if(hasNode) {\n                if(plotinfo.layerClipId) {\n                    Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n                }\n            } else {\n                g.remove();\n            }\n        });\n\n        join.selectAll('text')\n            .call(Drawing.textPointStyle, trace, gd)\n            .each(function(d) {\n                // This just *has* to be totally custom because of SVG text positioning :(\n                // It's obviously copied from translatePoint; we just can't use that\n                var x = xa.c2p(d.x);\n                var y = ya.c2p(d.y);\n\n                d3.select(this).selectAll('tspan.line').each(function() {\n                    transition(d3.select(this)).attr({x: x, y: y});\n                });\n            });\n\n        join.exit().remove();\n    }\n\n    points.datum(cdscatter);\n    text.datum(cdscatter);\n    makePoints(points, text, cdscatter);\n\n    // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n    Drawing.setClipUrl(points, clipUrl, gd);\n    Drawing.setClipUrl(text, clipUrl, gd);\n}\n\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n    var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n\n    var trace = cdscatter[0].trace;\n    if(!subTypes.hasMarkers(trace)) return;\n    // if marker.maxdisplayed is used, select a maximum of\n    // mnum markers to show, from the set that are in the viewport\n    var mnum = trace.marker.maxdisplayed;\n\n    // TODO: remove some as we get away from the viewport?\n    if(mnum === 0) return;\n\n    var cd = cdscatter.filter(function(v) {\n        return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n    });\n    var inc = Math.ceil(cd.length / mnum);\n    var tnum = 0;\n    cdscatterAll.forEach(function(cdj, j) {\n        var tracei = cdj[0].trace;\n        if(subTypes.hasMarkers(tracei) &&\n                tracei.marker.maxdisplayed > 0 && j < idx) {\n            tnum++;\n        }\n    });\n\n    // if multiple traces use maxdisplayed, stagger which markers we\n    // display this formula offsets successive traces by 1/3 of the\n    // increment, adding an extra small amount after each triplet so\n    // it's not quite periodic\n    var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);\n\n    // for error bars: save in cd which markers to show\n    // so we don't have to repeat this\n    cdscatter.forEach(function(v) { delete v.vis; });\n    cd.forEach(function(v, i) {\n        if(Math.round((i + i0) % inc) === 0) v.vis = true;\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}