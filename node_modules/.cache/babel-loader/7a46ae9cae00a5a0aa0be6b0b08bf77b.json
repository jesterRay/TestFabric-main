{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar boxCalc = require('../box/calc');\nvar helpers = require('./helpers');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nmodule.exports = function calc(gd, trace) {\n  var cd = boxCalc(gd, trace);\n  if (cd[0].t.empty) return cd;\n  var fullLayout = gd._fullLayout;\n  var valAxis = Axes.getFromId(gd, trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']);\n  var spanMin = Infinity;\n  var spanMax = -Infinity;\n  var maxKDE = 0;\n  var maxCount = 0;\n  for (var i = 0; i < cd.length; i++) {\n    var cdi = cd[i];\n    var vals = cdi.pts.map(helpers.extractVal);\n    var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n    var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n    if (cdi.min === cdi.max && bandwidth === 0) {\n      // if span is zero and bandwidth is zero, we want a violin with zero width\n      span = cdi.span = [cdi.min, cdi.max];\n      cdi.density = [{\n        v: 1,\n        t: span[0]\n      }];\n      cdi.bandwidth = bandwidth;\n      maxKDE = Math.max(maxKDE, 1);\n    } else {\n      // step that well covers the bandwidth and is multiple of span distance\n      var dist = span[1] - span[0];\n      var n = Math.ceil(dist / (bandwidth / 3));\n      var step = dist / n;\n      if (!isFinite(step) || !isFinite(n)) {\n        Lib.error('Something went wrong with computing the violin span');\n        cd[0].t.empty = true;\n        return cd;\n      }\n      var kde = helpers.makeKDE(cdi, trace, vals);\n      cdi.density = new Array(n);\n      for (var k = 0, t = span[0]; t < span[1] + step / 2; k++, t += step) {\n        var v = kde(t);\n        cdi.density[k] = {\n          v: v,\n          t: t\n        };\n        maxKDE = Math.max(maxKDE, v);\n      }\n    }\n    maxCount = Math.max(maxCount, vals.length);\n    spanMin = Math.min(spanMin, span[0]);\n    spanMax = Math.max(spanMax, span[1]);\n  }\n  var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {\n    padded: true\n  });\n  trace._extremes[valAxis._id] = extremes;\n  if (trace.width) {\n    cd[0].t.maxKDE = maxKDE;\n  } else {\n    var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n    var scaleGroup = trace.scalegroup;\n    var groupStats = violinScaleGroupStats[scaleGroup];\n    if (groupStats) {\n      groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n      groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n    } else {\n      violinScaleGroupStats[scaleGroup] = {\n        maxKDE: maxKDE,\n        maxCount: maxCount\n      };\n    }\n  }\n  cd[0].t.labels.kde = Lib._(gd, 'kde:');\n  return cd;\n};\n\n// Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\nfunction silvermanRule(len, ssd, iqr) {\n  var a = Math.min(ssd, iqr / 1.349);\n  return 1.059 * a * Math.pow(len, -0.2);\n}\nfunction calcBandwidth(trace, cdi, vals) {\n  var span = cdi.max - cdi.min;\n\n  // If span is zero\n  if (!span) {\n    if (trace.bandwidth) {\n      return trace.bandwidth;\n    } else {\n      // if span is zero and no bandwidth is specified\n      // it returns zero bandwidth which is a special case\n      return 0;\n    }\n  }\n\n  // Limit how small the bandwidth can be.\n  //\n  // Silverman's rule of thumb can be \"very\" small\n  // when IQR does a poor job at describing the spread\n  // of the distribution.\n  // We also want to limit custom bandwidths\n  // to not blow up kde computations.\n\n  if (trace.bandwidth) {\n    return Math.max(trace.bandwidth, span / 1e4);\n  } else {\n    var len = vals.length;\n    var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n    return Math.max(silvermanRule(len, ssd, cdi.q3 - cdi.q1), span / 100);\n  }\n}\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n  var spanmode = trace.spanmode;\n  var spanIn = trace.span || [];\n  var spanTight = [cdi.min, cdi.max];\n  var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n  var spanOut;\n  function calcSpanItem(index) {\n    var s = spanIn[index];\n    var sc = valAxis.type === 'multicategory' ? valAxis.r2c(s) : valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n    return sc === BADNUM ? spanLoose[index] : sc;\n  }\n  if (spanmode === 'soft') {\n    spanOut = spanLoose;\n  } else if (spanmode === 'hard') {\n    spanOut = spanTight;\n  } else {\n    spanOut = [calcSpanItem(0), calcSpanItem(1)];\n  }\n\n  // to reuse the equal-range-item block\n  var dummyAx = {\n    type: 'linear',\n    range: spanOut\n  };\n  Axes.setConvert(dummyAx);\n  dummyAx.cleanRange();\n  return spanOut;\n}","map":{"version":3,"names":["Lib","require","Axes","boxCalc","helpers","BADNUM","module","exports","calc","gd","trace","cd","t","empty","fullLayout","_fullLayout","valAxis","getFromId","orientation","spanMin","Infinity","spanMax","maxKDE","maxCount","i","length","cdi","vals","pts","map","extractVal","bandwidth","calcBandwidth","span","calcSpan","min","max","density","v","Math","dist","n","ceil","step","isFinite","error","kde","makeKDE","Array","k","extremes","findExtremes","padded","_extremes","_id","width","violinScaleGroupStats","_violinScaleGroupStats","scaleGroup","scalegroup","groupStats","labels","_","silvermanRule","len","ssd","iqr","a","pow","stdev","mean","q3","q1","spanmode","spanIn","spanTight","spanLoose","spanOut","calcSpanItem","index","s","sc","type","r2c","d2c","valLetter","dummyAx","range","setConvert","cleanRange"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/violin/calc.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar boxCalc = require('../box/calc');\nvar helpers = require('./helpers');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function calc(gd, trace) {\n    var cd = boxCalc(gd, trace);\n\n    if(cd[0].t.empty) return cd;\n\n    var fullLayout = gd._fullLayout;\n    var valAxis = Axes.getFromId(\n        gd,\n        trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']\n    );\n\n    var spanMin = Infinity;\n    var spanMax = -Infinity;\n    var maxKDE = 0;\n    var maxCount = 0;\n\n    for(var i = 0; i < cd.length; i++) {\n        var cdi = cd[i];\n        var vals = cdi.pts.map(helpers.extractVal);\n\n        var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n        var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n\n        if(cdi.min === cdi.max && bandwidth === 0) {\n            // if span is zero and bandwidth is zero, we want a violin with zero width\n            span = cdi.span = [cdi.min, cdi.max];\n            cdi.density = [{v: 1, t: span[0]}];\n            cdi.bandwidth = bandwidth;\n            maxKDE = Math.max(maxKDE, 1);\n        } else {\n            // step that well covers the bandwidth and is multiple of span distance\n            var dist = span[1] - span[0];\n            var n = Math.ceil(dist / (bandwidth / 3));\n            var step = dist / n;\n\n            if(!isFinite(step) || !isFinite(n)) {\n                Lib.error('Something went wrong with computing the violin span');\n                cd[0].t.empty = true;\n                return cd;\n            }\n\n            var kde = helpers.makeKDE(cdi, trace, vals);\n            cdi.density = new Array(n);\n\n            for(var k = 0, t = span[0]; t < (span[1] + step / 2); k++, t += step) {\n                var v = kde(t);\n                cdi.density[k] = {v: v, t: t};\n                maxKDE = Math.max(maxKDE, v);\n            }\n        }\n\n        maxCount = Math.max(maxCount, vals.length);\n        spanMin = Math.min(spanMin, span[0]);\n        spanMax = Math.max(spanMax, span[1]);\n    }\n\n    var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {padded: true});\n    trace._extremes[valAxis._id] = extremes;\n\n    if(trace.width) {\n        cd[0].t.maxKDE = maxKDE;\n    } else {\n        var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n        var scaleGroup = trace.scalegroup;\n        var groupStats = violinScaleGroupStats[scaleGroup];\n\n        if(groupStats) {\n            groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n            groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n        } else {\n            violinScaleGroupStats[scaleGroup] = {\n                maxKDE: maxKDE,\n                maxCount: maxCount\n            };\n        }\n    }\n\n    cd[0].t.labels.kde = Lib._(gd, 'kde:');\n\n    return cd;\n};\n\n// Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\nfunction silvermanRule(len, ssd, iqr) {\n    var a = Math.min(ssd, iqr / 1.349);\n    return 1.059 * a * Math.pow(len, -0.2);\n}\n\nfunction calcBandwidth(trace, cdi, vals) {\n    var span = cdi.max - cdi.min;\n\n    // If span is zero\n    if(!span) {\n        if(trace.bandwidth) {\n            return trace.bandwidth;\n        } else {\n            // if span is zero and no bandwidth is specified\n            // it returns zero bandwidth which is a special case\n            return 0;\n        }\n    }\n\n    // Limit how small the bandwidth can be.\n    //\n    // Silverman's rule of thumb can be \"very\" small\n    // when IQR does a poor job at describing the spread\n    // of the distribution.\n    // We also want to limit custom bandwidths\n    // to not blow up kde computations.\n\n    if(trace.bandwidth) {\n        return Math.max(trace.bandwidth, span / 1e4);\n    } else {\n        var len = vals.length;\n        var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n        return Math.max(\n            silvermanRule(len, ssd, cdi.q3 - cdi.q1),\n            span / 100\n        );\n    }\n}\n\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n    var spanmode = trace.spanmode;\n    var spanIn = trace.span || [];\n    var spanTight = [cdi.min, cdi.max];\n    var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n    var spanOut;\n\n    function calcSpanItem(index) {\n        var s = spanIn[index];\n        var sc = valAxis.type === 'multicategory' ?\n            valAxis.r2c(s) :\n            valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n        return sc === BADNUM ? spanLoose[index] : sc;\n    }\n\n    if(spanmode === 'soft') {\n        spanOut = spanLoose;\n    } else if(spanmode === 'hard') {\n        spanOut = spanTight;\n    } else {\n        spanOut = [calcSpanItem(0), calcSpanItem(1)];\n    }\n\n    // to reuse the equal-range-item block\n    var dummyAx = {\n        type: 'linear',\n        range: spanOut\n    };\n    Axes.setConvert(dummyAx);\n    dummyAx.cleanRange();\n\n    return spanOut;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}