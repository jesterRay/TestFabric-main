{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar interpolate = require('d3-interpolate').interpolate;\nvar helpers = require('../sunburst/helpers');\nvar Lib = require('../../lib');\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\nvar barPlot = require('../bar/plot');\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar constants = require('./constants');\nvar drawAncestors = require('./draw_ancestors');\nfunction getKey(pt) {\n  return helpers.isHierarchyRoot(pt) ? '' :\n  // don't use the dummyId\n  helpers.getPtId(pt);\n}\nmodule.exports = function plotOne(gd, cd, element, transitionOpts, drawDescendants) {\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var type = trace.type;\n  var isIcicle = type === 'icicle';\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var gTrace = d3.select(element);\n  var selAncestors = gTrace.selectAll('g.pathbar');\n  var selDescendants = gTrace.selectAll('g.slice');\n  if (!entry) {\n    selAncestors.remove();\n    selDescendants.remove();\n    return;\n  }\n  var isRoot = helpers.isHierarchyRoot(entry);\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var maxDepth = helpers.getMaxDepth(trace);\n  var hasVisibleDepth = function (pt) {\n    return pt.data.depth - entry.data.depth < maxDepth;\n  };\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var barW = vpw;\n  var barH = trace.pathbar.thickness;\n  var barPad = trace.marker.line.width + constants.gapWithPathbar;\n  var barDifY = !trace.pathbar.visible ? 0 : trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n  var pathbarOrigin = {\n    x0: barW,\n    // slide to the right\n    x1: barW,\n    y0: barDifY,\n    y1: barDifY + barH\n  };\n  var findClosestEdge = function (pt, ref, size) {\n    var e = trace.tiling.pad;\n    var isLeftOfRect = function (x) {\n      return x - e <= ref.x0;\n    };\n    var isRightOfRect = function (x) {\n      return x + e >= ref.x1;\n    };\n    var isBottomOfRect = function (y) {\n      return y - e <= ref.y0;\n    };\n    var isTopOfRect = function (y) {\n      return y + e >= ref.y1;\n    };\n    if (pt.x0 === ref.x0 && pt.x1 === ref.x1 && pt.y0 === ref.y0 && pt.y1 === ref.y1) {\n      return {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n    }\n    return {\n      x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n      x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n      y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n      y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n    };\n  };\n\n  // stash of 'previous' position data used by tweening functions\n  var prevEntry = null;\n  var prevLookupPathbar = {};\n  var prevLookupSlices = {};\n  var nextOfPrevEntry = null;\n  var getPrev = function (pt, onPathbar) {\n    return onPathbar ? prevLookupPathbar[getKey(pt)] : prevLookupSlices[getKey(pt)];\n  };\n  var getOrigin = function (pt, onPathbar, refRect, size) {\n    if (onPathbar) {\n      return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n    } else {\n      var ref = prevLookupSlices[trace.level] || refRect;\n      if (hasVisibleDepth(pt)) {\n        // case of an empty object - happens when maxdepth is set\n        return findClosestEdge(pt, ref, size);\n      }\n    }\n    return {};\n  };\n\n  // N.B. handle multiple-root special case\n  if (cd0.hasMultipleRoots && isRoot) {\n    maxDepth++;\n  }\n  trace._maxDepth = maxDepth;\n  trace._backgroundColor = fullLayout.paper_bgcolor;\n  trace._entryDepth = entry.data.depth;\n  trace._atRootLevel = isRoot;\n  var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n  var viewMapX = function (x) {\n    return cenX + x;\n  };\n  var viewMapY = function (y) {\n    return cenY + y;\n  };\n  var barY0 = viewMapY(0);\n  var barX0 = viewMapX(0);\n  var viewBarX = function (x) {\n    return barX0 + x;\n  };\n  var viewBarY = function (y) {\n    return barY0 + y;\n  };\n  function pos(x, y) {\n    return x + ',' + y;\n  }\n  var xStart = viewBarX(0);\n  var limitX0 = function (p) {\n    p.x = Math.max(xStart, p.x);\n  };\n  var edgeshape = trace.pathbar.edgeshape;\n\n  // pathbar(directory) path generation fn\n  var pathAncestor = function (d) {\n    var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n    var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n    var _y0 = viewBarY(d.y0);\n    var _y1 = viewBarY(d.y1);\n    var halfH = barH / 2;\n    var pL = {};\n    var pR = {};\n    pL.x = _x0;\n    pR.x = _x1;\n    pL.y = pR.y = (_y0 + _y1) / 2;\n    var pA = {\n      x: _x0,\n      y: _y0\n    };\n    var pB = {\n      x: _x1,\n      y: _y0\n    };\n    var pC = {\n      x: _x1,\n      y: _y1\n    };\n    var pD = {\n      x: _x0,\n      y: _y1\n    };\n    if (edgeshape === '>') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pC.x -= halfH;\n      pD.x -= halfH;\n    } else if (edgeshape === '/') {\n      pC.x -= halfH;\n      pD.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '\\\\') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '<') {\n      pL.x -= halfH;\n      pR.x -= halfH;\n    }\n    limitX0(pA);\n    limitX0(pD);\n    limitX0(pL);\n    limitX0(pB);\n    limitX0(pC);\n    limitX0(pR);\n    return 'M' + pos(pA.x, pA.y) + 'L' + pos(pB.x, pB.y) + 'L' + pos(pR.x, pR.y) + 'L' + pos(pC.x, pC.y) + 'L' + pos(pD.x, pD.y) + 'L' + pos(pL.x, pL.y) + 'Z';\n  };\n\n  // Note that `pad` is just an integer for `icicle`` traces where\n  // `pad` is a hashmap for treemap: pad.t, pad.b, pad.l, and pad.r\n  var pad = trace[isIcicle ? 'tiling' : 'marker'].pad;\n  var hasFlag = function (f) {\n    return trace.textposition.indexOf(f) !== -1;\n  };\n  var hasTop = hasFlag('top');\n  var hasLeft = hasFlag('left');\n  var hasRight = hasFlag('right');\n  var hasBottom = hasFlag('bottom');\n\n  // slice path generation fn\n  var pathDescendant = function (d) {\n    var _x0 = viewMapX(d.x0);\n    var _x1 = viewMapX(d.x1);\n    var _y0 = viewMapY(d.y0);\n    var _y1 = viewMapY(d.y1);\n    var dx = _x1 - _x0;\n    var dy = _y1 - _y0;\n    if (!dx || !dy) return '';\n    var cornerradius = trace.marker.cornerradius || 0;\n    var r = Math.min(cornerradius, dx / 2, dy / 2);\n    if (r && d.data && d.data.data && d.data.data.label) {\n      if (hasTop) r = Math.min(r, pad.t);\n      if (hasLeft) r = Math.min(r, pad.l);\n      if (hasRight) r = Math.min(r, pad.r);\n      if (hasBottom) r = Math.min(r, pad.b);\n    }\n    var arc = function (rx, ry) {\n      return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : '';\n    };\n    return 'M' + pos(_x0, _y0 + r) + arc(r, -r) + 'L' + pos(_x1 - r, _y0) + arc(r, r) + 'L' + pos(_x1, _y1 - r) + arc(-r, r) + 'L' + pos(_x0 + r, _y1) + arc(-r, -r) + 'Z';\n  };\n  var toMoveInsideSlice = function (pt, opts) {\n    var x0 = pt.x0;\n    var x1 = pt.x1;\n    var y0 = pt.y0;\n    var y1 = pt.y1;\n    var textBB = pt.textBB;\n    var _hasTop = hasTop || opts.isHeader && !hasBottom;\n    var anchor = _hasTop ? 'start' : hasBottom ? 'end' : 'middle';\n    var _hasRight = hasFlag('right');\n    var _hasLeft = hasFlag('left') || opts.onPathbar;\n    var leftToRight = _hasLeft ? -1 : _hasRight ? 1 : 0;\n    if (opts.isHeader) {\n      x0 += (isIcicle ? pad : pad.l) - TEXTPAD;\n      x1 -= (isIcicle ? pad : pad.r) - TEXTPAD;\n      if (x0 >= x1) {\n        var mid = (x0 + x1) / 2;\n        x0 = mid;\n        x1 = mid;\n      }\n\n      // limit the drawing area for headers\n      var limY;\n      if (hasBottom) {\n        limY = y1 - (isIcicle ? pad : pad.b);\n        if (y0 < limY && limY < y1) y0 = limY;\n      } else {\n        limY = y0 + (isIcicle ? pad : pad.t);\n        if (y0 < limY && limY < y1) y1 = limY;\n      }\n    }\n\n    // position the text relative to the slice\n    var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: false,\n      constrained: true,\n      angle: 0,\n      anchor: anchor,\n      leftToRight: leftToRight\n    });\n    transform.fontSize = opts.fontSize;\n    transform.targetX = viewMapX(transform.targetX);\n    transform.targetY = viewMapY(transform.targetY);\n    if (isNaN(transform.targetX) || isNaN(transform.targetY)) {\n      return {};\n    }\n    if (x0 !== x1 && y0 !== y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n    return {\n      scale: transform.scale,\n      rotate: transform.rotate,\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY\n    };\n  };\n  var interpFromParent = function (pt, onPathbar) {\n    var parentPrev;\n    var i = 0;\n    var Q = pt;\n    while (!parentPrev && i < maxDepth) {\n      // loop to find a parent/grandParent on the previous graph\n      i++;\n      Q = Q.parent;\n      if (Q) {\n        parentPrev = getPrev(Q, onPathbar);\n      } else i = maxDepth;\n    }\n    return parentPrev || {};\n  };\n  var makeExitSliceInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev = getPrev(pt, onPathbar);\n    var next;\n    if (onPathbar) {\n      next = pathbarOrigin;\n    } else {\n      var entryPrev = getPrev(entry, onPathbar);\n      if (entryPrev) {\n        // 'entryPrev' is here has the previous coordinates of the entry\n        // node, which corresponds to the last \"clicked\" node when zooming in\n        next = findClosestEdge(pt, entryPrev, size);\n      } else {\n        // this happens when maxdepth is set, when leaves must\n        // be removed and the entry is new (i.e. does not have a 'prev' object)\n        next = {};\n      }\n    }\n    return interpolate(prev, next);\n  };\n  var makeUpdateSliceInterpolator = function (pt, onPathbar, refRect, size, opts) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev;\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (onPathbar) {\n        prev = pathbarOrigin;\n      } else {\n        if (prevEntry) {\n          // if trace was visible before\n          if (pt.parent) {\n            var ref = nextOfPrevEntry || refRect;\n            if (ref && !onPathbar) {\n              prev = findClosestEdge(pt, ref, size);\n            } else {\n              // if new leaf (when maxdepth is set),\n              // grow it from its parent node\n              prev = {};\n              Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n          } else {\n            prev = Lib.extendFlat({}, pt);\n            if (isIcicle) {\n              if (opts.orientation === 'h') {\n                if (opts.flipX) prev.x0 = pt.x1;else prev.x1 = 0;\n              } else {\n                if (opts.flipY) prev.y0 = pt.y1;else prev.y1 = 0;\n              }\n            }\n          }\n        } else {\n          prev = {};\n        }\n      }\n    }\n    return interpolate(prev, {\n      x0: pt.x0,\n      x1: pt.x1,\n      y0: pt.y0,\n      y1: pt.y1\n    });\n  };\n  var makeUpdateTextInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev = {};\n    var origin = getOrigin(pt, onPathbar, refRect, size);\n    Lib.extendFlat(prev, {\n      transform: toMoveInsideSlice({\n        x0: origin.x0,\n        x1: origin.x1,\n        y0: origin.y0,\n        y1: origin.y1,\n        textBB: pt.textBB,\n        _text: pt._text\n      }, {\n        isHeader: helpers.isHeader(pt, trace)\n      })\n    });\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (pt.parent) {\n        Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n      }\n    }\n    var transform = pt.transform;\n    if (pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n    return interpolate(prev, {\n      transform: {\n        scale: transform.scale,\n        rotate: transform.rotate,\n        textX: transform.textX,\n        textY: transform.textY,\n        anchorX: transform.anchorX,\n        anchorY: transform.anchorY,\n        targetX: transform.targetX,\n        targetY: transform.targetY\n      }\n    });\n  };\n  var handleSlicesExit = function (slices, onPathbar, refRect, size, pathSlice) {\n    var width = size[0];\n    var height = size[1];\n    if (hasTransition) {\n      slices.exit().transition().each(function () {\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.select('path.surface');\n        slicePath.transition().attrTween('d', function (pt2) {\n          var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n          return function (t) {\n            return pathSlice(interp(t));\n          };\n        });\n        var sliceTextGroup = sliceTop.select('g.slicetext');\n        sliceTextGroup.attr('opacity', 0);\n      }).remove();\n    } else {\n      slices.exit().remove();\n    }\n  };\n  var strTransform = function (d) {\n    var transform = d.transform;\n    if (d.x0 !== d.x1 && d.y0 !== d.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n    return Lib.getTextTransform({\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY,\n      scale: transform.scale,\n      rotate: transform.rotate\n    });\n  };\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n\n    selAncestors.each(function (pt) {\n      prevLookupPathbar[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n      if (pt.transform) {\n        prevLookupPathbar[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n    });\n    selDescendants.each(function (pt) {\n      prevLookupSlices[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n      if (pt.transform) {\n        prevLookupSlices[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  }\n  nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n    width: vpw,\n    height: vph,\n    viewX: viewMapX,\n    viewY: viewMapY,\n    pathSlice: pathDescendant,\n    toMoveInsideSlice: toMoveInsideSlice,\n    prevEntry: prevEntry,\n    makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n    makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n    handleSlicesExit: handleSlicesExit,\n    hasTransition: hasTransition,\n    strTransform: strTransform\n  });\n  if (trace.pathbar.visible) {\n    drawAncestors(gd, cd, entry, selAncestors, {\n      barDifY: barDifY,\n      width: barW,\n      height: barH,\n      viewX: viewBarX,\n      viewY: viewBarY,\n      pathSlice: pathAncestor,\n      toMoveInsideSlice: toMoveInsideSlice,\n      makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n      makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n      handleSlicesExit: handleSlicesExit,\n      hasTransition: hasTransition,\n      strTransform: strTransform\n    });\n  } else {\n    selAncestors.remove();\n  }\n};","map":{"version":3,"names":["d3","require","interpolate","helpers","Lib","TEXTPAD","barPlot","toMoveInsideBar","uniformText","recordMinTextSize","constants","drawAncestors","getKey","pt","isHierarchyRoot","getPtId","module","exports","plotOne","gd","cd","element","transitionOpts","drawDescendants","fullLayout","_fullLayout","cd0","trace","type","isIcicle","hierarchy","entry","findEntryWithLevel","level","gTrace","select","selAncestors","selectAll","selDescendants","remove","isRoot","hasTransition","uniformtext","mode","maxDepth","getMaxDepth","hasVisibleDepth","data","depth","gs","_size","domain","vpw","w","x","vph","h","y","barW","barH","pathbar","thickness","barPad","marker","line","width","gapWithPathbar","barDifY","visible","side","indexOf","pathbarOrigin","x0","x1","y0","y1","findClosestEdge","ref","size","e","tiling","pad","isLeftOfRect","isRightOfRect","isBottomOfRect","isTopOfRect","prevEntry","prevLookupPathbar","prevLookupSlices","nextOfPrevEntry","getPrev","onPathbar","getOrigin","refRect","hasMultipleRoots","_maxDepth","_backgroundColor","paper_bgcolor","_entryDepth","_atRootLevel","cenX","l","cenY","t","viewMapX","viewMapY","barY0","barX0","viewBarX","viewBarY","pos","xStart","limitX0","p","Math","max","edgeshape","pathAncestor","d","_x0","min","_x1","_y0","_y1","halfH","pL","pR","pA","pB","pC","pD","hasFlag","f","textposition","hasTop","hasLeft","hasRight","hasBottom","pathDescendant","dx","dy","cornerradius","r","label","b","arc","rx","ry","toMoveInsideSlice","opts","textBB","_hasTop","isHeader","anchor","_hasRight","_hasLeft","leftToRight","mid","limY","transform","isHorizontal","constrained","angle","fontSize","targetX","targetY","isNaN","scale","rotate","textX","textY","anchorX","anchorY","interpFromParent","parentPrev","i","Q","parent","makeExitSliceInterpolator","prev","next","entryPrev","makeUpdateSliceInterpolator","prev0","extendFlat","orientation","flipX","flipY","makeUpdateTextInterpolator","origin","_text","handleSlicesExit","slices","pathSlice","height","exit","transition","each","sliceTop","slicePath","attrTween","pt2","interp","sliceTextGroup","attr","strTransform","getTextTransform","isEntry","viewX","viewY"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/treemap/plot_one.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\nvar barPlot = require('../bar/plot');\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar constants = require('./constants');\nvar drawAncestors = require('./draw_ancestors');\n\nfunction getKey(pt) {\n    return helpers.isHierarchyRoot(pt) ?\n        '' : // don't use the dummyId\n        helpers.getPtId(pt);\n}\n\nmodule.exports = function plotOne(gd, cd, element, transitionOpts, drawDescendants) {\n    var fullLayout = gd._fullLayout;\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var type = trace.type;\n    var isIcicle = type === 'icicle';\n\n    var hierarchy = cd0.hierarchy;\n    var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n\n    var gTrace = d3.select(element);\n    var selAncestors = gTrace.selectAll('g.pathbar');\n    var selDescendants = gTrace.selectAll('g.slice');\n\n    if(!entry) {\n        selAncestors.remove();\n        selDescendants.remove();\n        return;\n    }\n\n    var isRoot = helpers.isHierarchyRoot(entry);\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    var maxDepth = helpers.getMaxDepth(trace);\n    var hasVisibleDepth = function(pt) {\n        return pt.data.depth - entry.data.depth < maxDepth;\n    };\n\n    var gs = fullLayout._size;\n    var domain = trace.domain;\n\n    var vpw = gs.w * (domain.x[1] - domain.x[0]);\n    var vph = gs.h * (domain.y[1] - domain.y[0]);\n    var barW = vpw;\n    var barH = trace.pathbar.thickness;\n    var barPad = trace.marker.line.width + constants.gapWithPathbar;\n    var barDifY = !trace.pathbar.visible ? 0 :\n        trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n\n    var pathbarOrigin = {\n        x0: barW, // slide to the right\n        x1: barW,\n        y0: barDifY,\n        y1: barDifY + barH\n    };\n\n    var findClosestEdge = function(pt, ref, size) {\n        var e = trace.tiling.pad;\n        var isLeftOfRect = function(x) { return x - e <= ref.x0; };\n        var isRightOfRect = function(x) { return x + e >= ref.x1; };\n        var isBottomOfRect = function(y) { return y - e <= ref.y0; };\n        var isTopOfRect = function(y) { return y + e >= ref.y1; };\n\n        if(pt.x0 === ref.x0 && pt.x1 === ref.x1 && pt.y0 === ref.y0 && pt.y1 === ref.y1) {\n            return {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n        }\n\n        return {\n            x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n            x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n            y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n            y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n        };\n    };\n\n    // stash of 'previous' position data used by tweening functions\n    var prevEntry = null;\n    var prevLookupPathbar = {};\n    var prevLookupSlices = {};\n    var nextOfPrevEntry = null;\n    var getPrev = function(pt, onPathbar) {\n        return onPathbar ?\n            prevLookupPathbar[getKey(pt)] :\n            prevLookupSlices[getKey(pt)];\n    };\n\n    var getOrigin = function(pt, onPathbar, refRect, size) {\n        if(onPathbar) {\n            return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n        } else {\n            var ref = prevLookupSlices[trace.level] || refRect;\n\n            if(hasVisibleDepth(pt)) { // case of an empty object - happens when maxdepth is set\n                return findClosestEdge(pt, ref, size);\n            }\n        }\n        return {};\n    };\n\n    // N.B. handle multiple-root special case\n    if(cd0.hasMultipleRoots && isRoot) {\n        maxDepth++;\n    }\n\n    trace._maxDepth = maxDepth;\n    trace._backgroundColor = fullLayout.paper_bgcolor;\n    trace._entryDepth = entry.data.depth;\n    trace._atRootLevel = isRoot;\n\n    var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n    var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n    var viewMapX = function(x) { return cenX + x; };\n    var viewMapY = function(y) { return cenY + y; };\n\n    var barY0 = viewMapY(0);\n    var barX0 = viewMapX(0);\n\n    var viewBarX = function(x) { return barX0 + x; };\n    var viewBarY = function(y) { return barY0 + y; };\n\n    function pos(x, y) {\n        return x + ',' + y;\n    }\n\n    var xStart = viewBarX(0);\n    var limitX0 = function(p) { p.x = Math.max(xStart, p.x); };\n\n    var edgeshape = trace.pathbar.edgeshape;\n\n    // pathbar(directory) path generation fn\n    var pathAncestor = function(d) {\n        var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n        var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n        var _y0 = viewBarY(d.y0);\n        var _y1 = viewBarY(d.y1);\n\n        var halfH = barH / 2;\n\n        var pL = {};\n        var pR = {};\n\n        pL.x = _x0;\n        pR.x = _x1;\n\n        pL.y = pR.y = (_y0 + _y1) / 2;\n\n        var pA = {x: _x0, y: _y0};\n        var pB = {x: _x1, y: _y0};\n        var pC = {x: _x1, y: _y1};\n        var pD = {x: _x0, y: _y1};\n\n        if(edgeshape === '>') {\n            pA.x -= halfH;\n            pB.x -= halfH;\n            pC.x -= halfH;\n            pD.x -= halfH;\n        } else if(edgeshape === '/') {\n            pC.x -= halfH;\n            pD.x -= halfH;\n            pL.x -= halfH / 2;\n            pR.x -= halfH / 2;\n        } else if(edgeshape === '\\\\') {\n            pA.x -= halfH;\n            pB.x -= halfH;\n            pL.x -= halfH / 2;\n            pR.x -= halfH / 2;\n        } else if(edgeshape === '<') {\n            pL.x -= halfH;\n            pR.x -= halfH;\n        }\n\n        limitX0(pA);\n        limitX0(pD);\n        limitX0(pL);\n\n        limitX0(pB);\n        limitX0(pC);\n        limitX0(pR);\n\n        return (\n           'M' + pos(pA.x, pA.y) +\n           'L' + pos(pB.x, pB.y) +\n           'L' + pos(pR.x, pR.y) +\n           'L' + pos(pC.x, pC.y) +\n           'L' + pos(pD.x, pD.y) +\n           'L' + pos(pL.x, pL.y) +\n           'Z'\n        );\n    };\n\n    // Note that `pad` is just an integer for `icicle`` traces where\n    // `pad` is a hashmap for treemap: pad.t, pad.b, pad.l, and pad.r\n    var pad = trace[isIcicle ? 'tiling' : 'marker'].pad;\n\n    var hasFlag = function(f) { return trace.textposition.indexOf(f) !== -1; };\n\n    var hasTop = hasFlag('top');\n    var hasLeft = hasFlag('left');\n    var hasRight = hasFlag('right');\n    var hasBottom = hasFlag('bottom');\n\n    // slice path generation fn\n    var pathDescendant = function(d) {\n        var _x0 = viewMapX(d.x0);\n        var _x1 = viewMapX(d.x1);\n        var _y0 = viewMapY(d.y0);\n        var _y1 = viewMapY(d.y1);\n\n        var dx = _x1 - _x0;\n        var dy = _y1 - _y0;\n        if(!dx || !dy) return '';\n\n        var cornerradius = trace.marker.cornerradius || 0;\n        var r = Math.min(cornerradius, dx / 2, dy / 2);\n        if(\n            r &&\n            d.data &&\n            d.data.data &&\n            d.data.data.label\n        ) {\n            if(hasTop) r = Math.min(r, pad.t);\n            if(hasLeft) r = Math.min(r, pad.l);\n            if(hasRight) r = Math.min(r, pad.r);\n            if(hasBottom) r = Math.min(r, pad.b);\n        }\n\n        var arc = function(rx, ry) { return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : ''; };\n\n        return (\n           'M' + pos(_x0, _y0 + r) +\n           arc(r, -r) +\n           'L' + pos(_x1 - r, _y0) +\n           arc(r, r) +\n           'L' + pos(_x1, _y1 - r) +\n           arc(-r, r) +\n           'L' + pos(_x0 + r, _y1) +\n           arc(-r, -r) + 'Z'\n        );\n    };\n\n    var toMoveInsideSlice = function(pt, opts) {\n        var x0 = pt.x0;\n        var x1 = pt.x1;\n        var y0 = pt.y0;\n        var y1 = pt.y1;\n        var textBB = pt.textBB;\n\n        var _hasTop = hasTop || (opts.isHeader && !hasBottom);\n\n        var anchor =\n            _hasTop ? 'start' :\n            hasBottom ? 'end' : 'middle';\n\n        var _hasRight = hasFlag('right');\n        var _hasLeft = hasFlag('left') || opts.onPathbar;\n\n        var leftToRight =\n            _hasLeft ? -1 :\n            _hasRight ? 1 : 0;\n\n        if(opts.isHeader) {\n            x0 += (isIcicle ? pad : pad.l) - TEXTPAD;\n            x1 -= (isIcicle ? pad : pad.r) - TEXTPAD;\n            if(x0 >= x1) {\n                var mid = (x0 + x1) / 2;\n                x0 = mid;\n                x1 = mid;\n            }\n\n            // limit the drawing area for headers\n            var limY;\n            if(hasBottom) {\n                limY = y1 - (isIcicle ? pad : pad.b);\n                if(y0 < limY && limY < y1) y0 = limY;\n            } else {\n                limY = y0 + (isIcicle ? pad : pad.t);\n                if(y0 < limY && limY < y1) y1 = limY;\n            }\n        }\n\n        // position the text relative to the slice\n        var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: false,\n            constrained: true,\n            angle: 0,\n            anchor: anchor,\n            leftToRight: leftToRight\n        });\n        transform.fontSize = opts.fontSize;\n\n        transform.targetX = viewMapX(transform.targetX);\n        transform.targetY = viewMapY(transform.targetY);\n\n        if(isNaN(transform.targetX) || isNaN(transform.targetY)) {\n            return {};\n        }\n\n        if(x0 !== x1 && y0 !== y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return {\n            scale: transform.scale,\n            rotate: transform.rotate,\n            textX: transform.textX,\n            textY: transform.textY,\n            anchorX: transform.anchorX,\n            anchorY: transform.anchorY,\n            targetX: transform.targetX,\n            targetY: transform.targetY\n        };\n    };\n\n    var interpFromParent = function(pt, onPathbar) {\n        var parentPrev;\n        var i = 0;\n        var Q = pt;\n        while(!parentPrev && i < maxDepth) { // loop to find a parent/grandParent on the previous graph\n            i++;\n            Q = Q.parent;\n            if(Q) {\n                parentPrev = getPrev(Q, onPathbar);\n            } else i = maxDepth;\n        }\n        return parentPrev || {};\n    };\n\n    var makeExitSliceInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev = getPrev(pt, onPathbar);\n        var next;\n\n        if(onPathbar) {\n            next = pathbarOrigin;\n        } else {\n            var entryPrev = getPrev(entry, onPathbar);\n            if(entryPrev) {\n                // 'entryPrev' is here has the previous coordinates of the entry\n                // node, which corresponds to the last \"clicked\" node when zooming in\n                next = findClosestEdge(pt, entryPrev, size);\n            } else {\n                // this happens when maxdepth is set, when leaves must\n                // be removed and the entry is new (i.e. does not have a 'prev' object)\n                next = {};\n            }\n        }\n\n        return interpolate(prev, next);\n    };\n\n    var makeUpdateSliceInterpolator = function(pt, onPathbar, refRect, size, opts) {\n        var prev0 = getPrev(pt, onPathbar);\n        var prev;\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(onPathbar) {\n                prev = pathbarOrigin;\n            } else {\n                if(prevEntry) {\n                    // if trace was visible before\n                    if(pt.parent) {\n                        var ref = nextOfPrevEntry || refRect;\n\n                        if(ref && !onPathbar) {\n                            prev = findClosestEdge(pt, ref, size);\n                        } else {\n                            // if new leaf (when maxdepth is set),\n                            // grow it from its parent node\n                            prev = {};\n                            Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n                        }\n                    } else {\n                        prev = Lib.extendFlat({}, pt);\n                        if(isIcicle) {\n                            if(opts.orientation === 'h') {\n                                if(opts.flipX) prev.x0 = pt.x1;\n                                else prev.x1 = 0;\n                            } else {\n                                if(opts.flipY) prev.y0 = pt.y1;\n                                else prev.y1 = 0;\n                            }\n                        }\n                    }\n                } else {\n                    prev = {};\n                }\n            }\n        }\n\n        return interpolate(prev, {\n            x0: pt.x0,\n            x1: pt.x1,\n            y0: pt.y0,\n            y1: pt.y1\n        });\n    };\n\n    var makeUpdateTextInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev0 = getPrev(pt, onPathbar);\n        var prev = {};\n        var origin = getOrigin(pt, onPathbar, refRect, size);\n\n        Lib.extendFlat(prev, {\n            transform: toMoveInsideSlice({\n                x0: origin.x0,\n                x1: origin.x1,\n                y0: origin.y0,\n                y1: origin.y1,\n                textBB: pt.textBB,\n                _text: pt._text\n            }, {\n                isHeader: helpers.isHeader(pt, trace)\n            })\n        });\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(pt.parent) {\n                Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n        }\n\n        var transform = pt.transform;\n        if(pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return interpolate(prev, {\n            transform: {\n                scale: transform.scale,\n                rotate: transform.rotate,\n                textX: transform.textX,\n                textY: transform.textY,\n                anchorX: transform.anchorX,\n                anchorY: transform.anchorY,\n                targetX: transform.targetX,\n                targetY: transform.targetY\n            }\n        });\n    };\n\n    var handleSlicesExit = function(slices, onPathbar, refRect, size, pathSlice) {\n        var width = size[0];\n        var height = size[1];\n\n        if(hasTransition) {\n            slices.exit().transition()\n                .each(function() {\n                    var sliceTop = d3.select(this);\n\n                    var slicePath = sliceTop.select('path.surface');\n                    slicePath.transition().attrTween('d', function(pt2) {\n                        var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n                        return function(t) { return pathSlice(interp(t)); };\n                    });\n\n                    var sliceTextGroup = sliceTop.select('g.slicetext');\n                    sliceTextGroup.attr('opacity', 0);\n                })\n                .remove();\n        } else {\n            slices.exit().remove();\n        }\n    };\n\n    var strTransform = function(d) {\n        var transform = d.transform;\n\n        if(d.x0 !== d.x1 && d.y0 !== d.y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return Lib.getTextTransform({\n            textX: transform.textX,\n            textY: transform.textY,\n            anchorX: transform.anchorX,\n            anchorY: transform.anchorY,\n            targetX: transform.targetX,\n            targetY: transform.targetY,\n            scale: transform.scale,\n            rotate: transform.rotate\n        });\n    };\n\n    if(hasTransition) {\n        // Important: do this before binding new sliceData!\n\n        selAncestors.each(function(pt) {\n            prevLookupPathbar[getKey(pt)] = {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n\n            if(pt.transform) {\n                prevLookupPathbar[getKey(pt)].transform = {\n                    textX: pt.transform.textX,\n                    textY: pt.transform.textY,\n                    anchorX: pt.transform.anchorX,\n                    anchorY: pt.transform.anchorY,\n                    targetX: pt.transform.targetX,\n                    targetY: pt.transform.targetY,\n                    scale: pt.transform.scale,\n                    rotate: pt.transform.rotate\n                };\n            }\n        });\n\n        selDescendants.each(function(pt) {\n            prevLookupSlices[getKey(pt)] = {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n\n            if(pt.transform) {\n                prevLookupSlices[getKey(pt)].transform = {\n                    textX: pt.transform.textX,\n                    textY: pt.transform.textY,\n                    anchorX: pt.transform.anchorX,\n                    anchorY: pt.transform.anchorY,\n                    targetX: pt.transform.targetX,\n                    targetY: pt.transform.targetY,\n                    scale: pt.transform.scale,\n                    rotate: pt.transform.rotate\n                };\n            }\n\n            if(!prevEntry && helpers.isEntry(pt)) {\n                prevEntry = pt;\n            }\n        });\n    }\n\n    nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n        width: vpw,\n        height: vph,\n\n        viewX: viewMapX,\n        viewY: viewMapY,\n\n        pathSlice: pathDescendant,\n        toMoveInsideSlice: toMoveInsideSlice,\n\n        prevEntry: prevEntry,\n        makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n        makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n\n        handleSlicesExit: handleSlicesExit,\n        hasTransition: hasTransition,\n        strTransform: strTransform\n    });\n\n    if(trace.pathbar.visible) {\n        drawAncestors(gd, cd, entry, selAncestors, {\n            barDifY: barDifY,\n            width: barW,\n            height: barH,\n\n            viewX: viewBarX,\n            viewY: viewBarY,\n\n            pathSlice: pathAncestor,\n            toMoveInsideSlice: toMoveInsideSlice,\n\n            makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n            makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n\n            handleSlicesExit: handleSlicesExit,\n            hasTransition: hasTransition,\n            strTransform: strTransform\n        });\n    } else {\n        selAncestors.remove();\n    }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,YAAY,CAAC;AAC9B,IAAIC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC,CAACC,WAAW;AAEvD,IAAIC,OAAO,GAAGF,OAAO,CAAC,qBAAqB,CAAC;AAE5C,IAAIG,GAAG,GAAGH,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAII,OAAO,GAAGJ,OAAO,CAAC,kBAAkB,CAAC,CAACI,OAAO;AACjD,IAAIC,OAAO,GAAGL,OAAO,CAAC,aAAa,CAAC;AACpC,IAAIM,eAAe,GAAGD,OAAO,CAACC,eAAe;AAC7C,IAAIC,WAAW,GAAGP,OAAO,CAAC,qBAAqB,CAAC;AAChD,IAAIQ,iBAAiB,GAAGD,WAAW,CAACC,iBAAiB;AACrD,IAAIC,SAAS,GAAGT,OAAO,CAAC,aAAa,CAAC;AACtC,IAAIU,aAAa,GAAGV,OAAO,CAAC,kBAAkB,CAAC;AAE/C,SAASW,MAAMA,CAACC,EAAE,EAAE;EAChB,OAAOV,OAAO,CAACW,eAAe,CAACD,EAAE,CAAC,GAC9B,EAAE;EAAG;EACLV,OAAO,CAACY,OAAO,CAACF,EAAE,CAAC;AAC3B;AAEAG,MAAM,CAACC,OAAO,GAAG,SAASC,OAAOA,CAACC,EAAE,EAAEC,EAAE,EAAEC,OAAO,EAAEC,cAAc,EAAEC,eAAe,EAAE;EAChF,IAAIC,UAAU,GAAGL,EAAE,CAACM,WAAW;EAC/B,IAAIC,GAAG,GAAGN,EAAE,CAAC,CAAC,CAAC;EACf,IAAIO,KAAK,GAAGD,GAAG,CAACC,KAAK;EACrB,IAAIC,IAAI,GAAGD,KAAK,CAACC,IAAI;EACrB,IAAIC,QAAQ,GAAGD,IAAI,KAAK,QAAQ;EAEhC,IAAIE,SAAS,GAAGJ,GAAG,CAACI,SAAS;EAC7B,IAAIC,KAAK,GAAG5B,OAAO,CAAC6B,kBAAkB,CAACF,SAAS,EAAEH,KAAK,CAACM,KAAK,CAAC;EAE9D,IAAIC,MAAM,GAAGlC,EAAE,CAACmC,MAAM,CAACd,OAAO,CAAC;EAC/B,IAAIe,YAAY,GAAGF,MAAM,CAACG,SAAS,CAAC,WAAW,CAAC;EAChD,IAAIC,cAAc,GAAGJ,MAAM,CAACG,SAAS,CAAC,SAAS,CAAC;EAEhD,IAAG,CAACN,KAAK,EAAE;IACPK,YAAY,CAACG,MAAM,CAAC,CAAC;IACrBD,cAAc,CAACC,MAAM,CAAC,CAAC;IACvB;EACJ;EAEA,IAAIC,MAAM,GAAGrC,OAAO,CAACW,eAAe,CAACiB,KAAK,CAAC;EAC3C,IAAIU,aAAa,GAAG,CAACjB,UAAU,CAACkB,WAAW,CAACC,IAAI,IAAIxC,OAAO,CAACsC,aAAa,CAACnB,cAAc,CAAC;EAEzF,IAAIsB,QAAQ,GAAGzC,OAAO,CAAC0C,WAAW,CAAClB,KAAK,CAAC;EACzC,IAAImB,eAAe,GAAG,SAAAA,CAASjC,EAAE,EAAE;IAC/B,OAAOA,EAAE,CAACkC,IAAI,CAACC,KAAK,GAAGjB,KAAK,CAACgB,IAAI,CAACC,KAAK,GAAGJ,QAAQ;EACtD,CAAC;EAED,IAAIK,EAAE,GAAGzB,UAAU,CAAC0B,KAAK;EACzB,IAAIC,MAAM,GAAGxB,KAAK,CAACwB,MAAM;EAEzB,IAAIC,GAAG,GAAGH,EAAE,CAACI,CAAC,IAAIF,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,GAAGH,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAIC,GAAG,GAAGN,EAAE,CAACO,CAAC,IAAIL,MAAM,CAACM,CAAC,CAAC,CAAC,CAAC,GAAGN,MAAM,CAACM,CAAC,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAIC,IAAI,GAAGN,GAAG;EACd,IAAIO,IAAI,GAAGhC,KAAK,CAACiC,OAAO,CAACC,SAAS;EAClC,IAAIC,MAAM,GAAGnC,KAAK,CAACoC,MAAM,CAACC,IAAI,CAACC,KAAK,GAAGvD,SAAS,CAACwD,cAAc;EAC/D,IAAIC,OAAO,GAAG,CAACxC,KAAK,CAACiC,OAAO,CAACQ,OAAO,GAAG,CAAC,GACpCzC,KAAK,CAACiC,OAAO,CAACS,IAAI,CAACC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAGf,GAAG,GAAGO,MAAM,GAAG,EAAEH,IAAI,GAAGG,MAAM,CAAC;EAE/E,IAAIS,aAAa,GAAG;IAChBC,EAAE,EAAEd,IAAI;IAAE;IACVe,EAAE,EAAEf,IAAI;IACRgB,EAAE,EAAEP,OAAO;IACXQ,EAAE,EAAER,OAAO,GAAGR;EAClB,CAAC;EAED,IAAIiB,eAAe,GAAG,SAAAA,CAAS/D,EAAE,EAAEgE,GAAG,EAAEC,IAAI,EAAE;IAC1C,IAAIC,CAAC,GAAGpD,KAAK,CAACqD,MAAM,CAACC,GAAG;IACxB,IAAIC,YAAY,GAAG,SAAAA,CAAS5B,CAAC,EAAE;MAAE,OAAOA,CAAC,GAAGyB,CAAC,IAAIF,GAAG,CAACL,EAAE;IAAE,CAAC;IAC1D,IAAIW,aAAa,GAAG,SAAAA,CAAS7B,CAAC,EAAE;MAAE,OAAOA,CAAC,GAAGyB,CAAC,IAAIF,GAAG,CAACJ,EAAE;IAAE,CAAC;IAC3D,IAAIW,cAAc,GAAG,SAAAA,CAAS3B,CAAC,EAAE;MAAE,OAAOA,CAAC,GAAGsB,CAAC,IAAIF,GAAG,CAACH,EAAE;IAAE,CAAC;IAC5D,IAAIW,WAAW,GAAG,SAAAA,CAAS5B,CAAC,EAAE;MAAE,OAAOA,CAAC,GAAGsB,CAAC,IAAIF,GAAG,CAACF,EAAE;IAAE,CAAC;IAEzD,IAAG9D,EAAE,CAAC2D,EAAE,KAAKK,GAAG,CAACL,EAAE,IAAI3D,EAAE,CAAC4D,EAAE,KAAKI,GAAG,CAACJ,EAAE,IAAI5D,EAAE,CAAC6D,EAAE,KAAKG,GAAG,CAACH,EAAE,IAAI7D,EAAE,CAAC8D,EAAE,KAAKE,GAAG,CAACF,EAAE,EAAE;MAC7E,OAAO;QACHH,EAAE,EAAE3D,EAAE,CAAC2D,EAAE;QACTC,EAAE,EAAE5D,EAAE,CAAC4D,EAAE;QACTC,EAAE,EAAE7D,EAAE,CAAC6D,EAAE;QACTC,EAAE,EAAE9D,EAAE,CAAC8D;MACX,CAAC;IACL;IAEA,OAAO;MACHH,EAAE,EAAEU,YAAY,CAACrE,EAAE,CAAC2D,EAAE,GAAGO,CAAC,CAAC,GAAG,CAAC,GAAGI,aAAa,CAACtE,EAAE,CAAC2D,EAAE,GAAGO,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAC,GAAGjE,EAAE,CAAC2D,EAAE;MAC5EC,EAAE,EAAES,YAAY,CAACrE,EAAE,CAAC4D,EAAE,GAAGM,CAAC,CAAC,GAAG,CAAC,GAAGI,aAAa,CAACtE,EAAE,CAAC4D,EAAE,GAAGM,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAC,GAAGjE,EAAE,CAAC4D,EAAE;MAC5EC,EAAE,EAAEU,cAAc,CAACvE,EAAE,CAAC6D,EAAE,GAAGK,CAAC,CAAC,GAAG,CAAC,GAAGM,WAAW,CAACxE,EAAE,CAAC6D,EAAE,GAAGK,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAC,GAAGjE,EAAE,CAAC6D,EAAE;MAC5EC,EAAE,EAAES,cAAc,CAACvE,EAAE,CAAC8D,EAAE,GAAGI,CAAC,CAAC,GAAG,CAAC,GAAGM,WAAW,CAACxE,EAAE,CAAC8D,EAAE,GAAGI,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAC,GAAGjE,EAAE,CAAC8D;IAC9E,CAAC;EACL,CAAC;;EAED;EACA,IAAIW,SAAS,GAAG,IAAI;EACpB,IAAIC,iBAAiB,GAAG,CAAC,CAAC;EAC1B,IAAIC,gBAAgB,GAAG,CAAC,CAAC;EACzB,IAAIC,eAAe,GAAG,IAAI;EAC1B,IAAIC,OAAO,GAAG,SAAAA,CAAS7E,EAAE,EAAE8E,SAAS,EAAE;IAClC,OAAOA,SAAS,GACZJ,iBAAiB,CAAC3E,MAAM,CAACC,EAAE,CAAC,CAAC,GAC7B2E,gBAAgB,CAAC5E,MAAM,CAACC,EAAE,CAAC,CAAC;EACpC,CAAC;EAED,IAAI+E,SAAS,GAAG,SAAAA,CAAS/E,EAAE,EAAE8E,SAAS,EAAEE,OAAO,EAAEf,IAAI,EAAE;IACnD,IAAGa,SAAS,EAAE;MACV,OAAOJ,iBAAiB,CAAC3E,MAAM,CAACkB,SAAS,CAAC,CAAC,IAAIyC,aAAa;IAChE,CAAC,MAAM;MACH,IAAIM,GAAG,GAAGW,gBAAgB,CAAC7D,KAAK,CAACM,KAAK,CAAC,IAAI4D,OAAO;MAElD,IAAG/C,eAAe,CAACjC,EAAE,CAAC,EAAE;QAAE;QACtB,OAAO+D,eAAe,CAAC/D,EAAE,EAAEgE,GAAG,EAAEC,IAAI,CAAC;MACzC;IACJ;IACA,OAAO,CAAC,CAAC;EACb,CAAC;;EAED;EACA,IAAGpD,GAAG,CAACoE,gBAAgB,IAAItD,MAAM,EAAE;IAC/BI,QAAQ,EAAE;EACd;EAEAjB,KAAK,CAACoE,SAAS,GAAGnD,QAAQ;EAC1BjB,KAAK,CAACqE,gBAAgB,GAAGxE,UAAU,CAACyE,aAAa;EACjDtE,KAAK,CAACuE,WAAW,GAAGnE,KAAK,CAACgB,IAAI,CAACC,KAAK;EACpCrB,KAAK,CAACwE,YAAY,GAAG3D,MAAM;EAE3B,IAAI4D,IAAI,GAAG,CAAChD,GAAG,GAAG,CAAC,GAAGH,EAAE,CAACoD,CAAC,GAAGpD,EAAE,CAACI,CAAC,IAAIF,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,GAAGH,MAAM,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EACnE,IAAIgD,IAAI,GAAG,CAAC/C,GAAG,GAAG,CAAC,GAAGN,EAAE,CAACsD,CAAC,GAAGtD,EAAE,CAACO,CAAC,IAAI,CAAC,GAAG,CAACL,MAAM,CAACM,CAAC,CAAC,CAAC,CAAC,GAAGN,MAAM,CAACM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;EAEzE,IAAI+C,QAAQ,GAAG,SAAAA,CAASlD,CAAC,EAAE;IAAE,OAAO8C,IAAI,GAAG9C,CAAC;EAAE,CAAC;EAC/C,IAAImD,QAAQ,GAAG,SAAAA,CAAShD,CAAC,EAAE;IAAE,OAAO6C,IAAI,GAAG7C,CAAC;EAAE,CAAC;EAE/C,IAAIiD,KAAK,GAAGD,QAAQ,CAAC,CAAC,CAAC;EACvB,IAAIE,KAAK,GAAGH,QAAQ,CAAC,CAAC,CAAC;EAEvB,IAAII,QAAQ,GAAG,SAAAA,CAAStD,CAAC,EAAE;IAAE,OAAOqD,KAAK,GAAGrD,CAAC;EAAE,CAAC;EAChD,IAAIuD,QAAQ,GAAG,SAAAA,CAASpD,CAAC,EAAE;IAAE,OAAOiD,KAAK,GAAGjD,CAAC;EAAE,CAAC;EAEhD,SAASqD,GAAGA,CAACxD,CAAC,EAAEG,CAAC,EAAE;IACf,OAAOH,CAAC,GAAG,GAAG,GAAGG,CAAC;EACtB;EAEA,IAAIsD,MAAM,GAAGH,QAAQ,CAAC,CAAC,CAAC;EACxB,IAAII,OAAO,GAAG,SAAAA,CAASC,CAAC,EAAE;IAAEA,CAAC,CAAC3D,CAAC,GAAG4D,IAAI,CAACC,GAAG,CAACJ,MAAM,EAAEE,CAAC,CAAC3D,CAAC,CAAC;EAAE,CAAC;EAE1D,IAAI8D,SAAS,GAAGzF,KAAK,CAACiC,OAAO,CAACwD,SAAS;;EAEvC;EACA,IAAIC,YAAY,GAAG,SAAAA,CAASC,CAAC,EAAE;IAC3B,IAAIC,GAAG,GAAGX,QAAQ,CAACM,IAAI,CAACC,GAAG,CAACD,IAAI,CAACM,GAAG,CAACF,CAAC,CAAC9C,EAAE,EAAE8C,CAAC,CAAC9C,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACrD,IAAIiD,GAAG,GAAGb,QAAQ,CAACM,IAAI,CAACM,GAAG,CAACN,IAAI,CAACC,GAAG,CAACG,CAAC,CAAC7C,EAAE,EAAE6C,CAAC,CAAC7C,EAAE,CAAC,EAAEf,IAAI,CAAC,CAAC;IACxD,IAAIgE,GAAG,GAAGb,QAAQ,CAACS,CAAC,CAAC5C,EAAE,CAAC;IACxB,IAAIiD,GAAG,GAAGd,QAAQ,CAACS,CAAC,CAAC3C,EAAE,CAAC;IAExB,IAAIiD,KAAK,GAAGjE,IAAI,GAAG,CAAC;IAEpB,IAAIkE,EAAE,GAAG,CAAC,CAAC;IACX,IAAIC,EAAE,GAAG,CAAC,CAAC;IAEXD,EAAE,CAACvE,CAAC,GAAGiE,GAAG;IACVO,EAAE,CAACxE,CAAC,GAAGmE,GAAG;IAEVI,EAAE,CAACpE,CAAC,GAAGqE,EAAE,CAACrE,CAAC,GAAG,CAACiE,GAAG,GAAGC,GAAG,IAAI,CAAC;IAE7B,IAAII,EAAE,GAAG;MAACzE,CAAC,EAAEiE,GAAG;MAAE9D,CAAC,EAAEiE;IAAG,CAAC;IACzB,IAAIM,EAAE,GAAG;MAAC1E,CAAC,EAAEmE,GAAG;MAAEhE,CAAC,EAAEiE;IAAG,CAAC;IACzB,IAAIO,EAAE,GAAG;MAAC3E,CAAC,EAAEmE,GAAG;MAAEhE,CAAC,EAAEkE;IAAG,CAAC;IACzB,IAAIO,EAAE,GAAG;MAAC5E,CAAC,EAAEiE,GAAG;MAAE9D,CAAC,EAAEkE;IAAG,CAAC;IAEzB,IAAGP,SAAS,KAAK,GAAG,EAAE;MAClBW,EAAE,CAACzE,CAAC,IAAIsE,KAAK;MACbI,EAAE,CAAC1E,CAAC,IAAIsE,KAAK;MACbK,EAAE,CAAC3E,CAAC,IAAIsE,KAAK;MACbM,EAAE,CAAC5E,CAAC,IAAIsE,KAAK;IACjB,CAAC,MAAM,IAAGR,SAAS,KAAK,GAAG,EAAE;MACzBa,EAAE,CAAC3E,CAAC,IAAIsE,KAAK;MACbM,EAAE,CAAC5E,CAAC,IAAIsE,KAAK;MACbC,EAAE,CAACvE,CAAC,IAAIsE,KAAK,GAAG,CAAC;MACjBE,EAAE,CAACxE,CAAC,IAAIsE,KAAK,GAAG,CAAC;IACrB,CAAC,MAAM,IAAGR,SAAS,KAAK,IAAI,EAAE;MAC1BW,EAAE,CAACzE,CAAC,IAAIsE,KAAK;MACbI,EAAE,CAAC1E,CAAC,IAAIsE,KAAK;MACbC,EAAE,CAACvE,CAAC,IAAIsE,KAAK,GAAG,CAAC;MACjBE,EAAE,CAACxE,CAAC,IAAIsE,KAAK,GAAG,CAAC;IACrB,CAAC,MAAM,IAAGR,SAAS,KAAK,GAAG,EAAE;MACzBS,EAAE,CAACvE,CAAC,IAAIsE,KAAK;MACbE,EAAE,CAACxE,CAAC,IAAIsE,KAAK;IACjB;IAEAZ,OAAO,CAACe,EAAE,CAAC;IACXf,OAAO,CAACkB,EAAE,CAAC;IACXlB,OAAO,CAACa,EAAE,CAAC;IAEXb,OAAO,CAACgB,EAAE,CAAC;IACXhB,OAAO,CAACiB,EAAE,CAAC;IACXjB,OAAO,CAACc,EAAE,CAAC;IAEX,OACG,GAAG,GAAGhB,GAAG,CAACiB,EAAE,CAACzE,CAAC,EAAEyE,EAAE,CAACtE,CAAC,CAAC,GACrB,GAAG,GAAGqD,GAAG,CAACkB,EAAE,CAAC1E,CAAC,EAAE0E,EAAE,CAACvE,CAAC,CAAC,GACrB,GAAG,GAAGqD,GAAG,CAACgB,EAAE,CAACxE,CAAC,EAAEwE,EAAE,CAACrE,CAAC,CAAC,GACrB,GAAG,GAAGqD,GAAG,CAACmB,EAAE,CAAC3E,CAAC,EAAE2E,EAAE,CAACxE,CAAC,CAAC,GACrB,GAAG,GAAGqD,GAAG,CAACoB,EAAE,CAAC5E,CAAC,EAAE4E,EAAE,CAACzE,CAAC,CAAC,GACrB,GAAG,GAAGqD,GAAG,CAACe,EAAE,CAACvE,CAAC,EAAEuE,EAAE,CAACpE,CAAC,CAAC,GACrB,GAAG;EAEV,CAAC;;EAED;EACA;EACA,IAAIwB,GAAG,GAAGtD,KAAK,CAACE,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,CAACoD,GAAG;EAEnD,IAAIkD,OAAO,GAAG,SAAAA,CAASC,CAAC,EAAE;IAAE,OAAOzG,KAAK,CAAC0G,YAAY,CAAC/D,OAAO,CAAC8D,CAAC,CAAC,KAAK,CAAC,CAAC;EAAE,CAAC;EAE1E,IAAIE,MAAM,GAAGH,OAAO,CAAC,KAAK,CAAC;EAC3B,IAAII,OAAO,GAAGJ,OAAO,CAAC,MAAM,CAAC;EAC7B,IAAIK,QAAQ,GAAGL,OAAO,CAAC,OAAO,CAAC;EAC/B,IAAIM,SAAS,GAAGN,OAAO,CAAC,QAAQ,CAAC;;EAEjC;EACA,IAAIO,cAAc,GAAG,SAAAA,CAASpB,CAAC,EAAE;IAC7B,IAAIC,GAAG,GAAGf,QAAQ,CAACc,CAAC,CAAC9C,EAAE,CAAC;IACxB,IAAIiD,GAAG,GAAGjB,QAAQ,CAACc,CAAC,CAAC7C,EAAE,CAAC;IACxB,IAAIiD,GAAG,GAAGjB,QAAQ,CAACa,CAAC,CAAC5C,EAAE,CAAC;IACxB,IAAIiD,GAAG,GAAGlB,QAAQ,CAACa,CAAC,CAAC3C,EAAE,CAAC;IAExB,IAAIgE,EAAE,GAAGlB,GAAG,GAAGF,GAAG;IAClB,IAAIqB,EAAE,GAAGjB,GAAG,GAAGD,GAAG;IAClB,IAAG,CAACiB,EAAE,IAAI,CAACC,EAAE,EAAE,OAAO,EAAE;IAExB,IAAIC,YAAY,GAAGlH,KAAK,CAACoC,MAAM,CAAC8E,YAAY,IAAI,CAAC;IACjD,IAAIC,CAAC,GAAG5B,IAAI,CAACM,GAAG,CAACqB,YAAY,EAAEF,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAG,CAAC,CAAC;IAC9C,IACIE,CAAC,IACDxB,CAAC,CAACvE,IAAI,IACNuE,CAAC,CAACvE,IAAI,CAACA,IAAI,IACXuE,CAAC,CAACvE,IAAI,CAACA,IAAI,CAACgG,KAAK,EACnB;MACE,IAAGT,MAAM,EAAEQ,CAAC,GAAG5B,IAAI,CAACM,GAAG,CAACsB,CAAC,EAAE7D,GAAG,CAACsB,CAAC,CAAC;MACjC,IAAGgC,OAAO,EAAEO,CAAC,GAAG5B,IAAI,CAACM,GAAG,CAACsB,CAAC,EAAE7D,GAAG,CAACoB,CAAC,CAAC;MAClC,IAAGmC,QAAQ,EAAEM,CAAC,GAAG5B,IAAI,CAACM,GAAG,CAACsB,CAAC,EAAE7D,GAAG,CAAC6D,CAAC,CAAC;MACnC,IAAGL,SAAS,EAAEK,CAAC,GAAG5B,IAAI,CAACM,GAAG,CAACsB,CAAC,EAAE7D,GAAG,CAAC+D,CAAC,CAAC;IACxC;IAEA,IAAIC,GAAG,GAAG,SAAAA,CAASC,EAAE,EAAEC,EAAE,EAAE;MAAE,OAAOL,CAAC,GAAG,GAAG,GAAGhC,GAAG,CAACgC,CAAC,EAAEA,CAAC,CAAC,GAAG,SAAS,GAAGhC,GAAG,CAACoC,EAAE,EAAEC,EAAE,CAAC,GAAG,EAAE;IAAE,CAAC;IAEzF,OACG,GAAG,GAAGrC,GAAG,CAACS,GAAG,EAAEG,GAAG,GAAGoB,CAAC,CAAC,GACvBG,GAAG,CAACH,CAAC,EAAE,CAACA,CAAC,CAAC,GACV,GAAG,GAAGhC,GAAG,CAACW,GAAG,GAAGqB,CAAC,EAAEpB,GAAG,CAAC,GACvBuB,GAAG,CAACH,CAAC,EAAEA,CAAC,CAAC,GACT,GAAG,GAAGhC,GAAG,CAACW,GAAG,EAAEE,GAAG,GAAGmB,CAAC,CAAC,GACvBG,GAAG,CAAC,CAACH,CAAC,EAAEA,CAAC,CAAC,GACV,GAAG,GAAGhC,GAAG,CAACS,GAAG,GAAGuB,CAAC,EAAEnB,GAAG,CAAC,GACvBsB,GAAG,CAAC,CAACH,CAAC,EAAE,CAACA,CAAC,CAAC,GAAG,GAAG;EAExB,CAAC;EAED,IAAIM,iBAAiB,GAAG,SAAAA,CAASvI,EAAE,EAAEwI,IAAI,EAAE;IACvC,IAAI7E,EAAE,GAAG3D,EAAE,CAAC2D,EAAE;IACd,IAAIC,EAAE,GAAG5D,EAAE,CAAC4D,EAAE;IACd,IAAIC,EAAE,GAAG7D,EAAE,CAAC6D,EAAE;IACd,IAAIC,EAAE,GAAG9D,EAAE,CAAC8D,EAAE;IACd,IAAI2E,MAAM,GAAGzI,EAAE,CAACyI,MAAM;IAEtB,IAAIC,OAAO,GAAGjB,MAAM,IAAKe,IAAI,CAACG,QAAQ,IAAI,CAACf,SAAU;IAErD,IAAIgB,MAAM,GACNF,OAAO,GAAG,OAAO,GACjBd,SAAS,GAAG,KAAK,GAAG,QAAQ;IAEhC,IAAIiB,SAAS,GAAGvB,OAAO,CAAC,OAAO,CAAC;IAChC,IAAIwB,QAAQ,GAAGxB,OAAO,CAAC,MAAM,CAAC,IAAIkB,IAAI,CAAC1D,SAAS;IAEhD,IAAIiE,WAAW,GACXD,QAAQ,GAAG,CAAC,CAAC,GACbD,SAAS,GAAG,CAAC,GAAG,CAAC;IAErB,IAAGL,IAAI,CAACG,QAAQ,EAAE;MACdhF,EAAE,IAAI,CAAC3C,QAAQ,GAAGoD,GAAG,GAAGA,GAAG,CAACoB,CAAC,IAAIhG,OAAO;MACxCoE,EAAE,IAAI,CAAC5C,QAAQ,GAAGoD,GAAG,GAAGA,GAAG,CAAC6D,CAAC,IAAIzI,OAAO;MACxC,IAAGmE,EAAE,IAAIC,EAAE,EAAE;QACT,IAAIoF,GAAG,GAAG,CAACrF,EAAE,GAAGC,EAAE,IAAI,CAAC;QACvBD,EAAE,GAAGqF,GAAG;QACRpF,EAAE,GAAGoF,GAAG;MACZ;;MAEA;MACA,IAAIC,IAAI;MACR,IAAGrB,SAAS,EAAE;QACVqB,IAAI,GAAGnF,EAAE,IAAI9C,QAAQ,GAAGoD,GAAG,GAAGA,GAAG,CAAC+D,CAAC,CAAC;QACpC,IAAGtE,EAAE,GAAGoF,IAAI,IAAIA,IAAI,GAAGnF,EAAE,EAAED,EAAE,GAAGoF,IAAI;MACxC,CAAC,MAAM;QACHA,IAAI,GAAGpF,EAAE,IAAI7C,QAAQ,GAAGoD,GAAG,GAAGA,GAAG,CAACsB,CAAC,CAAC;QACpC,IAAG7B,EAAE,GAAGoF,IAAI,IAAIA,IAAI,GAAGnF,EAAE,EAAEA,EAAE,GAAGmF,IAAI;MACxC;IACJ;;IAEA;IACA,IAAIC,SAAS,GAAGxJ,eAAe,CAACiE,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE2E,MAAM,EAAE;MACpDU,YAAY,EAAE,KAAK;MACnBC,WAAW,EAAE,IAAI;MACjBC,KAAK,EAAE,CAAC;MACRT,MAAM,EAAEA,MAAM;MACdG,WAAW,EAAEA;IACjB,CAAC,CAAC;IACFG,SAAS,CAACI,QAAQ,GAAGd,IAAI,CAACc,QAAQ;IAElCJ,SAAS,CAACK,OAAO,GAAG5D,QAAQ,CAACuD,SAAS,CAACK,OAAO,CAAC;IAC/CL,SAAS,CAACM,OAAO,GAAG5D,QAAQ,CAACsD,SAAS,CAACM,OAAO,CAAC;IAE/C,IAAGC,KAAK,CAACP,SAAS,CAACK,OAAO,CAAC,IAAIE,KAAK,CAACP,SAAS,CAACM,OAAO,CAAC,EAAE;MACrD,OAAO,CAAC,CAAC;IACb;IAEA,IAAG7F,EAAE,KAAKC,EAAE,IAAIC,EAAE,KAAKC,EAAE,EAAE;MACvBlE,iBAAiB,CAACkB,KAAK,CAACC,IAAI,EAAEmI,SAAS,EAAEvI,UAAU,CAAC;IACxD;IAEA,OAAO;MACH+I,KAAK,EAAER,SAAS,CAACQ,KAAK;MACtBC,MAAM,EAAET,SAAS,CAACS,MAAM;MACxBC,KAAK,EAAEV,SAAS,CAACU,KAAK;MACtBC,KAAK,EAAEX,SAAS,CAACW,KAAK;MACtBC,OAAO,EAAEZ,SAAS,CAACY,OAAO;MAC1BC,OAAO,EAAEb,SAAS,CAACa,OAAO;MAC1BR,OAAO,EAAEL,SAAS,CAACK,OAAO;MAC1BC,OAAO,EAAEN,SAAS,CAACM;IACvB,CAAC;EACL,CAAC;EAED,IAAIQ,gBAAgB,GAAG,SAAAA,CAAShK,EAAE,EAAE8E,SAAS,EAAE;IAC3C,IAAImF,UAAU;IACd,IAAIC,CAAC,GAAG,CAAC;IACT,IAAIC,CAAC,GAAGnK,EAAE;IACV,OAAM,CAACiK,UAAU,IAAIC,CAAC,GAAGnI,QAAQ,EAAE;MAAE;MACjCmI,CAAC,EAAE;MACHC,CAAC,GAAGA,CAAC,CAACC,MAAM;MACZ,IAAGD,CAAC,EAAE;QACFF,UAAU,GAAGpF,OAAO,CAACsF,CAAC,EAAErF,SAAS,CAAC;MACtC,CAAC,MAAMoF,CAAC,GAAGnI,QAAQ;IACvB;IACA,OAAOkI,UAAU,IAAI,CAAC,CAAC;EAC3B,CAAC;EAED,IAAII,yBAAyB,GAAG,SAAAA,CAASrK,EAAE,EAAE8E,SAAS,EAAEE,OAAO,EAAEf,IAAI,EAAE;IACnE,IAAIqG,IAAI,GAAGzF,OAAO,CAAC7E,EAAE,EAAE8E,SAAS,CAAC;IACjC,IAAIyF,IAAI;IAER,IAAGzF,SAAS,EAAE;MACVyF,IAAI,GAAG7G,aAAa;IACxB,CAAC,MAAM;MACH,IAAI8G,SAAS,GAAG3F,OAAO,CAAC3D,KAAK,EAAE4D,SAAS,CAAC;MACzC,IAAG0F,SAAS,EAAE;QACV;QACA;QACAD,IAAI,GAAGxG,eAAe,CAAC/D,EAAE,EAAEwK,SAAS,EAAEvG,IAAI,CAAC;MAC/C,CAAC,MAAM;QACH;QACA;QACAsG,IAAI,GAAG,CAAC,CAAC;MACb;IACJ;IAEA,OAAOlL,WAAW,CAACiL,IAAI,EAAEC,IAAI,CAAC;EAClC,CAAC;EAED,IAAIE,2BAA2B,GAAG,SAAAA,CAASzK,EAAE,EAAE8E,SAAS,EAAEE,OAAO,EAAEf,IAAI,EAAEuE,IAAI,EAAE;IAC3E,IAAIkC,KAAK,GAAG7F,OAAO,CAAC7E,EAAE,EAAE8E,SAAS,CAAC;IAClC,IAAIwF,IAAI;IAER,IAAGI,KAAK,EAAE;MACN;MACAJ,IAAI,GAAGI,KAAK;IAChB,CAAC,MAAM;MACH;MACA,IAAG5F,SAAS,EAAE;QACVwF,IAAI,GAAG5G,aAAa;MACxB,CAAC,MAAM;QACH,IAAGe,SAAS,EAAE;UACV;UACA,IAAGzE,EAAE,CAACoK,MAAM,EAAE;YACV,IAAIpG,GAAG,GAAGY,eAAe,IAAII,OAAO;YAEpC,IAAGhB,GAAG,IAAI,CAACc,SAAS,EAAE;cAClBwF,IAAI,GAAGvG,eAAe,CAAC/D,EAAE,EAAEgE,GAAG,EAAEC,IAAI,CAAC;YACzC,CAAC,MAAM;cACH;cACA;cACAqG,IAAI,GAAG,CAAC,CAAC;cACT/K,GAAG,CAACoL,UAAU,CAACL,IAAI,EAAEN,gBAAgB,CAAChK,EAAE,EAAE8E,SAAS,CAAC,CAAC;YACzD;UACJ,CAAC,MAAM;YACHwF,IAAI,GAAG/K,GAAG,CAACoL,UAAU,CAAC,CAAC,CAAC,EAAE3K,EAAE,CAAC;YAC7B,IAAGgB,QAAQ,EAAE;cACT,IAAGwH,IAAI,CAACoC,WAAW,KAAK,GAAG,EAAE;gBACzB,IAAGpC,IAAI,CAACqC,KAAK,EAAEP,IAAI,CAAC3G,EAAE,GAAG3D,EAAE,CAAC4D,EAAE,CAAC,KAC1B0G,IAAI,CAAC1G,EAAE,GAAG,CAAC;cACpB,CAAC,MAAM;gBACH,IAAG4E,IAAI,CAACsC,KAAK,EAAER,IAAI,CAACzG,EAAE,GAAG7D,EAAE,CAAC8D,EAAE,CAAC,KAC1BwG,IAAI,CAACxG,EAAE,GAAG,CAAC;cACpB;YACJ;UACJ;QACJ,CAAC,MAAM;UACHwG,IAAI,GAAG,CAAC,CAAC;QACb;MACJ;IACJ;IAEA,OAAOjL,WAAW,CAACiL,IAAI,EAAE;MACrB3G,EAAE,EAAE3D,EAAE,CAAC2D,EAAE;MACTC,EAAE,EAAE5D,EAAE,CAAC4D,EAAE;MACTC,EAAE,EAAE7D,EAAE,CAAC6D,EAAE;MACTC,EAAE,EAAE9D,EAAE,CAAC8D;IACX,CAAC,CAAC;EACN,CAAC;EAED,IAAIiH,0BAA0B,GAAG,SAAAA,CAAS/K,EAAE,EAAE8E,SAAS,EAAEE,OAAO,EAAEf,IAAI,EAAE;IACpE,IAAIyG,KAAK,GAAG7F,OAAO,CAAC7E,EAAE,EAAE8E,SAAS,CAAC;IAClC,IAAIwF,IAAI,GAAG,CAAC,CAAC;IACb,IAAIU,MAAM,GAAGjG,SAAS,CAAC/E,EAAE,EAAE8E,SAAS,EAAEE,OAAO,EAAEf,IAAI,CAAC;IAEpD1E,GAAG,CAACoL,UAAU,CAACL,IAAI,EAAE;MACjBpB,SAAS,EAAEX,iBAAiB,CAAC;QACzB5E,EAAE,EAAEqH,MAAM,CAACrH,EAAE;QACbC,EAAE,EAAEoH,MAAM,CAACpH,EAAE;QACbC,EAAE,EAAEmH,MAAM,CAACnH,EAAE;QACbC,EAAE,EAAEkH,MAAM,CAAClH,EAAE;QACb2E,MAAM,EAAEzI,EAAE,CAACyI,MAAM;QACjBwC,KAAK,EAAEjL,EAAE,CAACiL;MACd,CAAC,EAAE;QACCtC,QAAQ,EAAErJ,OAAO,CAACqJ,QAAQ,CAAC3I,EAAE,EAAEc,KAAK;MACxC,CAAC;IACL,CAAC,CAAC;IAEF,IAAG4J,KAAK,EAAE;MACN;MACAJ,IAAI,GAAGI,KAAK;IAChB,CAAC,MAAM;MACH;MACA,IAAG1K,EAAE,CAACoK,MAAM,EAAE;QACV7K,GAAG,CAACoL,UAAU,CAACL,IAAI,EAAEN,gBAAgB,CAAChK,EAAE,EAAE8E,SAAS,CAAC,CAAC;MACzD;IACJ;IAEA,IAAIoE,SAAS,GAAGlJ,EAAE,CAACkJ,SAAS;IAC5B,IAAGlJ,EAAE,CAAC2D,EAAE,KAAK3D,EAAE,CAAC4D,EAAE,IAAI5D,EAAE,CAAC6D,EAAE,KAAK7D,EAAE,CAAC8D,EAAE,EAAE;MACnClE,iBAAiB,CAACkB,KAAK,CAACC,IAAI,EAAEmI,SAAS,EAAEvI,UAAU,CAAC;IACxD;IAEA,OAAOtB,WAAW,CAACiL,IAAI,EAAE;MACrBpB,SAAS,EAAE;QACPQ,KAAK,EAAER,SAAS,CAACQ,KAAK;QACtBC,MAAM,EAAET,SAAS,CAACS,MAAM;QACxBC,KAAK,EAAEV,SAAS,CAACU,KAAK;QACtBC,KAAK,EAAEX,SAAS,CAACW,KAAK;QACtBC,OAAO,EAAEZ,SAAS,CAACY,OAAO;QAC1BC,OAAO,EAAEb,SAAS,CAACa,OAAO;QAC1BR,OAAO,EAAEL,SAAS,CAACK,OAAO;QAC1BC,OAAO,EAAEN,SAAS,CAACM;MACvB;IACJ,CAAC,CAAC;EACN,CAAC;EAED,IAAI0B,gBAAgB,GAAG,SAAAA,CAASC,MAAM,EAAErG,SAAS,EAAEE,OAAO,EAAEf,IAAI,EAAEmH,SAAS,EAAE;IACzE,IAAIhI,KAAK,GAAGa,IAAI,CAAC,CAAC,CAAC;IACnB,IAAIoH,MAAM,GAAGpH,IAAI,CAAC,CAAC,CAAC;IAEpB,IAAGrC,aAAa,EAAE;MACduJ,MAAM,CAACG,IAAI,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CACrBC,IAAI,CAAC,YAAW;QACb,IAAIC,QAAQ,GAAGtM,EAAE,CAACmC,MAAM,CAAC,IAAI,CAAC;QAE9B,IAAIoK,SAAS,GAAGD,QAAQ,CAACnK,MAAM,CAAC,cAAc,CAAC;QAC/CoK,SAAS,CAACH,UAAU,CAAC,CAAC,CAACI,SAAS,CAAC,GAAG,EAAE,UAASC,GAAG,EAAE;UAChD,IAAIC,MAAM,GAAGxB,yBAAyB,CAACuB,GAAG,EAAE9G,SAAS,EAAEE,OAAO,EAAE,CAAC5B,KAAK,EAAEiI,MAAM,CAAC,CAAC;UAChF,OAAO,UAAS3F,CAAC,EAAE;YAAE,OAAO0F,SAAS,CAACS,MAAM,CAACnG,CAAC,CAAC,CAAC;UAAE,CAAC;QACvD,CAAC,CAAC;QAEF,IAAIoG,cAAc,GAAGL,QAAQ,CAACnK,MAAM,CAAC,aAAa,CAAC;QACnDwK,cAAc,CAACC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;MACrC,CAAC,CAAC,CACDrK,MAAM,CAAC,CAAC;IACjB,CAAC,MAAM;MACHyJ,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC5J,MAAM,CAAC,CAAC;IAC1B;EACJ,CAAC;EAED,IAAIsK,YAAY,GAAG,SAAAA,CAASvF,CAAC,EAAE;IAC3B,IAAIyC,SAAS,GAAGzC,CAAC,CAACyC,SAAS;IAE3B,IAAGzC,CAAC,CAAC9C,EAAE,KAAK8C,CAAC,CAAC7C,EAAE,IAAI6C,CAAC,CAAC5C,EAAE,KAAK4C,CAAC,CAAC3C,EAAE,EAAE;MAC/BlE,iBAAiB,CAACkB,KAAK,CAACC,IAAI,EAAEmI,SAAS,EAAEvI,UAAU,CAAC;IACxD;IAEA,OAAOpB,GAAG,CAAC0M,gBAAgB,CAAC;MACxBrC,KAAK,EAAEV,SAAS,CAACU,KAAK;MACtBC,KAAK,EAAEX,SAAS,CAACW,KAAK;MACtBC,OAAO,EAAEZ,SAAS,CAACY,OAAO;MAC1BC,OAAO,EAAEb,SAAS,CAACa,OAAO;MAC1BR,OAAO,EAAEL,SAAS,CAACK,OAAO;MAC1BC,OAAO,EAAEN,SAAS,CAACM,OAAO;MAC1BE,KAAK,EAAER,SAAS,CAACQ,KAAK;MACtBC,MAAM,EAAET,SAAS,CAACS;IACtB,CAAC,CAAC;EACN,CAAC;EAED,IAAG/H,aAAa,EAAE;IACd;;IAEAL,YAAY,CAACiK,IAAI,CAAC,UAASxL,EAAE,EAAE;MAC3B0E,iBAAiB,CAAC3E,MAAM,CAACC,EAAE,CAAC,CAAC,GAAG;QAC5B2D,EAAE,EAAE3D,EAAE,CAAC2D,EAAE;QACTC,EAAE,EAAE5D,EAAE,CAAC4D,EAAE;QACTC,EAAE,EAAE7D,EAAE,CAAC6D,EAAE;QACTC,EAAE,EAAE9D,EAAE,CAAC8D;MACX,CAAC;MAED,IAAG9D,EAAE,CAACkJ,SAAS,EAAE;QACbxE,iBAAiB,CAAC3E,MAAM,CAACC,EAAE,CAAC,CAAC,CAACkJ,SAAS,GAAG;UACtCU,KAAK,EAAE5J,EAAE,CAACkJ,SAAS,CAACU,KAAK;UACzBC,KAAK,EAAE7J,EAAE,CAACkJ,SAAS,CAACW,KAAK;UACzBC,OAAO,EAAE9J,EAAE,CAACkJ,SAAS,CAACY,OAAO;UAC7BC,OAAO,EAAE/J,EAAE,CAACkJ,SAAS,CAACa,OAAO;UAC7BR,OAAO,EAAEvJ,EAAE,CAACkJ,SAAS,CAACK,OAAO;UAC7BC,OAAO,EAAExJ,EAAE,CAACkJ,SAAS,CAACM,OAAO;UAC7BE,KAAK,EAAE1J,EAAE,CAACkJ,SAAS,CAACQ,KAAK;UACzBC,MAAM,EAAE3J,EAAE,CAACkJ,SAAS,CAACS;QACzB,CAAC;MACL;IACJ,CAAC,CAAC;IAEFlI,cAAc,CAAC+J,IAAI,CAAC,UAASxL,EAAE,EAAE;MAC7B2E,gBAAgB,CAAC5E,MAAM,CAACC,EAAE,CAAC,CAAC,GAAG;QAC3B2D,EAAE,EAAE3D,EAAE,CAAC2D,EAAE;QACTC,EAAE,EAAE5D,EAAE,CAAC4D,EAAE;QACTC,EAAE,EAAE7D,EAAE,CAAC6D,EAAE;QACTC,EAAE,EAAE9D,EAAE,CAAC8D;MACX,CAAC;MAED,IAAG9D,EAAE,CAACkJ,SAAS,EAAE;QACbvE,gBAAgB,CAAC5E,MAAM,CAACC,EAAE,CAAC,CAAC,CAACkJ,SAAS,GAAG;UACrCU,KAAK,EAAE5J,EAAE,CAACkJ,SAAS,CAACU,KAAK;UACzBC,KAAK,EAAE7J,EAAE,CAACkJ,SAAS,CAACW,KAAK;UACzBC,OAAO,EAAE9J,EAAE,CAACkJ,SAAS,CAACY,OAAO;UAC7BC,OAAO,EAAE/J,EAAE,CAACkJ,SAAS,CAACa,OAAO;UAC7BR,OAAO,EAAEvJ,EAAE,CAACkJ,SAAS,CAACK,OAAO;UAC7BC,OAAO,EAAExJ,EAAE,CAACkJ,SAAS,CAACM,OAAO;UAC7BE,KAAK,EAAE1J,EAAE,CAACkJ,SAAS,CAACQ,KAAK;UACzBC,MAAM,EAAE3J,EAAE,CAACkJ,SAAS,CAACS;QACzB,CAAC;MACL;MAEA,IAAG,CAAClF,SAAS,IAAInF,OAAO,CAAC4M,OAAO,CAAClM,EAAE,CAAC,EAAE;QAClCyE,SAAS,GAAGzE,EAAE;MAClB;IACJ,CAAC,CAAC;EACN;EAEA4E,eAAe,GAAGlE,eAAe,CAACJ,EAAE,EAAEC,EAAE,EAAEW,KAAK,EAAEO,cAAc,EAAE;IAC7D2B,KAAK,EAAEb,GAAG;IACV8I,MAAM,EAAE3I,GAAG;IAEXyJ,KAAK,EAAExG,QAAQ;IACfyG,KAAK,EAAExG,QAAQ;IAEfwF,SAAS,EAAEvD,cAAc;IACzBU,iBAAiB,EAAEA,iBAAiB;IAEpC9D,SAAS,EAAEA,SAAS;IACpBgG,2BAA2B,EAAEA,2BAA2B;IACxDM,0BAA0B,EAAEA,0BAA0B;IAEtDG,gBAAgB,EAAEA,gBAAgB;IAClCtJ,aAAa,EAAEA,aAAa;IAC5BoK,YAAY,EAAEA;EAClB,CAAC,CAAC;EAEF,IAAGlL,KAAK,CAACiC,OAAO,CAACQ,OAAO,EAAE;IACtBzD,aAAa,CAACQ,EAAE,EAAEC,EAAE,EAAEW,KAAK,EAAEK,YAAY,EAAE;MACvC+B,OAAO,EAAEA,OAAO;MAChBF,KAAK,EAAEP,IAAI;MACXwI,MAAM,EAAEvI,IAAI;MAEZqJ,KAAK,EAAEpG,QAAQ;MACfqG,KAAK,EAAEpG,QAAQ;MAEfoF,SAAS,EAAE5E,YAAY;MACvB+B,iBAAiB,EAAEA,iBAAiB;MAEpCkC,2BAA2B,EAAEA,2BAA2B;MACxDM,0BAA0B,EAAEA,0BAA0B;MAEtDG,gBAAgB,EAAEA,gBAAgB;MAClCtJ,aAAa,EAAEA,aAAa;MAC5BoK,YAAY,EAAEA;IAClB,CAAC,CAAC;EACN,CAAC,MAAM;IACHzK,YAAY,CAACG,MAAM,CAAC,CAAC;EACzB;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}