{"ast":null,"code":"'use strict';\n\nvar vertexShaderSource = ['precision highp float;', '', 'varying vec4 fragColor;', '', 'attribute vec4 p01_04, p05_08, p09_12, p13_16,', '               p17_20, p21_24, p25_28, p29_32,', '               p33_36, p37_40, p41_44, p45_48,', '               p49_52, p53_56, p57_60, colors;', '', 'uniform mat4 dim0A, dim1A, dim0B, dim1B, dim0C, dim1C, dim0D, dim1D,', '             loA, hiA, loB, hiB, loC, hiC, loD, hiD;', '', 'uniform vec2 resolution, viewBoxPos, viewBoxSize;', 'uniform float maskHeight;', 'uniform float drwLayer; // 0: context, 1: focus, 2: pick', 'uniform vec4 contextColor;', 'uniform sampler2D maskTexture, palette;', '', 'bool isPick    = (drwLayer > 1.5);', 'bool isContext = (drwLayer < 0.5);', '', 'const vec4 ZEROS = vec4(0.0, 0.0, 0.0, 0.0);', 'const vec4 UNITS = vec4(1.0, 1.0, 1.0, 1.0);', '', 'float val(mat4 p, mat4 v) {', '    return dot(matrixCompMult(p, v) * UNITS, UNITS);', '}', '', 'float axisY(float ratio, mat4 A, mat4 B, mat4 C, mat4 D) {', '    float y1 = val(A, dim0A) + val(B, dim0B) + val(C, dim0C) + val(D, dim0D);', '    float y2 = val(A, dim1A) + val(B, dim1B) + val(C, dim1C) + val(D, dim1D);', '    return y1 * (1.0 - ratio) + y2 * ratio;', '}', '', 'int iMod(int a, int b) {', '    return a - b * (a / b);', '}', '', 'bool fOutside(float p, float lo, float hi) {', '    return (lo < hi) && (lo > p || p > hi);', '}', '', 'bool vOutside(vec4 p, vec4 lo, vec4 hi) {', '    return (', '        fOutside(p[0], lo[0], hi[0]) ||', '        fOutside(p[1], lo[1], hi[1]) ||', '        fOutside(p[2], lo[2], hi[2]) ||', '        fOutside(p[3], lo[3], hi[3])', '    );', '}', '', 'bool mOutside(mat4 p, mat4 lo, mat4 hi) {', '    return (', '        vOutside(p[0], lo[0], hi[0]) ||', '        vOutside(p[1], lo[1], hi[1]) ||', '        vOutside(p[2], lo[2], hi[2]) ||', '        vOutside(p[3], lo[3], hi[3])', '    );', '}', '', 'bool outsideBoundingBox(mat4 A, mat4 B, mat4 C, mat4 D) {', '    return mOutside(A, loA, hiA) ||', '           mOutside(B, loB, hiB) ||', '           mOutside(C, loC, hiC) ||', '           mOutside(D, loD, hiD);', '}', '', 'bool outsideRasterMask(mat4 A, mat4 B, mat4 C, mat4 D) {', '    mat4 pnts[4];', '    pnts[0] = A;', '    pnts[1] = B;', '    pnts[2] = C;', '    pnts[3] = D;', '', '    for(int i = 0; i < 4; ++i) {', '        for(int j = 0; j < 4; ++j) {', '            for(int k = 0; k < 4; ++k) {', '                if(0 == iMod(', '                    int(255.0 * texture2D(maskTexture,', '                        vec2(', '                            (float(i * 2 + j / 2) + 0.5) / 8.0,', '                            (pnts[i][j][k] * (maskHeight - 1.0) + 1.0) / maskHeight', '                        ))[3]', '                    ) / int(pow(2.0, float(iMod(j * 4 + k, 8)))),', '                    2', '                )) return true;', '            }', '        }', '    }', '    return false;', '}', '', 'vec4 position(bool isContext, float v, mat4 A, mat4 B, mat4 C, mat4 D) {', '    float x = 0.5 * sign(v) + 0.5;', '    float y = axisY(x, A, B, C, D);', '    float z = 1.0 - abs(v);', '', '    z += isContext ? 0.0 : 2.0 * float(', '        outsideBoundingBox(A, B, C, D) ||', '        outsideRasterMask(A, B, C, D)', '    );', '', '    return vec4(', '        2.0 * (vec2(x, y) * viewBoxSize + viewBoxPos) / resolution - 1.0,', '        z,', '        1.0', '    );', '}', '', 'void main() {', '    mat4 A = mat4(p01_04, p05_08, p09_12, p13_16);', '    mat4 B = mat4(p17_20, p21_24, p25_28, p29_32);', '    mat4 C = mat4(p33_36, p37_40, p41_44, p45_48);', '    mat4 D = mat4(p49_52, p53_56, p57_60, ZEROS);', '', '    float v = colors[3];', '', '    gl_Position = position(isContext, v, A, B, C, D);', '', '    fragColor =', '        isContext ? vec4(contextColor) :', '        isPick ? vec4(colors.rgb, 1.0) : texture2D(palette, vec2(abs(v), 0.5));', '}'].join('\\n');\nvar fragmentShaderSource = ['precision highp float;', '', 'varying vec4 fragColor;', '', 'void main() {', '    gl_FragColor = fragColor;', '}'].join('\\n');\nvar maxDim = require('./constants').maxDimensionCount;\nvar Lib = require('../../lib');\n\n// don't change; otherwise near/far plane lines are lost\nvar depthLimitEpsilon = 1e-6;\n\n// precision of multiselect is the full range divided into this many parts\nvar maskHeight = 2048;\nvar dummyPixel = new Uint8Array(4);\nvar dataPixel = new Uint8Array(4);\nvar paletteTextureConfig = {\n  shape: [256, 1],\n  format: 'rgba',\n  type: 'uint8',\n  mag: 'nearest',\n  min: 'nearest'\n};\nfunction ensureDraw(regl) {\n  regl.read({\n    x: 0,\n    y: 0,\n    width: 1,\n    height: 1,\n    data: dummyPixel\n  });\n}\nfunction clear(regl, x, y, width, height) {\n  var gl = regl._gl;\n  gl.enable(gl.SCISSOR_TEST);\n  gl.scissor(x, y, width, height);\n  regl.clear({\n    color: [0, 0, 0, 0],\n    depth: 1\n  }); // clearing is done in scissored panel only\n}\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n  var rafKey = item.key;\n  function render(blockNumber) {\n    var count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n    if (blockNumber === 0) {\n      // stop drawing possibly stale glyphs before clearing\n      window.cancelAnimationFrame(renderState.currentRafs[rafKey]);\n      delete renderState.currentRafs[rafKey];\n      clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n    }\n    if (renderState.clearOnly) {\n      return;\n    }\n    item.count = 2 * count;\n    item.offset = 2 * blockNumber * blockLineCount;\n    glAes(item);\n    if (blockNumber * blockLineCount + count < sampleCount) {\n      renderState.currentRafs[rafKey] = window.requestAnimationFrame(function () {\n        render(blockNumber + 1);\n      });\n    }\n    renderState.drawCompleted = false;\n  }\n  if (!renderState.drawCompleted) {\n    ensureDraw(regl);\n    renderState.drawCompleted = true;\n  }\n\n  // start with rendering item 0; recursion handles the rest\n  render(0);\n}\nfunction adjustDepth(d) {\n  // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n  // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n  // near or the far plane.\n  return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\nfunction palette(unitToColor, opacity) {\n  var result = new Array(256);\n  for (var i = 0; i < 256; i++) {\n    result[i] = unitToColor(i / 255).concat(opacity);\n  }\n  return result;\n}\n\n// Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\nfunction calcPickColor(i, rgbIndex) {\n  return (i >>> 8 * rgbIndex) % 256 / 255;\n}\nfunction makePoints(sampleCount, dims, color) {\n  var points = new Array(sampleCount * (maxDim + 4));\n  var n = 0;\n  for (var i = 0; i < sampleCount; i++) {\n    for (var k = 0; k < maxDim; k++) {\n      points[n++] = k < dims.length ? dims[k].paddedUnitValues[i] : 0.5;\n    }\n    points[n++] = calcPickColor(i, 2);\n    points[n++] = calcPickColor(i, 1);\n    points[n++] = calcPickColor(i, 0);\n    points[n++] = adjustDepth(color[i]);\n  }\n  return points;\n}\nfunction makeVecAttr(vecIndex, sampleCount, points) {\n  var pointPairs = new Array(sampleCount * 8);\n  var n = 0;\n  for (var i = 0; i < sampleCount; i++) {\n    for (var j = 0; j < 2; j++) {\n      for (var k = 0; k < 4; k++) {\n        var q = vecIndex * 4 + k;\n        var v = points[i * 64 + q];\n        if (q === 63 && j === 0) {\n          v *= -1;\n        }\n        pointPairs[n++] = v;\n      }\n    }\n  }\n  return pointPairs;\n}\nfunction pad2(num) {\n  var s = '0' + num;\n  return s.substr(s.length - 2);\n}\nfunction getAttrName(i) {\n  return i < maxDim ? 'p' + pad2(i + 1) + '_' + pad2(i + 4) : 'colors';\n}\nfunction setAttributes(attributes, sampleCount, points) {\n  for (var i = 0; i <= maxDim; i += 4) {\n    attributes[getAttrName(i)](makeVecAttr(i / 4, sampleCount, points));\n  }\n}\nfunction emptyAttributes(regl) {\n  var attributes = {};\n  for (var i = 0; i <= maxDim; i += 4) {\n    attributes[getAttrName(i)] = regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array(0)\n    });\n  }\n  return attributes;\n}\nfunction makeItem(model, leftmost, rightmost, itemNumber, i0, i1, x, y, panelSizeX, panelSizeY, crossfilterDimensionIndex, drwLayer, constraints, plotGlPixelRatio) {\n  var dims = [[], []];\n  for (var k = 0; k < 64; k++) {\n    dims[0][k] = k === i0 ? 1 : 0;\n    dims[1][k] = k === i1 ? 1 : 0;\n  }\n  x *= plotGlPixelRatio;\n  y *= plotGlPixelRatio;\n  panelSizeX *= plotGlPixelRatio;\n  panelSizeY *= plotGlPixelRatio;\n  var overdrag = model.lines.canvasOverdrag * plotGlPixelRatio;\n  var domain = model.domain;\n  var canvasWidth = model.canvasWidth * plotGlPixelRatio;\n  var canvasHeight = model.canvasHeight * plotGlPixelRatio;\n  var padL = model.pad.l * plotGlPixelRatio;\n  var padB = model.pad.b * plotGlPixelRatio;\n  var layoutHeight = model.layoutHeight * plotGlPixelRatio;\n  var layoutWidth = model.layoutWidth * plotGlPixelRatio;\n  var deselectedLinesColor = model.deselectedLines.color;\n  var deselectedLinesOpacity = model.deselectedLines.opacity;\n  var itemModel = Lib.extendFlat({\n    key: crossfilterDimensionIndex,\n    resolution: [canvasWidth, canvasHeight],\n    viewBoxPos: [x + overdrag, y],\n    viewBoxSize: [panelSizeX, panelSizeY],\n    i0: i0,\n    i1: i1,\n    dim0A: dims[0].slice(0, 16),\n    dim0B: dims[0].slice(16, 32),\n    dim0C: dims[0].slice(32, 48),\n    dim0D: dims[0].slice(48, 64),\n    dim1A: dims[1].slice(0, 16),\n    dim1B: dims[1].slice(16, 32),\n    dim1C: dims[1].slice(32, 48),\n    dim1D: dims[1].slice(48, 64),\n    drwLayer: drwLayer,\n    contextColor: [deselectedLinesColor[0] / 255, deselectedLinesColor[1] / 255, deselectedLinesColor[2] / 255, deselectedLinesOpacity !== 'auto' ? deselectedLinesColor[3] * deselectedLinesOpacity : Math.max(1 / 255, Math.pow(1 / model.lines.color.length, 1 / 3))],\n    scissorX: (itemNumber === leftmost ? 0 : x + overdrag) + (padL - overdrag) + layoutWidth * domain.x[0],\n    scissorWidth: (itemNumber === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (itemNumber === leftmost ? x + overdrag : 0),\n    scissorY: y + padB + layoutHeight * domain.y[0],\n    scissorHeight: panelSizeY,\n    viewportX: padL - overdrag + layoutWidth * domain.x[0],\n    viewportY: padB + layoutHeight * domain.y[0],\n    viewportWidth: canvasWidth,\n    viewportHeight: canvasHeight\n  }, constraints);\n  return itemModel;\n}\nfunction expandedPixelRange(bounds) {\n  var dh = maskHeight - 1;\n  var a = Math.max(0, Math.floor(bounds[0] * dh), 0);\n  var b = Math.min(dh, Math.ceil(bounds[1] * dh), dh);\n  return [Math.min(a, b), Math.max(a, b)];\n}\nmodule.exports = function (canvasGL, d) {\n  // context & pick describe which canvas we're talking about - won't change with new data\n  var isContext = d.context;\n  var isPick = d.pick;\n  var regl = d.regl;\n  var gl = regl._gl;\n  var supportedLineWidth = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);\n  // ensure here that plotGlPixelRatio is within supported range; otherwise regl throws error\n  var plotGlPixelRatio = Math.max(supportedLineWidth[0], Math.min(supportedLineWidth[1], d.viewModel.plotGlPixelRatio));\n  var renderState = {\n    currentRafs: {},\n    drawCompleted: true,\n    clearOnly: false\n  };\n\n  // state to be set by update and used later\n  var model;\n  var vm;\n  var initialDims;\n  var sampleCount;\n  var attributes = emptyAttributes(regl);\n  var maskTexture;\n  var paletteTexture = regl.texture(paletteTextureConfig);\n  var prevAxisOrder = [];\n  update(d);\n  var glAes = regl({\n    profile: false,\n    blend: {\n      enable: isContext,\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 1,\n        dstAlpha: 1 // 'one minus src alpha'\n      },\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      color: [0, 0, 0, 0]\n    },\n    depth: {\n      enable: !isContext,\n      mask: true,\n      func: 'less',\n      range: [0, 1]\n    },\n    // for polygons\n    cull: {\n      enable: true,\n      face: 'back'\n    },\n    scissor: {\n      enable: true,\n      box: {\n        x: regl.prop('scissorX'),\n        y: regl.prop('scissorY'),\n        width: regl.prop('scissorWidth'),\n        height: regl.prop('scissorHeight')\n      }\n    },\n    viewport: {\n      x: regl.prop('viewportX'),\n      y: regl.prop('viewportY'),\n      width: regl.prop('viewportWidth'),\n      height: regl.prop('viewportHeight')\n    },\n    dither: false,\n    vert: vertexShaderSource,\n    frag: fragmentShaderSource,\n    primitive: 'lines',\n    lineWidth: plotGlPixelRatio,\n    attributes: attributes,\n    uniforms: {\n      resolution: regl.prop('resolution'),\n      viewBoxPos: regl.prop('viewBoxPos'),\n      viewBoxSize: regl.prop('viewBoxSize'),\n      dim0A: regl.prop('dim0A'),\n      dim1A: regl.prop('dim1A'),\n      dim0B: regl.prop('dim0B'),\n      dim1B: regl.prop('dim1B'),\n      dim0C: regl.prop('dim0C'),\n      dim1C: regl.prop('dim1C'),\n      dim0D: regl.prop('dim0D'),\n      dim1D: regl.prop('dim1D'),\n      loA: regl.prop('loA'),\n      hiA: regl.prop('hiA'),\n      loB: regl.prop('loB'),\n      hiB: regl.prop('hiB'),\n      loC: regl.prop('loC'),\n      hiC: regl.prop('hiC'),\n      loD: regl.prop('loD'),\n      hiD: regl.prop('hiD'),\n      palette: paletteTexture,\n      contextColor: regl.prop('contextColor'),\n      maskTexture: regl.prop('maskTexture'),\n      drwLayer: regl.prop('drwLayer'),\n      maskHeight: regl.prop('maskHeight')\n    },\n    offset: regl.prop('offset'),\n    count: regl.prop('count')\n  });\n  function update(dNew) {\n    model = dNew.model;\n    vm = dNew.viewModel;\n    initialDims = vm.dimensions.slice();\n    sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n    var lines = model.lines;\n    var color = isPick ? lines.color.map(function (_, i) {\n      return i / lines.color.length;\n    }) : lines.color;\n    var points = makePoints(sampleCount, initialDims, color);\n    setAttributes(attributes, sampleCount, points);\n    if (!isContext && !isPick) {\n      paletteTexture = regl.texture(Lib.extendFlat({\n        data: palette(model.unitToColor, 255)\n      }, paletteTextureConfig));\n    }\n  }\n  function makeConstraints(isContext) {\n    var i, j, k;\n    var limits = [[], []];\n    for (k = 0; k < 64; k++) {\n      var p = !isContext && k < initialDims.length ? initialDims[k].brush.filter.getBounds() : [-Infinity, Infinity];\n      limits[0][k] = p[0];\n      limits[1][k] = p[1];\n    }\n    var len = maskHeight * 8;\n    var mask = new Array(len);\n    for (i = 0; i < len; i++) {\n      mask[i] = 255;\n    }\n    if (!isContext) {\n      for (i = 0; i < initialDims.length; i++) {\n        var u = i % 8;\n        var v = (i - u) / 8;\n        var bitMask = Math.pow(2, u);\n        var dim = initialDims[i];\n        var ranges = dim.brush.filter.get();\n        if (ranges.length < 2) continue; // bail if the bounding box based filter is sufficient\n\n        var prevEnd = expandedPixelRange(ranges[0])[1];\n        for (j = 1; j < ranges.length; j++) {\n          var nextRange = expandedPixelRange(ranges[j]);\n          for (k = prevEnd + 1; k < nextRange[0]; k++) {\n            mask[k * 8 + v] &= ~bitMask;\n          }\n          prevEnd = Math.max(prevEnd, nextRange[1]);\n        }\n      }\n    }\n    var textureData = {\n      // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support\n      shape: [8, maskHeight],\n      format: 'alpha',\n      type: 'uint8',\n      mag: 'nearest',\n      min: 'nearest',\n      data: mask\n    };\n    if (maskTexture) maskTexture(textureData);else maskTexture = regl.texture(textureData);\n    return {\n      maskTexture: maskTexture,\n      maskHeight: maskHeight,\n      loA: limits[0].slice(0, 16),\n      loB: limits[0].slice(16, 32),\n      loC: limits[0].slice(32, 48),\n      loD: limits[0].slice(48, 64),\n      hiA: limits[1].slice(0, 16),\n      hiB: limits[1].slice(16, 32),\n      hiC: limits[1].slice(32, 48),\n      hiD: limits[1].slice(48, 64)\n    };\n  }\n  function renderGLParcoords(panels, setChanged, clearOnly) {\n    var panelCount = panels.length;\n    var i;\n    var leftmost;\n    var rightmost;\n    var lowestX = Infinity;\n    var highestX = -Infinity;\n    for (i = 0; i < panelCount; i++) {\n      if (panels[i].dim0.canvasX < lowestX) {\n        lowestX = panels[i].dim0.canvasX;\n        leftmost = i;\n      }\n      if (panels[i].dim1.canvasX > highestX) {\n        highestX = panels[i].dim1.canvasX;\n        rightmost = i;\n      }\n    }\n    if (panelCount === 0) {\n      // clear canvas here, as the panel iteration below will not enter the loop body\n      clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);\n    }\n    var constraints = makeConstraints(isContext);\n    for (i = 0; i < panelCount; i++) {\n      var p = panels[i];\n      var i0 = p.dim0.crossfilterDimensionIndex;\n      var i1 = p.dim1.crossfilterDimensionIndex;\n      var x = p.canvasX;\n      var y = p.canvasY;\n      var nextX = x + p.panelSizeX;\n      var plotGlPixelRatio = p.plotGlPixelRatio;\n      if (setChanged || !prevAxisOrder[i0] || prevAxisOrder[i0][0] !== x || prevAxisOrder[i0][1] !== nextX) {\n        prevAxisOrder[i0] = [x, nextX];\n        var item = makeItem(model, leftmost, rightmost, i, i0, i1, x, y, p.panelSizeX, p.panelSizeY, p.dim0.crossfilterDimensionIndex, isContext ? 0 : isPick ? 2 : 1, constraints, plotGlPixelRatio);\n        renderState.clearOnly = clearOnly;\n        var blockLineCount = setChanged ? model.lines.blockLineCount : sampleCount;\n        renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item);\n      }\n    }\n  }\n  function readPixel(canvasX, canvasY) {\n    regl.read({\n      x: canvasX,\n      y: canvasY,\n      width: 1,\n      height: 1,\n      data: dataPixel\n    });\n    return dataPixel;\n  }\n  function readPixels(canvasX, canvasY, width, height) {\n    var pixelArray = new Uint8Array(4 * width * height);\n    regl.read({\n      x: canvasX,\n      y: canvasY,\n      width: width,\n      height: height,\n      data: pixelArray\n    });\n    return pixelArray;\n  }\n  function destroy() {\n    canvasGL.style['pointer-events'] = 'none';\n    paletteTexture.destroy();\n    if (maskTexture) maskTexture.destroy();\n    for (var k in attributes) attributes[k].destroy();\n  }\n  return {\n    render: renderGLParcoords,\n    readPixel: readPixel,\n    readPixels: readPixels,\n    destroy: destroy,\n    update: update\n  };\n};","map":{"version":3,"names":["vertexShaderSource","join","fragmentShaderSource","maxDim","require","maxDimensionCount","Lib","depthLimitEpsilon","maskHeight","dummyPixel","Uint8Array","dataPixel","paletteTextureConfig","shape","format","type","mag","min","ensureDraw","regl","read","x","y","width","height","data","clear","gl","_gl","enable","SCISSOR_TEST","scissor","color","depth","renderBlock","glAes","renderState","blockLineCount","sampleCount","item","rafKey","key","render","blockNumber","count","Math","window","cancelAnimationFrame","currentRafs","scissorX","scissorY","scissorWidth","viewBoxSize","clearOnly","offset","requestAnimationFrame","drawCompleted","adjustDepth","d","max","palette","unitToColor","opacity","result","Array","i","concat","calcPickColor","rgbIndex","makePoints","dims","points","n","k","length","paddedUnitValues","makeVecAttr","vecIndex","pointPairs","j","q","v","pad2","num","s","substr","getAttrName","setAttributes","attributes","emptyAttributes","buffer","usage","makeItem","model","leftmost","rightmost","itemNumber","i0","i1","panelSizeX","panelSizeY","crossfilterDimensionIndex","drwLayer","constraints","plotGlPixelRatio","overdrag","lines","canvasOverdrag","domain","canvasWidth","canvasHeight","padL","pad","l","padB","b","layoutHeight","layoutWidth","deselectedLinesColor","deselectedLines","deselectedLinesOpacity","itemModel","extendFlat","resolution","viewBoxPos","dim0A","slice","dim0B","dim0C","dim0D","dim1A","dim1B","dim1C","dim1D","contextColor","pow","scissorHeight","viewportX","viewportY","viewportWidth","viewportHeight","expandedPixelRange","bounds","dh","a","floor","ceil","module","exports","canvasGL","isContext","context","isPick","pick","supportedLineWidth","getParameter","ALIASED_LINE_WIDTH_RANGE","viewModel","vm","initialDims","maskTexture","paletteTexture","texture","prevAxisOrder","update","profile","blend","func","srcRGB","dstRGB","srcAlpha","dstAlpha","equation","rgb","alpha","mask","range","cull","face","box","prop","viewport","dither","vert","frag","primitive","lineWidth","uniforms","loA","hiA","loB","hiB","loC","hiC","loD","hiD","dNew","dimensions","values","map","_","makeConstraints","limits","p","brush","filter","getBounds","Infinity","len","u","bitMask","dim","ranges","get","prevEnd","nextRange","textureData","renderGLParcoords","panels","setChanged","panelCount","lowestX","highestX","dim0","canvasX","dim1","canvasY","nextX","readPixel","readPixels","pixelArray","destroy","style"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/parcoords/lines.js"],"sourcesContent":["'use strict';\n\nvar vertexShaderSource = [\n    'precision highp float;',\n    '',\n    'varying vec4 fragColor;',\n    '',\n    'attribute vec4 p01_04, p05_08, p09_12, p13_16,',\n    '               p17_20, p21_24, p25_28, p29_32,',\n    '               p33_36, p37_40, p41_44, p45_48,',\n    '               p49_52, p53_56, p57_60, colors;',\n    '',\n    'uniform mat4 dim0A, dim1A, dim0B, dim1B, dim0C, dim1C, dim0D, dim1D,',\n    '             loA, hiA, loB, hiB, loC, hiC, loD, hiD;',\n    '',\n    'uniform vec2 resolution, viewBoxPos, viewBoxSize;',\n    'uniform float maskHeight;',\n    'uniform float drwLayer; // 0: context, 1: focus, 2: pick',\n    'uniform vec4 contextColor;',\n    'uniform sampler2D maskTexture, palette;',\n    '',\n    'bool isPick    = (drwLayer > 1.5);',\n    'bool isContext = (drwLayer < 0.5);',\n    '',\n    'const vec4 ZEROS = vec4(0.0, 0.0, 0.0, 0.0);',\n    'const vec4 UNITS = vec4(1.0, 1.0, 1.0, 1.0);',\n    '',\n    'float val(mat4 p, mat4 v) {',\n    '    return dot(matrixCompMult(p, v) * UNITS, UNITS);',\n    '}',\n    '',\n    'float axisY(float ratio, mat4 A, mat4 B, mat4 C, mat4 D) {',\n    '    float y1 = val(A, dim0A) + val(B, dim0B) + val(C, dim0C) + val(D, dim0D);',\n    '    float y2 = val(A, dim1A) + val(B, dim1B) + val(C, dim1C) + val(D, dim1D);',\n    '    return y1 * (1.0 - ratio) + y2 * ratio;',\n    '}',\n    '',\n    'int iMod(int a, int b) {',\n    '    return a - b * (a / b);',\n    '}',\n    '',\n    'bool fOutside(float p, float lo, float hi) {',\n    '    return (lo < hi) && (lo > p || p > hi);',\n    '}',\n    '',\n    'bool vOutside(vec4 p, vec4 lo, vec4 hi) {',\n    '    return (',\n    '        fOutside(p[0], lo[0], hi[0]) ||',\n    '        fOutside(p[1], lo[1], hi[1]) ||',\n    '        fOutside(p[2], lo[2], hi[2]) ||',\n    '        fOutside(p[3], lo[3], hi[3])',\n    '    );',\n    '}',\n    '',\n    'bool mOutside(mat4 p, mat4 lo, mat4 hi) {',\n    '    return (',\n    '        vOutside(p[0], lo[0], hi[0]) ||',\n    '        vOutside(p[1], lo[1], hi[1]) ||',\n    '        vOutside(p[2], lo[2], hi[2]) ||',\n    '        vOutside(p[3], lo[3], hi[3])',\n    '    );',\n    '}',\n    '',\n    'bool outsideBoundingBox(mat4 A, mat4 B, mat4 C, mat4 D) {',\n    '    return mOutside(A, loA, hiA) ||',\n    '           mOutside(B, loB, hiB) ||',\n    '           mOutside(C, loC, hiC) ||',\n    '           mOutside(D, loD, hiD);',\n    '}',\n    '',\n    'bool outsideRasterMask(mat4 A, mat4 B, mat4 C, mat4 D) {',\n    '    mat4 pnts[4];',\n    '    pnts[0] = A;',\n    '    pnts[1] = B;',\n    '    pnts[2] = C;',\n    '    pnts[3] = D;',\n    '',\n    '    for(int i = 0; i < 4; ++i) {',\n    '        for(int j = 0; j < 4; ++j) {',\n    '            for(int k = 0; k < 4; ++k) {',\n    '                if(0 == iMod(',\n    '                    int(255.0 * texture2D(maskTexture,',\n    '                        vec2(',\n    '                            (float(i * 2 + j / 2) + 0.5) / 8.0,',\n    '                            (pnts[i][j][k] * (maskHeight - 1.0) + 1.0) / maskHeight',\n    '                        ))[3]',\n    '                    ) / int(pow(2.0, float(iMod(j * 4 + k, 8)))),',\n    '                    2',\n    '                )) return true;',\n    '            }',\n    '        }',\n    '    }',\n    '    return false;',\n    '}',\n    '',\n    'vec4 position(bool isContext, float v, mat4 A, mat4 B, mat4 C, mat4 D) {',\n    '    float x = 0.5 * sign(v) + 0.5;',\n    '    float y = axisY(x, A, B, C, D);',\n    '    float z = 1.0 - abs(v);',\n    '',\n    '    z += isContext ? 0.0 : 2.0 * float(',\n    '        outsideBoundingBox(A, B, C, D) ||',\n    '        outsideRasterMask(A, B, C, D)',\n    '    );',\n    '',\n    '    return vec4(',\n    '        2.0 * (vec2(x, y) * viewBoxSize + viewBoxPos) / resolution - 1.0,',\n    '        z,',\n    '        1.0',\n    '    );',\n    '}',\n    '',\n    'void main() {',\n    '    mat4 A = mat4(p01_04, p05_08, p09_12, p13_16);',\n    '    mat4 B = mat4(p17_20, p21_24, p25_28, p29_32);',\n    '    mat4 C = mat4(p33_36, p37_40, p41_44, p45_48);',\n    '    mat4 D = mat4(p49_52, p53_56, p57_60, ZEROS);',\n    '',\n    '    float v = colors[3];',\n    '',\n    '    gl_Position = position(isContext, v, A, B, C, D);',\n    '',\n    '    fragColor =',\n    '        isContext ? vec4(contextColor) :',\n    '        isPick ? vec4(colors.rgb, 1.0) : texture2D(palette, vec2(abs(v), 0.5));',\n    '}'\n].join('\\n');\n\nvar fragmentShaderSource = [\n    'precision highp float;',\n    '',\n    'varying vec4 fragColor;',\n    '',\n    'void main() {',\n    '    gl_FragColor = fragColor;',\n    '}'\n].join('\\n');\n\nvar maxDim = require('./constants').maxDimensionCount;\n\nvar Lib = require('../../lib');\n\n// don't change; otherwise near/far plane lines are lost\nvar depthLimitEpsilon = 1e-6;\n\n// precision of multiselect is the full range divided into this many parts\nvar maskHeight = 2048;\n\nvar dummyPixel = new Uint8Array(4);\nvar dataPixel = new Uint8Array(4);\n\nvar paletteTextureConfig = {\n    shape: [256, 1],\n    format: 'rgba',\n    type: 'uint8',\n    mag: 'nearest',\n    min: 'nearest'\n};\n\nfunction ensureDraw(regl) {\n    regl.read({\n        x: 0,\n        y: 0,\n        width: 1,\n        height: 1,\n        data: dummyPixel\n    });\n}\n\nfunction clear(regl, x, y, width, height) {\n    var gl = regl._gl;\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(x, y, width, height);\n    regl.clear({color: [0, 0, 0, 0], depth: 1}); // clearing is done in scissored panel only\n}\n\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n    var rafKey = item.key;\n\n    function render(blockNumber) {\n        var count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n\n        if(blockNumber === 0) {\n            // stop drawing possibly stale glyphs before clearing\n            window.cancelAnimationFrame(renderState.currentRafs[rafKey]);\n            delete renderState.currentRafs[rafKey];\n            clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n        }\n\n        if(renderState.clearOnly) {\n            return;\n        }\n\n        item.count = 2 * count;\n        item.offset = 2 * blockNumber * blockLineCount;\n        glAes(item);\n\n        if(blockNumber * blockLineCount + count < sampleCount) {\n            renderState.currentRafs[rafKey] = window.requestAnimationFrame(function() {\n                render(blockNumber + 1);\n            });\n        }\n\n        renderState.drawCompleted = false;\n    }\n\n    if(!renderState.drawCompleted) {\n        ensureDraw(regl);\n        renderState.drawCompleted = true;\n    }\n\n    // start with rendering item 0; recursion handles the rest\n    render(0);\n}\n\nfunction adjustDepth(d) {\n    // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n    // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n    // near or the far plane.\n    return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\n\nfunction palette(unitToColor, opacity) {\n    var result = new Array(256);\n    for(var i = 0; i < 256; i++) {\n        result[i] = unitToColor(i / 255).concat(opacity);\n    }\n    return result;\n}\n\n// Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\nfunction calcPickColor(i, rgbIndex) {\n    return (i >>> 8 * rgbIndex) % 256 / 255;\n}\n\nfunction makePoints(sampleCount, dims, color) {\n    var points = new Array(sampleCount * (maxDim + 4));\n    var n = 0;\n    for(var i = 0; i < sampleCount; i++) {\n        for(var k = 0; k < maxDim; k++) {\n            points[n++] = (k < dims.length) ? dims[k].paddedUnitValues[i] : 0.5;\n        }\n        points[n++] = calcPickColor(i, 2);\n        points[n++] = calcPickColor(i, 1);\n        points[n++] = calcPickColor(i, 0);\n        points[n++] = adjustDepth(color[i]);\n    }\n    return points;\n}\n\nfunction makeVecAttr(vecIndex, sampleCount, points) {\n    var pointPairs = new Array(sampleCount * 8);\n    var n = 0;\n    for(var i = 0; i < sampleCount; i++) {\n        for(var j = 0; j < 2; j++) {\n            for(var k = 0; k < 4; k++) {\n                var q = vecIndex * 4 + k;\n                var v = points[i * 64 + q];\n                if(q === 63 && j === 0) {\n                    v *= -1;\n                }\n                pointPairs[n++] = v;\n            }\n        }\n    }\n    return pointPairs;\n}\n\nfunction pad2(num) {\n    var s = '0' + num;\n    return s.substr(s.length - 2);\n}\n\nfunction getAttrName(i) {\n    return (i < maxDim) ? 'p' + pad2(i + 1) + '_' + pad2(i + 4) : 'colors';\n}\n\nfunction setAttributes(attributes, sampleCount, points) {\n    for(var i = 0; i <= maxDim; i += 4) {\n        attributes[getAttrName(i)](makeVecAttr(i / 4, sampleCount, points));\n    }\n}\n\nfunction emptyAttributes(regl) {\n    var attributes = {};\n    for(var i = 0; i <= maxDim; i += 4) {\n        attributes[getAttrName(i)] = regl.buffer({usage: 'dynamic', type: 'float', data: new Uint8Array(0)});\n    }\n    return attributes;\n}\n\nfunction makeItem(\n    model, leftmost, rightmost, itemNumber, i0, i1, x, y, panelSizeX, panelSizeY,\n    crossfilterDimensionIndex, drwLayer, constraints, plotGlPixelRatio\n) {\n    var dims = [[], []];\n    for(var k = 0; k < 64; k++) {\n        dims[0][k] = (k === i0) ? 1 : 0;\n        dims[1][k] = (k === i1) ? 1 : 0;\n    }\n    x *= plotGlPixelRatio;\n    y *= plotGlPixelRatio;\n    panelSizeX *= plotGlPixelRatio;\n    panelSizeY *= plotGlPixelRatio;\n    var overdrag = model.lines.canvasOverdrag * plotGlPixelRatio;\n    var domain = model.domain;\n    var canvasWidth = model.canvasWidth * plotGlPixelRatio;\n    var canvasHeight = model.canvasHeight * plotGlPixelRatio;\n    var padL = model.pad.l * plotGlPixelRatio;\n    var padB = model.pad.b * plotGlPixelRatio;\n    var layoutHeight = model.layoutHeight * plotGlPixelRatio;\n    var layoutWidth = model.layoutWidth * plotGlPixelRatio;\n\n    var deselectedLinesColor = model.deselectedLines.color;\n    var deselectedLinesOpacity = model.deselectedLines.opacity;\n\n    var itemModel = Lib.extendFlat({\n        key: crossfilterDimensionIndex,\n        resolution: [canvasWidth, canvasHeight],\n        viewBoxPos: [x + overdrag, y],\n        viewBoxSize: [panelSizeX, panelSizeY],\n        i0: i0,\n        i1: i1,\n\n        dim0A: dims[0].slice(0, 16),\n        dim0B: dims[0].slice(16, 32),\n        dim0C: dims[0].slice(32, 48),\n        dim0D: dims[0].slice(48, 64),\n        dim1A: dims[1].slice(0, 16),\n        dim1B: dims[1].slice(16, 32),\n        dim1C: dims[1].slice(32, 48),\n        dim1D: dims[1].slice(48, 64),\n\n        drwLayer: drwLayer,\n        contextColor: [\n            deselectedLinesColor[0] / 255,\n            deselectedLinesColor[1] / 255,\n            deselectedLinesColor[2] / 255,\n            deselectedLinesOpacity !== 'auto' ?\n                deselectedLinesColor[3] * deselectedLinesOpacity :\n                Math.max(1 / 255, Math.pow(1 / model.lines.color.length, 1 / 3))\n        ],\n\n        scissorX: (itemNumber === leftmost ? 0 : x + overdrag) + (padL - overdrag) + layoutWidth * domain.x[0],\n        scissorWidth: (itemNumber === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (itemNumber === leftmost ? x + overdrag : 0),\n        scissorY: y + padB + layoutHeight * domain.y[0],\n        scissorHeight: panelSizeY,\n\n        viewportX: padL - overdrag + layoutWidth * domain.x[0],\n        viewportY: padB + layoutHeight * domain.y[0],\n        viewportWidth: canvasWidth,\n        viewportHeight: canvasHeight\n    }, constraints);\n\n    return itemModel;\n}\n\nfunction expandedPixelRange(bounds) {\n    var dh = maskHeight - 1;\n    var a = Math.max(0, Math.floor(bounds[0] * dh), 0);\n    var b = Math.min(dh, Math.ceil(bounds[1] * dh), dh);\n    return [\n        Math.min(a, b),\n        Math.max(a, b)\n    ];\n}\n\nmodule.exports = function(canvasGL, d) {\n    // context & pick describe which canvas we're talking about - won't change with new data\n    var isContext = d.context;\n    var isPick = d.pick;\n\n    var regl = d.regl;\n    var gl = regl._gl;\n    var supportedLineWidth = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);\n    // ensure here that plotGlPixelRatio is within supported range; otherwise regl throws error\n    var plotGlPixelRatio = Math.max(\n        supportedLineWidth[0],\n        Math.min(\n            supportedLineWidth[1],\n            d.viewModel.plotGlPixelRatio\n        )\n    );\n\n    var renderState = {\n        currentRafs: {},\n        drawCompleted: true,\n        clearOnly: false\n    };\n\n    // state to be set by update and used later\n    var model;\n    var vm;\n    var initialDims;\n    var sampleCount;\n    var attributes = emptyAttributes(regl);\n    var maskTexture;\n    var paletteTexture = regl.texture(paletteTextureConfig);\n\n    var prevAxisOrder = [];\n\n    update(d);\n\n    var glAes = regl({\n\n        profile: false,\n\n        blend: {\n            enable: isContext,\n            func: {\n                srcRGB: 'src alpha',\n                dstRGB: 'one minus src alpha',\n                srcAlpha: 1,\n                dstAlpha: 1 // 'one minus src alpha'\n            },\n            equation: {\n                rgb: 'add',\n                alpha: 'add'\n            },\n            color: [0, 0, 0, 0]\n        },\n\n        depth: {\n            enable: !isContext,\n            mask: true,\n            func: 'less',\n            range: [0, 1]\n        },\n\n        // for polygons\n        cull: {\n            enable: true,\n            face: 'back'\n        },\n\n        scissor: {\n            enable: true,\n            box: {\n                x: regl.prop('scissorX'),\n                y: regl.prop('scissorY'),\n                width: regl.prop('scissorWidth'),\n                height: regl.prop('scissorHeight')\n            }\n        },\n\n        viewport: {\n            x: regl.prop('viewportX'),\n            y: regl.prop('viewportY'),\n            width: regl.prop('viewportWidth'),\n            height: regl.prop('viewportHeight')\n        },\n\n        dither: false,\n\n        vert: vertexShaderSource,\n\n        frag: fragmentShaderSource,\n\n        primitive: 'lines',\n        lineWidth: plotGlPixelRatio,\n        attributes: attributes,\n        uniforms: {\n            resolution: regl.prop('resolution'),\n            viewBoxPos: regl.prop('viewBoxPos'),\n            viewBoxSize: regl.prop('viewBoxSize'),\n            dim0A: regl.prop('dim0A'),\n            dim1A: regl.prop('dim1A'),\n            dim0B: regl.prop('dim0B'),\n            dim1B: regl.prop('dim1B'),\n            dim0C: regl.prop('dim0C'),\n            dim1C: regl.prop('dim1C'),\n            dim0D: regl.prop('dim0D'),\n            dim1D: regl.prop('dim1D'),\n            loA: regl.prop('loA'),\n            hiA: regl.prop('hiA'),\n            loB: regl.prop('loB'),\n            hiB: regl.prop('hiB'),\n            loC: regl.prop('loC'),\n            hiC: regl.prop('hiC'),\n            loD: regl.prop('loD'),\n            hiD: regl.prop('hiD'),\n            palette: paletteTexture,\n            contextColor: regl.prop('contextColor'),\n            maskTexture: regl.prop('maskTexture'),\n            drwLayer: regl.prop('drwLayer'),\n            maskHeight: regl.prop('maskHeight')\n        },\n        offset: regl.prop('offset'),\n        count: regl.prop('count')\n    });\n\n    function update(dNew) {\n        model = dNew.model;\n        vm = dNew.viewModel;\n        initialDims = vm.dimensions.slice();\n        sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n\n        var lines = model.lines;\n        var color = isPick ? lines.color.map(function(_, i) {return i / lines.color.length;}) : lines.color;\n\n        var points = makePoints(sampleCount, initialDims, color);\n        setAttributes(attributes, sampleCount, points);\n\n        if(!isContext && !isPick) {\n            paletteTexture = regl.texture(Lib.extendFlat({\n                data: palette(model.unitToColor, 255)\n            }, paletteTextureConfig));\n        }\n    }\n\n    function makeConstraints(isContext) {\n        var i, j, k;\n\n        var limits = [[], []];\n        for(k = 0; k < 64; k++) {\n            var p = (!isContext && k < initialDims.length) ?\n                initialDims[k].brush.filter.getBounds() : [-Infinity, Infinity];\n\n            limits[0][k] = p[0];\n            limits[1][k] = p[1];\n        }\n\n        var len = maskHeight * 8;\n        var mask = new Array(len);\n        for(i = 0; i < len; i++) {\n            mask[i] = 255;\n        }\n        if(!isContext) {\n            for(i = 0; i < initialDims.length; i++) {\n                var u = i % 8;\n                var v = (i - u) / 8;\n                var bitMask = Math.pow(2, u);\n                var dim = initialDims[i];\n                var ranges = dim.brush.filter.get();\n                if(ranges.length < 2) continue; // bail if the bounding box based filter is sufficient\n\n                var prevEnd = expandedPixelRange(ranges[0])[1];\n                for(j = 1; j < ranges.length; j++) {\n                    var nextRange = expandedPixelRange(ranges[j]);\n                    for(k = prevEnd + 1; k < nextRange[0]; k++) {\n                        mask[k * 8 + v] &= ~bitMask;\n                    }\n                    prevEnd = Math.max(prevEnd, nextRange[1]);\n                }\n            }\n        }\n\n        var textureData = {\n            // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support\n            shape: [8, maskHeight],\n            format: 'alpha',\n            type: 'uint8',\n            mag: 'nearest',\n            min: 'nearest',\n            data: mask\n        };\n        if(maskTexture) maskTexture(textureData);\n        else maskTexture = regl.texture(textureData);\n\n        return {\n            maskTexture: maskTexture,\n            maskHeight: maskHeight,\n            loA: limits[0].slice(0, 16),\n            loB: limits[0].slice(16, 32),\n            loC: limits[0].slice(32, 48),\n            loD: limits[0].slice(48, 64),\n            hiA: limits[1].slice(0, 16),\n            hiB: limits[1].slice(16, 32),\n            hiC: limits[1].slice(32, 48),\n            hiD: limits[1].slice(48, 64),\n        };\n    }\n\n    function renderGLParcoords(panels, setChanged, clearOnly) {\n        var panelCount = panels.length;\n        var i;\n\n        var leftmost;\n        var rightmost;\n        var lowestX = Infinity;\n        var highestX = -Infinity;\n\n        for(i = 0; i < panelCount; i++) {\n            if(panels[i].dim0.canvasX < lowestX) {\n                lowestX = panels[i].dim0.canvasX;\n                leftmost = i;\n            }\n            if(panels[i].dim1.canvasX > highestX) {\n                highestX = panels[i].dim1.canvasX;\n                rightmost = i;\n            }\n        }\n\n        if(panelCount === 0) {\n            // clear canvas here, as the panel iteration below will not enter the loop body\n            clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);\n        }\n        var constraints = makeConstraints(isContext);\n\n        for(i = 0; i < panelCount; i++) {\n            var p = panels[i];\n            var i0 = p.dim0.crossfilterDimensionIndex;\n            var i1 = p.dim1.crossfilterDimensionIndex;\n            var x = p.canvasX;\n            var y = p.canvasY;\n            var nextX = x + p.panelSizeX;\n            var plotGlPixelRatio = p.plotGlPixelRatio;\n            if(setChanged ||\n                !prevAxisOrder[i0] ||\n                prevAxisOrder[i0][0] !== x ||\n                prevAxisOrder[i0][1] !== nextX\n            ) {\n                prevAxisOrder[i0] = [x, nextX];\n\n                var item = makeItem(\n                    model,\n                    leftmost, rightmost, i, i0, i1, x, y,\n                    p.panelSizeX, p.panelSizeY,\n                    p.dim0.crossfilterDimensionIndex,\n                    isContext ? 0 : isPick ? 2 : 1,\n                    constraints,\n                    plotGlPixelRatio\n                );\n\n                renderState.clearOnly = clearOnly;\n\n                var blockLineCount = setChanged ? model.lines.blockLineCount : sampleCount;\n                renderBlock(\n                    regl, glAes, renderState, blockLineCount, sampleCount, item\n                );\n            }\n        }\n    }\n\n    function readPixel(canvasX, canvasY) {\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: 1,\n            height: 1,\n            data: dataPixel\n        });\n        return dataPixel;\n    }\n\n    function readPixels(canvasX, canvasY, width, height) {\n        var pixelArray = new Uint8Array(4 * width * height);\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: width,\n            height: height,\n            data: pixelArray\n        });\n        return pixelArray;\n    }\n\n    function destroy() {\n        canvasGL.style['pointer-events'] = 'none';\n        paletteTexture.destroy();\n        if(maskTexture) maskTexture.destroy();\n        for(var k in attributes) attributes[k].destroy();\n    }\n\n    return {\n        render: renderGLParcoords,\n        readPixel: readPixel,\n        readPixels: readPixels,\n        destroy: destroy,\n        update: update\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}