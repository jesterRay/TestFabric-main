{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\nvar PlotSchema = require('../plot_api/plot_schema');\nvar Plots = require('../plots/plots');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\nexports.moduleType = 'transform';\nexports.name = 'groupby';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    editType: 'calc',\n    description: ['Determines whether this group-by transform is enabled or disabled.'].join(' ')\n  },\n  groups: {\n    valType: 'data_array',\n    dflt: [],\n    editType: 'calc',\n    description: ['Sets the groups in which the trace data will be split.', 'For example, with `x` set to *[1, 2, 3, 4]* and', '`groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*,', 'the groupby transform with split in one trace', 'with `x` [1, 3] and one trace with `x` [2, 4].'].join(' ')\n  },\n  nameformat: {\n    valType: 'string',\n    editType: 'calc',\n    description: ['Pattern by which grouped traces are named. If only one trace is present,', 'defaults to the group name (`\"%{group}\"`), otherwise defaults to the group name', 'with trace name (`\"%{group} (%{trace})\"`). Available escape sequences are `%{group}`, which', 'inserts the group name, and `%{trace}`, which inserts the trace name. If grouping', 'GDP data by country when more than one trace is present, for example, the', 'default \"%{group} (%{trace})\" would return \"Monaco (GDP per capita)\".'].join(' ')\n  },\n  styles: {\n    _isLinkedToArray: 'style',\n    target: {\n      valType: 'string',\n      editType: 'calc',\n      description: ['The group value which receives these styles.'].join(' ')\n    },\n    value: {\n      valType: 'any',\n      dflt: {},\n      editType: 'calc',\n      description: ['Sets each group styles.', 'For example, with `groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*', 'and `styles` set to *[{target: \\'a\\', value: { marker: { color: \\'red\\' } }}]', 'marker points in group *\\'a\\'* will be drawn in red.'].join(' '),\n      _compareAsJSON: true\n    },\n    editType: 'calc'\n  },\n  editType: 'calc'\n};\n\n/**\n * Supply transform attributes defaults\n *\n * @param {object} transformIn\n *  object linked to trace.transforms[i] with 'type' set to exports.name\n * @param {object} traceOut\n *  the _fullData trace this transform applies to\n * @param {object} layout\n *  the plot's (not-so-full) layout\n * @param {object} traceIn\n *  the input data trace this transform applies to\n *\n * @return {object} transformOut\n *  copy of transformIn that contains attribute defaults\n */\nexports.supplyDefaults = function (transformIn, traceOut, layout) {\n  var i;\n  var transformOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n  var enabled = coerce('enabled');\n  if (!enabled) return transformOut;\n  coerce('groups');\n  coerce('nameformat', layout._dataLength > 1 ? '%{group} (%{trace})' : '%{group}');\n  var styleIn = transformIn.styles;\n  var styleOut = transformOut.styles = [];\n  if (styleIn) {\n    for (i = 0; i < styleIn.length; i++) {\n      var thisStyle = styleOut[i] = {};\n      Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'target');\n      var value = Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'value');\n\n      // so that you can edit value in place and have Plotly.react notice it, or\n      // rebuild it every time and have Plotly.react NOT think it changed:\n      // use _compareAsJSON to say we should diff the _JSON_value\n      if (Lib.isPlainObject(value)) thisStyle.value = Lib.extendDeep({}, value);else if (value) delete thisStyle.value;\n    }\n  }\n  return transformOut;\n};\n\n/**\n * Apply transform !!!\n *\n * @param {array} data\n *  array of transformed traces (is [fullTrace] upon first transform)\n *\n * @param {object} state\n *  state object which includes:\n *      - transform {object} full transform attributes\n *      - fullTrace {object} full trace object which is being transformed\n *      - fullData {array} full pre-transform(s) data array\n *      - layout {object} the plot's (not-so-full) layout\n *\n * @return {object} newData\n *  array of transformed traces\n */\nexports.transform = function (data, state) {\n  var newTraces, i, j;\n  var newData = [];\n  for (i = 0; i < data.length; i++) {\n    newTraces = transformOne(data[i], state);\n    for (j = 0; j < newTraces.length; j++) {\n      newData.push(newTraces[j]);\n    }\n  }\n  return newData;\n};\nfunction transformOne(trace, state) {\n  var i, j, k, attr, srcArray, groupName, newTrace, transforms, arrayLookup;\n  var groupNameObj;\n  var opts = state.transform;\n  var transformIndex = state.transformIndex;\n  var groups = trace.transforms[transformIndex].groups;\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n  if (!Lib.isArrayOrTypedArray(groups) || groups.length === 0) {\n    return [trace];\n  }\n  var groupNames = Lib.filterUnique(groups);\n  var newData = new Array(groupNames.length);\n  var len = groups.length;\n  var arrayAttrs = PlotSchema.findArrayAttributes(trace);\n  var styles = opts.styles || [];\n  var styleLookup = {};\n  for (i = 0; i < styles.length; i++) {\n    styleLookup[styles[i].target] = styles[i].value;\n  }\n  if (opts.styles) {\n    groupNameObj = Lib.keyedContainer(opts, 'styles', 'target', 'value.name');\n  }\n\n  // An index to map group name --> expanded trace index\n  var indexLookup = {};\n  var indexCnts = {};\n  for (i = 0; i < groupNames.length; i++) {\n    groupName = groupNames[i];\n    indexLookup[groupName] = i;\n    indexCnts[groupName] = 0;\n\n    // Start with a deep extend that just copies array references.\n    newTrace = newData[i] = Lib.extendDeepNoArrays({}, trace);\n    newTrace._group = groupName;\n    newTrace.transforms[transformIndex]._indexToPoints = {};\n    var suppliedName = null;\n    if (groupNameObj) {\n      suppliedName = groupNameObj.get(groupName);\n    }\n    if (suppliedName || suppliedName === '') {\n      newTrace.name = suppliedName;\n    } else {\n      newTrace.name = Lib.templateString(opts.nameformat, {\n        trace: trace.name,\n        group: groupName\n      });\n    }\n\n    // In order for groups to apply correctly to other transform data (e.g.\n    // a filter transform), we have to break the connection and clone the\n    // transforms so that each group writes grouped values into a different\n    // destination. This function does not break the array reference\n    // connection between the split transforms it creates. That's handled in\n    // initialize, which creates a new empty array for each arrayAttr.\n    transforms = newTrace.transforms;\n    newTrace.transforms = [];\n    for (j = 0; j < transforms.length; j++) {\n      newTrace.transforms[j] = Lib.extendDeepNoArrays({}, transforms[j]);\n    }\n\n    // Initialize empty arrays for the arrayAttrs, to be split in the next step\n    for (j = 0; j < arrayAttrs.length; j++) {\n      Lib.nestedProperty(newTrace, arrayAttrs[j]).set([]);\n    }\n  }\n\n  // For each array attribute including those nested inside this and other\n  // transforms (small note that we technically only need to do this for\n  // transforms that have not yet been applied):\n  for (k = 0; k < arrayAttrs.length; k++) {\n    attr = arrayAttrs[k];\n\n    // Cache all the arrays to which we'll push:\n    for (j = 0, arrayLookup = []; j < groupNames.length; j++) {\n      arrayLookup[j] = Lib.nestedProperty(newData[j], attr).get();\n    }\n\n    // Get the input data:\n    srcArray = Lib.nestedProperty(trace, attr).get();\n\n    // Send each data point to the appropriate expanded trace:\n    for (j = 0; j < len; j++) {\n      // Map group data --> trace index --> array and push data onto it\n      arrayLookup[indexLookup[groups[j]]].push(srcArray[j]);\n    }\n  }\n  for (j = 0; j < len; j++) {\n    newTrace = newData[indexLookup[groups[j]]];\n    var indexToPoints = newTrace.transforms[transformIndex]._indexToPoints;\n    indexToPoints[indexCnts[groups[j]]] = originalPointsAccessor(j);\n    indexCnts[groups[j]]++;\n  }\n  for (i = 0; i < groupNames.length; i++) {\n    groupName = groupNames[i];\n    newTrace = newData[i];\n    Plots.clearExpandedTraceDefaultColors(newTrace);\n\n    // there's no need to coerce styleLookup[groupName] here\n    // as another round of supplyDefaults is done on the transformed traces\n    newTrace = Lib.extendDeepNoArrays(newTrace, styleLookup[groupName] || {});\n  }\n  return newData;\n}","map":{"version":3,"names":["Lib","require","PlotSchema","Plots","pointsAccessorFunction","exports","moduleType","name","attributes","enabled","valType","dflt","editType","description","join","groups","nameformat","styles","_isLinkedToArray","target","value","_compareAsJSON","supplyDefaults","transformIn","traceOut","layout","i","transformOut","coerce","attr","_dataLength","styleIn","styleOut","length","thisStyle","isPlainObject","extendDeep","transform","data","state","newTraces","j","newData","transformOne","push","trace","k","srcArray","groupName","newTrace","transforms","arrayLookup","groupNameObj","opts","transformIndex","originalPointsAccessor","isArrayOrTypedArray","groupNames","filterUnique","Array","len","arrayAttrs","findArrayAttributes","styleLookup","keyedContainer","indexLookup","indexCnts","extendDeepNoArrays","_group","_indexToPoints","suppliedName","get","templateString","group","nestedProperty","set","indexToPoints","clearExpandedTraceDefaultColors"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/transforms/groupby.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../lib');\nvar PlotSchema = require('../plot_api/plot_schema');\nvar Plots = require('../plots/plots');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nexports.moduleType = 'transform';\n\nexports.name = 'groupby';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        editType: 'calc',\n        description: [\n            'Determines whether this group-by transform is enabled or disabled.'\n        ].join(' ')\n    },\n    groups: {\n        valType: 'data_array',\n        dflt: [],\n        editType: 'calc',\n        description: [\n            'Sets the groups in which the trace data will be split.',\n            'For example, with `x` set to *[1, 2, 3, 4]* and',\n            '`groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*,',\n            'the groupby transform with split in one trace',\n            'with `x` [1, 3] and one trace with `x` [2, 4].'\n        ].join(' ')\n    },\n    nameformat: {\n        valType: 'string',\n        editType: 'calc',\n        description: [\n            'Pattern by which grouped traces are named. If only one trace is present,',\n            'defaults to the group name (`\"%{group}\"`), otherwise defaults to the group name',\n            'with trace name (`\"%{group} (%{trace})\"`). Available escape sequences are `%{group}`, which',\n            'inserts the group name, and `%{trace}`, which inserts the trace name. If grouping',\n            'GDP data by country when more than one trace is present, for example, the',\n            'default \"%{group} (%{trace})\" would return \"Monaco (GDP per capita)\".'\n        ].join(' ')\n    },\n    styles: {\n        _isLinkedToArray: 'style',\n        target: {\n            valType: 'string',\n            editType: 'calc',\n            description: [\n                'The group value which receives these styles.'\n            ].join(' ')\n        },\n        value: {\n            valType: 'any',\n            dflt: {},\n            editType: 'calc',\n            description: [\n                'Sets each group styles.',\n                'For example, with `groups` set to *[\\'a\\', \\'b\\', \\'a\\', \\'b\\']*',\n                'and `styles` set to *[{target: \\'a\\', value: { marker: { color: \\'red\\' } }}]',\n                'marker points in group *\\'a\\'* will be drawn in red.'\n            ].join(' '),\n            _compareAsJSON: true\n        },\n        editType: 'calc'\n    },\n    editType: 'calc'\n};\n\n/**\n * Supply transform attributes defaults\n *\n * @param {object} transformIn\n *  object linked to trace.transforms[i] with 'type' set to exports.name\n * @param {object} traceOut\n *  the _fullData trace this transform applies to\n * @param {object} layout\n *  the plot's (not-so-full) layout\n * @param {object} traceIn\n *  the input data trace this transform applies to\n *\n * @return {object} transformOut\n *  copy of transformIn that contains attribute defaults\n */\nexports.supplyDefaults = function(transformIn, traceOut, layout) {\n    var i;\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(!enabled) return transformOut;\n\n    coerce('groups');\n    coerce('nameformat', layout._dataLength > 1 ? '%{group} (%{trace})' : '%{group}');\n\n    var styleIn = transformIn.styles;\n    var styleOut = transformOut.styles = [];\n\n    if(styleIn) {\n        for(i = 0; i < styleIn.length; i++) {\n            var thisStyle = styleOut[i] = {};\n            Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'target');\n            var value = Lib.coerce(styleIn[i], styleOut[i], exports.attributes.styles, 'value');\n\n            // so that you can edit value in place and have Plotly.react notice it, or\n            // rebuild it every time and have Plotly.react NOT think it changed:\n            // use _compareAsJSON to say we should diff the _JSON_value\n            if(Lib.isPlainObject(value)) thisStyle.value = Lib.extendDeep({}, value);\n            else if(value) delete thisStyle.value;\n        }\n    }\n\n    return transformOut;\n};\n\n\n/**\n * Apply transform !!!\n *\n * @param {array} data\n *  array of transformed traces (is [fullTrace] upon first transform)\n *\n * @param {object} state\n *  state object which includes:\n *      - transform {object} full transform attributes\n *      - fullTrace {object} full trace object which is being transformed\n *      - fullData {array} full pre-transform(s) data array\n *      - layout {object} the plot's (not-so-full) layout\n *\n * @return {object} newData\n *  array of transformed traces\n */\nexports.transform = function(data, state) {\n    var newTraces, i, j;\n    var newData = [];\n\n    for(i = 0; i < data.length; i++) {\n        newTraces = transformOne(data[i], state);\n\n        for(j = 0; j < newTraces.length; j++) {\n            newData.push(newTraces[j]);\n        }\n    }\n\n    return newData;\n};\n\nfunction transformOne(trace, state) {\n    var i, j, k, attr, srcArray, groupName, newTrace, transforms, arrayLookup;\n    var groupNameObj;\n\n    var opts = state.transform;\n    var transformIndex = state.transformIndex;\n    var groups = trace.transforms[transformIndex].groups;\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n    if(!(Lib.isArrayOrTypedArray(groups)) || groups.length === 0) {\n        return [trace];\n    }\n\n    var groupNames = Lib.filterUnique(groups);\n    var newData = new Array(groupNames.length);\n    var len = groups.length;\n\n    var arrayAttrs = PlotSchema.findArrayAttributes(trace);\n\n    var styles = opts.styles || [];\n    var styleLookup = {};\n    for(i = 0; i < styles.length; i++) {\n        styleLookup[styles[i].target] = styles[i].value;\n    }\n\n    if(opts.styles) {\n        groupNameObj = Lib.keyedContainer(opts, 'styles', 'target', 'value.name');\n    }\n\n    // An index to map group name --> expanded trace index\n    var indexLookup = {};\n    var indexCnts = {};\n\n    for(i = 0; i < groupNames.length; i++) {\n        groupName = groupNames[i];\n        indexLookup[groupName] = i;\n        indexCnts[groupName] = 0;\n\n        // Start with a deep extend that just copies array references.\n        newTrace = newData[i] = Lib.extendDeepNoArrays({}, trace);\n        newTrace._group = groupName;\n        newTrace.transforms[transformIndex]._indexToPoints = {};\n\n        var suppliedName = null;\n        if(groupNameObj) {\n            suppliedName = groupNameObj.get(groupName);\n        }\n\n        if(suppliedName || suppliedName === '') {\n            newTrace.name = suppliedName;\n        } else {\n            newTrace.name = Lib.templateString(opts.nameformat, {\n                trace: trace.name,\n                group: groupName\n            });\n        }\n\n        // In order for groups to apply correctly to other transform data (e.g.\n        // a filter transform), we have to break the connection and clone the\n        // transforms so that each group writes grouped values into a different\n        // destination. This function does not break the array reference\n        // connection between the split transforms it creates. That's handled in\n        // initialize, which creates a new empty array for each arrayAttr.\n        transforms = newTrace.transforms;\n        newTrace.transforms = [];\n        for(j = 0; j < transforms.length; j++) {\n            newTrace.transforms[j] = Lib.extendDeepNoArrays({}, transforms[j]);\n        }\n\n        // Initialize empty arrays for the arrayAttrs, to be split in the next step\n        for(j = 0; j < arrayAttrs.length; j++) {\n            Lib.nestedProperty(newTrace, arrayAttrs[j]).set([]);\n        }\n    }\n\n    // For each array attribute including those nested inside this and other\n    // transforms (small note that we technically only need to do this for\n    // transforms that have not yet been applied):\n    for(k = 0; k < arrayAttrs.length; k++) {\n        attr = arrayAttrs[k];\n\n        // Cache all the arrays to which we'll push:\n        for(j = 0, arrayLookup = []; j < groupNames.length; j++) {\n            arrayLookup[j] = Lib.nestedProperty(newData[j], attr).get();\n        }\n\n        // Get the input data:\n        srcArray = Lib.nestedProperty(trace, attr).get();\n\n        // Send each data point to the appropriate expanded trace:\n        for(j = 0; j < len; j++) {\n            // Map group data --> trace index --> array and push data onto it\n            arrayLookup[indexLookup[groups[j]]].push(srcArray[j]);\n        }\n    }\n\n    for(j = 0; j < len; j++) {\n        newTrace = newData[indexLookup[groups[j]]];\n\n        var indexToPoints = newTrace.transforms[transformIndex]._indexToPoints;\n        indexToPoints[indexCnts[groups[j]]] = originalPointsAccessor(j);\n        indexCnts[groups[j]]++;\n    }\n\n    for(i = 0; i < groupNames.length; i++) {\n        groupName = groupNames[i];\n        newTrace = newData[i];\n\n        Plots.clearExpandedTraceDefaultColors(newTrace);\n\n        // there's no need to coerce styleLookup[groupName] here\n        // as another round of supplyDefaults is done on the transformed traces\n        newTrace = Lib.extendDeepNoArrays(newTrace, styleLookup[groupName] || {});\n    }\n\n    return newData;\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,GAAG,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC3B,IAAIC,UAAU,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AACnD,IAAIE,KAAK,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACrC,IAAIG,sBAAsB,GAAGH,OAAO,CAAC,WAAW,CAAC,CAACG,sBAAsB;AAExEC,OAAO,CAACC,UAAU,GAAG,WAAW;AAEhCD,OAAO,CAACE,IAAI,GAAG,SAAS;AAExBF,OAAO,CAACG,UAAU,GAAG;EACjBC,OAAO,EAAE;IACLC,OAAO,EAAE,SAAS;IAClBC,IAAI,EAAE,IAAI;IACVC,QAAQ,EAAE,MAAM;IAChBC,WAAW,EAAE,CACT,oEAAoE,CACvE,CAACC,IAAI,CAAC,GAAG;EACd,CAAC;EACDC,MAAM,EAAE;IACJL,OAAO,EAAE,YAAY;IACrBC,IAAI,EAAE,EAAE;IACRC,QAAQ,EAAE,MAAM;IAChBC,WAAW,EAAE,CACT,wDAAwD,EACxD,iDAAiD,EACjD,iDAAiD,EACjD,+CAA+C,EAC/C,gDAAgD,CACnD,CAACC,IAAI,CAAC,GAAG;EACd,CAAC;EACDE,UAAU,EAAE;IACRN,OAAO,EAAE,QAAQ;IACjBE,QAAQ,EAAE,MAAM;IAChBC,WAAW,EAAE,CACT,0EAA0E,EAC1E,iFAAiF,EACjF,6FAA6F,EAC7F,mFAAmF,EACnF,2EAA2E,EAC3E,uEAAuE,CAC1E,CAACC,IAAI,CAAC,GAAG;EACd,CAAC;EACDG,MAAM,EAAE;IACJC,gBAAgB,EAAE,OAAO;IACzBC,MAAM,EAAE;MACJT,OAAO,EAAE,QAAQ;MACjBE,QAAQ,EAAE,MAAM;MAChBC,WAAW,EAAE,CACT,8CAA8C,CACjD,CAACC,IAAI,CAAC,GAAG;IACd,CAAC;IACDM,KAAK,EAAE;MACHV,OAAO,EAAE,KAAK;MACdC,IAAI,EAAE,CAAC,CAAC;MACRC,QAAQ,EAAE,MAAM;MAChBC,WAAW,EAAE,CACT,yBAAyB,EACzB,kEAAkE,EAClE,+EAA+E,EAC/E,sDAAsD,CACzD,CAACC,IAAI,CAAC,GAAG,CAAC;MACXO,cAAc,EAAE;IACpB,CAAC;IACDT,QAAQ,EAAE;EACd,CAAC;EACDA,QAAQ,EAAE;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAP,OAAO,CAACiB,cAAc,GAAG,UAASC,WAAW,EAAEC,QAAQ,EAAEC,MAAM,EAAE;EAC7D,IAAIC,CAAC;EACL,IAAIC,YAAY,GAAG,CAAC,CAAC;EAErB,SAASC,MAAMA,CAACC,IAAI,EAAElB,IAAI,EAAE;IACxB,OAAOX,GAAG,CAAC4B,MAAM,CAACL,WAAW,EAAEI,YAAY,EAAEtB,OAAO,CAACG,UAAU,EAAEqB,IAAI,EAAElB,IAAI,CAAC;EAChF;EAEA,IAAIF,OAAO,GAAGmB,MAAM,CAAC,SAAS,CAAC;EAE/B,IAAG,CAACnB,OAAO,EAAE,OAAOkB,YAAY;EAEhCC,MAAM,CAAC,QAAQ,CAAC;EAChBA,MAAM,CAAC,YAAY,EAAEH,MAAM,CAACK,WAAW,GAAG,CAAC,GAAG,qBAAqB,GAAG,UAAU,CAAC;EAEjF,IAAIC,OAAO,GAAGR,WAAW,CAACN,MAAM;EAChC,IAAIe,QAAQ,GAAGL,YAAY,CAACV,MAAM,GAAG,EAAE;EAEvC,IAAGc,OAAO,EAAE;IACR,KAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,OAAO,CAACE,MAAM,EAAEP,CAAC,EAAE,EAAE;MAChC,IAAIQ,SAAS,GAAGF,QAAQ,CAACN,CAAC,CAAC,GAAG,CAAC,CAAC;MAChC1B,GAAG,CAAC4B,MAAM,CAACG,OAAO,CAACL,CAAC,CAAC,EAAEM,QAAQ,CAACN,CAAC,CAAC,EAAErB,OAAO,CAACG,UAAU,CAACS,MAAM,EAAE,QAAQ,CAAC;MACxE,IAAIG,KAAK,GAAGpB,GAAG,CAAC4B,MAAM,CAACG,OAAO,CAACL,CAAC,CAAC,EAAEM,QAAQ,CAACN,CAAC,CAAC,EAAErB,OAAO,CAACG,UAAU,CAACS,MAAM,EAAE,OAAO,CAAC;;MAEnF;MACA;MACA;MACA,IAAGjB,GAAG,CAACmC,aAAa,CAACf,KAAK,CAAC,EAAEc,SAAS,CAACd,KAAK,GAAGpB,GAAG,CAACoC,UAAU,CAAC,CAAC,CAAC,EAAEhB,KAAK,CAAC,CAAC,KACpE,IAAGA,KAAK,EAAE,OAAOc,SAAS,CAACd,KAAK;IACzC;EACJ;EAEA,OAAOO,YAAY;AACvB,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtB,OAAO,CAACgC,SAAS,GAAG,UAASC,IAAI,EAAEC,KAAK,EAAE;EACtC,IAAIC,SAAS,EAAEd,CAAC,EAAEe,CAAC;EACnB,IAAIC,OAAO,GAAG,EAAE;EAEhB,KAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACL,MAAM,EAAEP,CAAC,EAAE,EAAE;IAC7Bc,SAAS,GAAGG,YAAY,CAACL,IAAI,CAACZ,CAAC,CAAC,EAAEa,KAAK,CAAC;IAExC,KAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACP,MAAM,EAAEQ,CAAC,EAAE,EAAE;MAClCC,OAAO,CAACE,IAAI,CAACJ,SAAS,CAACC,CAAC,CAAC,CAAC;IAC9B;EACJ;EAEA,OAAOC,OAAO;AAClB,CAAC;AAED,SAASC,YAAYA,CAACE,KAAK,EAAEN,KAAK,EAAE;EAChC,IAAIb,CAAC,EAAEe,CAAC,EAAEK,CAAC,EAAEjB,IAAI,EAAEkB,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,WAAW;EACzE,IAAIC,YAAY;EAEhB,IAAIC,IAAI,GAAGd,KAAK,CAACF,SAAS;EAC1B,IAAIiB,cAAc,GAAGf,KAAK,CAACe,cAAc;EACzC,IAAIvC,MAAM,GAAG8B,KAAK,CAACK,UAAU,CAACI,cAAc,CAAC,CAACvC,MAAM;EACpD,IAAIwC,sBAAsB,GAAGnD,sBAAsB,CAACyC,KAAK,CAACK,UAAU,EAAEG,IAAI,CAAC;EAE3E,IAAG,CAAErD,GAAG,CAACwD,mBAAmB,CAACzC,MAAM,CAAE,IAAIA,MAAM,CAACkB,MAAM,KAAK,CAAC,EAAE;IAC1D,OAAO,CAACY,KAAK,CAAC;EAClB;EAEA,IAAIY,UAAU,GAAGzD,GAAG,CAAC0D,YAAY,CAAC3C,MAAM,CAAC;EACzC,IAAI2B,OAAO,GAAG,IAAIiB,KAAK,CAACF,UAAU,CAACxB,MAAM,CAAC;EAC1C,IAAI2B,GAAG,GAAG7C,MAAM,CAACkB,MAAM;EAEvB,IAAI4B,UAAU,GAAG3D,UAAU,CAAC4D,mBAAmB,CAACjB,KAAK,CAAC;EAEtD,IAAI5B,MAAM,GAAGoC,IAAI,CAACpC,MAAM,IAAI,EAAE;EAC9B,IAAI8C,WAAW,GAAG,CAAC,CAAC;EACpB,KAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAACgB,MAAM,EAAEP,CAAC,EAAE,EAAE;IAC/BqC,WAAW,CAAC9C,MAAM,CAACS,CAAC,CAAC,CAACP,MAAM,CAAC,GAAGF,MAAM,CAACS,CAAC,CAAC,CAACN,KAAK;EACnD;EAEA,IAAGiC,IAAI,CAACpC,MAAM,EAAE;IACZmC,YAAY,GAAGpD,GAAG,CAACgE,cAAc,CAACX,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,CAAC;EAC7E;;EAEA;EACA,IAAIY,WAAW,GAAG,CAAC,CAAC;EACpB,IAAIC,SAAS,GAAG,CAAC,CAAC;EAElB,KAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,UAAU,CAACxB,MAAM,EAAEP,CAAC,EAAE,EAAE;IACnCsB,SAAS,GAAGS,UAAU,CAAC/B,CAAC,CAAC;IACzBuC,WAAW,CAACjB,SAAS,CAAC,GAAGtB,CAAC;IAC1BwC,SAAS,CAAClB,SAAS,CAAC,GAAG,CAAC;;IAExB;IACAC,QAAQ,GAAGP,OAAO,CAAChB,CAAC,CAAC,GAAG1B,GAAG,CAACmE,kBAAkB,CAAC,CAAC,CAAC,EAAEtB,KAAK,CAAC;IACzDI,QAAQ,CAACmB,MAAM,GAAGpB,SAAS;IAC3BC,QAAQ,CAACC,UAAU,CAACI,cAAc,CAAC,CAACe,cAAc,GAAG,CAAC,CAAC;IAEvD,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAGlB,YAAY,EAAE;MACbkB,YAAY,GAAGlB,YAAY,CAACmB,GAAG,CAACvB,SAAS,CAAC;IAC9C;IAEA,IAAGsB,YAAY,IAAIA,YAAY,KAAK,EAAE,EAAE;MACpCrB,QAAQ,CAAC1C,IAAI,GAAG+D,YAAY;IAChC,CAAC,MAAM;MACHrB,QAAQ,CAAC1C,IAAI,GAAGP,GAAG,CAACwE,cAAc,CAACnB,IAAI,CAACrC,UAAU,EAAE;QAChD6B,KAAK,EAAEA,KAAK,CAACtC,IAAI;QACjBkE,KAAK,EAAEzB;MACX,CAAC,CAAC;IACN;;IAEA;IACA;IACA;IACA;IACA;IACA;IACAE,UAAU,GAAGD,QAAQ,CAACC,UAAU;IAChCD,QAAQ,CAACC,UAAU,GAAG,EAAE;IACxB,KAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,UAAU,CAACjB,MAAM,EAAEQ,CAAC,EAAE,EAAE;MACnCQ,QAAQ,CAACC,UAAU,CAACT,CAAC,CAAC,GAAGzC,GAAG,CAACmE,kBAAkB,CAAC,CAAC,CAAC,EAAEjB,UAAU,CAACT,CAAC,CAAC,CAAC;IACtE;;IAEA;IACA,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,UAAU,CAAC5B,MAAM,EAAEQ,CAAC,EAAE,EAAE;MACnCzC,GAAG,CAAC0E,cAAc,CAACzB,QAAQ,EAAEY,UAAU,CAACpB,CAAC,CAAC,CAAC,CAACkC,GAAG,CAAC,EAAE,CAAC;IACvD;EACJ;;EAEA;EACA;EACA;EACA,KAAI7B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,UAAU,CAAC5B,MAAM,EAAEa,CAAC,EAAE,EAAE;IACnCjB,IAAI,GAAGgC,UAAU,CAACf,CAAC,CAAC;;IAEpB;IACA,KAAIL,CAAC,GAAG,CAAC,EAAEU,WAAW,GAAG,EAAE,EAAEV,CAAC,GAAGgB,UAAU,CAACxB,MAAM,EAAEQ,CAAC,EAAE,EAAE;MACrDU,WAAW,CAACV,CAAC,CAAC,GAAGzC,GAAG,CAAC0E,cAAc,CAAChC,OAAO,CAACD,CAAC,CAAC,EAAEZ,IAAI,CAAC,CAAC0C,GAAG,CAAC,CAAC;IAC/D;;IAEA;IACAxB,QAAQ,GAAG/C,GAAG,CAAC0E,cAAc,CAAC7B,KAAK,EAAEhB,IAAI,CAAC,CAAC0C,GAAG,CAAC,CAAC;;IAEhD;IACA,KAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,GAAG,EAAEnB,CAAC,EAAE,EAAE;MACrB;MACAU,WAAW,CAACc,WAAW,CAAClD,MAAM,CAAC0B,CAAC,CAAC,CAAC,CAAC,CAACG,IAAI,CAACG,QAAQ,CAACN,CAAC,CAAC,CAAC;IACzD;EACJ;EAEA,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,GAAG,EAAEnB,CAAC,EAAE,EAAE;IACrBQ,QAAQ,GAAGP,OAAO,CAACuB,WAAW,CAAClD,MAAM,CAAC0B,CAAC,CAAC,CAAC,CAAC;IAE1C,IAAImC,aAAa,GAAG3B,QAAQ,CAACC,UAAU,CAACI,cAAc,CAAC,CAACe,cAAc;IACtEO,aAAa,CAACV,SAAS,CAACnD,MAAM,CAAC0B,CAAC,CAAC,CAAC,CAAC,GAAGc,sBAAsB,CAACd,CAAC,CAAC;IAC/DyB,SAAS,CAACnD,MAAM,CAAC0B,CAAC,CAAC,CAAC,EAAE;EAC1B;EAEA,KAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,UAAU,CAACxB,MAAM,EAAEP,CAAC,EAAE,EAAE;IACnCsB,SAAS,GAAGS,UAAU,CAAC/B,CAAC,CAAC;IACzBuB,QAAQ,GAAGP,OAAO,CAAChB,CAAC,CAAC;IAErBvB,KAAK,CAAC0E,+BAA+B,CAAC5B,QAAQ,CAAC;;IAE/C;IACA;IACAA,QAAQ,GAAGjD,GAAG,CAACmE,kBAAkB,CAAClB,QAAQ,EAAEc,WAAW,CAACf,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;EAC7E;EAEA,OAAON,OAAO;AAClB","ignoreList":[]},"metadata":{},"sourceType":"script"}