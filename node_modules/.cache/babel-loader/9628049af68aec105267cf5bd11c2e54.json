{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nmodule.exports = function calcAutorange(gd) {\n  var fullLayout = gd._fullLayout;\n  var shapeList = Lib.filterVisible(fullLayout.shapes);\n  if (!shapeList.length || !gd._fullData.length) return;\n  for (var i = 0; i < shapeList.length; i++) {\n    var shape = shapeList[i];\n    shape._extremes = {};\n    var ax;\n    var bounds;\n    var xRefType = Axes.getRefType(shape.xref);\n    var yRefType = Axes.getRefType(shape.yref);\n\n    // paper and axis domain referenced shapes don't affect autorange\n    if (shape.xref !== 'paper' && xRefType !== 'domain') {\n      ax = Axes.getFromId(gd, shape.xref);\n      bounds = shapeBounds(ax, shape, constants.paramIsX);\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n      }\n    }\n    if (shape.yref !== 'paper' && yRefType !== 'domain') {\n      ax = Axes.getFromId(gd, shape.yref);\n      bounds = shapeBounds(ax, shape, constants.paramIsY);\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n      }\n    }\n  }\n};\nfunction calcXPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\nfunction calcYPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n  var ppad = lineWidth / 2;\n  var axisDirectionReverted = isYAxis;\n  if (sizeMode === 'pixel') {\n    var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];\n    var maxValue = Lib.aggNums(Math.max, null, coords);\n    var minValue = Lib.aggNums(Math.min, null, coords);\n    var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n    var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n    return {\n      ppad: ppad,\n      ppadplus: axisDirectionReverted ? beforePad : afterPad,\n      ppadminus: axisDirectionReverted ? afterPad : beforePad\n    };\n  } else {\n    return {\n      ppad: ppad\n    };\n  }\n}\nfunction shapeBounds(ax, shape, paramsToUse) {\n  var dim = ax._id.charAt(0) === 'x' ? 'x' : 'y';\n  var isCategory = ax.type === 'category' || ax.type === 'multicategory';\n  var v0;\n  var v1;\n  var shiftStart = 0;\n  var shiftEnd = 0;\n  var convertVal = isCategory ? ax.r2c : ax.d2c;\n  var isSizeModeScale = shape[dim + 'sizemode'] === 'scaled';\n  if (isSizeModeScale) {\n    v0 = shape[dim + '0'];\n    v1 = shape[dim + '1'];\n    if (isCategory) {\n      shiftStart = shape[dim + '0shift'];\n      shiftEnd = shape[dim + '1shift'];\n    }\n  } else {\n    v0 = shape[dim + 'anchor'];\n    v1 = shape[dim + 'anchor'];\n  }\n  if (v0 !== undefined) return [convertVal(v0) + shiftStart, convertVal(v1) + shiftEnd];\n  if (!shape.path) return;\n  var min = Infinity;\n  var max = -Infinity;\n  var segments = shape.path.match(constants.segmentRE);\n  var i;\n  var segment;\n  var drawnParam;\n  var params;\n  var val;\n  if (ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n  for (i = 0; i < segments.length; i++) {\n    segment = segments[i];\n    drawnParam = paramsToUse[segment.charAt(0)].drawn;\n    if (drawnParam === undefined) continue;\n    params = segments[i].substr(1).match(constants.paramRE);\n    if (!params || params.length < drawnParam) continue;\n    val = convertVal(params[drawnParam]);\n    if (val < min) min = val;\n    if (val > max) max = val;\n  }\n  if (max >= min) return [min, max];\n}","map":{"version":3,"names":["Lib","require","Axes","constants","helpers","module","exports","calcAutorange","gd","fullLayout","_fullLayout","shapeList","filterVisible","shapes","length","_fullData","i","shape","_extremes","ax","bounds","xRefType","getRefType","xref","yRefType","yref","getFromId","shapeBounds","paramIsX","_id","findExtremes","calcXPaddingOptions","paramIsY","calcYPaddingOptions","calcPaddingOptions","line","width","xsizemode","x0","x1","path","ysizemode","y0","y1","lineWidth","sizeMode","v0","v1","isYAxis","ppad","axisDirectionReverted","coords","extractPathCoords","maxValue","aggNums","Math","max","minValue","min","beforePad","abs","afterPad","ppadplus","ppadminus","paramsToUse","dim","charAt","isCategory","type","shiftStart","shiftEnd","convertVal","r2c","d2c","isSizeModeScale","undefined","Infinity","segments","match","segmentRE","segment","drawnParam","params","val","decodeDate","drawn","substr","paramRE"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/shapes/calc_autorange.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\nmodule.exports = function calcAutorange(gd) {\n    var fullLayout = gd._fullLayout;\n    var shapeList = Lib.filterVisible(fullLayout.shapes);\n\n    if(!shapeList.length || !gd._fullData.length) return;\n\n    for(var i = 0; i < shapeList.length; i++) {\n        var shape = shapeList[i];\n        shape._extremes = {};\n\n        var ax; var bounds;\n        var xRefType = Axes.getRefType(shape.xref);\n        var yRefType = Axes.getRefType(shape.yref);\n\n        // paper and axis domain referenced shapes don't affect autorange\n        if(shape.xref !== 'paper' && xRefType !== 'domain') {\n            ax = Axes.getFromId(gd, shape.xref);\n\n            bounds = shapeBounds(ax, shape, constants.paramIsX);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n            }\n        }\n\n        if(shape.yref !== 'paper' && yRefType !== 'domain') {\n            ax = Axes.getFromId(gd, shape.yref);\n\n            bounds = shapeBounds(ax, shape, constants.paramIsY);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n            }\n        }\n    }\n};\n\nfunction calcXPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\n\nfunction calcYPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\n\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n    var ppad = lineWidth / 2;\n    var axisDirectionReverted = isYAxis;\n\n    if(sizeMode === 'pixel') {\n        var coords = path ?\n            helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) :\n            [v0, v1];\n        var maxValue = Lib.aggNums(Math.max, null, coords);\n        var minValue = Lib.aggNums(Math.min, null, coords);\n        var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n        var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n\n        return {\n            ppad: ppad,\n            ppadplus: axisDirectionReverted ? beforePad : afterPad,\n            ppadminus: axisDirectionReverted ? afterPad : beforePad\n        };\n    } else {\n        return {ppad: ppad};\n    }\n}\n\nfunction shapeBounds(ax, shape, paramsToUse) {\n    var dim = ax._id.charAt(0) === 'x' ? 'x' : 'y';\n    var isCategory = ax.type === 'category' || ax.type === 'multicategory';\n    var v0;\n    var v1;\n    var shiftStart = 0;\n    var shiftEnd = 0;\n\n    var convertVal = isCategory ? ax.r2c : ax.d2c;\n\n    var isSizeModeScale = shape[dim + 'sizemode'] === 'scaled';\n    if(isSizeModeScale) {\n        v0 = shape[dim + '0'];\n        v1 = shape[dim + '1'];\n        if(isCategory) {\n            shiftStart = shape[dim + '0shift'];\n            shiftEnd = shape[dim + '1shift'];\n        }\n    } else {\n        v0 = shape[dim + 'anchor'];\n        v1 = shape[dim + 'anchor'];\n    }\n\n    if(v0 !== undefined) return [convertVal(v0) + shiftStart, convertVal(v1) + shiftEnd];\n    if(!shape.path) return;\n\n    var min = Infinity;\n    var max = -Infinity;\n    var segments = shape.path.match(constants.segmentRE);\n    var i;\n    var segment;\n    var drawnParam;\n    var params;\n    var val;\n\n    if(ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n\n    for(i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        drawnParam = paramsToUse[segment.charAt(0)].drawn;\n        if(drawnParam === undefined) continue;\n\n        params = segments[i].substr(1).match(constants.paramRE);\n        if(!params || params.length < drawnParam) continue;\n\n        val = convertVal(params[drawnParam]);\n        if(val < min) min = val;\n        if(val > max) max = val;\n    }\n    if(max >= min) return [min, max];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}