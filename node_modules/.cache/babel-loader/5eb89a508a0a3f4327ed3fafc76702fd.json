{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  if (trace.visible !== true) return opts;\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(gd, trace);\n    opts.textSel = convertTextSelection(gd, trace, trace.selected);\n    opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n  }\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(gd, trace);\n    opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);\n    if (!trace.unselected && isArrayOrTypedArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width * plotGlPixelRatio,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width * plotGlPixelRatio;\n    }\n    opts.line.dashes = dashes;\n  }\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n  }\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n  }\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n  return opts;\n}\nfunction convertTextStyle(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = isArrayOrTypedArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var tfw = textfontIn.weight;\n  var tfy = textfontIn.style;\n  var tfv = textfontIn.variant;\n  var optsOut = {};\n  var i;\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  var texttemplate = trace.texttemplate;\n  if (texttemplate) {\n    optsOut.text = [];\n    var d3locale = fullLayout._d3locale;\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, count) : count;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n    for (i = 0; i < N; i++) {\n      var d = {\n        i: i\n      };\n      var labels = trace._module.formatLabels(d, trace, fullLayout);\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, i);\n      var meta = trace._meta || {};\n      optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n    }\n  } else {\n    if (isArrayOrTypedArray(trace.text) && trace.text.length < count) {\n      // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n      optsOut.text = trace.text.slice();\n    } else {\n      optsOut.text = trace.text;\n    }\n  }\n  // pad text array with empty strings\n  if (isArrayOrTypedArray(optsOut.text)) {\n    for (i = optsOut.text.length; i < count; i++) {\n      optsOut.text[i] = '';\n    }\n  }\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n      case 'right':\n        optsOut.align.push('left');\n        break;\n      default:\n        optsOut.align.push(tp[1]);\n    }\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n  if (isArrayOrTypedArray(tfc)) {\n    optsOut.color = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n  if (isArrayOrTypedArray(tfs) || Array.isArray(tff) || isArrayOrTypedArray(tfw) || Array.isArray(tfy) || Array.isArray(tfv)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = (Lib.isTypedArray(tfs) ? tfs[i] : isArrayOrTypedArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs) * plotGlPixelRatio;\n      fonti.family = Array.isArray(tff) ? tff[i] : tff;\n      fonti.weight = weightFallBack(isArrayOrTypedArray(tfw) ? tfw[i] : tfw);\n      fonti.style = Array.isArray(tfy) ? tfy[i] : tfy;\n      fonti.variant = Array.isArray(tfv) ? tfv[i] : tfv;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs * plotGlPixelRatio,\n      family: tff,\n      weight: weightFallBack(tfw),\n      style: tfy,\n      variant: tfv\n    };\n  }\n  return optsOut;\n}\n\n// scattergl rendering pipeline has limited support of numeric weight values\n// Here we map the numbers to be either bold or normal.\nfunction weightFallBack(w) {\n  if (w <= 1000) {\n    return w > 500 ? 'bold' : 'normal';\n  }\n  return w;\n}\nfunction convertMarkerStyle(gd, trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = isArrayOrTypedArray(optsIn.symbol);\n  var multiAngle = isArrayOrTypedArray(optsIn.angle);\n  var multiColor = isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n  // prepare colors\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {\n    optsOut.symbols = new Array(count);\n    optsOut.angles = new Array(count);\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var symbols = optsIn.symbol;\n    var angles = optsIn.angle;\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n    if (!isArrayOrTypedArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n    if (!isArrayOrTypedArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n    if (!isArrayOrTypedArray(symbols)) {\n      var symbol = symbols;\n      symbols = Array(count);\n      for (i = 0; i < count; i++) {\n        symbols[i] = symbol;\n      }\n    }\n    if (!isArrayOrTypedArray(angles)) {\n      var angle = angles;\n      angles = Array(count);\n      for (i = 0; i < count; i++) {\n        angles[i] = angle;\n      }\n    }\n    optsOut.symbols = symbols;\n    optsOut.angles = angles;\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);\n      }\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n    optsOut.opacity = trace.opacity;\n    optsOut.markers = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf({\n        mx: optsOut.symbols[i],\n        ma: optsOut.angles[i]\n      }, trace);\n    }\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n    optsOut.marker = getSymbolSdf({\n      mx: optsIn.symbol,\n      ma: optsIn.angle\n    }, trace);\n  }\n\n  // prepare sizes\n  var sizeFactor = 1;\n  var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n  var s;\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    }\n\n    // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i];\n      }\n    } else {\n      s = optsIn.line.width;\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n  return optsOut;\n}\nfunction convertMarkerSelection(gd, trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n  return optsOut;\n}\nfunction convertTextSelection(gd, trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      texttemplate: trace.texttemplate,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n    optsOut = convertTextStyle(gd, optsIn);\n  }\n  return optsOut;\n}\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n  var optsOut = {\n    capSize: target.width * 2 * plotGlPixelRatio,\n    lineWidth: target.thickness * plotGlPixelRatio,\n    color: target.color\n  };\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n  return optsOut;\n}\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\nfunction getSymbolSdf(d, trace) {\n  var symbol = d.mx;\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = helpers.isDotSymbol(symbol);\n\n  // until we may handle angles in shader?\n  if (d.ma) symbol += '_' + d.ma;\n\n  // get symbol sdf from cache or generate it\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n  var angle = Drawing.getMarkerAngle(d, trace);\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE, angle);\n  }\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  }\n\n  // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n  var hasNaN = false;\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n  // fill gaps\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis, 'x');\n  var ya = AxisIDs.getFromId(gd, trace.yaxis, 'y');\n  var count = positions.length / 2;\n  var out = {};\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n    var opts = trace['error_' + axLetter];\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i;\n\n  // corresponds to textPointPosition from component.drawing\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = isArrayOrTypedArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = isArrayOrTypedArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = isArrayOrTypedArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n  return out;\n}\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":{"version":3,"names":["isNumeric","require","svgSdf","rgba","Registry","Lib","isArrayOrTypedArray","Drawing","AxisIDs","formatColor","subTypes","makeBubbleSizeFn","helpers","constants","DESELECTDIM","TEXTOFFSETSIGN","start","left","end","right","middle","center","bottom","top","appendArrayPointValue","convertStyle","gd","trace","i","opts","marker","undefined","markerSel","markerUnsel","line","fill","errorX","errorY","text","textSel","textUnsel","plotGlPixelRatio","_context","visible","hasText","convertTextStyle","convertTextSelection","selected","unselected","hasMarkers","convertMarkerStyle","convertMarkerSelection","opacity","mo","Array","length","hasLines","overlay","thickness","width","color","dashes","DASHES","dash","slice","error_x","convertErrorBarStyle","error_y","closed","fillcolor","fullLayout","_fullLayout","count","_length","textfontIn","textfont","textpositionIn","textposition","textPos","tfc","tfs","size","tff","family","tfw","weight","tfy","style","tfv","variant","optsOut","texttemplate","d3locale","_d3locale","isArray","N","Math","min","txt","d","labels","_module","formatLabels","pointValues","meta","_meta","push","texttemplateString","font","align","baseline","tp","split","fonti","isTypedArray","weightFallBack","w","optsIn","multiSymbol","symbol","multiAngle","angle","multiColor","multiLineColor","multiOpacity","multiSize","multiLineWidth","isOpen","isOpenSymbol","symbols","angles","colors","borderColors","borderColor","markers","getSymbolSdf","mx","ma","sizeFactor","markerSizeFunc","s","sizes","borderSizes","sizeTotal","sizeAvg","target","extendFlat","capSize","lineWidth","copy_ystyle","SYMBOL_SDF_SIZE","SYMBOL_SIZE","SYMBOL_STROKE","SYMBOL_SDF","SYMBOL_SVG_CIRCLE","symbolFuncs","symbolPath","symbolSdf","symbolNumber","symbolFunc","symbolNoDot","symbolNoFill","isDot","isDotSymbol","getMarkerAngle","h","viewBox","stroke","convertLinePositions","positions","len","linePositions","shape","isNaN","NaN","midPtX","midPtY","hasNaN","join","TOO_MANY_POINTS","connectgaps","lastX","lastY","convertErrorBarPositions","x","y","makeComputeError","getComponentMethod","xa","getFromId","xaxis","ya","yaxis","out","convertOneAxis","coords","ax","axLetter","_id","charAt","type","computeError","pOffset","eOffset","errors","Float64Array","minShoe","Infinity","maxHat","j","dc","dl","vals","lv","hv","shoe","hat","c2l","max","_bnds","convertTextPosition","textOpts","markerOpts","fontOpts","offset","ms","fs","a","b","hSign","vSign","xPad","yPad","module","exports","markerStyle","markerSelection","errorBarPositions","textPosition"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scattergl/convert.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n    start: 1, left: 1, end: -1, right: -1, middle: 0, center: 0, bottom: 1, top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n    var i;\n\n    var opts = {\n        marker: undefined,\n        markerSel: undefined,\n        markerUnsel: undefined,\n        line: undefined,\n        fill: undefined,\n        errorX: undefined,\n        errorY: undefined,\n        text: undefined,\n        textSel: undefined,\n        textUnsel: undefined\n    };\n\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    if(trace.visible !== true) return opts;\n\n    if(subTypes.hasText(trace)) {\n        opts.text = convertTextStyle(gd, trace);\n        opts.textSel = convertTextSelection(gd, trace, trace.selected);\n        opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        opts.marker = convertMarkerStyle(gd, trace);\n        opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);\n        opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);\n\n        if(!trace.unselected && isArrayOrTypedArray(trace.marker.opacity)) {\n            var mo = trace.marker.opacity;\n            opts.markerUnsel.opacity = new Array(mo.length);\n            for(i = 0; i < mo.length; i++) {\n                opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n            }\n        }\n    }\n\n    if(subTypes.hasLines(trace)) {\n        opts.line = {\n            overlay: true,\n            thickness: trace.line.width * plotGlPixelRatio,\n            color: trace.line.color,\n            opacity: trace.opacity\n        };\n\n        var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n        for(i = 0; i < dashes.length; ++i) {\n            dashes[i] *= trace.line.width * plotGlPixelRatio;\n        }\n        opts.line.dashes = dashes;\n    }\n\n    if(trace.error_x && trace.error_x.visible) {\n        opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n    }\n\n    if(trace.error_y && trace.error_y.visible) {\n        opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n    }\n\n    if(!!trace.fill && trace.fill !== 'none') {\n        opts.fill = {\n            closed: true,\n            fill: trace.fillcolor,\n            thickness: 0\n        };\n    }\n\n    return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var count = trace._length;\n    var textfontIn = trace.textfont;\n    var textpositionIn = trace.textposition;\n    var textPos = isArrayOrTypedArray(textpositionIn) ? textpositionIn : [textpositionIn];\n    var tfc = textfontIn.color;\n    var tfs = textfontIn.size;\n    var tff = textfontIn.family;\n    var tfw = textfontIn.weight;\n    var tfy = textfontIn.style;\n    var tfv = textfontIn.variant;\n    var optsOut = {};\n    var i;\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    var texttemplate = trace.texttemplate;\n    if(texttemplate) {\n        optsOut.text = [];\n\n        var d3locale = fullLayout._d3locale;\n        var isArray = Array.isArray(texttemplate);\n        var N = isArray ? Math.min(texttemplate.length, count) : count;\n        var txt = isArray ?\n            function(i) { return texttemplate[i]; } :\n            function() { return texttemplate; };\n\n        for(i = 0; i < N; i++) {\n            var d = {i: i};\n            var labels = trace._module.formatLabels(d, trace, fullLayout);\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, i);\n            var meta = trace._meta || {};\n            optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n        }\n    } else {\n        if(isArrayOrTypedArray(trace.text) && trace.text.length < count) {\n            // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n            optsOut.text = trace.text.slice();\n        } else {\n            optsOut.text = trace.text;\n        }\n    }\n    // pad text array with empty strings\n    if(isArrayOrTypedArray(optsOut.text)) {\n        for(i = optsOut.text.length; i < count; i++) {\n            optsOut.text[i] = '';\n        }\n    }\n\n    optsOut.opacity = trace.opacity;\n    optsOut.font = {};\n    optsOut.align = [];\n    optsOut.baseline = [];\n\n    for(i = 0; i < textPos.length; i++) {\n        var tp = textPos[i].split(/\\s+/);\n\n        switch(tp[1]) {\n            case 'left':\n                optsOut.align.push('right');\n                break;\n            case 'right':\n                optsOut.align.push('left');\n                break;\n            default:\n                optsOut.align.push(tp[1]);\n        }\n        switch(tp[0]) {\n            case 'top':\n                optsOut.baseline.push('bottom');\n                break;\n            case 'bottom':\n                optsOut.baseline.push('top');\n                break;\n            default:\n                optsOut.baseline.push(tp[0]);\n        }\n    }\n\n    if(isArrayOrTypedArray(tfc)) {\n        optsOut.color = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.color[i] = tfc[i];\n        }\n    } else {\n        optsOut.color = tfc;\n    }\n\n    if(\n        isArrayOrTypedArray(tfs) ||\n        Array.isArray(tff) ||\n        isArrayOrTypedArray(tfw) ||\n        Array.isArray(tfy) ||\n        Array.isArray(tfv)\n    ) {\n        // if any textfont param is array - make render a batch\n        optsOut.font = new Array(count);\n        for(i = 0; i < count; i++) {\n            var fonti = optsOut.font[i] = {};\n\n            fonti.size = (\n                Lib.isTypedArray(tfs) ? tfs[i] :\n                isArrayOrTypedArray(tfs) ? (\n                    isNumeric(tfs[i]) ? tfs[i] : 0\n                ) : tfs\n            ) * plotGlPixelRatio;\n\n            fonti.family = Array.isArray(tff) ? tff[i] : tff;\n            fonti.weight = weightFallBack(isArrayOrTypedArray(tfw) ? tfw[i] : tfw);\n            fonti.style = Array.isArray(tfy) ? tfy[i] : tfy;\n            fonti.variant = Array.isArray(tfv) ? tfv[i] : tfv;\n        }\n    } else {\n        // if both are single values, make render fast single-value\n        optsOut.font = {\n            size: tfs * plotGlPixelRatio,\n            family: tff,\n            weight: weightFallBack(tfw),\n            style: tfy,\n            variant: tfv\n        };\n    }\n\n    return optsOut;\n}\n\n// scattergl rendering pipeline has limited support of numeric weight values\n// Here we map the numbers to be either bold or normal.\nfunction weightFallBack(w) {\n    if(w <= 1000) {\n        return w > 500 ? 'bold' : 'normal';\n    }\n    return w;\n}\n\nfunction convertMarkerStyle(gd, trace) {\n    var count = trace._length;\n    var optsIn = trace.marker;\n    var optsOut = {};\n    var i;\n\n    var multiSymbol = isArrayOrTypedArray(optsIn.symbol);\n    var multiAngle = isArrayOrTypedArray(optsIn.angle);\n    var multiColor = isArrayOrTypedArray(optsIn.color);\n    var multiLineColor = isArrayOrTypedArray(optsIn.line.color);\n    var multiOpacity = isArrayOrTypedArray(optsIn.opacity);\n    var multiSize = isArrayOrTypedArray(optsIn.size);\n    var multiLineWidth = isArrayOrTypedArray(optsIn.line.width);\n\n    var isOpen;\n    if(!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n    // prepare colors\n    if(multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {\n        optsOut.symbols = new Array(count);\n        optsOut.angles = new Array(count);\n        optsOut.colors = new Array(count);\n        optsOut.borderColors = new Array(count);\n\n        var symbols = optsIn.symbol;\n        var angles = optsIn.angle;\n        var colors = formatColor(optsIn, optsIn.opacity, count);\n        var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n        if(!isArrayOrTypedArray(borderColors[0])) {\n            var borderColor = borderColors;\n            borderColors = Array(count);\n            for(i = 0; i < count; i++) {\n                borderColors[i] = borderColor;\n            }\n        }\n        if(!isArrayOrTypedArray(colors[0])) {\n            var color = colors;\n            colors = Array(count);\n            for(i = 0; i < count; i++) {\n                colors[i] = color;\n            }\n        }\n        if(!isArrayOrTypedArray(symbols)) {\n            var symbol = symbols;\n            symbols = Array(count);\n            for(i = 0; i < count; i++) {\n                symbols[i] = symbol;\n            }\n        }\n        if(!isArrayOrTypedArray(angles)) {\n            var angle = angles;\n            angles = Array(count);\n            for(i = 0; i < count; i++) {\n                angles[i] = angle;\n            }\n        }\n\n        optsOut.symbols = symbols;\n        optsOut.angles = angles;\n        optsOut.colors = colors;\n        optsOut.borderColors = borderColors;\n\n        for(i = 0; i < count; i++) {\n            if(multiSymbol) {\n                isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);\n            }\n            if(isOpen) {\n                borderColors[i] = colors[i].slice();\n                colors[i] = colors[i].slice();\n                colors[i][3] = 0;\n            }\n        }\n\n        optsOut.opacity = trace.opacity;\n\n        optsOut.markers = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.markers[i] = getSymbolSdf({\n                mx: optsOut.symbols[i],\n                ma: optsOut.angles[i]\n            }, trace);\n        }\n    } else {\n        if(isOpen) {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.color[3] = 0;\n            optsOut.borderColor = rgba(optsIn.color, 'uint8');\n        } else {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n        }\n\n        optsOut.opacity = trace.opacity * optsIn.opacity;\n\n        optsOut.marker = getSymbolSdf({\n            mx: optsIn.symbol,\n            ma: optsIn.angle\n        }, trace);\n    }\n\n    // prepare sizes\n    var sizeFactor = 1;\n    var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n    var s;\n\n    if(multiSize || multiLineWidth) {\n        var sizes = optsOut.sizes = new Array(count);\n        var borderSizes = optsOut.borderSizes = new Array(count);\n        var sizeTotal = 0;\n        var sizeAvg;\n\n        if(multiSize) {\n            for(i = 0; i < count; i++) {\n                sizes[i] = markerSizeFunc(optsIn.size[i]);\n                sizeTotal += sizes[i];\n            }\n            sizeAvg = sizeTotal / count;\n        } else {\n            s = markerSizeFunc(optsIn.size);\n            for(i = 0; i < count; i++) {\n                sizes[i] = s;\n            }\n        }\n\n        // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n        if(multiLineWidth) {\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = optsIn.line.width[i];\n            }\n        } else {\n            s = optsIn.line.width;\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = s;\n            }\n        }\n\n        optsOut.sizeAvg = sizeAvg;\n    } else {\n        optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n        optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n    }\n\n    return optsOut;\n}\n\nfunction convertMarkerSelection(gd, trace, target) {\n    var optsIn = trace.marker;\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.marker && target.marker.symbol) {\n        optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));\n    } else if(target.marker) {\n        if(target.marker.size) optsOut.size = target.marker.size;\n        if(target.marker.color) optsOut.colors = target.marker.color;\n        if(target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n    }\n\n    return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.textfont) {\n        var optsIn = {\n            opacity: 1,\n            text: trace.text,\n            texttemplate: trace.texttemplate,\n            textposition: trace.textposition,\n            textfont: Lib.extendFlat({}, trace.textfont)\n        };\n        if(target.textfont) {\n            Lib.extendFlat(optsIn.textfont, target.textfont);\n        }\n        optsOut = convertTextStyle(gd, optsIn);\n    }\n\n    return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n    var optsOut = {\n        capSize: target.width * 2 * plotGlPixelRatio,\n        lineWidth: target.thickness * plotGlPixelRatio,\n        color: target.color\n    };\n\n    if(target.copy_ystyle) {\n        optsOut = trace.error_y;\n    }\n\n    return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(d, trace) {\n    var symbol = d.mx;\n    if(symbol === 'circle') return null;\n\n    var symbolPath, symbolSdf;\n    var symbolNumber = Drawing.symbolNumber(symbol);\n    var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n    var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n    var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n\n    var isDot = helpers.isDotSymbol(symbol);\n\n    // until we may handle angles in shader?\n    if(d.ma) symbol += '_' + d.ma;\n\n    // get symbol sdf from cache or generate it\n    if(SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n    var angle = Drawing.getMarkerAngle(d, trace);\n    if(isDot && !symbolNoDot) {\n        symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;\n    } else {\n        symbolPath = symbolFunc(SYMBOL_SIZE, angle);\n    }\n\n    symbolSdf = svgSdf(symbolPath, {\n        w: SYMBOL_SDF_SIZE,\n        h: SYMBOL_SDF_SIZE,\n        viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n        stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n    });\n\n    SYMBOL_SDF[symbol] = symbolSdf;\n\n    return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n    var len = positions.length;\n    var count = len / 2;\n    var linePositions;\n    var i;\n\n    if(subTypes.hasLines(trace) && count) {\n        if(trace.line.shape === 'hv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'hvh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 3]\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vhv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        positions[i * 2],\n                        midPtY,\n                        positions[i * 2 + 2],\n                        midPtY\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else {\n            linePositions = positions;\n        }\n    }\n\n    // If we have data with gaps, we ought to use rect joins\n    // FIXME: get rid of this\n    var hasNaN = false;\n    for(i = 0; i < linePositions.length; i++) {\n        if(isNaN(linePositions[i])) {\n            hasNaN = true;\n            break;\n        }\n    }\n\n    var join = (hasNaN || linePositions.length > constants.TOO_MANY_POINTS) ? 'rect' :\n        subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n    // fill gaps\n    if(hasNaN && trace.connectgaps) {\n        var lastX = linePositions[0];\n        var lastY = linePositions[1];\n\n        for(i = 0; i < linePositions.length; i += 2) {\n            if(isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n                linePositions[i] = lastX;\n                linePositions[i + 1] = lastY;\n            } else {\n                lastX = linePositions[i];\n                lastY = linePositions[i + 1];\n            }\n        }\n    }\n\n    return {\n        join: join,\n        positions: linePositions\n    };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n    var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n    var xa = AxisIDs.getFromId(gd, trace.xaxis, 'x');\n    var ya = AxisIDs.getFromId(gd, trace.yaxis, 'y');\n    var count = positions.length / 2;\n    var out = {};\n\n    function convertOneAxis(coords, ax) {\n        var axLetter = ax._id.charAt(0);\n        var opts = trace['error_' + axLetter];\n\n        if(opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n            var computeError = makeComputeError(opts);\n            var pOffset = {x: 0, y: 1}[axLetter];\n            var eOffset = {x: [0, 1, 2, 3], y: [2, 3, 0, 1]}[axLetter];\n            var errors = new Float64Array(4 * count);\n            var minShoe = Infinity;\n            var maxHat = -Infinity;\n\n            for(var i = 0, j = 0; i < count; i++, j += 4) {\n                var dc = coords[i];\n\n                if(isNumeric(dc)) {\n                    var dl = positions[i * 2 + pOffset];\n                    var vals = computeError(dc, i);\n                    var lv = vals[0];\n                    var hv = vals[1];\n\n                    if(isNumeric(lv) && isNumeric(hv)) {\n                        var shoe = dc - lv;\n                        var hat = dc + hv;\n\n                        errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n                        errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n                        errors[j + eOffset[2]] = 0;\n                        errors[j + eOffset[3]] = 0;\n\n                        minShoe = Math.min(minShoe, dc - lv);\n                        maxHat = Math.max(maxHat, dc + hv);\n                    }\n                }\n            }\n\n            out[axLetter] = {\n                positions: positions,\n                errors: errors,\n                _bnds: [minShoe, maxHat]\n            };\n        }\n    }\n\n    convertOneAxis(x, xa);\n    convertOneAxis(y, ya);\n    return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n    var count = trace._length;\n    var out = {};\n    var i;\n\n    // corresponds to textPointPosition from component.drawing\n    if(subTypes.hasMarkers(trace)) {\n        var fontOpts = textOpts.font;\n        var align = textOpts.align;\n        var baseline = textOpts.baseline;\n        out.offset = new Array(count);\n\n        for(i = 0; i < count; i++) {\n            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n            var fs = isArrayOrTypedArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n\n            var a = isArrayOrTypedArray(align) ?\n                (align.length > 1 ? align[i] : align[0]) :\n                align;\n            var b = isArrayOrTypedArray(baseline) ?\n                (baseline.length > 1 ? baseline[i] : baseline[0]) :\n                baseline;\n\n            var hSign = TEXTOFFSETSIGN[a];\n            var vSign = TEXTOFFSETSIGN[b];\n            var xPad = ms ? ms / 0.8 + 1 : 0;\n            var yPad = -vSign * xPad - vSign * 0.5;\n            out.offset[i] = [hSign * xPad / fs, yPad / fs];\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    style: convertStyle,\n\n    markerStyle: convertMarkerStyle,\n    markerSelection: convertMarkerSelection,\n\n    linePositions: convertLinePositions,\n    errorBarPositions: convertErrorBarPositions,\n    textPosition: convertTextPosition\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}