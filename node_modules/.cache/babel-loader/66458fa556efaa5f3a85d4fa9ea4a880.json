{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Plots = require('../../plots/plots');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar constants = require('./constants');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\nmodule.exports = function draw(gd) {\n  var staticPlot = gd._context.staticPlot;\n  var fullLayout = gd._fullLayout;\n  var sliderData = makeSliderData(fullLayout, gd);\n\n  // draw a container for *all* sliders:\n  var sliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);\n  sliders.enter().append('g').classed(constants.containerClassName, true).style('cursor', staticPlot ? null : 'ew-resize');\n  function clearSlider(sliderOpts) {\n    if (sliderOpts._commandObserver) {\n      sliderOpts._commandObserver.remove();\n      delete sliderOpts._commandObserver;\n    }\n\n    // Most components don't need to explicitly remove autoMargin, because\n    // marginPushers does this - but slider updates don't go through\n    // a full replot so we need to explicitly remove it.\n    Plots.autoMargin(gd, autoMarginId(sliderOpts));\n  }\n  sliders.exit().each(function () {\n    d3.select(this).selectAll('g.' + constants.groupClassName).each(clearSlider);\n  }).remove();\n\n  // Return early if no menus visible:\n  if (sliderData.length === 0) return;\n  var sliderGroups = sliders.selectAll('g.' + constants.groupClassName).data(sliderData, keyFunction);\n  sliderGroups.enter().append('g').classed(constants.groupClassName, true);\n  sliderGroups.exit().each(clearSlider).remove();\n\n  // Find the dimensions of the sliders:\n  for (var i = 0; i < sliderData.length; i++) {\n    var sliderOpts = sliderData[i];\n    findDimensions(gd, sliderOpts);\n  }\n  sliderGroups.each(function (sliderOpts) {\n    var gSlider = d3.select(this);\n    computeLabelSteps(sliderOpts);\n    Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function (data) {\n      // NB: Same as below. This is *not* always the same as sliderOpts since\n      // if a new set of steps comes in, the reference in this callback would\n      // be invalid. We need to refetch it from the slider group, which is\n      // the join data that creates this slider. So if this slider still exists,\n      // the group should be valid, *to the best of my knowledge.* If not,\n      // we'd have to look it up by d3 data join index/key.\n      var opts = gSlider.data()[0];\n      if (opts.active === data.index) return;\n      if (opts._dragging) return;\n      setActive(gd, gSlider, opts, data.index, false, true);\n    });\n    drawSlider(gd, d3.select(this), sliderOpts);\n  });\n};\nfunction autoMarginId(sliderOpts) {\n  return constants.autoMarginIdRoot + sliderOpts._index;\n}\n\n// This really only just filters by visibility:\nfunction makeSliderData(fullLayout, gd) {\n  var contOpts = fullLayout[constants.name];\n  var sliderData = [];\n  for (var i = 0; i < contOpts.length; i++) {\n    var item = contOpts[i];\n    if (!item.visible) continue;\n    item._gd = gd;\n    sliderData.push(item);\n  }\n  return sliderData;\n}\n\n// This is set in the defaults step:\nfunction keyFunction(opts) {\n  return opts._index;\n}\n\n// Compute the dimensions (mutates sliderOpts):\nfunction findDimensions(gd, sliderOpts) {\n  var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass).data(sliderOpts._visibleSteps);\n  sliderLabels.enter().append('g').classed(constants.labelGroupClass, true);\n\n  // loop over fake buttons to find width / height\n  var maxLabelWidth = 0;\n  var labelHeight = 0;\n  sliderLabels.each(function (stepOpts) {\n    var labelGroup = d3.select(this);\n    var text = drawLabel(labelGroup, {\n      step: stepOpts\n    }, sliderOpts);\n    var textNode = text.node();\n    if (textNode) {\n      var bBox = Drawing.bBox(textNode);\n      labelHeight = Math.max(labelHeight, bBox.height);\n      maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n    }\n  });\n  sliderLabels.remove();\n  var dims = sliderOpts._dims = {};\n  dims.inputAreaWidth = Math.max(constants.railWidth, constants.gripHeight);\n\n  // calculate some overall dimensions - some of these are needed for\n  // calculating the currentValue dimensions\n  var graphSize = gd._fullLayout._size;\n  dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n  dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n  if (sliderOpts.lenmode === 'fraction') {\n    // fraction:\n    dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n  } else {\n    // pixels:\n    dims.outerLength = sliderOpts.len;\n  }\n\n  // The length of the rail, *excluding* padding on either end:\n  dims.inputAreaStart = 0;\n  dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n  var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n  var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n  var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n  dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n  dims.labelHeight = labelHeight;\n\n  // loop over all possible values for currentValue to find the\n  // area we need for it\n  dims.currentValueMaxWidth = 0;\n  dims.currentValueHeight = 0;\n  dims.currentValueTotalHeight = 0;\n  dims.currentValueMaxLines = 1;\n  if (sliderOpts.currentvalue.visible) {\n    // Get the dimensions of the current value label:\n    var dummyGroup = Drawing.tester.append('g');\n    sliderLabels.each(function (stepOpts) {\n      var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n      var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || {\n        width: 0,\n        height: 0\n      };\n      var lines = svgTextUtils.lineCount(curValPrefix);\n      dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n      dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n      dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n    });\n    dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n    dummyGroup.remove();\n  }\n  dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n  var xanchor = 'left';\n  if (Lib.isRightAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength;\n    xanchor = 'right';\n  }\n  if (Lib.isCenterAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength / 2;\n    xanchor = 'center';\n  }\n  var yanchor = 'top';\n  if (Lib.isBottomAnchor(sliderOpts)) {\n    dims.ly -= dims.height;\n    yanchor = 'bottom';\n  }\n  if (Lib.isMiddleAnchor(sliderOpts)) {\n    dims.ly -= dims.height / 2;\n    yanchor = 'middle';\n  }\n  dims.outerLength = Math.ceil(dims.outerLength);\n  dims.height = Math.ceil(dims.height);\n  dims.lx = Math.round(dims.lx);\n  dims.ly = Math.round(dims.ly);\n  var marginOpts = {\n    y: sliderOpts.y,\n    b: dims.height * FROM_BR[yanchor],\n    t: dims.height * FROM_TL[yanchor]\n  };\n  if (sliderOpts.lenmode === 'fraction') {\n    marginOpts.l = 0;\n    marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n    marginOpts.r = 0;\n    marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n  } else {\n    marginOpts.x = sliderOpts.x;\n    marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n    marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n  }\n  Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n  // This is related to the other long notes in this file regarding what happens\n  // when slider steps disappear. This particular fix handles what happens when\n  // the *current* slider step is removed. The drawing functions will error out\n  // when they fail to find it, so the fix for now is that it will just draw the\n  // slider in the first position but will not execute the command.\n  if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {\n    sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n  }\n\n  // These are carefully ordered for proper z-ordering:\n  sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);\n  var dims = sliderOpts._dims;\n\n  // Position the rectangle:\n  Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n  sliderGroup.call(setGripPosition, sliderOpts, false);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n}\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n  if (!sliderOpts.currentvalue.visible) return;\n  var dims = sliderOpts._dims;\n  var x0, textAnchor;\n  switch (sliderOpts.currentvalue.xanchor) {\n    case 'right':\n      // This is anchored left and adjusted by the width of the longest label\n      // so that the prefix doesn't move. The goal of this is to emphasize\n      // what's actually changing and make the update less distracting.\n      x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n      textAnchor = 'left';\n      break;\n    case 'center':\n      x0 = dims.inputAreaLength * 0.5;\n      textAnchor = 'middle';\n      break;\n    default:\n      x0 = constants.currentValueInset;\n      textAnchor = 'left';\n  }\n  var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function (s) {\n    s.attr({\n      'text-anchor': textAnchor,\n      'data-notex': 1\n    });\n  });\n  var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n  if (typeof valueOverride === 'string') {\n    str += valueOverride;\n  } else {\n    var curVal = sliderOpts.steps[sliderOpts.active].label;\n    var _meta = sliderOpts._gd._fullLayout._meta;\n    if (_meta) curVal = Lib.templateString(curVal, _meta);\n    str += curVal;\n  }\n  if (sliderOpts.currentvalue.suffix) {\n    str += sliderOpts.currentvalue.suffix;\n  }\n  text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  var lines = svgTextUtils.lineCount(text);\n  var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;\n  svgTextUtils.positionText(text, x0, y0);\n  return text;\n}\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n  var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  grip.attr({\n    width: constants.gripWidth,\n    height: constants.gripHeight,\n    rx: constants.gripRadius,\n    ry: constants.gripRadius\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n}\nfunction drawLabel(item, data, sliderOpts) {\n  var text = Lib.ensureSingle(item, 'text', constants.labelClass, function (s) {\n    s.attr({\n      'text-anchor': 'middle',\n      'data-notex': 1\n    });\n  });\n  var tx = data.step.label;\n  var _meta = sliderOpts._gd._fullLayout._meta;\n  if (_meta) tx = Lib.templateString(tx, _meta);\n  text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  return text;\n}\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n  var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n  var dims = sliderOpts._dims;\n  var labelItems = labels.selectAll('g.' + constants.labelGroupClass).data(dims.labelSteps);\n  labelItems.enter().append('g').classed(constants.labelGroupClass, true);\n  labelItems.exit().remove();\n  labelItems.each(function (d) {\n    var item = d3.select(this);\n    item.call(drawLabel, d, sliderOpts);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, d.fraction), constants.tickOffset + sliderOpts.ticklen +\n    // position is the baseline of the top line of text only, even\n    // if the label spans multiple lines\n    sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight);\n  });\n}\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n  var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n  var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n  if (quantizedIndex !== sliderOpts.active) {\n    setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n  }\n}\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n  var previousActive = sliderOpts.active;\n  sliderOpts.active = index;\n\n  // due to templating, it's possible this slider doesn't even exist yet\n  arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate('active', index);\n  var step = sliderOpts.steps[sliderOpts.active];\n  sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n  gd.emit('plotly_sliderchange', {\n    slider: sliderOpts,\n    step: sliderOpts.steps[sliderOpts.active],\n    interaction: doCallback,\n    previousActive: previousActive\n  });\n  if (step && step.method && doCallback) {\n    if (sliderGroup._nextMethod) {\n      // If we've already queued up an update, just overwrite it with the most recent:\n      sliderGroup._nextMethod.step = step;\n      sliderGroup._nextMethod.doCallback = doCallback;\n      sliderGroup._nextMethod.doTransition = doTransition;\n    } else {\n      sliderGroup._nextMethod = {\n        step: step,\n        doCallback: doCallback,\n        doTransition: doTransition\n      };\n      sliderGroup._nextMethodRaf = window.requestAnimationFrame(function () {\n        var _step = sliderGroup._nextMethod.step;\n        if (!_step.method) return;\n        if (_step.execute) {\n          Plots.executeAPICommand(gd, _step.method, _step.args);\n        }\n        sliderGroup._nextMethod = null;\n        sliderGroup._nextMethodRaf = null;\n      });\n    }\n  }\n}\nfunction attachGripEvents(item, gd, sliderGroup) {\n  if (gd._context.staticPlot) return;\n  var node = sliderGroup.node();\n  var $gd = d3.select(gd);\n\n  // NB: This is *not* the same as sliderOpts itself! These callbacks\n  // are in a closure so this array won't actually be correct if the\n  // steps have changed since this was initialized. The sliderGroup,\n  // however, has not changed since that *is* the slider, so it must\n  // be present to receive mouse events.\n  function getSliderOpts() {\n    return sliderGroup.data()[0];\n  }\n  function mouseDownHandler() {\n    var sliderOpts = getSliderOpts();\n    gd.emit('plotly_sliderstart', {\n      slider: sliderOpts\n    });\n    var grip = sliderGroup.select('.' + constants.gripRectClass);\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n    grip.call(Color.fill, sliderOpts.activebgcolor);\n    var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n    handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n    sliderOpts._dragging = true;\n    function mouseMoveHandler() {\n      var sliderOpts = getSliderOpts();\n      var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n      handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n    }\n    $gd.on('mousemove', mouseMoveHandler);\n    $gd.on('touchmove', mouseMoveHandler);\n    function mouseUpHandler() {\n      var sliderOpts = getSliderOpts();\n      sliderOpts._dragging = false;\n      grip.call(Color.fill, sliderOpts.bgcolor);\n      $gd.on('mouseup', null);\n      $gd.on('mousemove', null);\n      $gd.on('touchend', null);\n      $gd.on('touchmove', null);\n      gd.emit('plotly_sliderend', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active]\n      });\n    }\n    $gd.on('mouseup', mouseUpHandler);\n    $gd.on('touchend', mouseUpHandler);\n  }\n  item.on('mousedown', mouseDownHandler);\n  item.on('touchstart', mouseDownHandler);\n}\nfunction drawTicks(sliderGroup, sliderOpts) {\n  var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass).data(sliderOpts._visibleSteps);\n  var dims = sliderOpts._dims;\n  tick.enter().append('rect').classed(constants.tickRectClass, true);\n  tick.exit().remove();\n  tick.attr({\n    width: sliderOpts.tickwidth + 'px',\n    'shape-rendering': 'crispEdges'\n  });\n  tick.each(function (d, i) {\n    var isMajor = i % dims.labelStride === 0;\n    var item = d3.select(this);\n    item.attr({\n      height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen\n    }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth, (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight);\n  });\n}\nfunction computeLabelSteps(sliderOpts) {\n  var dims = sliderOpts._dims;\n  dims.labelSteps = [];\n  var nsteps = sliderOpts._stepCount;\n  for (var i = 0; i < nsteps; i += dims.labelStride) {\n    dims.labelSteps.push({\n      fraction: i / (nsteps - 1),\n      step: sliderOpts._visibleSteps[i]\n    });\n  }\n}\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n  var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n  var quantizedIndex = 0;\n  for (var i = 0; i < sliderOpts._stepCount; i++) {\n    if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n      quantizedIndex = i;\n      break;\n    }\n  }\n  var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));\n\n  // If this is true, then *this component* is already invoking its own command\n  // and has triggered its own animation.\n  if (sliderOpts._invokingCommand) return;\n  var el = grip;\n  if (doTransition && sliderOpts.transition.duration > 0) {\n    el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);\n  }\n\n  // Drawing.setTranslate doesn't work here because of the transition duck-typing.\n  // It's also not necessary because there are no other transitions to preserve.\n  el.attr('transform', strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));\n}\n\n// Convert a number from [0-1] to a pixel position relative to the slider group container:\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n  var dims = sliderOpts._dims;\n  return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n}\n\n// Convert a position relative to the slider group to a nubmer in [0, 1]\nfunction positionToNormalizedValue(sliderOpts, position) {\n  var dims = sliderOpts._dims;\n  return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  rect.attr({\n    width: dims.inputAreaLength,\n    height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n  }).call(Color.fill, sliderOpts.bgcolor).attr('opacity', 0);\n  Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\nfunction drawRail(sliderGroup, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var computedLength = dims.inputAreaLength - constants.railInset * 2;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n  rect.attr({\n    width: computedLength,\n    height: constants.railWidth,\n    rx: constants.railRadius,\n    ry: constants.railRadius,\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n  Drawing.setTranslate(rect, constants.railInset, (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight);\n}","map":{"version":3,"names":["d3","require","Plots","Color","Drawing","Lib","strTranslate","svgTextUtils","arrayEditor","constants","alignmentConstants","LINE_SPACING","FROM_TL","FROM_BR","module","exports","draw","gd","staticPlot","_context","fullLayout","_fullLayout","sliderData","makeSliderData","sliders","_infolayer","selectAll","containerClassName","data","length","enter","append","classed","style","clearSlider","sliderOpts","_commandObserver","remove","autoMargin","autoMarginId","exit","each","select","groupClassName","sliderGroups","keyFunction","i","findDimensions","gSlider","computeLabelSteps","manageCommandObserver","_visibleSteps","opts","active","index","_dragging","setActive","drawSlider","autoMarginIdRoot","_index","contOpts","name","item","visible","_gd","push","sliderLabels","tester","labelGroupClass","maxLabelWidth","labelHeight","stepOpts","labelGroup","text","drawLabel","step","textNode","node","bBox","Math","max","height","width","dims","_dims","inputAreaWidth","railWidth","gripHeight","graphSize","_size","lx","l","w","x","ly","t","h","y","lenmode","outerLength","round","len","inputAreaStart","inputAreaLength","pad","r","textableInputLength","stepInset","availableSpacePerLabel","_stepCount","computedSpacePerLabel","labelPadding","labelStride","ceil","currentValueMaxWidth","currentValueHeight","currentValueTotalHeight","currentValueMaxLines","currentvalue","dummyGroup","curValPrefix","drawCurrentValue","label","curValSize","lines","lineCount","offset","tickOffset","ticklen","labelOffset","b","xanchor","isRightAnchor","isCenterAnchor","yanchor","isBottomAnchor","isMiddleAnchor","marginOpts","xl","xr","sliderGroup","steps","call","drawRail","drawLabelGroup","drawTicks","drawTouchRect","drawGrip","setTranslate","setGripPosition","valueOverride","x0","textAnchor","currentValueInset","ensureSingle","labelClass","s","attr","str","prefix","curVal","_meta","templateString","suffix","font","convertToTspans","y0","size","positionText","grip","gripRectClass","attachGripEvents","gripWidth","rx","gripRadius","ry","stroke","bordercolor","fill","bgcolor","borderwidth","tx","labels","labelsClass","labelItems","labelSteps","d","normalizedValueToPosition","fraction","handleInput","normalizedPosition","doTransition","quantizedPosition","quantizedIndex","doCallback","previousActive","layout","applyUpdate","emit","slider","interaction","method","_nextMethod","_nextMethodRaf","window","requestAnimationFrame","_step","execute","executeAPICommand","args","$gd","getSliderOpts","mouseDownHandler","event","stopPropagation","preventDefault","activebgcolor","positionToNormalizedValue","mouse","mouseMoveHandler","on","mouseUpHandler","tick","tickRectClass","tickwidth","isMajor","minorticklen","tickcolor","minorTickOffset","nsteps","_invokingCommand","el","transition","duration","ease","easing","min","position","rect","railTouchRectClass","computedLength","railInset","railRectClass","railRadius"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/sliders/draw.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Plots = require('../../plots/plots');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar constants = require('./constants');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nmodule.exports = function draw(gd) {\n    var staticPlot = gd._context.staticPlot;\n    var fullLayout = gd._fullLayout;\n    var sliderData = makeSliderData(fullLayout, gd);\n\n    // draw a container for *all* sliders:\n    var sliders = fullLayout._infolayer\n        .selectAll('g.' + constants.containerClassName)\n        .data(sliderData.length > 0 ? [0] : []);\n\n    sliders.enter().append('g')\n        .classed(constants.containerClassName, true)\n        .style('cursor', staticPlot ? null : 'ew-resize');\n\n    function clearSlider(sliderOpts) {\n        if(sliderOpts._commandObserver) {\n            sliderOpts._commandObserver.remove();\n            delete sliderOpts._commandObserver;\n        }\n\n        // Most components don't need to explicitly remove autoMargin, because\n        // marginPushers does this - but slider updates don't go through\n        // a full replot so we need to explicitly remove it.\n        Plots.autoMargin(gd, autoMarginId(sliderOpts));\n    }\n\n    sliders.exit().each(function() {\n        d3.select(this).selectAll('g.' + constants.groupClassName)\n            .each(clearSlider);\n    })\n    .remove();\n\n    // Return early if no menus visible:\n    if(sliderData.length === 0) return;\n\n    var sliderGroups = sliders.selectAll('g.' + constants.groupClassName)\n        .data(sliderData, keyFunction);\n\n    sliderGroups.enter().append('g')\n        .classed(constants.groupClassName, true);\n\n    sliderGroups.exit()\n        .each(clearSlider)\n        .remove();\n\n    // Find the dimensions of the sliders:\n    for(var i = 0; i < sliderData.length; i++) {\n        var sliderOpts = sliderData[i];\n        findDimensions(gd, sliderOpts);\n    }\n\n    sliderGroups.each(function(sliderOpts) {\n        var gSlider = d3.select(this);\n\n        computeLabelSteps(sliderOpts);\n\n        Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function(data) {\n            // NB: Same as below. This is *not* always the same as sliderOpts since\n            // if a new set of steps comes in, the reference in this callback would\n            // be invalid. We need to refetch it from the slider group, which is\n            // the join data that creates this slider. So if this slider still exists,\n            // the group should be valid, *to the best of my knowledge.* If not,\n            // we'd have to look it up by d3 data join index/key.\n            var opts = gSlider.data()[0];\n\n            if(opts.active === data.index) return;\n            if(opts._dragging) return;\n\n            setActive(gd, gSlider, opts, data.index, false, true);\n        });\n\n        drawSlider(gd, d3.select(this), sliderOpts);\n    });\n};\n\nfunction autoMarginId(sliderOpts) {\n    return constants.autoMarginIdRoot + sliderOpts._index;\n}\n\n// This really only just filters by visibility:\nfunction makeSliderData(fullLayout, gd) {\n    var contOpts = fullLayout[constants.name];\n    var sliderData = [];\n\n    for(var i = 0; i < contOpts.length; i++) {\n        var item = contOpts[i];\n        if(!item.visible) continue;\n        item._gd = gd;\n        sliderData.push(item);\n    }\n\n    return sliderData;\n}\n\n// This is set in the defaults step:\nfunction keyFunction(opts) {\n    return opts._index;\n}\n\n// Compute the dimensions (mutates sliderOpts):\nfunction findDimensions(gd, sliderOpts) {\n    var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass)\n        .data(sliderOpts._visibleSteps);\n\n    sliderLabels.enter().append('g')\n        .classed(constants.labelGroupClass, true);\n\n    // loop over fake buttons to find width / height\n    var maxLabelWidth = 0;\n    var labelHeight = 0;\n    sliderLabels.each(function(stepOpts) {\n        var labelGroup = d3.select(this);\n\n        var text = drawLabel(labelGroup, {step: stepOpts}, sliderOpts);\n\n        var textNode = text.node();\n        if(textNode) {\n            var bBox = Drawing.bBox(textNode);\n            labelHeight = Math.max(labelHeight, bBox.height);\n            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n        }\n    });\n\n    sliderLabels.remove();\n\n    var dims = sliderOpts._dims = {};\n\n    dims.inputAreaWidth = Math.max(\n        constants.railWidth,\n        constants.gripHeight\n    );\n\n    // calculate some overall dimensions - some of these are needed for\n    // calculating the currentValue dimensions\n    var graphSize = gd._fullLayout._size;\n    dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n    dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n\n    if(sliderOpts.lenmode === 'fraction') {\n        // fraction:\n        dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n    } else {\n        // pixels:\n        dims.outerLength = sliderOpts.len;\n    }\n\n    // The length of the rail, *excluding* padding on either end:\n    dims.inputAreaStart = 0;\n    dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n\n    var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n    var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n    var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n    dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n    dims.labelHeight = labelHeight;\n\n    // loop over all possible values for currentValue to find the\n    // area we need for it\n    dims.currentValueMaxWidth = 0;\n    dims.currentValueHeight = 0;\n    dims.currentValueTotalHeight = 0;\n    dims.currentValueMaxLines = 1;\n\n    if(sliderOpts.currentvalue.visible) {\n        // Get the dimensions of the current value label:\n        var dummyGroup = Drawing.tester.append('g');\n\n        sliderLabels.each(function(stepOpts) {\n            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n            var curValSize = (curValPrefix.node() && Drawing.bBox(curValPrefix.node())) || {width: 0, height: 0};\n            var lines = svgTextUtils.lineCount(curValPrefix);\n            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n        });\n\n        dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n\n        dummyGroup.remove();\n    }\n\n    dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n\n    var xanchor = 'left';\n    if(Lib.isRightAnchor(sliderOpts)) {\n        dims.lx -= dims.outerLength;\n        xanchor = 'right';\n    }\n    if(Lib.isCenterAnchor(sliderOpts)) {\n        dims.lx -= dims.outerLength / 2;\n        xanchor = 'center';\n    }\n\n    var yanchor = 'top';\n    if(Lib.isBottomAnchor(sliderOpts)) {\n        dims.ly -= dims.height;\n        yanchor = 'bottom';\n    }\n    if(Lib.isMiddleAnchor(sliderOpts)) {\n        dims.ly -= dims.height / 2;\n        yanchor = 'middle';\n    }\n\n    dims.outerLength = Math.ceil(dims.outerLength);\n    dims.height = Math.ceil(dims.height);\n    dims.lx = Math.round(dims.lx);\n    dims.ly = Math.round(dims.ly);\n\n    var marginOpts = {\n        y: sliderOpts.y,\n        b: dims.height * FROM_BR[yanchor],\n        t: dims.height * FROM_TL[yanchor]\n    };\n\n    if(sliderOpts.lenmode === 'fraction') {\n        marginOpts.l = 0;\n        marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n        marginOpts.r = 0;\n        marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n    } else {\n        marginOpts.x = sliderOpts.x;\n        marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n        marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n    }\n\n    Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\n\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n    // This is related to the other long notes in this file regarding what happens\n    // when slider steps disappear. This particular fix handles what happens when\n    // the *current* slider step is removed. The drawing functions will error out\n    // when they fail to find it, so the fix for now is that it will just draw the\n    // slider in the first position but will not execute the command.\n    if(!((sliderOpts.steps[sliderOpts.active] || {}).visible)) {\n        sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n    }\n\n    // These are carefully ordered for proper z-ordering:\n    sliderGroup\n        .call(drawCurrentValue, sliderOpts)\n        .call(drawRail, sliderOpts)\n        .call(drawLabelGroup, sliderOpts)\n        .call(drawTicks, sliderOpts)\n        .call(drawTouchRect, gd, sliderOpts)\n        .call(drawGrip, gd, sliderOpts);\n\n    var dims = sliderOpts._dims;\n\n    // Position the rectangle:\n    Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n\n    sliderGroup.call(setGripPosition, sliderOpts, false);\n    sliderGroup.call(drawCurrentValue, sliderOpts);\n}\n\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n    if(!sliderOpts.currentvalue.visible) return;\n\n    var dims = sliderOpts._dims;\n    var x0, textAnchor;\n\n    switch(sliderOpts.currentvalue.xanchor) {\n        case 'right':\n            // This is anchored left and adjusted by the width of the longest label\n            // so that the prefix doesn't move. The goal of this is to emphasize\n            // what's actually changing and make the update less distracting.\n            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n            textAnchor = 'left';\n            break;\n        case 'center':\n            x0 = dims.inputAreaLength * 0.5;\n            textAnchor = 'middle';\n            break;\n        default:\n            x0 = constants.currentValueInset;\n            textAnchor = 'left';\n    }\n\n    var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function(s) {\n        s.attr({\n            'text-anchor': textAnchor,\n            'data-notex': 1\n        });\n    });\n\n    var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n\n    if(typeof valueOverride === 'string') {\n        str += valueOverride;\n    } else {\n        var curVal = sliderOpts.steps[sliderOpts.active].label;\n        var _meta = sliderOpts._gd._fullLayout._meta;\n        if(_meta) curVal = Lib.templateString(curVal, _meta);\n        str += curVal;\n    }\n\n    if(sliderOpts.currentvalue.suffix) {\n        str += sliderOpts.currentvalue.suffix;\n    }\n\n    text.call(Drawing.font, sliderOpts.currentvalue.font)\n        .text(str)\n        .call(svgTextUtils.convertToTspans, sliderOpts._gd);\n\n    var lines = svgTextUtils.lineCount(text);\n\n    var y0 = (dims.currentValueMaxLines + 1 - lines) *\n        sliderOpts.currentvalue.font.size * LINE_SPACING;\n\n    svgTextUtils.positionText(text, x0, y0);\n\n    return text;\n}\n\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n    var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function(s) {\n        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)\n            .style('pointer-events', 'all');\n    });\n\n    grip.attr({\n        width: constants.gripWidth,\n        height: constants.gripHeight,\n        rx: constants.gripRadius,\n        ry: constants.gripRadius,\n    })\n    .call(Color.stroke, sliderOpts.bordercolor)\n    .call(Color.fill, sliderOpts.bgcolor)\n    .style('stroke-width', sliderOpts.borderwidth + 'px');\n}\n\nfunction drawLabel(item, data, sliderOpts) {\n    var text = Lib.ensureSingle(item, 'text', constants.labelClass, function(s) {\n        s.attr({\n            'text-anchor': 'middle',\n            'data-notex': 1\n        });\n    });\n\n    var tx = data.step.label;\n    var _meta = sliderOpts._gd._fullLayout._meta;\n    if(_meta) tx = Lib.templateString(tx, _meta);\n\n    text.call(Drawing.font, sliderOpts.font)\n        .text(tx)\n        .call(svgTextUtils.convertToTspans, sliderOpts._gd);\n\n    return text;\n}\n\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n    var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n    var dims = sliderOpts._dims;\n\n    var labelItems = labels.selectAll('g.' + constants.labelGroupClass)\n        .data(dims.labelSteps);\n\n    labelItems.enter().append('g')\n        .classed(constants.labelGroupClass, true);\n\n    labelItems.exit().remove();\n\n    labelItems.each(function(d) {\n        var item = d3.select(this);\n\n        item.call(drawLabel, d, sliderOpts);\n\n        Drawing.setTranslate(item,\n            normalizedValueToPosition(sliderOpts, d.fraction),\n            constants.tickOffset +\n                sliderOpts.ticklen +\n                // position is the baseline of the top line of text only, even\n                // if the label spans multiple lines\n                sliderOpts.font.size * LINE_SPACING +\n                constants.labelOffset +\n                dims.currentValueTotalHeight\n        );\n    });\n}\n\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n    var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n    var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n\n    if(quantizedIndex !== sliderOpts.active) {\n        setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n    }\n}\n\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n    var previousActive = sliderOpts.active;\n    sliderOpts.active = index;\n\n    // due to templating, it's possible this slider doesn't even exist yet\n    arrayEditor(gd.layout, constants.name, sliderOpts)\n        .applyUpdate('active', index);\n\n    var step = sliderOpts.steps[sliderOpts.active];\n\n    sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n    sliderGroup.call(drawCurrentValue, sliderOpts);\n\n    gd.emit('plotly_sliderchange', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active],\n        interaction: doCallback,\n        previousActive: previousActive\n    });\n\n    if(step && step.method && doCallback) {\n        if(sliderGroup._nextMethod) {\n            // If we've already queued up an update, just overwrite it with the most recent:\n            sliderGroup._nextMethod.step = step;\n            sliderGroup._nextMethod.doCallback = doCallback;\n            sliderGroup._nextMethod.doTransition = doTransition;\n        } else {\n            sliderGroup._nextMethod = {step: step, doCallback: doCallback, doTransition: doTransition};\n            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {\n                var _step = sliderGroup._nextMethod.step;\n                if(!_step.method) return;\n\n                if(_step.execute) {\n                    Plots.executeAPICommand(gd, _step.method, _step.args);\n                }\n\n                sliderGroup._nextMethod = null;\n                sliderGroup._nextMethodRaf = null;\n            });\n        }\n    }\n}\n\nfunction attachGripEvents(item, gd, sliderGroup) {\n    if(gd._context.staticPlot) return;\n\n    var node = sliderGroup.node();\n    var $gd = d3.select(gd);\n\n    // NB: This is *not* the same as sliderOpts itself! These callbacks\n    // are in a closure so this array won't actually be correct if the\n    // steps have changed since this was initialized. The sliderGroup,\n    // however, has not changed since that *is* the slider, so it must\n    // be present to receive mouse events.\n    function getSliderOpts() {\n        return sliderGroup.data()[0];\n    }\n\n    function mouseDownHandler() {\n        var sliderOpts = getSliderOpts();\n        gd.emit('plotly_sliderstart', {slider: sliderOpts});\n\n        var grip = sliderGroup.select('.' + constants.gripRectClass);\n\n        d3.event.stopPropagation();\n        d3.event.preventDefault();\n        grip.call(Color.fill, sliderOpts.activebgcolor);\n\n        var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n        handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n        sliderOpts._dragging = true;\n\n        function mouseMoveHandler() {\n            var sliderOpts = getSliderOpts();\n            var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n            handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n        }\n\n        $gd.on('mousemove', mouseMoveHandler);\n        $gd.on('touchmove', mouseMoveHandler);\n\n        function mouseUpHandler() {\n            var sliderOpts = getSliderOpts();\n            sliderOpts._dragging = false;\n            grip.call(Color.fill, sliderOpts.bgcolor);\n            $gd.on('mouseup', null);\n            $gd.on('mousemove', null);\n            $gd.on('touchend', null);\n            $gd.on('touchmove', null);\n\n            gd.emit('plotly_sliderend', {\n                slider: sliderOpts,\n                step: sliderOpts.steps[sliderOpts.active]\n            });\n        }\n\n        $gd.on('mouseup', mouseUpHandler);\n        $gd.on('touchend', mouseUpHandler);\n    }\n\n    item.on('mousedown', mouseDownHandler);\n    item.on('touchstart', mouseDownHandler);\n}\n\nfunction drawTicks(sliderGroup, sliderOpts) {\n    var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass)\n        .data(sliderOpts._visibleSteps);\n    var dims = sliderOpts._dims;\n\n    tick.enter().append('rect')\n        .classed(constants.tickRectClass, true);\n\n    tick.exit().remove();\n\n    tick.attr({\n        width: sliderOpts.tickwidth + 'px',\n        'shape-rendering': 'crispEdges'\n    });\n\n    tick.each(function(d, i) {\n        var isMajor = i % dims.labelStride === 0;\n        var item = d3.select(this);\n\n        item\n            .attr({height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen})\n            .call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n\n        Drawing.setTranslate(item,\n            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,\n            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight\n        );\n    });\n}\n\nfunction computeLabelSteps(sliderOpts) {\n    var dims = sliderOpts._dims;\n    dims.labelSteps = [];\n    var nsteps = sliderOpts._stepCount;\n\n    for(var i = 0; i < nsteps; i += dims.labelStride) {\n        dims.labelSteps.push({\n            fraction: i / (nsteps - 1),\n            step: sliderOpts._visibleSteps[i]\n        });\n    }\n}\n\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n    var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n\n    var quantizedIndex = 0;\n    for(var i = 0; i < sliderOpts._stepCount; i++) {\n        if(sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n            quantizedIndex = i;\n            break;\n        }\n    }\n\n    var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));\n\n    // If this is true, then *this component* is already invoking its own command\n    // and has triggered its own animation.\n    if(sliderOpts._invokingCommand) return;\n\n    var el = grip;\n    if(doTransition && sliderOpts.transition.duration > 0) {\n        el = el.transition()\n            .duration(sliderOpts.transition.duration)\n            .ease(sliderOpts.transition.easing);\n    }\n\n    // Drawing.setTranslate doesn't work here because of the transition duck-typing.\n    // It's also not necessary because there are no other transitions to preserve.\n    el.attr('transform', strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));\n}\n\n// Convert a number from [0-1] to a pixel position relative to the slider group container:\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n    var dims = sliderOpts._dims;\n    return dims.inputAreaStart + constants.stepInset +\n        (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n}\n\n// Convert a position relative to the slider group to a nubmer in [0, 1]\nfunction positionToNormalizedValue(sliderOpts, position) {\n    var dims = sliderOpts._dims;\n    return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\n\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n    var dims = sliderOpts._dims;\n    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function(s) {\n        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)\n            .style('pointer-events', 'all');\n    });\n\n    rect.attr({\n        width: dims.inputAreaLength,\n        height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n    })\n        .call(Color.fill, sliderOpts.bgcolor)\n        .attr('opacity', 0);\n\n    Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\n\nfunction drawRail(sliderGroup, sliderOpts) {\n    var dims = sliderOpts._dims;\n    var computedLength = dims.inputAreaLength - constants.railInset * 2;\n    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n\n    rect.attr({\n        width: computedLength,\n        height: constants.railWidth,\n        rx: constants.railRadius,\n        ry: constants.railRadius,\n        'shape-rendering': 'crispEdges'\n    })\n    .call(Color.stroke, sliderOpts.bordercolor)\n    .call(Color.fill, sliderOpts.bgcolor)\n    .style('stroke-width', sliderOpts.borderwidth + 'px');\n\n    Drawing.setTranslate(rect,\n        constants.railInset,\n        (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}