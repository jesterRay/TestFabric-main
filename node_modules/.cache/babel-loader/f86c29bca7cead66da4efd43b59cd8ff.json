{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar getTraceColor = require('./get_trace_color');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var pt = [xpx, ypx];\n  var hoveron = trace.hoveron || '';\n  var minRad = trace.mode.indexOf('markers') !== -1 ? 3 : 0.5;\n  var xPeriod = !!trace.xperiodalignment;\n  var yPeriod = !!trace.yperiodalignment;\n\n  // look for points to hover on first, then take fills only if we\n  // didn't find a point\n\n  if (hoveron.indexOf('points') !== -1) {\n    // dx and dy are used in compare modes - here we want to always\n    // prioritize the closest data point, at least as long as markers are\n    // the same size or nonexistent, but still try to prioritize small markers too.\n    var dx = function (di) {\n      if (xPeriod) {\n        var x0 = xa.c2p(di.xStart);\n        var x1 = xa.c2p(di.xEnd);\n        return xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;\n      }\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\n      return dxRaw < rad ? kink * dxRaw / rad : dxRaw - rad + kink;\n    };\n    var dy = function (di) {\n      if (yPeriod) {\n        var y0 = ya.c2p(di.yStart);\n        var y1 = ya.c2p(di.yEnd);\n        return ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;\n      }\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\n      return dyRaw < rad ? kink * dyRaw / rad : dyRaw - rad + kink;\n    };\n\n    // scatter points: d.mrc is the calculated marker radius\n    // adjust the distance so if you're inside the marker it\n    // always will show up regardless of point size, but\n    // prioritize smaller points\n    var dxy = function (di) {\n      var rad = Math.max(minRad, di.mrc || 0);\n      var dx = xa.c2p(di.x) - xpx;\n      var dy = ya.c2p(di.y) - ypx;\n      return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\n    };\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if (pointData.index !== false) {\n      // the closest data point\n      var di = cd[pointData.index];\n      var xc = xa.c2p(di.x, true);\n      var yc = ya.c2p(di.y, true);\n      var rad = di.mrc || 1;\n\n      // now we're done using the whole `calcdata` array, replace the\n      // index with the original index (in case of inserted point from\n      // stacked area)\n      pointData.index = di.i;\n      var orientation = cd[0].t.orientation;\n      // TODO: for scatter and bar, option to show (sub)totals and\n      // raw data? Currently stacked and/or normalized bars just show\n      // the normalized individual sizes, so that's what I'm doing here\n      // for now.\n      var sizeVal = orientation && (di.sNorm || di.s);\n      var xLabelVal = orientation === 'h' ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;\n      var yLabelVal = orientation === 'v' ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;\n      Lib.extendFlat(pointData, {\n        color: getTraceColor(trace, di),\n        x0: xc - rad,\n        x1: xc + rad,\n        xLabelVal: xLabelVal,\n        y0: yc - rad,\n        y1: yc + rad,\n        yLabelVal: yLabelVal,\n        spikeDistance: dxy(di),\n        hovertemplate: trace.hovertemplate\n      });\n      fillText(di, trace, pointData);\n      Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n      return [pointData];\n    }\n  }\n  function isHoverPointInFillElement(el) {\n    // Uses SVGElement.isPointInFill to accurately determine wether\n    // the hover point / cursor is contained in the fill, taking\n    // curved or jagged edges into account, which the Polygon-based\n    // approach does not.\n    if (!el) {\n      return false;\n    }\n    var svgElement = el.node();\n    try {\n      var domPoint = new DOMPoint(pt[0], pt[1]);\n      return svgElement.isPointInFill(domPoint);\n    } catch (TypeError) {\n      var svgPoint = svgElement.ownerSVGElement.createSVGPoint();\n      svgPoint.x = pt[0];\n      svgPoint.y = pt[1];\n      return svgElement.isPointInFill(svgPoint);\n    }\n  }\n  function getHoverLabelPosition(polygons) {\n    // Uses Polygon s to determine the left- and right-most x-coordinates\n    // of the subshape of the fill that contains the hover point / cursor.\n    // Doing this with the SVGElement directly is quite tricky, so this falls\n    // back to the existing relatively simple code, accepting some small inaccuracies\n    // of label positioning for curved/jagged edges.\n    var i;\n    var polygonsIn = [];\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    var ymin = Infinity;\n    var ymax = -Infinity;\n    var yPos;\n    for (i = 0; i < polygons.length; i++) {\n      var polygon = polygons[i];\n      // This is not going to work right for curved or jagged edges, it will\n      // act as though they're straight.\n      if (polygon.contains(pt)) {\n        polygonsIn.push(polygon);\n        ymin = Math.min(ymin, polygon.ymin);\n        ymax = Math.max(ymax, polygon.ymax);\n      }\n    }\n\n    // The above found no polygon that contains the cursor, but we know that\n    // the cursor must be inside the fill as determined by the SVGElement\n    // (so we are probably close to a curved/jagged edge...).\n    if (polygonsIn.length === 0) {\n      return null;\n    }\n\n    // constrain ymin/max to the visible plot, so the label goes\n    // at the middle of the piece you can see\n    ymin = Math.max(ymin, 0);\n    ymax = Math.min(ymax, ya._length);\n    yPos = (ymin + ymax) / 2;\n\n    // find the overall left-most and right-most points of the\n    // polygon(s) we're inside at their combined vertical midpoint.\n    // This is where we will draw the hover label.\n    // Note that this might not be the vertical midpoint of the\n    // whole trace, if it's disjoint.\n    var j, pts, xAtYPos, x0, x1, y0, y1;\n    for (i = 0; i < polygonsIn.length; i++) {\n      pts = polygonsIn[i].pts;\n      for (j = 1; j < pts.length; j++) {\n        y0 = pts[j - 1][1];\n        y1 = pts[j][1];\n        if (y0 > yPos !== y1 >= yPos) {\n          x0 = pts[j - 1][0];\n          x1 = pts[j][0];\n          if (y1 - y0) {\n            xAtYPos = x0 + (x1 - x0) * (yPos - y0) / (y1 - y0);\n            xmin = Math.min(xmin, xAtYPos);\n            xmax = Math.max(xmax, xAtYPos);\n          }\n        }\n      }\n    }\n\n    // constrain xmin/max to the visible plot now too\n    xmin = Math.max(xmin, 0);\n    xmax = Math.min(xmax, xa._length);\n    return {\n      x0: xmin,\n      x1: xmax,\n      y0: yPos,\n      y1: yPos\n    };\n  }\n\n  // even if hoveron is 'fills', only use it if we have a fill element too\n  if (hoveron.indexOf('fills') !== -1 && trace._fillElement) {\n    var inside = isHoverPointInFillElement(trace._fillElement) && !isHoverPointInFillElement(trace._fillExclusionElement);\n    if (inside) {\n      var hoverLabelCoords = getHoverLabelPosition(trace._polygons);\n\n      // getHoverLabelPosition may return null if the cursor / hover point is not contained\n      // in any of the trace's polygons, which can happen close to curved edges. in that\n      // case we fall back to displaying the hover label at the cursor position.\n      if (hoverLabelCoords === null) {\n        hoverLabelCoords = {\n          x0: pt[0],\n          x1: pt[0],\n          y0: pt[1],\n          y1: pt[1]\n        };\n      }\n\n      // get only fill or line color for the hover color\n      var color = Color.defaultLine;\n      if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;else if (Color.opacity((trace.line || {}).color)) {\n        color = trace.line.color;\n      }\n      Lib.extendFlat(pointData, {\n        // never let a 2D override 1D type as closest point\n        // also: no spikeDistance, it's not allowed for fills\n        distance: pointData.maxHoverDistance,\n        x0: hoverLabelCoords.x0,\n        x1: hoverLabelCoords.x1,\n        y0: hoverLabelCoords.y0,\n        y1: hoverLabelCoords.y1,\n        color: color,\n        hovertemplate: false\n      });\n      delete pointData.index;\n      if (trace.text && !Lib.isArrayOrTypedArray(trace.text)) {\n        pointData.text = String(trace.text);\n      } else pointData.text = trace.name;\n      return [pointData];\n    }\n  }\n};","map":{"version":3,"names":["Lib","require","Fx","Registry","getTraceColor","Color","fillText","module","exports","hoverPoints","pointData","xval","yval","hovermode","cd","trace","xa","ya","xpx","c2p","ypx","pt","hoveron","minRad","mode","indexOf","xPeriod","xperiodalignment","yPeriod","yperiodalignment","dx","di","x0","xStart","x1","xEnd","Math","min","max","Infinity","rad","mrc","kink","dxRaw","abs","x","dy","y0","yStart","y1","yEnd","dyRaw","y","dxy","sqrt","distfn","getDistanceFunction","getClosest","index","xc","yc","i","orientation","t","sizeVal","sNorm","s","xLabelVal","orig_x","undefined","yLabelVal","orig_y","extendFlat","color","spikeDistance","hovertemplate","getComponentMethod","isHoverPointInFillElement","el","svgElement","node","domPoint","DOMPoint","isPointInFill","TypeError","svgPoint","ownerSVGElement","createSVGPoint","getHoverLabelPosition","polygons","polygonsIn","xmin","xmax","ymin","ymax","yPos","length","polygon","contains","push","_length","j","pts","xAtYPos","_fillElement","inside","_fillExclusionElement","hoverLabelCoords","_polygons","defaultLine","opacity","fillcolor","line","distance","maxHoverDistance","text","isArrayOrTypedArray","String","name"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scatter/hover.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar getTraceColor = require('./get_trace_color');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var xpx = xa.c2p(xval);\n    var ypx = ya.c2p(yval);\n    var pt = [xpx, ypx];\n    var hoveron = trace.hoveron || '';\n    var minRad = (trace.mode.indexOf('markers') !== -1) ? 3 : 0.5;\n\n    var xPeriod = !!trace.xperiodalignment;\n    var yPeriod = !!trace.yperiodalignment;\n\n    // look for points to hover on first, then take fills only if we\n    // didn't find a point\n\n    if(hoveron.indexOf('points') !== -1) {\n        // dx and dy are used in compare modes - here we want to always\n        // prioritize the closest data point, at least as long as markers are\n        // the same size or nonexistent, but still try to prioritize small markers too.\n        var dx = function(di) {\n            if(xPeriod) {\n                var x0 = xa.c2p(di.xStart);\n                var x1 = xa.c2p(di.xEnd);\n\n                return (\n                    xpx >= Math.min(x0, x1) &&\n                    xpx <= Math.max(x0, x1)\n                ) ? 0 : Infinity;\n            }\n\n            var rad = Math.max(3, di.mrc || 0);\n            var kink = 1 - 1 / rad;\n            var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\n            return (dxRaw < rad) ? (kink * dxRaw / rad) : (dxRaw - rad + kink);\n        };\n        var dy = function(di) {\n            if(yPeriod) {\n                var y0 = ya.c2p(di.yStart);\n                var y1 = ya.c2p(di.yEnd);\n\n                return (\n                    ypx >= Math.min(y0, y1) &&\n                    ypx <= Math.max(y0, y1)\n                ) ? 0 : Infinity;\n            }\n\n            var rad = Math.max(3, di.mrc || 0);\n            var kink = 1 - 1 / rad;\n            var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\n            return (dyRaw < rad) ? (kink * dyRaw / rad) : (dyRaw - rad + kink);\n        };\n\n        // scatter points: d.mrc is the calculated marker radius\n        // adjust the distance so if you're inside the marker it\n        // always will show up regardless of point size, but\n        // prioritize smaller points\n        var dxy = function(di) {\n            var rad = Math.max(minRad, di.mrc || 0);\n            var dx = xa.c2p(di.x) - xpx;\n            var dy = ya.c2p(di.y) - ypx;\n            return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\n        };\n        var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n\n        Fx.getClosest(cd, distfn, pointData);\n\n        // skip the rest (for this trace) if we didn't find a close point\n        if(pointData.index !== false) {\n            // the closest data point\n            var di = cd[pointData.index];\n            var xc = xa.c2p(di.x, true);\n            var yc = ya.c2p(di.y, true);\n            var rad = di.mrc || 1;\n\n            // now we're done using the whole `calcdata` array, replace the\n            // index with the original index (in case of inserted point from\n            // stacked area)\n            pointData.index = di.i;\n\n            var orientation = cd[0].t.orientation;\n            // TODO: for scatter and bar, option to show (sub)totals and\n            // raw data? Currently stacked and/or normalized bars just show\n            // the normalized individual sizes, so that's what I'm doing here\n            // for now.\n            var sizeVal = orientation && (di.sNorm || di.s);\n            var xLabelVal = (orientation === 'h') ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;\n            var yLabelVal = (orientation === 'v') ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;\n\n            Lib.extendFlat(pointData, {\n                color: getTraceColor(trace, di),\n\n                x0: xc - rad,\n                x1: xc + rad,\n                xLabelVal: xLabelVal,\n\n                y0: yc - rad,\n                y1: yc + rad,\n                yLabelVal: yLabelVal,\n\n                spikeDistance: dxy(di),\n                hovertemplate: trace.hovertemplate\n            });\n\n            fillText(di, trace, pointData);\n            Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n\n            return [pointData];\n        }\n    }\n\n    function isHoverPointInFillElement(el) {\n        // Uses SVGElement.isPointInFill to accurately determine wether\n        // the hover point / cursor is contained in the fill, taking\n        // curved or jagged edges into account, which the Polygon-based\n        // approach does not.\n        if(!el) {\n            return false;\n        }\n        var svgElement = el.node();\n        try {\n            var domPoint = new DOMPoint(pt[0], pt[1]);\n            return svgElement.isPointInFill(domPoint);\n        } catch(TypeError) {\n            var svgPoint = svgElement.ownerSVGElement.createSVGPoint();\n            svgPoint.x = pt[0];\n            svgPoint.y = pt[1];\n            return svgElement.isPointInFill(svgPoint);\n        }\n    }\n\n    function getHoverLabelPosition(polygons) {\n        // Uses Polygon s to determine the left- and right-most x-coordinates\n        // of the subshape of the fill that contains the hover point / cursor.\n        // Doing this with the SVGElement directly is quite tricky, so this falls\n        // back to the existing relatively simple code, accepting some small inaccuracies\n        // of label positioning for curved/jagged edges.\n        var i;\n        var polygonsIn = [];\n        var xmin = Infinity;\n        var xmax = -Infinity;\n        var ymin = Infinity;\n        var ymax = -Infinity;\n        var yPos;\n\n        for(i = 0; i < polygons.length; i++) {\n            var polygon = polygons[i];\n            // This is not going to work right for curved or jagged edges, it will\n            // act as though they're straight.\n            if(polygon.contains(pt)) {\n                polygonsIn.push(polygon);\n                ymin = Math.min(ymin, polygon.ymin);\n                ymax = Math.max(ymax, polygon.ymax);\n            }\n        }\n\n        // The above found no polygon that contains the cursor, but we know that\n        // the cursor must be inside the fill as determined by the SVGElement\n        // (so we are probably close to a curved/jagged edge...).\n        if(polygonsIn.length === 0) {\n            return null;\n        }\n\n        // constrain ymin/max to the visible plot, so the label goes\n        // at the middle of the piece you can see\n        ymin = Math.max(ymin, 0);\n        ymax = Math.min(ymax, ya._length);\n\n        yPos = (ymin + ymax) / 2;\n\n        // find the overall left-most and right-most points of the\n        // polygon(s) we're inside at their combined vertical midpoint.\n        // This is where we will draw the hover label.\n        // Note that this might not be the vertical midpoint of the\n        // whole trace, if it's disjoint.\n        var j, pts, xAtYPos, x0, x1, y0, y1;\n        for(i = 0; i < polygonsIn.length; i++) {\n            pts = polygonsIn[i].pts;\n            for(j = 1; j < pts.length; j++) {\n                y0 = pts[j - 1][1];\n                y1 = pts[j][1];\n                if((y0 > yPos) !== (y1 >= yPos)) {\n                    x0 = pts[j - 1][0];\n                    x1 = pts[j][0];\n                    if(y1 - y0) {\n                        xAtYPos = x0 + (x1 - x0) * (yPos - y0) / (y1 - y0);\n                        xmin = Math.min(xmin, xAtYPos);\n                        xmax = Math.max(xmax, xAtYPos);\n                    }\n                }\n            }\n        }\n\n        // constrain xmin/max to the visible plot now too\n        xmin = Math.max(xmin, 0);\n        xmax = Math.min(xmax, xa._length);\n\n        return {\n            x0: xmin,\n            x1: xmax,\n            y0: yPos,\n            y1: yPos,\n        };\n    }\n\n    // even if hoveron is 'fills', only use it if we have a fill element too\n    if(hoveron.indexOf('fills') !== -1 && trace._fillElement) {\n        var inside = isHoverPointInFillElement(trace._fillElement) && !isHoverPointInFillElement(trace._fillExclusionElement);\n\n        if(inside) {\n            var hoverLabelCoords = getHoverLabelPosition(trace._polygons);\n\n            // getHoverLabelPosition may return null if the cursor / hover point is not contained\n            // in any of the trace's polygons, which can happen close to curved edges. in that\n            // case we fall back to displaying the hover label at the cursor position.\n            if(hoverLabelCoords === null) {\n                hoverLabelCoords = {\n                    x0: pt[0],\n                    x1: pt[0],\n                    y0: pt[1],\n                    y1: pt[1]\n                };\n            }\n\n            // get only fill or line color for the hover color\n            var color = Color.defaultLine;\n            if(Color.opacity(trace.fillcolor)) color = trace.fillcolor;\n            else if(Color.opacity((trace.line || {}).color)) {\n                color = trace.line.color;\n            }\n\n            Lib.extendFlat(pointData, {\n                // never let a 2D override 1D type as closest point\n                // also: no spikeDistance, it's not allowed for fills\n                distance: pointData.maxHoverDistance,\n                x0: hoverLabelCoords.x0,\n                x1: hoverLabelCoords.x1,\n                y0: hoverLabelCoords.y0,\n                y1: hoverLabelCoords.y1,\n                color: color,\n                hovertemplate: false\n            });\n\n            delete pointData.index;\n\n            if(trace.text && !Lib.isArrayOrTypedArray(trace.text)) {\n                pointData.text = String(trace.text);\n            } else pointData.text = trace.name;\n\n            return [pointData];\n        }\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}