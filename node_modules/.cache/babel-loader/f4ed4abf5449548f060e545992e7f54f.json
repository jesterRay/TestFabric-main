{"ast":null,"code":"'use strict';\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar setGroupPositions = require('../bar/cross_trace_calc').setGroupPositions;\nvar calcSelection = require('../scatter/calc_selection');\nvar traceIs = require('../../registry').traceIs;\nvar extendFlat = require('../../lib').extendFlat;\nfunction calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var subplotId = trace.subplot;\n  var radialAxis = fullLayout[subplotId].radialaxis;\n  var angularAxis = fullLayout[subplotId].angularaxis;\n  var rArray = radialAxis.makeCalcdata(trace, 'r');\n  var thetaArray = angularAxis.makeCalcdata(trace, 'theta');\n  var len = trace._length;\n  var cd = new Array(len);\n\n  // 'size' axis variables\n  var sArray = rArray;\n  // 'pos' axis variables\n  var pArray = thetaArray;\n  for (var i = 0; i < len; i++) {\n    cd[i] = {\n      p: pArray[i],\n      s: sArray[i]\n    };\n  }\n\n  // convert width and offset in 'c' coordinate,\n  // set 'c' value(s) in trace._width and trace._offset,\n  // to make Bar.crossTraceCalc \"just work\"\n  function d2c(attr) {\n    var val = trace[attr];\n    if (val !== undefined) {\n      trace['_' + attr] = isArrayOrTypedArray(val) ? angularAxis.makeCalcdata(trace, attr) : angularAxis.d2c(val, trace.thetaunit);\n    }\n  }\n  if (angularAxis.type === 'linear') {\n    d2c('width');\n    d2c('offset');\n  }\n  if (hasColorscale(trace, 'marker')) {\n    colorscaleCalc(gd, trace, {\n      vals: trace.marker.color,\n      containerStr: 'marker',\n      cLetter: 'c'\n    });\n  }\n  if (hasColorscale(trace, 'marker.line')) {\n    colorscaleCalc(gd, trace, {\n      vals: trace.marker.line.color,\n      containerStr: 'marker.line',\n      cLetter: 'c'\n    });\n  }\n  arraysToCalcdata(cd, trace);\n  calcSelection(cd, trace);\n  return cd;\n}\nfunction crossTraceCalc(gd, polarLayout, subplotId) {\n  var calcdata = gd.calcdata;\n  var barPolarCd = [];\n  for (var i = 0; i < calcdata.length; i++) {\n    var cdi = calcdata[i];\n    var trace = cdi[0].trace;\n    if (trace.visible === true && traceIs(trace, 'bar') && trace.subplot === subplotId) {\n      barPolarCd.push(cdi);\n    }\n  }\n\n  // to make _extremes is filled in correctly so that\n  // polar._subplot.radialAxis can get auotrange'd\n  // TODO clean up!\n  // I think we want to call getAutorange on polar.radialaxis\n  // NOT on polar._subplot.radialAxis\n  var rAxis = extendFlat({}, polarLayout.radialaxis, {\n    _id: 'x'\n  });\n  var aAxis = polarLayout.angularaxis;\n  setGroupPositions(gd, aAxis, rAxis, barPolarCd, {\n    mode: polarLayout.barmode,\n    norm: polarLayout.barnorm,\n    gap: polarLayout.bargap,\n    groupgap: polarLayout.bargroupgap\n  });\n}\nmodule.exports = {\n  calc: calc,\n  crossTraceCalc: crossTraceCalc\n};","map":{"version":3,"names":["hasColorscale","require","colorscaleCalc","isArrayOrTypedArray","arraysToCalcdata","setGroupPositions","calcSelection","traceIs","extendFlat","calc","gd","trace","fullLayout","_fullLayout","subplotId","subplot","radialAxis","radialaxis","angularAxis","angularaxis","rArray","makeCalcdata","thetaArray","len","_length","cd","Array","sArray","pArray","i","p","s","d2c","attr","val","undefined","thetaunit","type","vals","marker","color","containerStr","cLetter","line","crossTraceCalc","polarLayout","calcdata","barPolarCd","length","cdi","visible","push","rAxis","_id","aAxis","mode","barmode","norm","barnorm","gap","bargap","groupgap","bargroupgap","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/barpolar/calc.js"],"sourcesContent":["'use strict';\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar setGroupPositions = require('../bar/cross_trace_calc').setGroupPositions;\nvar calcSelection = require('../scatter/calc_selection');\nvar traceIs = require('../../registry').traceIs;\nvar extendFlat = require('../../lib').extendFlat;\n\nfunction calc(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var subplotId = trace.subplot;\n    var radialAxis = fullLayout[subplotId].radialaxis;\n    var angularAxis = fullLayout[subplotId].angularaxis;\n    var rArray = radialAxis.makeCalcdata(trace, 'r');\n    var thetaArray = angularAxis.makeCalcdata(trace, 'theta');\n    var len = trace._length;\n    var cd = new Array(len);\n\n    // 'size' axis variables\n    var sArray = rArray;\n    // 'pos' axis variables\n    var pArray = thetaArray;\n\n    for(var i = 0; i < len; i++) {\n        cd[i] = {p: pArray[i], s: sArray[i]};\n    }\n\n    // convert width and offset in 'c' coordinate,\n    // set 'c' value(s) in trace._width and trace._offset,\n    // to make Bar.crossTraceCalc \"just work\"\n    function d2c(attr) {\n        var val = trace[attr];\n        if(val !== undefined) {\n            trace['_' + attr] = isArrayOrTypedArray(val) ?\n                angularAxis.makeCalcdata(trace, attr) :\n                angularAxis.d2c(val, trace.thetaunit);\n        }\n    }\n\n    if(angularAxis.type === 'linear') {\n        d2c('width');\n        d2c('offset');\n    }\n\n    if(hasColorscale(trace, 'marker')) {\n        colorscaleCalc(gd, trace, {\n            vals: trace.marker.color,\n            containerStr: 'marker',\n            cLetter: 'c'\n        });\n    }\n    if(hasColorscale(trace, 'marker.line')) {\n        colorscaleCalc(gd, trace, {\n            vals: trace.marker.line.color,\n            containerStr: 'marker.line',\n            cLetter: 'c'\n        });\n    }\n\n    arraysToCalcdata(cd, trace);\n    calcSelection(cd, trace);\n\n    return cd;\n}\n\nfunction crossTraceCalc(gd, polarLayout, subplotId) {\n    var calcdata = gd.calcdata;\n    var barPolarCd = [];\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cdi = calcdata[i];\n        var trace = cdi[0].trace;\n\n        if(trace.visible === true && traceIs(trace, 'bar') &&\n            trace.subplot === subplotId\n        ) {\n            barPolarCd.push(cdi);\n        }\n    }\n\n    // to make _extremes is filled in correctly so that\n    // polar._subplot.radialAxis can get auotrange'd\n    // TODO clean up!\n    // I think we want to call getAutorange on polar.radialaxis\n    // NOT on polar._subplot.radialAxis\n    var rAxis = extendFlat({}, polarLayout.radialaxis, {_id: 'x'});\n    var aAxis = polarLayout.angularaxis;\n\n    setGroupPositions(gd, aAxis, rAxis, barPolarCd, {\n        mode: polarLayout.barmode,\n        norm: polarLayout.barnorm,\n        gap: polarLayout.bargap,\n        groupgap: polarLayout.bargroupgap\n    });\n}\n\nmodule.exports = {\n    calc: calc,\n    crossTraceCalc: crossTraceCalc\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}