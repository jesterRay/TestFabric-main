{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar binFunctions = require('../histogram/bin_functions');\nvar normFunctions = require('../histogram/norm_functions');\nvar doAvg = require('../histogram/average');\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\nvar calcAllAutoBins = require('../histogram/calc').calcAllAutoBins;\nmodule.exports = function calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var xcalendar = trace.xcalendar;\n  var ycalendar = trace.ycalendar;\n  var xr2c = function (v) {\n    return xa.r2c(v, 0, xcalendar);\n  };\n  var yr2c = function (v) {\n    return ya.r2c(v, 0, ycalendar);\n  };\n  var xc2r = function (v) {\n    return xa.c2r(v, 0, xcalendar);\n  };\n  var yc2r = function (v) {\n    return ya.c2r(v, 0, ycalendar);\n  };\n  var i, j, n, m;\n\n  // calculate the bins\n  var xBinsAndPos = calcAllAutoBins(gd, trace, xa, 'x');\n  var xBinSpec = xBinsAndPos[0];\n  var xPos0 = xBinsAndPos[1];\n  var yBinsAndPos = calcAllAutoBins(gd, trace, ya, 'y');\n  var yBinSpec = yBinsAndPos[0];\n  var yPos0 = yBinsAndPos[1];\n  var serieslen = trace._length;\n  if (xPos0.length > serieslen) xPos0.splice(serieslen, xPos0.length - serieslen);\n  if (yPos0.length > serieslen) yPos0.splice(serieslen, yPos0.length - serieslen);\n\n  // make the empty bin array & scale the map\n  var z = [];\n  var onecol = [];\n  var zerocol = [];\n  var nonuniformBinsX = typeof xBinSpec.size === 'string';\n  var nonuniformBinsY = typeof yBinSpec.size === 'string';\n  var xEdges = [];\n  var yEdges = [];\n  var xbins = nonuniformBinsX ? xEdges : xBinSpec;\n  var ybins = nonuniformBinsY ? yEdges : yBinSpec;\n  var total = 0;\n  var counts = [];\n  var inputPoints = [];\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densitynorm = norm.indexOf('density') !== -1;\n  var extremefunc = func === 'max' || func === 'min';\n  var sizeinit = extremefunc ? null : 0;\n  var binfunc = binFunctions.count;\n  var normfunc = normFunctions[norm];\n  var doavg = false;\n  var xinc = [];\n  var yinc = [];\n\n  // set a binning function other than count?\n  // for binning functions: check first for 'z',\n  // then 'mc' in case we had a colored scatter plot\n  // and want to transfer these colors to the 2D histo\n  // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n  var rawCounterData = 'z' in trace ? trace.z : 'marker' in trace && Array.isArray(trace.marker.color) ? trace.marker.color : '';\n  if (rawCounterData && func !== 'count') {\n    doavg = func === 'avg';\n    binfunc = binFunctions[func];\n  }\n\n  // decrease end a little in case of rounding errors\n  var xBinSize = xBinSpec.size;\n  var xBinStart = xr2c(xBinSpec.start);\n  var xBinEnd = xr2c(xBinSpec.end) + (xBinStart - Axes.tickIncrement(xBinStart, xBinSize, false, xcalendar)) / 1e6;\n  for (i = xBinStart; i < xBinEnd; i = Axes.tickIncrement(i, xBinSize, false, xcalendar)) {\n    onecol.push(sizeinit);\n    xEdges.push(i);\n    if (doavg) zerocol.push(0);\n  }\n  xEdges.push(i);\n  var nx = onecol.length;\n  var dx = (i - xBinStart) / nx;\n  var x0 = xc2r(xBinStart + dx / 2);\n  var yBinSize = yBinSpec.size;\n  var yBinStart = yr2c(yBinSpec.start);\n  var yBinEnd = yr2c(yBinSpec.end) + (yBinStart - Axes.tickIncrement(yBinStart, yBinSize, false, ycalendar)) / 1e6;\n  for (i = yBinStart; i < yBinEnd; i = Axes.tickIncrement(i, yBinSize, false, ycalendar)) {\n    z.push(onecol.slice());\n    yEdges.push(i);\n    var ipCol = new Array(nx);\n    for (j = 0; j < nx; j++) ipCol[j] = [];\n    inputPoints.push(ipCol);\n    if (doavg) counts.push(zerocol.slice());\n  }\n  yEdges.push(i);\n  var ny = z.length;\n  var dy = (i - yBinStart) / ny;\n  var y0 = yc2r(yBinStart + dy / 2);\n  if (densitynorm) {\n    xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n    yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n  }\n\n  // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n  if (!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n  if (!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins);\n\n  // put data into bins\n  var uniqueValsPerX = true;\n  var uniqueValsPerY = true;\n  var xVals = new Array(nx);\n  var yVals = new Array(ny);\n  var xGapLow = Infinity;\n  var xGapHigh = Infinity;\n  var yGapLow = Infinity;\n  var yGapHigh = Infinity;\n  for (i = 0; i < serieslen; i++) {\n    var xi = xPos0[i];\n    var yi = yPos0[i];\n    n = Lib.findBin(xi, xbins);\n    m = Lib.findBin(yi, ybins);\n    if (n >= 0 && n < nx && m >= 0 && m < ny) {\n      total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n      inputPoints[m][n].push(i);\n      if (uniqueValsPerX) {\n        if (xVals[n] === undefined) xVals[n] = xi;else if (xVals[n] !== xi) uniqueValsPerX = false;\n      }\n      if (uniqueValsPerY) {\n        if (yVals[m] === undefined) yVals[m] = yi;else if (yVals[m] !== yi) uniqueValsPerY = false;\n      }\n      xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n      xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n      yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n      yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n    }\n  }\n  // normalize, if needed\n  if (doavg) {\n    for (m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);\n  }\n  if (normfunc) {\n    for (m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);\n  }\n  return {\n    x: xPos0,\n    xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n    x0: x0,\n    dx: dx,\n    y: yPos0,\n    yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n    y0: y0,\n    dy: dy,\n    z: z,\n    pts: inputPoints\n  };\n};\nfunction makeIncrements(len, bins, dv, nonuniform) {\n  var out = new Array(len);\n  var i;\n  if (nonuniform) {\n    for (i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);\n  } else {\n    var inc = 1 / dv;\n    for (i = 0; i < len; i++) out[i] = inc;\n  }\n  return out;\n}\nfunction binsToCalc(r2c, bins) {\n  return {\n    start: r2c(bins.start),\n    end: r2c(bins.end),\n    size: bins.size\n  };\n}\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n  var i;\n  var len = edges.length - 1;\n  var out = new Array(len);\n  var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n  for (i = 0; i < len; i++) {\n    var v = (uniqueVals || [])[i];\n    out[i] = v === undefined ? [roundFn(edges[i]), roundFn(edges[i + 1], true)] : [v, v];\n  }\n  return out;\n}","map":{"version":3,"names":["Lib","require","Axes","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","calcAllAutoBins","module","exports","calc","gd","trace","xa","getFromId","xaxis","ya","yaxis","xcalendar","ycalendar","xr2c","v","r2c","yr2c","xc2r","c2r","yc2r","i","j","n","m","xBinsAndPos","xBinSpec","xPos0","yBinsAndPos","yBinSpec","yPos0","serieslen","_length","length","splice","z","onecol","zerocol","nonuniformBinsX","size","nonuniformBinsY","xEdges","yEdges","xbins","ybins","total","counts","inputPoints","norm","histnorm","func","histfunc","densitynorm","indexOf","extremefunc","sizeinit","binfunc","count","normfunc","doavg","xinc","yinc","rawCounterData","Array","isArray","marker","color","xBinSize","xBinStart","start","xBinEnd","end","tickIncrement","push","nx","dx","x0","yBinSize","yBinStart","yBinEnd","slice","ipCol","ny","dy","y0","makeIncrements","type","binsToCalc","uniqueValsPerX","uniqueValsPerY","xVals","yVals","xGapLow","Infinity","xGapHigh","yGapLow","yGapHigh","xi","yi","findBin","undefined","Math","min","x","xRanges","getRanges","y","yRanges","pts","len","bins","dv","nonuniform","out","inc","edges","uniqueVals","gapLow","gapHigh","ax","calendar","roundFn"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/histogram2d/calc.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar binFunctions = require('../histogram/bin_functions');\nvar normFunctions = require('../histogram/norm_functions');\nvar doAvg = require('../histogram/average');\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\nvar calcAllAutoBins = require('../histogram/calc').calcAllAutoBins;\n\nmodule.exports = function calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis);\n    var ya = Axes.getFromId(gd, trace.yaxis);\n\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var xr2c = function(v) { return xa.r2c(v, 0, xcalendar); };\n    var yr2c = function(v) { return ya.r2c(v, 0, ycalendar); };\n    var xc2r = function(v) { return xa.c2r(v, 0, xcalendar); };\n    var yc2r = function(v) { return ya.c2r(v, 0, ycalendar); };\n\n    var i, j, n, m;\n\n    // calculate the bins\n    var xBinsAndPos = calcAllAutoBins(gd, trace, xa, 'x');\n    var xBinSpec = xBinsAndPos[0];\n    var xPos0 = xBinsAndPos[1];\n    var yBinsAndPos = calcAllAutoBins(gd, trace, ya, 'y');\n    var yBinSpec = yBinsAndPos[0];\n    var yPos0 = yBinsAndPos[1];\n\n    var serieslen = trace._length;\n    if(xPos0.length > serieslen) xPos0.splice(serieslen, xPos0.length - serieslen);\n    if(yPos0.length > serieslen) yPos0.splice(serieslen, yPos0.length - serieslen);\n\n    // make the empty bin array & scale the map\n    var z = [];\n    var onecol = [];\n    var zerocol = [];\n    var nonuniformBinsX = typeof xBinSpec.size === 'string';\n    var nonuniformBinsY = typeof yBinSpec.size === 'string';\n    var xEdges = [];\n    var yEdges = [];\n    var xbins = nonuniformBinsX ? xEdges : xBinSpec;\n    var ybins = nonuniformBinsY ? yEdges : yBinSpec;\n    var total = 0;\n    var counts = [];\n    var inputPoints = [];\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densitynorm = norm.indexOf('density') !== -1;\n    var extremefunc = func === 'max' || func === 'min';\n    var sizeinit = extremefunc ? null : 0;\n    var binfunc = binFunctions.count;\n    var normfunc = normFunctions[norm];\n    var doavg = false;\n    var xinc = [];\n    var yinc = [];\n\n    // set a binning function other than count?\n    // for binning functions: check first for 'z',\n    // then 'mc' in case we had a colored scatter plot\n    // and want to transfer these colors to the 2D histo\n    // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n    var rawCounterData = ('z' in trace) ?\n        trace.z :\n        (('marker' in trace && Array.isArray(trace.marker.color)) ?\n            trace.marker.color : '');\n    if(rawCounterData && func !== 'count') {\n        doavg = func === 'avg';\n        binfunc = binFunctions[func];\n    }\n\n    // decrease end a little in case of rounding errors\n    var xBinSize = xBinSpec.size;\n    var xBinStart = xr2c(xBinSpec.start);\n    var xBinEnd = xr2c(xBinSpec.end) +\n        (xBinStart - Axes.tickIncrement(xBinStart, xBinSize, false, xcalendar)) / 1e6;\n\n    for(i = xBinStart; i < xBinEnd; i = Axes.tickIncrement(i, xBinSize, false, xcalendar)) {\n        onecol.push(sizeinit);\n        xEdges.push(i);\n        if(doavg) zerocol.push(0);\n    }\n    xEdges.push(i);\n\n    var nx = onecol.length;\n    var dx = (i - xBinStart) / nx;\n    var x0 = xc2r(xBinStart + dx / 2);\n\n    var yBinSize = yBinSpec.size;\n    var yBinStart = yr2c(yBinSpec.start);\n    var yBinEnd = yr2c(yBinSpec.end) +\n        (yBinStart - Axes.tickIncrement(yBinStart, yBinSize, false, ycalendar)) / 1e6;\n\n    for(i = yBinStart; i < yBinEnd; i = Axes.tickIncrement(i, yBinSize, false, ycalendar)) {\n        z.push(onecol.slice());\n        yEdges.push(i);\n        var ipCol = new Array(nx);\n        for(j = 0; j < nx; j++) ipCol[j] = [];\n        inputPoints.push(ipCol);\n        if(doavg) counts.push(zerocol.slice());\n    }\n    yEdges.push(i);\n\n    var ny = z.length;\n    var dy = (i - yBinStart) / ny;\n    var y0 = yc2r(yBinStart + dy / 2);\n\n    if(densitynorm) {\n        xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n        yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n    }\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n    if(!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins);\n\n    // put data into bins\n    var uniqueValsPerX = true;\n    var uniqueValsPerY = true;\n    var xVals = new Array(nx);\n    var yVals = new Array(ny);\n    var xGapLow = Infinity;\n    var xGapHigh = Infinity;\n    var yGapLow = Infinity;\n    var yGapHigh = Infinity;\n    for(i = 0; i < serieslen; i++) {\n        var xi = xPos0[i];\n        var yi = yPos0[i];\n        n = Lib.findBin(xi, xbins);\n        m = Lib.findBin(yi, ybins);\n        if(n >= 0 && n < nx && m >= 0 && m < ny) {\n            total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n            inputPoints[m][n].push(i);\n\n            if(uniqueValsPerX) {\n                if(xVals[n] === undefined) xVals[n] = xi;\n                else if(xVals[n] !== xi) uniqueValsPerX = false;\n            }\n            if(uniqueValsPerY) {\n                if(yVals[m] === undefined) yVals[m] = yi;\n                else if(yVals[m] !== yi) uniqueValsPerY = false;\n            }\n\n            xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n            xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n            yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n            yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n        }\n    }\n    // normalize, if needed\n    if(doavg) {\n        for(m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);\n    }\n    if(normfunc) {\n        for(m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);\n    }\n\n    return {\n        x: xPos0,\n        xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n        x0: x0,\n        dx: dx,\n        y: yPos0,\n        yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n        y0: y0,\n        dy: dy,\n        z: z,\n        pts: inputPoints\n    };\n};\n\nfunction makeIncrements(len, bins, dv, nonuniform) {\n    var out = new Array(len);\n    var i;\n    if(nonuniform) {\n        for(i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);\n    } else {\n        var inc = 1 / dv;\n        for(i = 0; i < len; i++) out[i] = inc;\n    }\n    return out;\n}\n\nfunction binsToCalc(r2c, bins) {\n    return {\n        start: r2c(bins.start),\n        end: r2c(bins.end),\n        size: bins.size\n    };\n}\n\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n    var i;\n    var len = edges.length - 1;\n    var out = new Array(len);\n    var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n\n    for(i = 0; i < len; i++) {\n        var v = (uniqueVals || [])[i];\n        out[i] = v === undefined ?\n            [roundFn(edges[i]), roundFn(edges[i + 1], true)] :\n            [v, v];\n    }\n    return out;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}