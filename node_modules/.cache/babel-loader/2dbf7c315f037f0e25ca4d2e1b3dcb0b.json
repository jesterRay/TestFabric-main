{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\nvar constants = require('../../constants/numerical');\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar ONEMILLI = constants.ONEMILLI;\nvar ONEMICROSEC = constants.ONEMICROSEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\nvar ZERO_PATH = {\n  K: 'zeroline'\n};\nvar GRID_PATH = {\n  K: 'gridline',\n  L: 'path'\n};\nvar MINORGRID_PATH = {\n  K: 'minor-gridline',\n  L: 'path'\n};\nvar TICK_PATH = {\n  K: 'tick',\n  L: 'path'\n};\nvar TICK_TEXT = {\n  K: 'tick',\n  L: 'text'\n};\nvar MARGIN_MAPPING = {\n  width: ['x', 'r', 'l', 'xl', 'xr'],\n  height: ['y', 't', 'b', 'yt', 'yb'],\n  right: ['r', 'xr'],\n  left: ['l', 'xl'],\n  top: ['t', 'yt'],\n  bottom: ['b', 'yb']\n};\nvar alignmentConstants = require('../../constants/alignment');\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\nvar TEXTPAD = 3;\nvar axes = module.exports = {};\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\nvar axisIds = require('./axis_ids');\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked;\n\n// tight coupling to chart studio\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\nvar epsilon = 0.0001;\nfunction expandRange(range) {\n  var delta = (range[1] - range[0]) * epsilon;\n  return [range[0] - delta, range[1] + delta];\n}\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {\n  var axLetter = attr.charAt(attr.length - 1);\n  var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n  var refAttr = attr + 'ref';\n  var attrDef = {};\n  if (!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n  if (!extraOption) extraOption = dflt;\n  axlist = axlist.concat(axlist.map(function (x) {\n    return x + ' domain';\n  }));\n\n  // data-ref annotations are not supported in gl2d yet\n\n  attrDef[refAttr] = {\n    valType: 'enumerated',\n    values: axlist.concat(extraOption ? typeof extraOption === 'string' ? [extraOption] : extraOption : []),\n    dflt: dflt\n  };\n\n  // xref, yref\n  return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\naxes.getRefType = function (ar) {\n  if (ar === undefined) {\n    return ar;\n  }\n  if (ar === 'paper') {\n    return 'paper';\n  }\n  if (ar === 'pixel') {\n    return 'pixel';\n  }\n  if (/( domain)$/.test(ar)) {\n    return 'domain';\n  } else {\n    return 'range';\n  }\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {\n  var cleanPos, pos;\n  var axRefType = axes.getRefType(axRef);\n  if (axRefType !== 'range') {\n    cleanPos = Lib.ensureNumber;\n    pos = coerce(attr, dflt);\n  } else {\n    var ax = axes.getFromId(gd, axRef);\n    dflt = ax.fraction2r(dflt);\n    pos = coerce(attr, dflt);\n    cleanPos = ax.cleanPos;\n  }\n  containerOut[attr] = cleanPos(pos);\n};\naxes.cleanPosition = function (pos, gd, axRef) {\n  var cleanPos = axRef === 'paper' || axRef === 'pixel' ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;\n  return cleanPos(pos);\n};\naxes.redrawComponents = function (gd, axIds) {\n  axIds = axIds ? axIds : axes.listIds(gd);\n  var fullLayout = gd._fullLayout;\n  function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n    var method = Registry.getComponentMethod(moduleName, methodName);\n    var stash = {};\n    for (var i = 0; i < axIds.length; i++) {\n      var ax = fullLayout[axes.id2name(axIds[i])];\n      var indices = ax[stashName];\n      for (var j = 0; j < indices.length; j++) {\n        var ind = indices[j];\n        if (!stash[ind]) {\n          method(gd, ind);\n          stash[ind] = 1;\n          // once is enough for images (which doesn't use the `i` arg anyway)\n          if (shortCircuit) return;\n        }\n      }\n    }\n  }\n\n  // annotations and shapes 'draw' method is slow,\n  // use the finer-grained 'drawOne' method instead\n  _redrawOneComp('annotations', 'drawOne', '_annIndices');\n  _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n  _redrawOneComp('images', 'draw', '_imgIndices', true);\n  _redrawOneComp('selections', 'drawOne', '_selectionIndices');\n};\nvar getDataConversions = axes.getDataConversions = function (gd, trace, target, targetArray) {\n  var ax;\n\n  // If target points to an axis, use the type we already have for that\n  // axis to find the data type. Otherwise use the values to autotype.\n  var d2cTarget = target === 'x' || target === 'y' || target === 'z' ? target : targetArray;\n\n  // In the case of an array target, make a mock data array\n  // and call supplyDefaults to the data type and\n  // setup the data-to-calc method.\n  if (Lib.isArrayOrTypedArray(d2cTarget)) {\n    ax = {\n      type: autoType(targetArray, undefined, {\n        autotypenumbers: gd._fullLayout.autotypenumbers\n      }),\n      _categories: []\n    };\n    axes.setConvert(ax);\n\n    // build up ax._categories (usually done during ax.makeCalcdata()\n    if (ax.type === 'category') {\n      for (var i = 0; i < targetArray.length; i++) {\n        ax.d2c(targetArray[i]);\n      }\n    }\n    // TODO what to do for transforms?\n  } else {\n    ax = axes.getFromTrace(gd, trace, d2cTarget);\n  }\n\n  // if 'target' has corresponding axis\n  // -> use setConvert method\n  if (ax) return {\n    d2c: ax.d2c,\n    c2d: ax.c2d\n  };\n\n  // special case for 'ids'\n  // -> cast to String\n  if (d2cTarget === 'ids') return {\n    d2c: toString,\n    c2d: toString\n  };\n\n  // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n  // -> cast to Number\n\n  return {\n    d2c: toNum,\n    c2d: toNum\n  };\n};\nfunction toNum(v) {\n  return +v;\n}\nfunction toString(v) {\n  return String(v);\n}\naxes.getDataToCoordFunc = function (gd, trace, target, targetArray) {\n  return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function (id) {\n  var axLetter = id.charAt(0);\n  if (axLetter === 'x') return 'y';\n  if (axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function (ax, newDiff, newFirst, allow) {\n  // doesn't make sense to do forced min dTick on log or category axes,\n  // and the plot itself may decide to cancel (ie non-grouped bars)\n  if (['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n    ax._minDtick = 0;\n  } else if (ax._minDtick === undefined) {\n    // undefined means there's nothing there yet\n\n    ax._minDtick = newDiff;\n    ax._forceTick0 = newFirst;\n  } else if (ax._minDtick) {\n    if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n    // existing minDtick is an integer multiple of newDiff\n    // (within rounding err)\n    // and forceTick0 can be shifted to newFirst\n\n    ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {\n      ax._minDtick = newDiff;\n      ax._forceTick0 = newFirst;\n    } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n    // if the converse is true (newDiff is a multiple of minDtick and\n    // newFirst can be shifted to forceTick0) then do nothing - same\n    // forcing stands. Otherwise, cancel forced minimum\n\n    ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {\n      ax._minDtick = 0;\n    }\n  }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._rangeInitial0 === undefined && ax._rangeInitial1 === undefined;\n    var hasChanged = isNew || ax.range[0] !== ax._rangeInitial0 || ax.range[1] !== ax._rangeInitial1;\n    var autorange = ax.autorange;\n    if (isNew && autorange !== true || overwrite && hasChanged) {\n      ax._rangeInitial0 = autorange === 'min' || autorange === 'max reversed' ? undefined : ax.range[0];\n      ax._rangeInitial1 = autorange === 'max' || autorange === 'min reversed' ? undefined : ax.range[1];\n      ax._autorangeInitial = autorange;\n      hasOneAxisChanged = true;\n    }\n  }\n  return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  var allSpikesEnabled = 'on';\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._showSpikeInitial === undefined;\n    var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n    if (isNew || overwrite && hasChanged) {\n      ax._showSpikeInitial = ax.showspikes;\n      hasOneAxisChanged = true;\n    }\n    if (allSpikesEnabled === 'on' && !ax.showspikes) {\n      allSpikesEnabled = 'off';\n    }\n  }\n  gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n  return hasOneAxisChanged;\n};\naxes.autoBin = function (data, ax, nbins, is2d, calendar, size) {\n  var dataMin = Lib.aggNums(Math.min, null, data);\n  var dataMax = Lib.aggNums(Math.max, null, data);\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    return {\n      start: dataMin - 0.5,\n      end: dataMax + 0.5,\n      size: Math.max(1, Math.round(size) || 1),\n      _dataSpan: dataMax - dataMin\n    };\n  }\n  if (!calendar) calendar = ax.calendar;\n\n  // piggyback off tick code to make \"nice\" bin sizes and edges\n  var dummyAx;\n  if (ax.type === 'log') {\n    dummyAx = {\n      type: 'linear',\n      range: [dataMin, dataMax]\n    };\n  } else {\n    dummyAx = {\n      type: ax.type,\n      range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n      calendar: calendar\n    };\n  }\n  axes.setConvert(dummyAx);\n  size = size && cleanTicks.dtick(size, dummyAx.type);\n  if (size) {\n    dummyAx.dtick = size;\n    dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n  } else {\n    var size0;\n    if (nbins) size0 = (dataMax - dataMin) / nbins;else {\n      // totally auto: scale off std deviation so the highest bin is\n      // somewhat taller than the total number of bins, but don't let\n      // the size get smaller than the 'nice' rounded down minimum\n      // difference between values\n      var distinctData = Lib.distinctVals(data);\n      var msexp = Math.pow(10, Math.floor(Math.log(distinctData.minDiff) / Math.LN10));\n      var minSize = msexp * Lib.roundUp(distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n      size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n      // fallback if ax.d2c output BADNUMs\n      // e.g. when user try to plot categorical bins\n      // on a layout.xaxis.type: 'linear'\n      if (!isNumeric(size0)) size0 = 1;\n    }\n    axes.autoTicks(dummyAx, size0);\n  }\n  var finalSize = dummyAx.dtick;\n  var binStart = axes.tickIncrement(axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n  var binEnd, bincount;\n\n  // check for too many data points right at the edges of bins\n  // (>50% within 1% of bin edges) or all data points integral\n  // and offset the bins accordingly\n  if (typeof finalSize === 'number') {\n    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n    bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n    binEnd = binStart + bincount * finalSize;\n  } else {\n    // month ticks - should be the only nonlinear kind we have at this point.\n    // dtick (as supplied by axes.autoTick) only has nonlinear values on\n    // date and log axes, but even if you display a histogram on a log axis\n    // we bin it on a linear axis (which one could argue against, but that's\n    // a separate issue)\n    if (dummyAx.dtick.charAt(0) === 'M') {\n      binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n    }\n\n    // calculate the endpoint for nonlinear ticks - you have to\n    // just increment until you're done\n    binEnd = binStart;\n    bincount = 0;\n    while (binEnd <= dataMax) {\n      binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n      bincount++;\n    }\n  }\n  return {\n    start: ax.c2r(binStart, 0, calendar),\n    end: ax.c2r(binEnd, 0, calendar),\n    size: finalSize,\n    _dataSpan: dataMax - dataMin\n  };\n};\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n  var edgecount = 0;\n  var midcount = 0;\n  var intcount = 0;\n  var blankCount = 0;\n  function nearEdge(v) {\n    // is a value within 1% of a bin edge?\n    return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n  }\n  for (var i = 0; i < data.length; i++) {\n    if (data[i] % 1 === 0) intcount++;else if (!isNumeric(data[i])) blankCount++;\n    if (nearEdge(data[i])) edgecount++;\n    if (nearEdge(data[i] + ax.dtick / 2)) midcount++;\n  }\n  var dataCount = data.length - blankCount;\n  if (intcount === dataCount && ax.type !== 'date') {\n    if (ax.dtick < 1) {\n      // all integers: if bin size is <1, it's because\n      // that was specifically requested (large nbins)\n      // so respect that... but center the bins containing\n      // integers on those integers\n\n      binStart = dataMin - 0.5 * ax.dtick;\n    } else {\n      // otherwise start half an integer down regardless of\n      // the bin size, just enough to clear up endpoint\n      // ambiguity about which integers are in which bins.\n\n      binStart -= 0.5;\n      if (binStart + ax.dtick < dataMin) binStart += ax.dtick;\n    }\n  } else if (midcount < dataCount * 0.1) {\n    if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {\n      // lots of points at the edge, not many in the middle\n      // shift half a bin\n      var binshift = ax.dtick / 2;\n      binStart += binStart + binshift < dataMin ? binshift : -binshift;\n    }\n  }\n  return binStart;\n}\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n  var stats = Lib.findExactDates(data, calendar);\n  // number of data points that needs to be an exact value\n  // to shift that increment to (near) the bin center\n  var threshold = 0.8;\n  if (stats.exactDays > threshold) {\n    var numMonths = Number(dtick.substr(1));\n    if (stats.exactYears > threshold && numMonths % 12 === 0) {\n      // The exact middle of a non-leap-year is 1.5 days into July\n      // so if we start the bins here, all but leap years will\n      // get hover-labeled as exact years.\n      binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n    } else if (stats.exactMonths > threshold) {\n      // Months are not as clean, but if we shift half the *longest*\n      // month (31/2 days) then 31-day months will get labeled exactly\n      // and shorter months will get labeled with the correct month\n      // but shifted 12-36 hours into it.\n      binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n    } else {\n      // Shifting half a day is exact, but since these are month bins it\n      // will always give a somewhat odd-looking label, until we do something\n      // smarter like showing the bin boundaries (or the bounds of the actual\n      // data in each bin)\n      binStart -= HALFDAY;\n    }\n    var nextBinStart = axes.tickIncrement(binStart, dtick);\n    if (nextBinStart <= dataMin) return nextBinStart;\n  }\n  return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have minor tick0 and dtick calculated\naxes.prepMinorTicks = function (mockAx, ax, opts) {\n  if (!ax.minor.dtick) {\n    delete mockAx.dtick;\n    var hasMajor = ax.dtick && isNumeric(ax._tmin);\n    var mockMinorRange;\n    if (hasMajor) {\n      var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);\n      // mock range a tiny bit smaller than one major tick interval\n      mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];\n    } else {\n      var rl = Lib.simpleMap(ax.range, ax.r2l);\n      // If we don't have a major dtick, the concept of minor ticks is a little\n      // ambiguous - just take a stab and say minor.nticks should span 1/5 the axis\n      mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];\n    }\n    mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);\n    mockAx._isMinor = true;\n    axes.prepTicks(mockAx, opts);\n    if (hasMajor) {\n      var numericMajor = isNumeric(ax.dtick);\n      var numericMinor = isNumeric(mockAx.dtick);\n      var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);\n      var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);\n      if (numericMajor && numericMinor) {\n        if (!isMultiple(majorNum, minorNum)) {\n          // give up on minor ticks - outside the below exceptions,\n          // this can only happen if minor.nticks is smaller than two jumps\n          // in the auto-tick scale and the first jump is not an even multiple\n          // (5 -> 2 or for dates 3 ->2, 15 -> 10 etc)  or if you provided\n          // an explicit dtick, in which case it's fine to give up,\n          // you can provide an explicit minor.dtick.\n          if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {\n            mockAx.dtick = ONEWEEK;\n          } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {\n            // minor.nticks defaults to 5, but in this one case we want 7,\n            // so the minor ticks show on all days of the week\n            mockAx.dtick = ONEDAY;\n          } else if (isClose(majorNum / minorNum, 2.5)) {\n            // 5*10^n -> 2*10^n and you've set nticks < 5\n            // quarters are pretty common, we don't do this by default as it\n            // would add an extra digit to display, but minor has no labels\n            mockAx.dtick = majorNum / 2;\n          } else {\n            mockAx.dtick = majorNum;\n          }\n        } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {\n          // this is a weird one: we don't want to automatically choose\n          // 2-day minor ticks for 2-week major, even though it IS an even multiple,\n          // because people would expect to see the weeks clearly\n          mockAx.dtick = ONEWEEK;\n        }\n      } else if (String(ax.dtick).charAt(0) === 'M') {\n        if (numericMinor) {\n          mockAx.dtick = 'M1';\n        } else {\n          if (!isMultiple(majorNum, minorNum)) {\n            // unless you provided an explicit ax.dtick (in which case\n            // it's OK for us to give up, you can provide an explicit\n            // minor.dtick too), this can only happen with:\n            // minor.nticks < 3 and dtick === M3, or\n            // minor.nticks < 5 and dtick === 5 * 10^n years\n            // so in all cases we just give up.\n            mockAx.dtick = ax.dtick;\n          } else if (majorNum >= 12 && minorNum === 2) {\n            // another special carve-out: for year major ticks, don't show\n            // 2-month minor ticks, bump to quarters\n            mockAx.dtick = 'M3';\n          }\n        }\n      } else if (String(mockAx.dtick).charAt(0) === 'L') {\n        if (String(ax.dtick).charAt(0) === 'L') {\n          if (!isMultiple(majorNum, minorNum)) {\n            mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;\n          }\n        } else {\n          mockAx.dtick = 'D1';\n        }\n      } else if (mockAx.dtick === 'D2' && +ax.dtick > 1) {\n        // the D2 log axis tick spacing is confusing for unlabeled minor ticks if\n        // the major dtick is more than one order of magnitude.\n        mockAx.dtick = 1;\n      }\n    }\n    // put back the original range, to use to find the full set of minor ticks\n    mockAx.range = ax.range;\n  }\n  if (ax.minor._tick0Init === undefined) {\n    // ensure identical tick0\n    mockAx.tick0 = ax.tick0;\n  }\n};\nfunction isMultiple(bigger, smaller) {\n  return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 0.001;\n}\nfunction isClose(a, b) {\n  return Math.abs(a / b - 1) < 0.001;\n}\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function (ax, opts) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n\n  // calculate max number of (auto) ticks to display based on plot size\n  if (ax.tickmode === 'auto' || !ax.dtick) {\n    var nt = ax.nticks;\n    var minPx;\n    if (!nt) {\n      if (ax.type === 'category' || ax.type === 'multicategory') {\n        minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n        nt = ax._length / minPx;\n      } else {\n        minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n        nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n      }\n\n      // radial axes span half their domain,\n      // multiply nticks value by two to get correct number of auto ticks.\n      if (ax._name === 'radialaxis') nt *= 2;\n    }\n    if (!(ax.minor && ax.minor.tickmode !== 'array')) {\n      // add a couple of extra digits for filling in ticks when we\n      // have explicit tickvals without tick text\n      if (ax.tickmode === 'array') nt *= 100;\n    }\n    ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n    axes.autoTicks(ax, ax._roughDTick);\n\n    // check for a forced minimum dtick\n    if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n      ax.dtick = ax._minDtick;\n      ax.tick0 = ax.l2r(ax._forceTick0);\n    }\n  }\n  if (ax.ticklabelmode === 'period') {\n    adjustPeriodDelta(ax);\n  }\n\n  // check for missing tick0\n  if (!ax.tick0) {\n    ax.tick0 = ax.type === 'date' ? '2000-01-01' : 0;\n  }\n\n  // ensure we don't try to make ticks below our minimum precision\n  // see https://github.com/plotly/plotly.js/issues/2892\n  if (ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n  // now figure out rounding of tick values\n  autoTickRound(ax);\n};\nfunction nMonths(dtick) {\n  return +dtick.substring(1);\n}\nfunction adjustPeriodDelta(ax) {\n  // adjusts ax.dtick and sets ax._definedDelta\n  var definedDelta;\n  function mDate() {\n    return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== 'M');\n  }\n  var isMDate = mDate();\n  var tickformat = axes.getTickFormat(ax);\n  if (tickformat) {\n    var noDtick = ax._dtickInit !== ax.dtick;\n    if (!/%[fLQsSMX]/.test(tickformat)\n    // %f: microseconds as a decimal number [000000, 999999]\n    // %L: milliseconds as a decimal number [000, 999]\n    // %Q: milliseconds since UNIX epoch\n    // %s: seconds since UNIX epoch\n    // %S: second as a decimal number [00,61]\n    // %M: minute as a decimal number [00,59]\n    // %X: the locale’s time, such as %-I:%M:%S %p\n    ) {\n      if (/%[HI]/.test(tickformat)\n      // %H: hour (24-hour clock) as a decimal number [00,23]\n      // %I: hour (12-hour clock) as a decimal number [01,12]\n      ) {\n        definedDelta = ONEHOUR;\n        if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n      } else if (/%p/.test(tickformat) // %p: either AM or PM\n      ) {\n        definedDelta = HALFDAY;\n        if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n      } else if (/%[Aadejuwx]/.test(tickformat)\n      // %A: full weekday name\n      // %a: abbreviated weekday name\n      // %d: zero-padded day of the month as a decimal number [01,31]\n      // %e: space-padded day of the month as a decimal number [ 1,31]\n      // %j: day of the year as a decimal number [001,366]\n      // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n      // %w: Sunday-based weekday as a decimal number [0,6]\n      // %x: the locale’s date, such as %-m/%-d/%Y\n      ) {\n        definedDelta = ONEDAY;\n        if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n      } else if (/%[UVW]/.test(tickformat)\n      // %U: Sunday-based week of the year as a decimal number [00,53]\n      // %V: ISO 8601 week of the year as a decimal number [01, 53]\n      // %W: Monday-based week of the year as a decimal number [00,53]\n      ) {\n        definedDelta = ONEWEEK;\n        if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n      } else if (/%[Bbm]/.test(tickformat)\n      // %B: full month name\n      // %b: abbreviated month name\n      // %m: month as a decimal number [01,12]\n      ) {\n        definedDelta = ONEAVGMONTH;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = 'M1';\n      } else if (/%[q]/.test(tickformat)\n      // %q: quarter of the year as a decimal number [1,4]\n      ) {\n        definedDelta = ONEAVGQUARTER;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = 'M3';\n      } else if (/%[Yy]/.test(tickformat)\n      // %Y: year with century as a decimal number, such as 1999\n      // %y: year without century as a decimal number [00,99]\n      ) {\n        definedDelta = ONEAVGYEAR;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = 'M12';\n      }\n    }\n  }\n  isMDate = mDate();\n  if (isMDate && ax.tick0 === ax._dowTick0) {\n    // discard Sunday/Monday tweaks\n    ax.tick0 = ax._rawTick0;\n  }\n  ax._definedDelta = definedDelta;\n}\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n  for (var i = 0; i < tickVals.length; i++) {\n    var v = tickVals[i].value;\n    var a = i;\n    var b = i + 1;\n    if (i < tickVals.length - 1) {\n      a = i;\n      b = i + 1;\n    } else if (i > 0) {\n      a = i - 1;\n      b = i;\n    } else {\n      a = i;\n      b = i;\n    }\n    var A = tickVals[a].value;\n    var B = tickVals[b].value;\n    var actualDelta = Math.abs(B - A);\n    var delta = definedDelta || actualDelta;\n    var periodLength = 0;\n    if (delta >= ONEMINYEAR) {\n      if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGYEAR;\n      }\n    } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n      if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGQUARTER;\n      }\n    } else if (delta >= ONEMINMONTH) {\n      if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGMONTH;\n      }\n    } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {\n      periodLength = ONEWEEK;\n    } else if (delta >= ONEDAY) {\n      periodLength = ONEDAY;\n    } else if (definedDelta === HALFDAY && delta >= HALFDAY) {\n      periodLength = HALFDAY;\n    } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {\n      periodLength = ONEHOUR;\n    }\n    var inBetween;\n    if (periodLength >= actualDelta) {\n      // ensure new label positions remain between ticks\n      periodLength = actualDelta;\n      inBetween = true;\n    }\n    var endPeriod = v + periodLength;\n    if (ax.rangebreaks && periodLength > 0) {\n      var nAll = 84; // highly divisible 7 * 12\n      var n = 0;\n      for (var c = 0; c < nAll; c++) {\n        var r = (c + 0.5) / nAll;\n        if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n      }\n      periodLength *= n / nAll;\n      if (!periodLength) {\n        tickVals[i].drop = true;\n      }\n      if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n    }\n    if (periodLength > 0 ||\n    // not instant\n    i === 0 // taking care first tick added\n    ) {\n      tickVals[i].periodX = v + periodLength / 2;\n    }\n  }\n}\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax, opts) {\n  var type = ax.type;\n  var calendar = ax.calendar;\n  var ticklabelstep = ax.ticklabelstep;\n  var isPeriod = ax.ticklabelmode === 'period';\n  var isReversed = ax.range[0] > ax.range[1];\n  var ticklabelIndex = !ax.ticklabelindex || Lib.isArrayOrTypedArray(ax.ticklabelindex) ? ax.ticklabelindex : [ax.ticklabelindex];\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var minRange = Math.min(rng[0], rng[1]);\n  var maxRange = Math.max(rng[0], rng[1]);\n  var maxTicks = Math.max(1000, ax._length || 0);\n  var ticksOut = [];\n  var minorTicks = [];\n  var tickVals = [];\n  var minorTickVals = [];\n  // all ticks for which labels are drawn which is not necessarily the major ticks when\n  // `ticklabelindex` is set.\n  var allTicklabelVals = [];\n  var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);\n\n  // calc major first\n  for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {\n    var isMinor = !major;\n    if (major) {\n      ax._dtickInit = ax.dtick;\n      ax._tick0Init = ax.tick0;\n    } else {\n      ax.minor._dtickInit = ax.minor.dtick;\n      ax.minor._tick0Init = ax.minor.tick0;\n    }\n    var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);\n    if (isMinor) {\n      axes.prepMinorTicks(mockAx, ax, opts);\n    } else {\n      axes.prepTicks(mockAx, opts);\n    }\n\n    // now that we've figured out the auto values for formatting\n    // in case we're missing some ticktext, we can break out for array ticks\n    if (mockAx.tickmode === 'array') {\n      if (major) {\n        tickVals = [];\n        ticksOut = arrayTicks(ax, !isMinor);\n      } else {\n        minorTickVals = [];\n        minorTicks = arrayTicks(ax, !isMinor);\n      }\n      continue;\n    }\n\n    // fill tickVals based on overlaying axis\n    if (mockAx.tickmode === 'sync') {\n      tickVals = [];\n      ticksOut = syncTicks(ax);\n      continue;\n    }\n\n    // add a tiny bit so we get ticks which may have rounded out\n    var exRng = expandRange(rng);\n    var startTick = exRng[0];\n    var endTick = exRng[1];\n    var numDtick = isNumeric(mockAx.dtick);\n    var isDLog = type === 'log' && !(numDtick || mockAx.dtick.charAt(0) === 'L');\n\n    // find the first tick\n    var x0 = axes.tickFirst(mockAx, opts);\n    if (major) {\n      ax._tmin = x0;\n\n      // No visible ticks? Quit.\n      // I've only seen this on category axes with all categories off the edge.\n      if (x0 < startTick !== axrev) break;\n\n      // return the full set of tick vals\n      if (type === 'category' || type === 'multicategory') {\n        endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);\n      }\n    }\n    var prevX = null;\n    var x = x0;\n    var majorId;\n    if (major) {\n      // ids for ticklabelstep\n      var _dTick;\n      if (numDtick) {\n        _dTick = ax.dtick;\n      } else {\n        if (type === 'date') {\n          if (typeof ax.dtick === 'string' && ax.dtick.charAt(0) === 'M') {\n            _dTick = ONEAVGMONTH * ax.dtick.substring(1);\n          }\n        } else {\n          _dTick = ax._roughDTick;\n        }\n      }\n      majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;\n    }\n    var dtick = mockAx.dtick;\n    if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {\n      // adjust tick0\n      x = moveOutsideBreak(x, ax);\n      if (!axrev) {\n        x = axes.tickIncrement(x, dtick, !axrev, calendar);\n      }\n    }\n    if (major && isPeriod) {\n      // add one item to label period before tick0\n      x = axes.tickIncrement(x, dtick, !axrev, calendar);\n      majorId--;\n    }\n    for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(x, dtick, axrev, calendar)) {\n      if (major) majorId++;\n      if (mockAx.rangebreaks) {\n        if (!axrev) {\n          if (x < startTick) continue;\n          if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;\n        }\n      }\n\n      // prevent infinite loops - no more than one tick per pixel,\n      // and make sure each value is different from the previous\n      if (tickVals.length > maxTicks || x === prevX) break;\n      prevX = x;\n      var obj = {\n        value: x\n      };\n      if (major) {\n        if (isDLog && x !== (x | 0)) {\n          obj.simpleLabel = true;\n        }\n        if (ticklabelstep > 1 && majorId % ticklabelstep) {\n          obj.skipLabel = true;\n        }\n        tickVals.push(obj);\n      } else {\n        obj.minor = true;\n        minorTickVals.push(obj);\n      }\n    }\n  }\n\n  // check if ticklabelIndex makes sense, otherwise ignore it\n  if (!minorTickVals || minorTickVals.length < 2) {\n    ticklabelIndex = false;\n  } else {\n    var diff = (minorTickVals[1].value - minorTickVals[0].value) * (isReversed ? -1 : 1);\n    if (!periodCompatibleWithTickformat(diff, ax.tickformat)) {\n      ticklabelIndex = false;\n    }\n  }\n  // Determine for which ticks to draw labels\n  if (!ticklabelIndex) {\n    allTicklabelVals = tickVals;\n  } else {\n    // Collect and sort all major and minor ticks, to find the minor ticks `ticklabelIndex`\n    // steps away from each major tick. For those minor ticks we want to draw the label.\n\n    var allTickVals = tickVals.concat(minorTickVals);\n    if (isPeriod && tickVals.length) {\n      // first major tick was just added for period handling\n      allTickVals = allTickVals.slice(1);\n    }\n    allTickVals = allTickVals.sort(function (a, b) {\n      return a.value - b.value;\n    }).filter(function (tick, index, self) {\n      return index === 0 || tick.value !== self[index - 1].value;\n    });\n    var majorTickIndices = allTickVals.map(function (item, index) {\n      return item.minor === undefined && !item.skipLabel ? index : null;\n    }).filter(function (index) {\n      return index !== null;\n    });\n    majorTickIndices.forEach(function (majorIdx) {\n      ticklabelIndex.map(function (nextLabelIdx) {\n        var minorIdx = majorIdx + nextLabelIdx;\n        if (minorIdx >= 0 && minorIdx < allTickVals.length) {\n          Lib.pushUnique(allTicklabelVals, allTickVals[minorIdx]);\n        }\n      });\n    });\n  }\n  if (hasMinor) {\n    var canOverlap = ax.minor.ticks === 'inside' && ax.ticks === 'outside' || ax.minor.ticks === 'outside' && ax.ticks === 'inside';\n    if (!canOverlap) {\n      // remove duplicate minors\n\n      var majorValues = tickVals.map(function (d) {\n        return d.value;\n      });\n      var list = [];\n      for (var k = 0; k < minorTickVals.length; k++) {\n        var T = minorTickVals[k];\n        var v = T.value;\n        if (majorValues.indexOf(v) !== -1) {\n          continue;\n        }\n        var found = false;\n        for (var q = 0; !found && q < tickVals.length; q++) {\n          if (\n          // add 10e6 to eliminate problematic digits\n          10e6 + tickVals[q].value === 10e6 + v) {\n            found = true;\n          }\n        }\n        if (!found) list.push(T);\n      }\n      minorTickVals = list;\n    }\n  }\n  if (isPeriod) positionPeriodTicks(allTicklabelVals, ax, ax._definedDelta);\n  var i;\n  if (ax.rangebreaks) {\n    var flip = ax._id.charAt(0) === 'y';\n    var fontSize = 1; // one pixel minimum\n    if (ax.tickmode === 'auto') {\n      fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    }\n    var prevL = NaN;\n    for (i = tickVals.length - 1; i > -1; i--) {\n      if (tickVals[i].drop) {\n        tickVals.splice(i, 1);\n        continue;\n      }\n      tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);\n\n      // avoid overlaps\n      var l = ax.c2p(tickVals[i].value);\n      if (flip ? prevL > l - fontSize : prevL < l + fontSize) {\n        // ensure one pixel minimum\n        tickVals.splice(axrev ? i + 1 : i, 1);\n      } else {\n        prevL = l;\n      }\n    }\n  }\n\n  // If same angle over a full circle, the last tick vals is a duplicate.\n  // TODO must do something similar for angular date axes.\n  if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n    tickVals.pop();\n  }\n\n  // save the last tick as well as first, so we can\n  // show the exponent only on the last one\n  ax._tmax = (tickVals[tickVals.length - 1] || {}).value;\n\n  // for showing the rest of a date when the main tick label is only the\n  // latter part: ax._prevDateHead holds what we showed most recently.\n  // Start with it cleared and mark that we're in calcTicks (ie calculating a\n  // whole string of these so we should care what the previous date head was!)\n  ax._prevDateHead = '';\n  ax._inCalcTicks = true;\n  var lastVisibleHead;\n  var hideLabel = function (tick) {\n    tick.text = '';\n    ax._prevDateHead = lastVisibleHead;\n  };\n  tickVals = tickVals.concat(minorTickVals);\n  function setTickLabel(ax, tickVal) {\n    var text = axes.tickText(ax, tickVal.value, false,\n    // hover\n    tickVal.simpleLabel // noSuffixPrefix\n    );\n    var p = tickVal.periodX;\n    if (p !== undefined) {\n      text.periodX = p;\n      if (p > maxRange || p < minRange) {\n        // hide label if outside the range\n        if (p > maxRange) text.periodX = maxRange;\n        if (p < minRange) text.periodX = minRange;\n        hideLabel(text);\n      }\n    }\n    return text;\n  }\n  var t;\n  for (i = 0; i < tickVals.length; i++) {\n    var _minor = tickVals[i].minor;\n    var _value = tickVals[i].value;\n    if (_minor) {\n      if (ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) !== -1) {\n        t = setTickLabel(ax, tickVals[i]);\n      } else {\n        t = {\n          x: _value\n        };\n      }\n      t.minor = true;\n      minorTicks.push(t);\n    } else {\n      lastVisibleHead = ax._prevDateHead;\n      t = setTickLabel(ax, tickVals[i]);\n      if (tickVals[i].skipLabel || ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) === -1) {\n        hideLabel(t);\n      }\n      ticksOut.push(t);\n    }\n  }\n  ticksOut = ticksOut.concat(minorTicks);\n  ax._inCalcTicks = false;\n  if (isPeriod && ticksOut.length) {\n    // drop very first tick that we added to handle period\n    ticksOut[0].noTick = true;\n  }\n  return ticksOut;\n};\nfunction filterRangeBreaks(ax, ticksOut) {\n  if (ax.rangebreaks) {\n    // remove ticks falling inside rangebreaks\n    ticksOut = ticksOut.filter(function (d) {\n      return ax.maskBreaks(d.x) !== BADNUM;\n    });\n  }\n  return ticksOut;\n}\nfunction syncTicks(ax) {\n  // get the overlaying axis\n  var baseAxis = ax._mainAxis;\n  var ticksOut = [];\n  if (baseAxis._vals) {\n    for (var i = 0; i < baseAxis._vals.length; i++) {\n      // filter vals with noTick flag\n      if (baseAxis._vals[i].noTick) {\n        continue;\n      }\n\n      // get the position of the every tick\n      var pos = baseAxis.l2p(baseAxis._vals[i].x);\n\n      // get the tick for the current axis based on position\n      var vali = ax.p2l(pos);\n      var obj = axes.tickText(ax, vali);\n\n      // assign minor ticks\n      if (baseAxis._vals[i].minor) {\n        obj.minor = true;\n        obj.text = '';\n      }\n      ticksOut.push(obj);\n    }\n  }\n  ticksOut = filterRangeBreaks(ax, ticksOut);\n  return ticksOut;\n}\nfunction arrayTicks(ax, majorOnly) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  var exRng = expandRange(rng);\n  var tickMin = Math.min(exRng[0], exRng[1]);\n  var tickMax = Math.max(exRng[0], exRng[1]);\n\n  // make sure showing ticks doesn't accidentally add new categories\n  // TODO multicategory, if we allow ticktext / tickvals\n  var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n  // array ticks on log axes always show the full number\n  // (if no explicit ticktext overrides it)\n  if (ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n    ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n  }\n  var ticksOut = [];\n  for (var isMinor = 0; isMinor <= 1; isMinor++) {\n    if (majorOnly !== undefined && (majorOnly && isMinor || majorOnly === false && !isMinor)) continue;\n    if (isMinor && !ax.minor) continue;\n    var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;\n    var text = !isMinor ? ax.ticktext : [];\n    if (!vals) continue;\n\n    // without a text array, just format the given values as any other ticks\n    // except with more precision to the numbers\n    if (!Lib.isArrayOrTypedArray(text)) text = [];\n    for (var i = 0; i < vals.length; i++) {\n      var vali = tickVal2l(vals[i]);\n      if (vali > tickMin && vali < tickMax) {\n        var obj = axes.tickText(ax, vali, false, String(text[i]));\n        if (isMinor) {\n          obj.minor = true;\n          obj.text = '';\n        }\n        ticksOut.push(obj);\n      }\n    }\n  }\n  ticksOut = filterRangeBreaks(ax, ticksOut);\n  return ticksOut;\n}\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\nfunction roundDTick(roughDTick, base, roundingSet) {\n  return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function (ax, roughDTick, isMinor) {\n  var base;\n  function getBase(v) {\n    return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n  }\n  if (ax.type === 'date') {\n    ax.tick0 = Lib.dateTick0(ax.calendar, 0);\n\n    // the criteria below are all based on the rough spacing we calculate\n    // being > half of the final unit - so precalculate twice the rough val\n    var roughX2 = 2 * roughDTick;\n    if (roughX2 > ONEAVGYEAR) {\n      roughDTick /= ONEAVGYEAR;\n      base = getBase(10);\n      ax.dtick = 'M' + 12 * roundDTick(roughDTick, base, roundBase10);\n    } else if (roughX2 > ONEAVGMONTH) {\n      roughDTick /= ONEAVGMONTH;\n      ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n    } else if (roughX2 > ONEDAY) {\n      ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);\n      if (!isMinor) {\n        // get week ticks on sunday\n        // this will also move the base tick off 2000-01-01 if dtick is\n        // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n        var tickformat = axes.getTickFormat(ax);\n        var isPeriod = ax.ticklabelmode === 'period';\n        if (isPeriod) ax._rawTick0 = ax.tick0;\n        if (/%[uVW]/.test(tickformat)) {\n          ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n        } else {\n          ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n        }\n        if (isPeriod) ax._dowTick0 = ax.tick0;\n      }\n    } else if (roughX2 > ONEHOUR) {\n      ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n    } else if (roughX2 > ONEMIN) {\n      ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n    } else if (roughX2 > ONESEC) {\n      ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n    } else {\n      // milliseconds\n      base = getBase(10);\n      ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n  } else if (ax.type === 'log') {\n    ax.tick0 = 0;\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    if (ax._isMinor) {\n      // Log axes by default get MORE than nTicks based on the metrics below\n      // But for minor ticks we don't want this increase, we already have\n      // the major ticks.\n      roughDTick *= 1.5;\n    }\n    if (roughDTick > 0.7) {\n      // only show powers of 10\n      ax.dtick = Math.ceil(roughDTick);\n    } else if (Math.abs(rng[1] - rng[0]) < 1) {\n      // span is less than one power of 10\n      var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n      // ticks on a linear scale, labeled fully\n      roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;\n      base = getBase(10);\n      ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n    } else {\n      // include intermediates between powers of 10,\n      // labeled with small digits\n      // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n      ax.dtick = roughDTick > 0.3 ? 'D2' : 'D1';\n    }\n  } else if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax.tick0 = 0;\n    ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n  } else if (isAngular(ax)) {\n    ax.tick0 = 0;\n    base = 1;\n    ax.dtick = roundDTick(roughDTick, base, roundAngles);\n  } else {\n    // auto ticks always start at 0\n    ax.tick0 = 0;\n    base = getBase(10);\n    ax.dtick = roundDTick(roughDTick, base, roundBase10);\n  }\n\n  // prevent infinite loops\n  if (ax.dtick === 0) ax.dtick = 1;\n\n  // TODO: this is from log axis histograms with autorange off\n  if (!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n    var olddtick = ax.dtick;\n    ax.dtick = 1;\n    throw 'ax.dtick error: ' + String(olddtick);\n  }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n  var dtick = ax.dtick;\n  ax._tickexponent = 0;\n  if (!isNumeric(dtick) && typeof dtick !== 'string') {\n    dtick = 1;\n  }\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax._tickround = null;\n  }\n  if (ax.type === 'date') {\n    // If tick0 is unusual, give tickround a bit more information\n    // not necessarily *all* the information in tick0 though, if it's really odd\n    // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n    // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n    var tick0ms = ax.r2l(ax.tick0);\n    var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n    var tick0len = tick0str.length;\n    if (String(dtick).charAt(0) === 'M') {\n      // any tick0 more specific than a year: alway show the full date\n      if (tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n      // show the month unless ticks are full multiples of a year\n      else ax._tickround = +dtick.substr(1) % 12 === 0 ? 'y' : 'm';\n    } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = 'd';else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = 'M';else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = 'S';else {\n      // tickround is a number of digits of fractional seconds\n      // of any two adjacent ticks, at least one will have the maximum fractional digits\n      // of all possible ticks - so take the max. length of tick0 and the next one\n      var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n      ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n      // We shouldn't get here... but in case there's a situation I'm\n      // not thinking of where tick0str and tick1str are identical or\n      // something, fall back on maximum precision\n      if (ax._tickround < 0) ax._tickround = 4;\n    }\n  } else if (isNumeric(dtick) || dtick.charAt(0) === 'L') {\n    // linear or log (except D1, D2)\n    var rng = ax.range.map(ax.r2d || Number);\n    if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n    // 2 digits past largest digit of dtick\n    ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n    var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n    var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n    var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n    if (Math.abs(rangeexp) > minexponent) {\n      if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n        ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n      } else ax._tickexponent = rangeexp;\n    }\n  } else {\n    // D1 or D2 (log)\n    ax._tickround = null;\n  }\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function (x, dtick, axrev, calendar) {\n  var axSign = axrev ? -1 : 1;\n\n  // includes linear, all dates smaller than month, and pure 10^n in log\n  if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick);\n\n  // everything else is a string, one character plus a number\n  var tType = dtick.charAt(0);\n  var dtSigned = axSign * Number(dtick.substr(1));\n\n  // Dates: months (or years - see Lib.incrementMonth)\n  if (tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n  // Log scales: Linear, Digits\n  if (tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n  // log10 of 2,5,10, or all digits (logs just have to be\n  // close enough to round)\n  if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var x2 = x + axSign * 0.01;\n    var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n    return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  }\n  throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function (ax, opts) {\n  var r2l = ax.r2l || Number;\n  var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var sRound = axrev ? Math.floor : Math.ceil;\n  // add a tiny extra bit to make sure we get ticks\n  // that may have been rounded out\n  var r0 = expandRange(rng)[0];\n  var dtick = ax.dtick;\n  var tick0 = r2l(ax.tick0);\n  if (isNumeric(dtick)) {\n    var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n    // make sure no ticks outside the category list\n    if (ax.type === 'category' || ax.type === 'multicategory') {\n      tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n    }\n    return tmin;\n  }\n  var tType = dtick.charAt(0);\n  var dtNum = Number(dtick.substr(1));\n\n  // Dates: months (or years)\n  if (tType === 'M') {\n    var cnt = 0;\n    var t0 = tick0;\n    var t1, mult, newDTick;\n\n    // This algorithm should work for *any* nonlinear (but close to linear!)\n    // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n    while (cnt < 10) {\n      t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n      if ((t1 - r0) * (t0 - r0) <= 0) {\n        // t1 and t0 are on opposite sides of r0! we've succeeded!\n        if (axrev) return Math.min(t0, t1);\n        return Math.max(t0, t1);\n      }\n      mult = (r0 - (t0 + t1) / 2) / (t1 - t0);\n      newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;\n      t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n      cnt++;\n    }\n    Lib.error('tickFirst did not converge', ax);\n    return t0;\n  } else if (tType === 'L') {\n    // Log scales: Linear, Digits\n\n    return Math.log(sRound((Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n  } else if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n    return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function (ax, x, hover, noSuffixPrefix) {\n  var out = tickTextObj(ax, x);\n  var arrayMode = ax.tickmode === 'array';\n  var extraPrecision = hover || arrayMode;\n  var axType = ax.type;\n  // TODO multicategory, if we allow ticktext / tickvals\n  var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n  var i;\n  var inbounds = function (v) {\n    var p = ax.l2p(v);\n    return p >= 0 && p <= ax._length ? v : null;\n  };\n  if (arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n    for (i = 0; i < ax.ticktext.length; i++) {\n      if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n    }\n    if (i < ax.ticktext.length) {\n      out.text = String(ax.ticktext[i]);\n      out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n      return out;\n    }\n  }\n  function isHidden(showAttr) {\n    if (showAttr === undefined) return true;\n    if (hover) return showAttr === 'none';\n    var firstOrLast = {\n      first: ax._tmin,\n      last: ax._tmax\n    }[showAttr];\n    return showAttr !== 'all' && x !== firstOrLast;\n  }\n  var hideexp = hover ? 'never' : ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n  if (axType === 'date') formatDate(ax, out, hover, extraPrecision);else if (axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);else if (axType === 'category') formatCategory(ax, out);else if (axType === 'multicategory') formatMultiCategory(ax, out, hover);else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n  // add prefix and suffix\n  if (!noSuffixPrefix) {\n    if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n    if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n  }\n  if (ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {\n    var t = ax.labelalias[out.text];\n    if (typeof t === 'string') out.text = t;\n  }\n\n  // Setup ticks and grid lines boundaries\n  // at 1/2 a 'category' to the left/bottom\n  if (ax.tickson === 'boundaries' || ax.showdividers) {\n    out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n  }\n  return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\naxes.hoverLabelText = function (ax, values, hoverformat) {\n  if (hoverformat) ax = Lib.extendFlat({}, ax, {\n    hoverformat: hoverformat\n  });\n  var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;\n  var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : undefined;\n  if (val2 !== undefined && val2 !== val) {\n    return axes.hoverLabelText(ax, val, hoverformat) + ' - ' + axes.hoverLabelText(ax, val2, hoverformat);\n  }\n  var logOffScale = ax.type === 'log' && val <= 0;\n  var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n  if (logOffScale) {\n    return val === 0 ? '0' : MINUS_SIGN + tx;\n  }\n\n  // TODO: should we do something special if the axis calendar and\n  // the data calendar are different? Somehow display both dates with\n  // their system names? Right now it will just display in the axis calendar\n  // but users could add the other one as text.\n  return tx;\n};\nfunction tickTextObj(ax, x, text) {\n  var tf = ax.tickfont || {};\n  return {\n    x: x,\n    dx: 0,\n    dy: 0,\n    text: text || '',\n    fontSize: tf.size,\n    font: tf.family,\n    fontWeight: tf.weight,\n    fontStyle: tf.style,\n    fontVariant: tf.variant,\n    fontTextcase: tf.textcase,\n    fontLineposition: tf.lineposition,\n    fontShadow: tf.shadow,\n    fontColor: tf.color\n  };\n}\nfunction formatDate(ax, out, hover, extraPrecision) {\n  var tr = ax._tickround;\n  var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);\n\n  // Only apply extra precision if no explicit format was provided.\n  extraPrecision = !fmt && extraPrecision;\n  if (extraPrecision) {\n    // second or sub-second precision: extra always shows max digits.\n    // for other fields, extra precision just adds one field.\n    if (isNumeric(tr)) tr = 4;else tr = {\n      y: 'm',\n      m: 'd',\n      d: 'M',\n      M: 'S',\n      S: 4\n    }[tr];\n  }\n  var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n  var headStr;\n  var splitIndex = dateStr.indexOf('\\n');\n  if (splitIndex !== -1) {\n    headStr = dateStr.substr(splitIndex + 1);\n    dateStr = dateStr.substr(0, splitIndex);\n  }\n  if (extraPrecision) {\n    // if extraPrecision led to trailing zeros, strip them off\n    // actually, this can lead to removing even more zeros than\n    // in the original rounding, but that's fine because in these\n    // contexts uniformity is not so important (if there's even\n    // anything to be uniform with!)\n\n    // can we remove the whole time part?\n    if (headStr !== undefined && (dateStr === '00:00:00' || dateStr === '00:00')) {\n      dateStr = headStr;\n      headStr = '';\n    } else if (dateStr.length === 8) {\n      // strip off seconds if they're zero (zero fractional seconds\n      // are already omitted)\n      // but we never remove minutes and leave just hours\n      dateStr = dateStr.replace(/:00$/, '');\n    }\n  }\n  if (headStr) {\n    if (hover) {\n      // hover puts it all on one line, so headPart works best up front\n      // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n      if (tr === 'd') dateStr += ', ' + headStr;else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n    } else {\n      if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {\n        ax._prevDateHead = headStr;\n        dateStr += '<br>' + headStr;\n      } else {\n        var isInside = insideTicklabelposition(ax);\n        var side = ax._trueSide || ax.side; // polar mocks the side of the radial axis\n        if (!isInside && side === 'top' || isInside && side === 'bottom') {\n          dateStr += '<br> ';\n        }\n      }\n    }\n  }\n  out.text = dateStr;\n}\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n  var dtick = ax.dtick;\n  var x = out.x;\n  var tickformat = ax.tickformat;\n  var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  }\n  if (extraPrecision && dtChar0 !== 'L') {\n    dtick = 'L3';\n    dtChar0 = 'L';\n  }\n  if (tickformat || dtChar0 === 'L') {\n    out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n  } else if (isNumeric(dtick) || dtChar0 === 'D' && Lib.mod(x + 0.01, 1) < 0.1) {\n    var p = Math.round(x);\n    var absP = Math.abs(p);\n    var exponentFormat = ax.exponentformat;\n    if (exponentFormat === 'power' || isSIFormat(exponentFormat) && beyondSI(p)) {\n      if (p === 0) out.text = 1;else if (p === 1) out.text = '10';else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n      out.fontSize *= 1.25;\n    } else if ((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n      out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n    } else {\n      out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n      if (dtick === 'D1' && ax._id.charAt(0) === 'y') {\n        out.dy -= out.fontSize / 6;\n      }\n    }\n  } else if (dtChar0 === 'D') {\n    out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n    out.fontSize *= 0.75;\n  } else throw 'unrecognized dtick ' + String(dtick);\n\n  // if 9's are printed on log scale, move the 10's away a bit\n  if (ax.dtick === 'D1') {\n    var firstChar = String(out.text).charAt(0);\n    if (firstChar === '0' || firstChar === '1') {\n      if (ax._id.charAt(0) === 'y') {\n        out.dx -= out.fontSize / 4;\n      } else {\n        out.dy += out.fontSize / 2;\n        out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);\n      }\n    }\n  }\n}\nfunction formatCategory(ax, out) {\n  var tt = ax._categories[Math.round(out.x)];\n  if (tt === undefined) tt = '';\n  out.text = String(tt);\n}\nfunction formatMultiCategory(ax, out, hover) {\n  var v = Math.round(out.x);\n  var cats = ax._categories[v] || [];\n  var tt = cats[1] === undefined ? '' : String(cats[1]);\n  var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n  if (hover) {\n    // TODO is this what we want?\n    out.text = tt2 + ' - ' + tt;\n  } else {\n    // setup for secondary labels\n    out.text = tt;\n    out.text2 = tt2;\n  }\n}\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  } else if (ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n    // don't add an exponent to zero if we're showing all exponents\n    // so the only reason you'd show an exponent on zero is if it's the\n    // ONLY tick to get an exponent (first or last)\n    hideexp = 'hide';\n  }\n  out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n  if (ax.thetaunit === 'radians' && !hover) {\n    var num = out.x / 180;\n    if (num === 0) {\n      out.text = '0';\n    } else {\n      var frac = num2frac(num);\n      if (frac[1] >= 100) {\n        out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n      } else {\n        var isNeg = out.x < 0;\n        if (frac[1] === 1) {\n          if (frac[0] === 1) out.text = 'π';else out.text = frac[0] + 'π';\n        } else {\n          out.text = ['<sup>', frac[0], '</sup>', '⁄', '<sub>', frac[1], '</sub>', 'π'].join('');\n        }\n        if (isNeg) out.text = MINUS_SIGN + out.text;\n      }\n    }\n  } else {\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n  }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n  function almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n  }\n  function findGCD(a, b) {\n    return almostEq(b, 0) ? a : findGCD(b, a % b);\n  }\n  function findPrecision(n) {\n    var e = 1;\n    while (!almostEq(Math.round(n * e) / e, n)) {\n      e *= 10;\n    }\n    return e;\n  }\n  var precision = findPrecision(num);\n  var number = num * precision;\n  var gcd = Math.abs(findGCD(number, precision));\n  return [\n  // numerator\n  Math.round(number / gcd),\n  // denominator\n  Math.round(precision / gcd)];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\nfunction isSIFormat(exponentFormat) {\n  return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n  return exponent > 14 || exponent < -15;\n}\nfunction numFormat(v, ax, fmtoverride, hover) {\n  var isNeg = v < 0;\n  // max number of digits past decimal point to show\n  var tickRound = ax._tickround;\n  var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n  var exponent = ax._tickexponent;\n  var tickformat = axes.getTickFormat(ax);\n  var separatethousands = ax.separatethousands;\n\n  // special case for hover: set exponent just for this value, and\n  // add a couple more digits of precision over tick labels\n  if (hover) {\n    // make a dummy axis obj to get the auto rounding and exponent\n    var ah = {\n      exponentformat: exponentFormat,\n      minexponent: ax.minexponent,\n      dtick: ax.showexponent === 'none' ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,\n      // if not showing any exponents, don't change the exponent\n      // from what we calculate\n      range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n    };\n    autoTickRound(ah);\n    tickRound = (Number(ah._tickround) || 0) + 4;\n    exponent = ah._tickexponent;\n    if (ax.hoverformat) tickformat = ax.hoverformat;\n  }\n  if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n  // 'epsilon' - rounding increment\n  var e = Math.pow(10, -tickRound) / 2;\n\n  // exponentFormat codes:\n  // 'e' (1.2e+6, default)\n  // 'E' (1.2E+6)\n  // 'SI' (1.2M)\n  // 'B' (same as SI except 10^9=B not G)\n  // 'none' (1200000)\n  // 'power' (1.2x10^6)\n  // 'hide' (1.2, use 3rd argument=='hide' to eg\n  //      only show exponent on last tick)\n  if (exponentFormat === 'none') exponent = 0;\n\n  // take the sign out, put it back manually at the end\n  // - makes cases easier\n  v = Math.abs(v);\n  if (v < e) {\n    // 0 is just 0, but may get exponent if it's the last tick\n    v = '0';\n    isNeg = false;\n  } else {\n    v += e;\n    // take out a common exponent, if any\n    if (exponent) {\n      v *= Math.pow(10, -exponent);\n      tickRound += exponent;\n    }\n    // round the mantissa\n    if (tickRound === 0) v = String(Math.floor(v));else if (tickRound < 0) {\n      v = String(Math.round(v));\n      v = v.substr(0, v.length + tickRound);\n      for (var i = tickRound; i < 0; i++) v += '0';\n    } else {\n      v = String(v);\n      var dp = v.indexOf('.') + 1;\n      if (dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n    }\n    // insert appropriate decimal point and thousands separator\n    v = Lib.numSeparate(v, ax._separators, separatethousands);\n  }\n\n  // add exponent\n  if (exponent && exponentFormat !== 'hide') {\n    if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n    var signedExponent;\n    if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;else if (exponentFormat !== 'power') signedExponent = '+' + exponent;else signedExponent = String(exponent);\n    if (exponentFormat === 'e' || exponentFormat === 'E') {\n      v += exponentFormat + signedExponent;\n    } else if (exponentFormat === 'power') {\n      v += '×10<sup>' + signedExponent + '</sup>';\n    } else if (exponentFormat === 'B' && exponent === 9) {\n      v += 'B';\n    } else if (isSIFormat(exponentFormat)) {\n      v += SIPREFIXES[exponent / 3 + 5];\n    }\n  }\n\n  // put sign back in and return\n  // replace standard minus character (which is technically a hyphen)\n  // with a true minus sign\n  if (isNeg) return MINUS_SIGN + v;\n  return v;\n}\naxes.getTickFormat = function (ax) {\n  var i;\n  function convertToMs(dtick) {\n    return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n  }\n  function compareLogTicks(left, right) {\n    var priority = ['L', 'D'];\n    if (typeof left === typeof right) {\n      if (typeof left === 'number') {\n        return left - right;\n      } else {\n        var leftPriority = priority.indexOf(left.charAt(0));\n        var rightPriority = priority.indexOf(right.charAt(0));\n        if (leftPriority === rightPriority) {\n          return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n        } else {\n          return leftPriority - rightPriority;\n        }\n      }\n    } else {\n      return typeof left === 'number' ? 1 : -1;\n    }\n  }\n  function isProperStop(dtick, range, convert) {\n    var convertFn = convert || function (x) {\n      return x;\n    };\n    var leftDtick = range[0];\n    var rightDtick = range[1];\n    return (!leftDtick && typeof leftDtick !== 'number' || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== 'number' || convertFn(rightDtick) >= convertFn(dtick));\n  }\n  function isProperLogStop(dtick, range) {\n    var isLeftDtickNull = range[0] === null;\n    var isRightDtickNull = range[1] === null;\n    var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n    var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n    return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n  }\n  var tickstop, stopi;\n  if (ax.tickformatstops && ax.tickformatstops.length > 0) {\n    switch (ax.type) {\n      case 'date':\n      case 'linear':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n            if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n          break;\n        }\n      case 'log':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n            if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n          break;\n        }\n      default:\n    }\n  }\n  return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function (gd, ax) {\n  var subplotObj = gd._fullLayout._subplots;\n  var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n  var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n  out.sort(function (a, b) {\n    var aParts = a.substr(1).split('y');\n    var bParts = b.substr(1).split('y');\n    if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n    return +aParts[0] - +bParts[0];\n  });\n  return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function (subplots, ax) {\n  var axMatch = new RegExp(ax._id.charAt(0) === 'x' ? '^' + ax._id + 'y' : ax._id + '$');\n  var subplotsWithAx = [];\n  for (var i = 0; i < subplots.length; i++) {\n    var sp = subplots[i];\n    if (axMatch.test(sp)) subplotsWithAx.push(sp);\n  }\n  return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function (gd) {\n  var fullLayout = gd._fullLayout;\n\n  // for more info: https://github.com/plotly/plotly.js/issues/2595\n  if (fullLayout._hasOnlyLargeSploms) return;\n  var fullWidth = {\n    _offset: 0,\n    _length: fullLayout.width,\n    _id: ''\n  };\n  var fullHeight = {\n    _offset: 0,\n    _length: fullLayout.height,\n    _id: ''\n  };\n  var xaList = axes.list(gd, 'x', true);\n  var yaList = axes.list(gd, 'y', true);\n  var clipList = [];\n  var i, j;\n  for (i = 0; i < xaList.length; i++) {\n    clipList.push({\n      x: xaList[i],\n      y: fullHeight\n    });\n    for (j = 0; j < yaList.length; j++) {\n      if (i === 0) clipList.push({\n        x: fullWidth,\n        y: yaList[j]\n      });\n      clipList.push({\n        x: xaList[i],\n        y: yaList[j]\n      });\n    }\n  }\n\n  // selectors don't work right with camelCase tags,\n  // have to use class instead\n  // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n  var axClips = fullLayout._clips.selectAll('.axesclip').data(clipList, function (d) {\n    return d.x._id + d.y._id;\n  });\n  axClips.enter().append('clipPath').classed('axesclip', true).attr('id', function (d) {\n    return 'clip' + fullLayout._uid + d.x._id + d.y._id;\n  }).append('rect');\n  axClips.exit().remove();\n  axClips.each(function (d) {\n    d3.select(this).select('rect').attr({\n      x: d.x._offset || 0,\n      y: d.y._offset || 0,\n      width: d.x._length || 1,\n      height: d.y._length || 1\n    });\n  });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function (gd, arg, opts) {\n  var fullLayout = gd._fullLayout;\n  if (arg === 'redraw') {\n    fullLayout._paper.selectAll('g.subplot').each(function (d) {\n      var id = d[0];\n      var plotinfo = fullLayout._plots[id];\n      if (plotinfo) {\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n        if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll('path').remove();\n        if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n        if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n        fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n        fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n      }\n    });\n  }\n  var axList = !arg || arg === 'redraw' ? axes.listIds(gd) : arg;\n  var fullAxList = axes.list(gd);\n  // Get the list of the overlaying axis for all 'shift' axes\n  var overlayingShiftedAx = fullAxList.filter(function (ax) {\n    return ax.autoshift;\n  }).map(function (ax) {\n    return ax.overlaying;\n  });\n\n  // order axes that have dependency to other axes\n  axList.map(function (axId) {\n    var ax = axes.getFromId(gd, axId);\n    if (ax.tickmode === 'sync' && ax.overlaying) {\n      var overlayingIndex = axList.findIndex(function (axis) {\n        return axis === ax.overlaying;\n      });\n      if (overlayingIndex >= 0) {\n        axList.unshift(axList.splice(overlayingIndex, 1).shift());\n      }\n    }\n  });\n  var axShifts = {\n    false: {\n      left: 0,\n      right: 0\n    }\n  };\n  return Lib.syncOrAsync(axList.map(function (axId) {\n    return function () {\n      if (!axId) return;\n      var ax = axes.getFromId(gd, axId);\n      if (!opts) opts = {};\n      opts.axShifts = axShifts;\n      opts.overlayingShiftedAx = overlayingShiftedAx;\n      var axDone = axes.drawOne(gd, ax, opts);\n      if (ax._shiftPusher) {\n        incrementShift(ax, ax._fullDepth || 0, axShifts, true);\n      }\n      ax._r = ax.range.slice();\n      ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n      return axDone;\n    };\n  }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\naxes.drawOne = function (gd, ax, opts) {\n  opts = opts || {};\n  var axShifts = opts.axShifts || {};\n  var overlayingShiftedAx = opts.overlayingShiftedAx || [];\n  var i, sp, plotinfo;\n  ax.setScale();\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var counterLetter = axes.counterLetter(axId);\n  var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n  // this happens when updating matched group with 'missing' axes\n  if (!mainPlotinfo) return;\n  ax._shiftPusher = ax.autoshift || overlayingShiftedAx.indexOf(ax._id) !== -1 || overlayingShiftedAx.indexOf(ax.overlaying) !== -1;\n  // An axis is also shifted by 1/2 of its own linewidth and inside tick length if applicable\n  // as well as its manually specified `shift` val if we're in the context of `autoshift`\n  if (ax._shiftPusher & ax.anchor === 'free') {\n    var selfPush = ax.linewidth / 2 || 0;\n    if (ax.ticks === 'inside') {\n      selfPush += ax.ticklen;\n    }\n    incrementShift(ax, selfPush, axShifts, true);\n    incrementShift(ax, ax.shift || 0, axShifts, false);\n  }\n\n  // Somewhat inelegant way of making sure that the shift value is only updated when the\n  // Axes.DrawOne() function is called from the right context. An issue when redrawing the\n  // axis as result of using the dragbox, for example.\n  if (opts.skipTitle !== true || ax._shift === undefined) ax._shift = setShiftVal(ax, axShifts);\n  var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n  var mainLinePosition = ax._mainLinePosition;\n  var mainLinePositionShift = mainLinePosition += ax._shift;\n  var mainMirrorPosition = ax._mainMirrorPosition;\n  var vals = ax._vals = axes.calcTicks(ax);\n\n  // Add a couple of axis properties that should cause us to recreate\n  // elements. Used in d3 data function.\n  var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join('_');\n  for (i = 0; i < vals.length; i++) {\n    vals[i].axInfo = axInfo;\n  }\n\n  // stash selections to avoid DOM queries e.g.\n  // - stash tickLabels selection, so that drawTitle can use it to scoot title\n  ax._selections = {};\n  // stash tick angle (including the computed 'auto' values) per tick-label class\n  // linkup 'previous' tick angles on redraws\n  if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n  ax._tickAngles = {};\n  // measure [in px] between axis position and outward-most part of bounding box\n  // (touching either the tick label or ticks)\n  // depth can be expansive to compute, so we only do so when required\n  ax._depth = null;\n\n  // calcLabelLevelBbox can be expensive,\n  // so make sure to not call it twice during the same Axes.drawOne call\n  // by stashing label-level bounding boxes per tick-label class\n  var llbboxes = {};\n  function getLabelLevelBbox(suffix) {\n    var cls = axId + (suffix || 'tick');\n    if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);\n    return llbboxes[cls];\n  }\n  if (!ax.visible) return;\n  var transTickFn = axes.makeTransTickFn(ax);\n  var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n  var tickVals;\n  // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n  // The key case here is removing zero lines when the axis bound is zero\n  var valsClipped;\n  var insideTicks = ax.ticks === 'inside';\n  var outsideTicks = ax.ticks === 'outside';\n  if (ax.tickson === 'boundaries') {\n    var boundaryVals = getBoundaryVals(ax, vals);\n    valsClipped = axes.clipEnds(ax, boundaryVals);\n    tickVals = insideTicks ? valsClipped : boundaryVals;\n  } else {\n    valsClipped = axes.clipEnds(ax, vals);\n    tickVals = insideTicks && ax.ticklabelmode !== 'period' ? valsClipped : vals;\n  }\n  var gridVals = ax._gridVals = valsClipped;\n  var dividerVals = getDividerVals(ax, vals);\n  if (!fullLayout._hasOnlyLargeSploms) {\n    var subplotsWithAx = ax._subplotsWith;\n\n    // keep track of which subplots (by main counter axis) we've already\n    // drawn grids for, so we don't overdraw overlaying subplots\n    var finishedGrids = {};\n    for (i = 0; i < subplotsWithAx.length; i++) {\n      sp = subplotsWithAx[i];\n      plotinfo = fullLayout._plots[sp];\n      var counterAxis = plotinfo[counterLetter + 'axis'];\n      var mainCounterID = counterAxis._mainAxis._id;\n      if (finishedGrids[mainCounterID]) continue;\n      finishedGrids[mainCounterID] = 1;\n      var gridPath = axLetter === 'x' ? 'M0,' + counterAxis._offset + 'v' + counterAxis._length : 'M' + counterAxis._offset + ',0h' + counterAxis._length;\n      axes.drawGrid(gd, ax, {\n        vals: gridVals,\n        counterAxis: counterAxis,\n        layer: plotinfo.gridlayer.select('.' + axId),\n        minorLayer: plotinfo.minorGridlayer.select('.' + axId),\n        path: gridPath,\n        transFn: transTickFn\n      });\n      axes.drawZeroLine(gd, ax, {\n        counterAxis: counterAxis,\n        layer: plotinfo.zerolinelayer,\n        path: gridPath,\n        transFn: transTickFn\n      });\n    }\n  }\n  var tickPath;\n  var majorTickSigns = axes.getTickSigns(ax);\n  var minorTickSigns = axes.getTickSigns(ax, 'minor');\n  if (ax.ticks || ax.minor && ax.minor.ticks) {\n    var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);\n    var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], {\n      minor: true\n    });\n    var mirrorMajorTickPath;\n    var mirrorMinorTickPath;\n    var fullMajorTickPath;\n    var fullMinorTickPath;\n    if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n      mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);\n      mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], {\n        minor: true\n      });\n      fullMajorTickPath = majorTickPath + mirrorMajorTickPath;\n      fullMinorTickPath = minorTickPath + mirrorMinorTickPath;\n    } else {\n      mirrorMajorTickPath = '';\n      mirrorMinorTickPath = '';\n      fullMajorTickPath = majorTickPath;\n      fullMinorTickPath = minorTickPath;\n    }\n    if (ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n      var dividerLookup = {};\n      for (i = 0; i < dividerVals.length; i++) {\n        dividerLookup[dividerVals[i].x] = 1;\n      }\n      tickPath = function (d) {\n        return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;\n      };\n    } else {\n      tickPath = function (d) {\n        return d.minor ? fullMinorTickPath : fullMajorTickPath;\n      };\n    }\n  }\n  axes.drawTicks(gd, ax, {\n    vals: tickVals,\n    layer: mainAxLayer,\n    path: tickPath,\n    transFn: transTickFn\n  });\n  if (ax.mirror === 'allticks') {\n    var tickSubplots = Object.keys(ax._linepositions || {});\n    for (i = 0; i < tickSubplots.length; i++) {\n      sp = tickSubplots[i];\n      plotinfo = fullLayout._plots[sp];\n      // [bottom or left, top or right], free and main are handled above\n      var linepositions = ax._linepositions[sp] || [];\n      var p0 = linepositions[0];\n      var p1 = linepositions[1];\n      var isMinor = linepositions[2];\n      var spTickPath = axes.makeTickPath(ax, p0, isMinor ? majorTickSigns[0] : minorTickSigns[0], {\n        minor: isMinor\n      }) + axes.makeTickPath(ax, p1, isMinor ? majorTickSigns[1] : minorTickSigns[1], {\n        minor: isMinor\n      });\n      axes.drawTicks(gd, ax, {\n        vals: tickVals,\n        layer: plotinfo[axLetter + 'axislayer'],\n        path: spTickPath,\n        transFn: transTickFn\n      });\n    }\n  }\n  var seq = [];\n\n  // tick labels - for now just the main labels.\n  // TODO: mirror labels, esp for subplots\n\n  seq.push(function () {\n    return axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: mainAxLayer,\n      plotinfo: plotinfo,\n      transFn: transTickLabelFn,\n      labelFns: axes.makeLabelFns(ax, mainLinePositionShift)\n    });\n  });\n  if (ax.type === 'multicategory') {\n    var pad = {\n      x: 2,\n      y: 10\n    }[axLetter];\n    seq.push(function () {\n      var bboxKey = {\n        x: 'height',\n        y: 'width'\n      }[axLetter];\n      var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n      return axes.drawLabels(gd, ax, {\n        vals: getSecondaryLabelVals(ax, vals),\n        layer: mainAxLayer,\n        cls: axId + 'tick2',\n        repositionOnUpdate: true,\n        secondary: true,\n        transFn: transTickFn,\n        labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])\n      });\n    });\n    seq.push(function () {\n      ax._depth = majorTickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePositionShift);\n      return drawDividers(gd, ax, {\n        vals: dividerVals,\n        layer: mainAxLayer,\n        path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], {\n          len: ax._depth\n        }),\n        transFn: transTickFn\n      });\n    });\n  } else if (ax.title.hasOwnProperty('standoff')) {\n    seq.push(function () {\n      ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);\n    });\n  }\n  var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n  if (!opts.skipTitle && !(hasRangeSlider && ax.side === 'bottom')) {\n    seq.push(function () {\n      return drawTitle(gd, ax);\n    });\n  }\n  seq.push(function () {\n    var s = ax.side.charAt(0);\n    var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n    var pos = axes.getPxPosition(gd, ax);\n    var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n    var llbbox;\n    var push;\n    var mirrorPush;\n    var rangeSliderPush;\n    if (ax.automargin || hasRangeSlider || ax._shiftPusher) {\n      if (ax.type === 'multicategory') {\n        llbbox = getLabelLevelBbox('tick2');\n      } else {\n        llbbox = getLabelLevelBbox();\n        if (axLetter === 'x' && s === 'b') {\n          ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n        }\n      }\n    }\n    var axDepth = 0;\n    var titleDepth = 0;\n    if (ax._shiftPusher) {\n      axDepth = Math.max(outsideTickLen, llbbox.height > 0 ? s === 'l' ? pos - llbbox.left : llbbox.right - pos : 0);\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);\n        if (s === 'l') {\n          titleDepth += approxTitleDepth(ax);\n        }\n      }\n      ax._fullDepth = Math.max(axDepth, titleDepth);\n    }\n    if (ax.automargin) {\n      push = {\n        x: 0,\n        y: 0,\n        r: 0,\n        l: 0,\n        t: 0,\n        b: 0\n      };\n      var domainIndices = [0, 1];\n      var shift = typeof ax._shift === 'number' ? ax._shift : 0;\n      if (axLetter === 'x') {\n        if (s === 'b') {\n          push[s] = ax._depth;\n        } else {\n          push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n          domainIndices.reverse();\n        }\n        if (llbbox.width > 0) {\n          var rExtra = llbbox.right - (ax._offset + ax._length);\n          if (rExtra > 0) {\n            push.xr = 1;\n            push.r = rExtra;\n          }\n          var lExtra = ax._offset - llbbox.left;\n          if (lExtra > 0) {\n            push.xl = 0;\n            push.l = lExtra;\n          }\n        }\n      } else {\n        if (s === 'l') {\n          ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n          push[s] = ax._depth - shift;\n        } else {\n          ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n          push[s] = ax._depth + shift;\n          domainIndices.reverse();\n        }\n        if (llbbox.height > 0) {\n          var bExtra = llbbox.bottom - (ax._offset + ax._length);\n          if (bExtra > 0) {\n            push.yb = 0;\n            push.b = bExtra;\n          }\n          var tExtra = ax._offset - llbbox.top;\n          if (tExtra > 0) {\n            push.yt = 1;\n            push.t = tExtra;\n          }\n        }\n      }\n      push[counterLetter] = ax.anchor === 'free' ? ax.position : ax._anchorAxis.domain[domainIndices[0]];\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n      }\n      if (ax.mirror && ax.anchor !== 'free') {\n        mirrorPush = {\n          x: 0,\n          y: 0,\n          r: 0,\n          l: 0,\n          t: 0,\n          b: 0\n        };\n        mirrorPush[sMirror] = ax.linewidth;\n        if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n        if (ax.mirror === true || ax.mirror === 'ticks') {\n          mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n        } else if (ax.mirror === 'all' || ax.mirror === 'allticks') {\n          mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n        }\n      }\n    }\n    if (hasRangeSlider) {\n      rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n    }\n    if (typeof ax.automargin === 'string') {\n      filterPush(push, ax.automargin);\n      filterPush(mirrorPush, ax.automargin);\n    }\n    Plots.autoMargin(gd, axAutoMarginID(ax), push);\n    Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n    Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n  });\n  return Lib.syncOrAsync(seq);\n};\nfunction filterPush(push, automargin) {\n  if (!push) return;\n  var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function (data, nextKey) {\n    if (automargin.indexOf(nextKey) !== -1) {\n      MARGIN_MAPPING[nextKey].forEach(function (key) {\n        data[key] = 1;\n      });\n    }\n    return data;\n  }, {});\n  Object.keys(push).forEach(function (key) {\n    if (!keepMargin[key]) {\n      if (key.length === 1) push[key] = 0;else delete push[key];\n    }\n  });\n}\nfunction getBoundaryVals(ax, vals) {\n  var out = [];\n  var i;\n\n  // boundaryVals are never used for labels;\n  // no need to worry about the other tickTextObj keys\n  var _push = function (d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n  if (vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      _push(vals[i], 0);\n    }\n    _push(vals[i - 1], 1);\n  }\n  return out;\n}\nfunction getSecondaryLabelVals(ax, vals) {\n  var out = [];\n  var lookup = {};\n  for (var i = 0; i < vals.length; i++) {\n    var d = vals[i];\n    if (lookup[d.text2]) {\n      lookup[d.text2].push(d.x);\n    } else {\n      lookup[d.text2] = [d.x];\n    }\n  }\n  for (var k in lookup) {\n    out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n  }\n  return out;\n}\nfunction getDividerVals(ax, vals) {\n  var out = [];\n  var i, current;\n  var reversed = vals.length && vals[vals.length - 1].x < vals[0].x;\n\n  // never used for labels;\n  // no need to worry about the other tickTextObj keys\n  var _push = function (d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n  if (ax.showdividers && vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      var d = vals[i];\n      if (d.text2 !== current) {\n        _push(d, reversed ? 1 : 0);\n      }\n      current = d.text2;\n    }\n    _push(vals[i - 1], reversed ? 0 : 1);\n  }\n  return out;\n}\nfunction calcLabelLevelBbox(ax, cls, mainLinePositionShift) {\n  var top, bottom;\n  var left, right;\n  if (ax._selections[cls].size()) {\n    top = Infinity;\n    bottom = -Infinity;\n    left = Infinity;\n    right = -Infinity;\n    ax._selections[cls].each(function () {\n      var thisLabel = selectTickLabel(this);\n      // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n      // retrieve a bbox computed with transform info\n      //\n      // To improve perf, it would be nice to use `thisLabel.node()`\n      // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n      // together with the makeLabelFns outputs and `tickangle`\n      // to compute one bbox per (tick value x tick style)\n      var bb = Drawing.bBox(thisLabel.node().parentNode);\n      top = Math.min(top, bb.top);\n      bottom = Math.max(bottom, bb.bottom);\n      left = Math.min(left, bb.left);\n      right = Math.max(right, bb.right);\n    });\n  } else {\n    var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);\n    top = bottom = dummyCalc.yFn({\n      dx: 0,\n      dy: 0,\n      fontSize: 0\n    });\n    left = right = dummyCalc.xFn({\n      dx: 0,\n      dy: 0,\n      fontSize: 0\n    });\n  }\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    height: bottom - top,\n    width: right - left\n  };\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\naxes.getTickSigns = function (ax, minor) {\n  var axLetter = ax._id.charAt(0);\n  var sideOpposite = {\n    x: 'top',\n    y: 'right'\n  }[axLetter];\n  var main = ax.side === sideOpposite ? 1 : -1;\n  var out = [-1, 1, main, -main];\n  // then we flip if outside XOR y axis\n\n  var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;\n  if (ticks !== 'inside' === (axLetter === 'x')) {\n    out = out.map(function (v) {\n      return -v;\n    });\n  }\n  // independent of `ticks`; do not flip this one\n  if (ax.side) {\n    out.push({\n      l: -1,\n      t: -1,\n      r: 1,\n      b: 1\n    }[ax.side.charAt(0)]);\n  }\n  return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransTickFn = function (ax) {\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(ax._offset + ax.l2p(d.x), 0);\n  } : function (d) {\n    return strTranslate(0, ax._offset + ax.l2p(d.x));\n  };\n};\naxes.makeTransTickLabelFn = function (ax) {\n  var uv = getTickLabelUV(ax);\n  var shift = ax.ticklabelshift || 0;\n  var standoff = ax.ticklabelstandoff || 0;\n  var u = uv[0];\n  var v = uv[1];\n  var isReversed = ax.range[0] > ax.range[1];\n  var labelsInside = ax.ticklabelposition && ax.ticklabelposition.indexOf('inside') !== -1;\n  var labelsOutside = !labelsInside;\n  if (shift) {\n    var shiftSign = isReversed ? -1 : 1;\n    shift = shift * shiftSign;\n  }\n  if (standoff) {\n    var side = ax.side;\n    var standoffSign = labelsInside && (side === 'top' || side === 'left') || labelsOutside && (side === 'bottom' || side === 'right') ? 1 : -1;\n    standoff = standoff * standoffSign;\n  }\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(u + ax._offset + ax.l2p(getPosX(d)) + shift, v + standoff);\n  } : function (d) {\n    return strTranslate(v + standoff, u + ax._offset + ax.l2p(getPosX(d)) + shift);\n  };\n};\nfunction getPosX(d) {\n  return d.periodX !== undefined ? d.periodX : d.x;\n}\n\n// u is a shift along the axis,\n// v is a shift perpendicular to the axis\nfunction getTickLabelUV(ax) {\n  var ticklabelposition = ax.ticklabelposition || '';\n  var has = function (str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isInside = has('inside');\n  var isAligned = isBottom || isLeft || isTop || isRight;\n\n  // early return\n  if (!isAligned && !isInside) return [0, 0];\n  var side = ax.side;\n  var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n  var v = TEXTPAD;\n  var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n  if (isBottom || isTop) {\n    u += fontSize * CAP_SHIFT;\n    v += (ax.linewidth || 0) / 2;\n  }\n  if (isLeft || isRight) {\n    u += (ax.linewidth || 0) / 2;\n    v += TEXTPAD;\n  }\n  if (isInside && side === 'top') {\n    v -= fontSize * (1 - CAP_SHIFT);\n  }\n  if (isLeft || isTop) u = -u;\n  if (side === 'bottom' || side === 'right') v = -v;\n  return [isAligned ? u : 0, isInside ? v : 0];\n}\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {object} opts\n * - {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function (ax, shift, sgn, opts) {\n  if (!opts) opts = {};\n  var minor = opts.minor;\n  if (minor && !ax.minor) return '';\n  var len = opts.len !== undefined ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;\n  var axLetter = ax._id.charAt(0);\n  var pad = (ax.linewidth || 1) / 2;\n  return axLetter === 'x' ? 'M0,' + (shift + pad * sgn) + 'v' + len * sgn : 'M' + (shift + pad * sgn) + ',0h' + len * sgn;\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\naxes.makeLabelFns = function (ax, shift, angle) {\n  var ticklabelposition = ax.ticklabelposition || '';\n  var has = function (str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isAligned = isBottom || isLeft || isTop || isRight;\n  var insideTickLabels = has('inside');\n  var labelsOverTicks = ticklabelposition === 'inside' && ax.ticks === 'inside' || !insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries';\n  var labelStandoff = 0;\n  var labelShift = 0;\n  var tickLen = labelsOverTicks ? ax.ticklen : 0;\n  if (insideTickLabels) {\n    tickLen *= -1;\n  } else if (isAligned) {\n    tickLen = 0;\n  }\n  if (labelsOverTicks) {\n    labelStandoff += tickLen;\n    if (angle) {\n      var rad = Lib.deg2rad(angle);\n      labelStandoff = tickLen * Math.cos(rad) + 1;\n      labelShift = tickLen * Math.sin(rad);\n    }\n  }\n  if (ax.showticklabels && (labelsOverTicks || ax.showline)) {\n    labelStandoff += 0.2 * ax.tickfont.size;\n  }\n  labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n  var out = {\n    labelStandoff: labelStandoff,\n    labelShift: labelShift\n  };\n  var x0, y0, ff, flipIt;\n  var xQ = 0;\n  var side = ax.side;\n  var axLetter = ax._id.charAt(0);\n  var tickangle = ax.tickangle;\n  var endSide;\n  if (axLetter === 'x') {\n    endSide = !insideTickLabels && side === 'bottom' || insideTickLabels && side === 'top';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelShift * flipIt;\n    y0 = shift + labelStandoff * flipIt;\n    ff = endSide ? 1 : -0.2;\n    if (Math.abs(tickangle) === 90) {\n      if (insideTickLabels) {\n        ff += MID_SHIFT;\n      } else {\n        if (tickangle === -90 && side === 'bottom') {\n          ff = CAP_SHIFT;\n        } else if (tickangle === 90 && side === 'top') {\n          ff = MID_SHIFT;\n        } else {\n          ff = 0.5;\n        }\n      }\n      xQ = MID_SHIFT / 2 * (tickangle / 90);\n    }\n    out.xFn = function (d) {\n      return d.dx + x0 + xQ * d.fontSize;\n    };\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * ff;\n    };\n    out.anchorFn = function (d, a) {\n      if (isAligned) {\n        if (isLeft) return 'end';\n        if (isRight) return 'start';\n      }\n      if (!isNumeric(a) || a === 0 || a === 180) {\n        return 'middle';\n      }\n      return a * flipIt < 0 !== insideTickLabels ? 'end' : 'start';\n    };\n    out.heightFn = function (d, a, h) {\n      return a < -60 || a > 60 ? -0.5 * h : ax.side === 'top' !== insideTickLabels ? -h : 0;\n    };\n  } else if (axLetter === 'y') {\n    endSide = !insideTickLabels && side === 'left' || insideTickLabels && side === 'right';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelStandoff;\n    y0 = labelShift * flipIt;\n    ff = 0;\n    if (!insideTickLabels && Math.abs(tickangle) === 90) {\n      if (tickangle === -90 && side === 'left' || tickangle === 90 && side === 'right') {\n        ff = CAP_SHIFT;\n      } else {\n        ff = 0.5;\n      }\n    }\n    if (insideTickLabels) {\n      var ang = isNumeric(tickangle) ? +tickangle : 0;\n      if (ang !== 0) {\n        var rA = Lib.deg2rad(ang);\n        xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n        ff = 0;\n      }\n    }\n    out.xFn = function (d) {\n      return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;\n    };\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * MID_SHIFT;\n    };\n    out.anchorFn = function (d, a) {\n      if (isNumeric(a) && Math.abs(a) === 90) {\n        return 'middle';\n      }\n      return endSide ? 'end' : 'start';\n    };\n    out.heightFn = function (d, a, h) {\n      if (ax.side === 'right') a *= -1;\n      return a < -30 ? -h : a < 30 ? -0.5 * h : 0;\n    };\n  }\n  return out;\n};\nfunction tickDataFn(d) {\n  return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'tick';\n  var vals = [].concat(ax.minor && ax.minor.ticks ?\n  // minor vals\n  opts.vals.filter(function (d) {\n    return d.minor && !d.noTick;\n  }) : []).concat(ax.ticks ?\n  // major vals\n  opts.vals.filter(function (d) {\n    return !d.minor && !d.noTick;\n  }) : []);\n  var ticks = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  ticks.exit().remove();\n  ticks.enter().append('path').classed(cls, 1).classed('ticks', 1).classed('crisp', opts.crisp !== false).each(function (d) {\n    return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);\n  }).style('stroke-width', function (d) {\n    return Drawing.crispRound(gd, d.minor ? ax.minor.tickwidth : ax.tickwidth, 1) + 'px';\n  }).attr('d', opts.path).style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n  ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {string} griddash\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function (gd, ax, opts) {\n  opts = opts || {};\n  if (ax.tickmode === 'sync') {\n    // for tickmode sync we use the overlaying axis grid\n    return;\n  }\n  var cls = ax._id + 'grid';\n  var hasMinor = ax.minor && ax.minor.showgrid;\n  var minorVals = hasMinor ? opts.vals.filter(function (d) {\n    return d.minor;\n  }) : [];\n  var majorVals = ax.showgrid ? opts.vals.filter(function (d) {\n    return !d.minor;\n  }) : [];\n  var counterAx = opts.counterAxis;\n  if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n    var isArrayMode = ax.tickmode === 'array';\n    for (var i = 0; i < majorVals.length; i++) {\n      var xi = majorVals[i].x;\n      if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {\n        majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));\n        // In array mode you can in principle have multiple\n        // ticks at 0, so test them all. Otherwise once we found\n        // one we can stop.\n        if (isArrayMode) i--;else break;\n      }\n    }\n  }\n  ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n  var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);\n  var majorLayer = opts.layer;\n  var minorLayer = opts.minorLayer;\n  for (var major = 1; major >= 0; major--) {\n    var layer = major ? majorLayer : minorLayer;\n    if (!layer) continue;\n    var grid = layer.selectAll('path.' + cls).data(major ? majorVals : minorVals, tickDataFn);\n    grid.exit().remove();\n    grid.enter().append('path').classed(cls, 1).classed('crisp', opts.crisp !== false);\n    grid.attr('transform', opts.transFn).attr('d', opts.path).each(function (d) {\n      return Color.stroke(d3.select(this), d.minor ? ax.minor.gridcolor : ax.gridcolor || '#ddd');\n    }).style('stroke-dasharray', function (d) {\n      return Drawing.dashStyle(d.minor ? ax.minor.griddash : ax.griddash, d.minor ? ax.minor.gridwidth : ax.gridwidth);\n    }).style('stroke-width', function (d) {\n      return (d.minor ? wMinor : ax._gw) + 'px';\n    }).style('display', null); // visible\n\n    if (typeof opts.path === 'function') grid.attr('d', opts.path);\n  }\n  hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function (gd, ax, opts) {\n  opts = opts || opts;\n  var cls = ax._id + 'zl';\n  var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n  var zl = opts.layer.selectAll('path.' + cls).data(show ? [{\n    x: 0,\n    id: ax._id\n  }] : []);\n  zl.exit().remove();\n  zl.enter().append('path').classed(cls, 1).classed('zl', 1).classed('crisp', opts.crisp !== false).each(function () {\n    // use the fact that only one element can enter to trigger a sort.\n    // If several zerolines enter at the same time we will sort once per,\n    // but generally this should be a minimal overhead.\n    opts.layer.selectAll('path').sort(function (da, db) {\n      return idSort(da.id, db.id);\n    });\n  });\n  zl.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px').style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\naxes.drawLabels = function (gd, ax, opts) {\n  opts = opts || {};\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var cls = opts.cls || axId + 'tick';\n  var vals = opts.vals.filter(function (d) {\n    return d.text;\n  });\n  var labelFns = opts.labelFns;\n  var tickAngle = opts.secondary ? 0 : ax.tickangle;\n  var prevAngle = (ax._prevTickAngles || {})[cls];\n  var tickLabels = opts.layer.selectAll('g.' + cls).data(ax.showticklabels ? vals : [], tickDataFn);\n  var labelsReady = [];\n  tickLabels.enter().append('g').classed(cls, 1).append('text')\n  // only so tex has predictable alignment that we can\n  // alter later\n  .attr('text-anchor', 'middle').each(function (d) {\n    var thisLabel = d3.select(this);\n    var newPromise = gd._promises.length;\n    thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, {\n      family: d.font,\n      size: d.fontSize,\n      color: d.fontColor,\n      weight: d.fontWeight,\n      style: d.fontStyle,\n      variant: d.fontVariant,\n      textcase: d.fontTextcase,\n      lineposition: d.fontLineposition,\n      shadow: d.fontShadow\n    }).text(d.text).call(svgTextUtils.convertToTspans, gd);\n    if (gd._promises[newPromise]) {\n      // if we have an async label, we'll deal with that\n      // all here so take it out of gd._promises and\n      // instead position the label and promise this in\n      // labelsReady\n      labelsReady.push(gd._promises.pop().then(function () {\n        positionLabels(thisLabel, tickAngle);\n      }));\n    } else {\n      // sync label: just position it now.\n      positionLabels(thisLabel, tickAngle);\n    }\n  });\n  hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n  tickLabels.exit().remove();\n  if (opts.repositionOnUpdate) {\n    tickLabels.each(function (d) {\n      d3.select(this).select('text').call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n    });\n  }\n  function positionLabels(s, angle) {\n    s.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      var anchor = labelFns.anchorFn(d, angle);\n      var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? ' rotate(' + angle + ',' + labelFns.xFn(d) + ',' + (labelFns.yFn(d) - d.fontSize / 2) + ')' : '');\n\n      // how much to shift a multi-line label to center it vertically.\n      var nLines = svgTextUtils.lineCount(thisLabel);\n      var lineHeight = LINE_SPACING * d.fontSize;\n      var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n      if (anchorHeight) {\n        transform += strTranslate(0, anchorHeight);\n      }\n      if (mathjaxGroup.empty()) {\n        var thisText = thisLabel.select('text');\n        thisText.attr({\n          transform: transform,\n          'text-anchor': anchor\n        });\n        thisText.style('opacity', 1); // visible\n\n        if (ax._adjustTickLabelsOverflow) {\n          ax._adjustTickLabelsOverflow();\n        }\n      } else {\n        var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n        var mjShift = mjWidth * {\n          end: -0.5,\n          start: 0.5\n        }[anchor];\n        mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n      }\n    });\n  }\n  ax._adjustTickLabelsOverflow = function () {\n    var ticklabeloverflow = ax.ticklabeloverflow;\n    if (!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n    var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n    var isX = ax._id.charAt(0) === 'x';\n    // div positions\n    var p0 = 0;\n    var p1 = isX ? gd._fullLayout.width : gd._fullLayout.height;\n    if (ticklabeloverflow.indexOf('domain') !== -1) {\n      // domain positions\n      var rl = Lib.simpleMap(ax.range, ax.r2l);\n      p0 = ax.l2p(rl[0]) + ax._offset;\n      p1 = ax.l2p(rl[1]) + ax._offset;\n    }\n    var min = Math.min(p0, p1);\n    var max = Math.max(p0, p1);\n    var side = ax.side;\n    var visibleLabelMin = Infinity;\n    var visibleLabelMax = -Infinity;\n    tickLabels.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      if (mathjaxGroup.empty()) {\n        var bb = Drawing.bBox(thisLabel.node());\n        var adjust = 0;\n        if (isX) {\n          if (bb.right > max) adjust = 1;else if (bb.left < min) adjust = 1;\n        } else {\n          if (bb.bottom > max) adjust = 1;else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n        }\n        var t = thisLabel.select('text');\n        if (adjust) {\n          if (hideOverflow) t.style('opacity', 0); // hidden\n        } else {\n          t.style('opacity', 1); // visible\n\n          if (side === 'bottom' || side === 'right') {\n            visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n          } else {\n            visibleLabelMin = -Infinity;\n          }\n          if (side === 'top' || side === 'left') {\n            visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n          } else {\n            visibleLabelMax = Infinity;\n          }\n        }\n      } // TODO: hide mathjax?\n    });\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n      if (anchorAx) {\n        anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n        anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n      }\n    }\n  };\n  ax._hideCounterAxisInsideTickLabels = function (partialOpts) {\n    var isX = ax._id.charAt(0) === 'x';\n    var anchoredAxes = [];\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n    }\n    anchoredAxes.forEach(function (anchorAx, idx) {\n      if (anchorAx && insideTicklabelposition(anchorAx)) {\n        (partialOpts || [ZERO_PATH, MINORGRID_PATH, GRID_PATH, TICK_PATH, TICK_TEXT]).forEach(function (e) {\n          var isPeriodLabel = e.K === 'tick' && e.L === 'text' && ax.ticklabelmode === 'period';\n          var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n          var sel;\n          if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll('.' + ax._id);else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n          sel.each(function () {\n            var w = d3.select(this);\n            if (e.L) w = w.selectAll(e.L);\n            w.each(function (d) {\n              var q = ax.l2p(isPeriodLabel ? getPosX(d) : d.x) + ax._offset;\n              var t = d3.select(this);\n              if (q < ax['_visibleLabelMax_' + anchorAx._id] && q > ax['_visibleLabelMin_' + anchorAx._id]) {\n                t.style('display', 'none'); // hidden\n              } else if (e.K === 'tick' && !idx) {\n                t.style('display', null); // visible\n              }\n            });\n          });\n        });\n      }\n    });\n  };\n\n  // make sure all labels are correctly positioned at their base angle\n  // the positionLabels call above is only for newly drawn labels.\n  // do this without waiting, using the last calculated angle to\n  // minimize flicker, then do it again when we know all labels are\n  // there, putting back the prescribed angle to check for overlaps.\n  positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);\n  function allLabelsReady() {\n    return labelsReady.length && Promise.all(labelsReady);\n  }\n  var autoangle = null;\n  function fixLabelOverlaps() {\n    positionLabels(tickLabels, tickAngle);\n\n    // check for auto-angling if x labels overlap\n    // don't auto-angle at all for log axes with\n    // base and digit format\n    if (vals.length && ax.autotickangles && (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {\n      autoangle = ax.autotickangles[0];\n      var maxFontSize = 0;\n      var lbbArray = [];\n      var i;\n      var maxLines = 1;\n      tickLabels.each(function (d) {\n        maxFontSize = Math.max(maxFontSize, d.fontSize);\n        var x = ax.l2p(d.x);\n        var thisLabel = selectTickLabel(this);\n        var bb = Drawing.bBox(thisLabel.node());\n        maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));\n        lbbArray.push({\n          // ignore about y, just deal with x overlaps\n          top: 0,\n          bottom: 10,\n          height: 10,\n          left: x - bb.width / 2,\n          // impose a 2px gap\n          right: x + bb.width / 2 + 2,\n          width: bb.width + 2\n        });\n      });\n\n      // autotickangles\n      // if there are dividers or ticks on boundaries, the labels will be in between and\n      // we need to prevent overlap with the next divider/tick. Else the labels will be on\n      // the ticks and we need to prevent overlap with the next label.\n\n      // TODO should secondary labels also fall into this fix-overlap regime?\n      var preventOverlapWithTick = (ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary;\n      var vLen = vals.length;\n      var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n      var adjacent = preventOverlapWithTick ? tickSpacing / 2 : tickSpacing;\n      var opposite = preventOverlapWithTick ? ax.ticklen : maxFontSize * 1.25 * maxLines;\n      var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));\n      var maxCos = adjacent / hypotenuse;\n      var autoTickAnglesRadians = ax.autotickangles.map(function (degrees) {\n        return degrees * Math.PI / 180;\n      });\n      var angleRadians = autoTickAnglesRadians.find(function (angle) {\n        return Math.abs(Math.cos(angle)) <= maxCos;\n      });\n      if (angleRadians === undefined) {\n        // no angle with smaller cosine than maxCos, just pick the angle with smallest cosine\n        angleRadians = autoTickAnglesRadians.reduce(function (currentMax, nextAngle) {\n          return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;\n        }, autoTickAnglesRadians[0]);\n      }\n      var newAngle = angleRadians * (180 / Math.PI /* to degrees */);\n      if (preventOverlapWithTick) {\n        var gap = 2;\n        if (ax.ticks) gap += ax.tickwidth / 2;\n        for (i = 0; i < lbbArray.length; i++) {\n          var xbnd = vals[i].xbnd;\n          var lbb = lbbArray[i];\n          if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {\n            autoangle = newAngle;\n            break;\n          }\n        }\n      } else {\n        var ticklabelposition = ax.ticklabelposition || '';\n        var has = function (str) {\n          return ticklabelposition.indexOf(str) !== -1;\n        };\n        var isTop = has('top');\n        var isLeft = has('left');\n        var isRight = has('right');\n        var isBottom = has('bottom');\n        var isAligned = isBottom || isLeft || isTop || isRight;\n        var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;\n        for (i = 0; i < lbbArray.length - 1; i++) {\n          if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n            autoangle = newAngle;\n            break;\n          }\n        }\n      }\n      if (autoangle) {\n        positionLabels(tickLabels, autoangle);\n      }\n    }\n  }\n  if (ax._selections) {\n    ax._selections[cls] = tickLabels;\n  }\n  var seq = [allLabelsReady];\n\n  // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n  // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n  // as this can lead to infinite redraw loops!\n  if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n    autoangle = prevAngle;\n    seq.push(function () {\n      positionLabels(tickLabels, prevAngle);\n    });\n  } else {\n    seq.push(fixLabelOverlaps);\n  }\n\n  // save current tick angle for future redraws\n  if (ax._tickAngles) {\n    seq.push(function () {\n      ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;\n    });\n  }\n  var computeTickLabelBoundingBoxes = function () {\n    var labelsMaxW = 0;\n    var labelsMaxH = 0;\n    tickLabels.each(function (d, i) {\n      var thisLabel = selectTickLabel(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      if (mathjaxGroup.empty()) {\n        var bb;\n        if (ax._vals[i]) {\n          bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());\n          ax._vals[i].bb = bb;\n        }\n        labelsMaxW = Math.max(labelsMaxW, bb.width);\n        labelsMaxH = Math.max(labelsMaxH, bb.height);\n      }\n    });\n    return {\n      labelsMaxW: labelsMaxW,\n      labelsMaxH: labelsMaxH\n    };\n  };\n  var anchorAx = ax._anchorAxis;\n  if (anchorAx && (anchorAx.autorange || anchorAx.insiderange) && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {\n    if (!fullLayout._insideTickLabelsUpdaterange) {\n      fullLayout._insideTickLabelsUpdaterange = {};\n    }\n    if (anchorAx.autorange) {\n      fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n      seq.push(computeTickLabelBoundingBoxes);\n    }\n    if (anchorAx.insiderange) {\n      var BBs = computeTickLabelBoundingBoxes();\n      var move = ax._id.charAt(0) === 'y' ? BBs.labelsMaxW : BBs.labelsMaxH;\n      move += 2 * TEXTPAD;\n      if (ax.ticklabelposition === 'inside') {\n        move += ax.ticklen || 0;\n      }\n      var sgn = ax.side === 'right' || ax.side === 'top' ? 1 : -1;\n      var index = sgn === 1 ? 1 : 0;\n      var otherIndex = sgn === 1 ? 0 : 1;\n      var newRange = [];\n      newRange[otherIndex] = anchorAx.range[otherIndex];\n      var anchorAxRange = anchorAx.range;\n      var p0 = anchorAx.r2p(anchorAxRange[index]);\n      var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);\n      var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'];\n      if (_tempNewRange) {\n        // case of having multiple anchored axes having insideticklabel\n        var q0 = anchorAx.r2p(_tempNewRange[index]);\n        var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);\n        var dir = sgn * (ax._id.charAt(0) === 'y' ? 1 : -1);\n        if (dir * p0 < dir * q0) {\n          p0 = q0;\n          newRange[index] = anchorAxRange[index] = _tempNewRange[index];\n        }\n        if (dir * p1 > dir * q1) {\n          p1 = q1;\n          newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];\n        }\n      }\n      var dist = Math.abs(p1 - p0);\n      if (dist - move > 0) {\n        dist -= move;\n        move *= 1 + move / dist;\n      } else {\n        move = 0;\n      }\n      if (ax._id.charAt(0) !== 'y') move = -move;\n      newRange[index] = anchorAx.p2r(anchorAx.r2p(anchorAxRange[index]) + sgn * move);\n\n      // handle partial ranges in insiderange\n      if (anchorAx.autorange === 'min' || anchorAx.autorange === 'max reversed') {\n        newRange[0] = null;\n        anchorAx._rangeInitial0 = undefined;\n        anchorAx._rangeInitial1 = undefined;\n      } else if (anchorAx.autorange === 'max' || anchorAx.autorange === 'min reversed') {\n        newRange[1] = null;\n        anchorAx._rangeInitial0 = undefined;\n        anchorAx._rangeInitial1 = undefined;\n      }\n      fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'] = newRange;\n    }\n  }\n  var done = Lib.syncOrAsync(seq);\n  if (done && done.then) gd._promises.push(done);\n  return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n  var cls = ax._id + 'divider';\n  var vals = opts.vals;\n  var dividers = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  dividers.exit().remove();\n  dividers.enter().insert('path', ':first-child').classed(cls, 1).classed('crisp', 1).call(Color.stroke, ax.dividercolor).style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n  dividers.attr('transform', opts.transFn).attr('d', opts.path);\n}\n\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\naxes.getPxPosition = function (gd, ax) {\n  var gs = gd._fullLayout._size;\n  var axLetter = ax._id.charAt(0);\n  var side = ax.side;\n  var anchorAxis;\n  if (ax.anchor !== 'free') {\n    anchorAxis = ax._anchorAxis;\n  } else if (axLetter === 'x') {\n    anchorAxis = {\n      _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n      _length: 0\n    };\n  } else if (axLetter === 'y') {\n    anchorAxis = {\n      _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,\n      _length: 0\n    };\n  }\n  if (side === 'top' || side === 'left') {\n    return anchorAxis._offset;\n  } else if (side === 'bottom' || side === 'right') {\n    return anchorAxis._offset + anchorAxis._length;\n  }\n};\n\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\nfunction approxTitleDepth(ax) {\n  var fontSize = ax.title.font.size;\n  var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n  if (ax.title.hasOwnProperty('standoff')) {\n    return fontSize * (CAP_SHIFT + extraLines * LINE_SPACING);\n  } else {\n    return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;\n  }\n}\n\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\nfunction drawTitle(gd, ax) {\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var fontSize = ax.title.font.size;\n  var titleStandoff;\n  var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n  if (ax.title.hasOwnProperty('standoff')) {\n    // With ax._depth the initial drawing baseline is at the outer axis border (where the\n    // ticklabels are drawn). Since the title text will be drawn above the baseline,\n    // bottom/right axes must be shifted by 1 text line to draw below ticklabels instead of on\n    // top of them, whereas for top/left axes, the first line would be drawn\n    // before the ticklabels, but we need an offset for the descender portion of the first line\n    // and all subsequent lines.\n    if (ax.side === 'bottom' || ax.side === 'right') {\n      titleStandoff = ax._depth + ax.title.standoff + fontSize * CAP_SHIFT;\n    } else if (ax.side === 'top' || ax.side === 'left') {\n      titleStandoff = ax._depth + ax.title.standoff + fontSize * (MID_SHIFT + extraLines * LINE_SPACING);\n    }\n  } else {\n    var isInside = insideTicklabelposition(ax);\n    if (ax.type === 'multicategory') {\n      titleStandoff = ax._depth;\n    } else {\n      var offsetBase = 1.5 * fontSize;\n      if (isInside) {\n        offsetBase = 0.5 * fontSize;\n        if (ax.ticks === 'outside') {\n          offsetBase += ax.ticklen;\n        }\n      }\n      titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n    }\n    if (!isInside) {\n      if (axLetter === 'x') {\n        titleStandoff += ax.side === 'top' ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);\n      } else {\n        titleStandoff += ax.side === 'right' ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);\n      }\n    }\n  }\n  var pos = axes.getPxPosition(gd, ax);\n  var transform, x, y;\n  if (axLetter === 'x') {\n    x = ax._offset + ax._length / 2;\n    y = ax.side === 'top' ? pos - titleStandoff : pos + titleStandoff;\n  } else {\n    y = ax._offset + ax._length / 2;\n    x = ax.side === 'right' ? pos + titleStandoff : pos - titleStandoff;\n    transform = {\n      rotate: '-90',\n      offset: 0\n    };\n  }\n  var avoid;\n  if (ax.type !== 'multicategory') {\n    var tickLabels = ax._selections[ax._id + 'tick'];\n    avoid = {\n      selection: tickLabels,\n      side: ax.side\n    };\n    if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n      var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n      avoid.offsetLeft = translation.x;\n      avoid.offsetTop = translation.y;\n    }\n    if (ax.title.hasOwnProperty('standoff')) {\n      avoid.pad = 0;\n    }\n  }\n  ax._titleStandoff = titleStandoff;\n  return Titles.draw(gd, axId + 'title', {\n    propContainer: ax,\n    propName: ax._name + '.title.text',\n    placeholder: fullLayout._dfltTitle[axLetter],\n    avoid: avoid,\n    transform: transform,\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    }\n  });\n}\naxes.shouldShowZeroLine = function (gd, ax, counterAxis) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === 'linear' || ax.type === '-') && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));\n};\naxes.clipEnds = function (ax, vals) {\n  return vals.filter(function (d) {\n    return clipEnds(ax, d.x);\n  });\n};\nfunction clipEnds(ax, l) {\n  var p = ax.l2p(l);\n  return p > 1 && p < ax._length - 1;\n}\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n  var mainCounterAxis = counterAxis._mainAxis;\n  if (!mainCounterAxis) return;\n  var fullLayout = gd._fullLayout;\n  var axLetter = ax._id.charAt(0);\n  var counterLetter = axes.counterLetter(ax._id);\n  var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === 'x') ? 0 : ax._length);\n  function lineNearZero(ax2) {\n    if (!ax2.showline || !ax2.linewidth) return false;\n    var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n    function closeEnough(pos2) {\n      return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n    }\n    if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n      return true;\n    }\n    var linePositions = ax2._linepositions || {};\n    for (var k in linePositions) {\n      if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n        return true;\n      }\n    }\n  }\n  var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n  if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n    return lineNearZero(counterAxis, zeroPosition);\n  }\n  var counterLetterAxes = axes.list(gd, counterLetter);\n  for (var i = 0; i < counterLetterAxes.length; i++) {\n    var counterAxis2 = counterLetterAxes[i];\n    if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {\n      return true;\n    }\n  }\n}\nfunction hasBarsOrFill(gd, ax) {\n  var fullData = gd._fullData;\n  var subplot = ax._mainSubplot;\n  var axLetter = ax._id.charAt(0);\n  for (var i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {\n      if (Registry.traceIs(trace, 'bar-like') && trace.orientation === {\n        x: 'h',\n        y: 'v'\n      }[axLetter]) return true;\n      if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;\n    }\n  }\n  return false;\n}\nfunction selectTickLabel(gTick) {\n  var s = d3.select(gTick);\n  var mj = s.select('.text-math-group');\n  return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function (gd) {\n  var axList = axes.list(gd, '', true);\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    if (ax.automargin) {\n      Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n      if (ax.mirror) {\n        Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n      }\n    }\n    if (Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n      Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n    }\n  }\n};\nfunction axAutoMarginID(ax) {\n  return ax._id + '.automargin';\n}\nfunction axMirrorAutoMarginID(ax) {\n  return axAutoMarginID(ax) + '.mirror';\n}\nfunction rangeSliderAutoMarginID(ax) {\n  return ax._id + '.rangeslider';\n}\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function (gd, traces) {\n  var axGroups = makeAxisGroups(gd, traces);\n  for (var i = 0; i < axGroups.length; i++) {\n    swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n  }\n};\nfunction makeAxisGroups(gd, traces) {\n  var groups = [];\n  var i, j;\n  for (i = 0; i < traces.length; i++) {\n    var groupsi = [];\n    var xi = gd._fullData[traces[i]].xaxis;\n    var yi = gd._fullData[traces[i]].yaxis;\n    if (!xi || !yi) continue; // not a 2D cartesian trace?\n\n    for (j = 0; j < groups.length; j++) {\n      if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n        groupsi.push(j);\n      }\n    }\n    if (!groupsi.length) {\n      groups.push({\n        x: [xi],\n        y: [yi]\n      });\n      continue;\n    }\n    var group0 = groups[groupsi[0]];\n    var groupj;\n    if (groupsi.length > 1) {\n      for (j = 1; j < groupsi.length; j++) {\n        groupj = groups[groupsi[j]];\n        mergeAxisGroups(group0.x, groupj.x);\n        mergeAxisGroups(group0.y, groupj.y);\n      }\n    }\n    mergeAxisGroups(group0.x, [xi]);\n    mergeAxisGroups(group0.y, [yi]);\n  }\n  return groups;\n}\nfunction mergeAxisGroups(intoSet, fromSet) {\n  for (var i = 0; i < fromSet.length; i++) {\n    if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n  }\n}\nfunction swapAxisGroup(gd, xIds, yIds) {\n  var xFullAxes = [];\n  var yFullAxes = [];\n  var layout = gd.layout;\n  var i, j;\n  for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n  for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n  var allAxKeys = Object.keys(axAttrs);\n  var noSwapAttrs = ['anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'];\n  var numericTypes = ['linear', 'log'];\n  for (i = 0; i < allAxKeys.length; i++) {\n    var keyi = allAxKeys[i];\n    var xVal = xFullAxes[0][keyi];\n    var yVal = yFullAxes[0][keyi];\n    var allEqual = true;\n    var coerceLinearX = false;\n    var coerceLinearY = false;\n    if (keyi.charAt(0) === '_' || typeof xVal === 'function' || noSwapAttrs.indexOf(keyi) !== -1) {\n      continue;\n    }\n    for (j = 1; j < xFullAxes.length && allEqual; j++) {\n      var xVali = xFullAxes[j][keyi];\n      if (keyi === 'type' && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearX = true;\n      } else if (xVali !== xVal) allEqual = false;\n    }\n    for (j = 1; j < yFullAxes.length && allEqual; j++) {\n      var yVali = yFullAxes[j][keyi];\n      if (keyi === 'type' && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearY = true;\n      } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;\n    }\n    if (allEqual) {\n      if (coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n      if (coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n      swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n    }\n  }\n\n  // now swap x&y for any annotations anchored to these x & y\n  for (i = 0; i < gd._fullLayout.annotations.length; i++) {\n    var ann = gd._fullLayout.annotations[i];\n    if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {\n      Lib.swapAttrs(layout.annotations[i], ['?']);\n    }\n  }\n}\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n  // in case the value is the default for either axis,\n  // look at the first axis in each list and see if\n  // this key's value is undefined\n  var np = Lib.nestedProperty;\n  var xVal = np(layout[xFullAxes[0]._name], key).get();\n  var yVal = np(layout[yFullAxes[0]._name], key).get();\n  var i;\n  if (key === 'title') {\n    // special handling of placeholder titles\n    if (xVal && xVal.text === dfltTitle.x) {\n      xVal.text = dfltTitle.y;\n    }\n    if (yVal && yVal.text === dfltTitle.y) {\n      yVal.text = dfltTitle.x;\n    }\n  }\n  for (i = 0; i < xFullAxes.length; i++) {\n    np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n  }\n  for (i = 0; i < yFullAxes.length; i++) {\n    np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n  }\n}\nfunction isAngular(ax) {\n  return ax._id === 'angularaxis';\n}\nfunction moveOutsideBreak(v, ax) {\n  var len = ax._rangebreaks.length;\n  for (var k = 0; k < len; k++) {\n    var brk = ax._rangebreaks[k];\n    if (v >= brk.min && v < brk.max) {\n      return brk.max;\n    }\n  }\n  return v;\n}\nfunction insideTicklabelposition(ax) {\n  return (ax.ticklabelposition || '').indexOf('inside') !== -1;\n}\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n  if (insideTicklabelposition(ax._anchorAxis || {})) {\n    if (ax._hideCounterAxisInsideTickLabels) {\n      ax._hideCounterAxisInsideTickLabels(opts);\n    }\n  }\n}\nfunction incrementShift(ax, shiftVal, axShifts, normalize) {\n  // Need to set 'overlay' for anchored axis\n  var overlay = ax.anchor !== 'free' && (ax.overlaying === undefined || ax.overlaying === false) ? ax._id : ax.overlaying;\n  var shiftValAdj;\n  if (normalize) {\n    shiftValAdj = ax.side === 'right' ? shiftVal : -shiftVal;\n  } else {\n    shiftValAdj = shiftVal;\n  }\n  if (!(overlay in axShifts)) {\n    axShifts[overlay] = {};\n  }\n  if (!(ax.side in axShifts[overlay])) {\n    axShifts[overlay][ax.side] = 0;\n  }\n  axShifts[overlay][ax.side] += shiftValAdj;\n}\nfunction setShiftVal(ax, axShifts) {\n  return ax.autoshift ? axShifts[ax.overlaying][ax.side] : ax.shift || 0;\n}\n\n/**\n * Checks if the given period is at least the period described by the tickformat or larger. If that\n * is the case, they are compatible, because then the tickformat can be used to describe the period.\n * E.g. it doesn't make sense to put a year label on a period spanning only a month.\n * @param {number} period in ms\n * @param {string} tickformat\n * @returns {boolean}\n */\nfunction periodCompatibleWithTickformat(period, tickformat) {\n  return /%f/.test(tickformat) ? period >= ONEMICROSEC : /%L/.test(tickformat) ? period >= ONEMILLI : /%[SX]/.test(tickformat) ? period >= ONESEC : /%M/.test(tickformat) ? period >= ONEMIN : /%[HI]/.test(tickformat) ? period >= ONEHOUR : /%p/.test(tickformat) ? period >= HALFDAY : /%[Aadejuwx]/.test(tickformat) ? period >= ONEDAY : /%[UVW]/.test(tickformat) ? period >= ONEWEEK : /%[Bbm]/.test(tickformat) ? period >= ONEMINMONTH : /%[q]/.test(tickformat) ? period >= ONEMINQUARTER : /%[Yy]/.test(tickformat) ? period >= ONEMINYEAR : true;\n}","map":{"version":3,"names":["d3","require","isNumeric","Plots","Registry","Lib","strTranslate","svgTextUtils","Titles","Color","Drawing","axAttrs","cleanTicks","constants","ONEMAXYEAR","ONEAVGYEAR","ONEMINYEAR","ONEMAXQUARTER","ONEAVGQUARTER","ONEMINQUARTER","ONEMAXMONTH","ONEAVGMONTH","ONEMINMONTH","ONEWEEK","ONEDAY","HALFDAY","ONEHOUR","ONEMIN","ONESEC","ONEMILLI","ONEMICROSEC","MINUS_SIGN","BADNUM","ZERO_PATH","K","GRID_PATH","L","MINORGRID_PATH","TICK_PATH","TICK_TEXT","MARGIN_MAPPING","width","height","right","left","top","bottom","alignmentConstants","MID_SHIFT","CAP_SHIFT","LINE_SPACING","OPPOSITE_SIDE","TEXTPAD","axes","module","exports","setConvert","autoType","axisIds","idSort","isLinked","id2name","name2id","cleanId","list","listIds","getFromId","getFromTrace","autorange","getAutoRange","findExtremes","epsilon","expandRange","range","delta","coerceRef","containerIn","containerOut","gd","attr","dflt","extraOption","axLetter","charAt","length","axlist","_fullLayout","_subplots","refAttr","attrDef","concat","map","x","valType","values","coerce","getRefType","ar","undefined","test","coercePosition","axRef","cleanPos","pos","axRefType","ensureNumber","ax","fraction2r","cleanPosition","redrawComponents","axIds","fullLayout","_redrawOneComp","moduleName","methodName","stashName","shortCircuit","method","getComponentMethod","stash","i","indices","j","ind","getDataConversions","trace","target","targetArray","d2cTarget","isArrayOrTypedArray","type","autotypenumbers","_categories","d2c","c2d","toString","toNum","v","String","getDataToCoordFunc","counterLetter","id","minDtick","newDiff","newFirst","allow","indexOf","_minDtick","_forceTick0","saveRangeInitial","overwrite","axList","hasOneAxisChanged","isNew","_rangeInitial0","_rangeInitial1","hasChanged","_autorangeInitial","saveShowSpikeInitial","allSpikesEnabled","_showSpikeInitial","showspikes","_showspikes","_cartesianSpikesEnabled","autoBin","data","nbins","is2d","calendar","size","dataMin","aggNums","Math","min","dataMax","max","start","end","round","_dataSpan","dummyAx","simpleMap","c2r","dtick","tick0","size0","distinctData","distinctVals","msexp","pow","floor","log","minDiff","LN10","minSize","roundUp","stdev","autoTicks","finalSize","binStart","tickIncrement","tickFirst","binEnd","bincount","autoShiftNumericBins","autoShiftMonthBins","edgecount","midcount","intcount","blankCount","nearEdge","dataCount","binshift","stats","findExactDates","threshold","exactDays","numMonths","Number","substr","exactYears","exactMonths","nextBinStart","prepMinorTicks","mockAx","opts","minor","hasMajor","_tmin","mockMinorRange","tick2","rl","r2l","l2r","_isMinor","prepTicks","numericMajor","numericMinor","majorNum","substring","minorNum","isMultiple","_input","nticks","isClose","_tick0Init","bigger","smaller","abs","a","b","rng","tickmode","nt","minPx","tickfont","bigFont","_length","_id","constrain","_name","_roughDTick","ticklabelmode","adjustPeriodDelta","autoTickRound","nMonths","definedDelta","mDate","isMDate","tickformat","getTickFormat","noDtick","_dtickInit","_dowTick0","_rawTick0","_definedDelta","positionPeriodTicks","tickVals","value","A","B","actualDelta","periodLength","inBetween","endPeriod","rangebreaks","nAll","n","c","r","maskBreaks","drop","periodX","calcTicks","ticklabelstep","isPeriod","isReversed","ticklabelIndex","ticklabelindex","axrev","minRange","maxRange","maxTicks","ticksOut","minorTicks","minorTickVals","allTicklabelVals","hasMinor","ticks","showgrid","major","isMinor","extendFlat","arrayTicks","syncTicks","exRng","startTick","endTick","numDtick","isDLog","x0","prevX","majorId","_dTick","moveOutsideBreak","obj","simpleLabel","skipLabel","push","diff","periodCompatibleWithTickformat","allTickVals","slice","sort","filter","tick","index","self","majorTickIndices","item","forEach","majorIdx","nextLabelIdx","minorIdx","pushUnique","canOverlap","majorValues","d","k","T","found","q","flip","fontSize","prevL","NaN","splice","l","c2p","isAngular","pop","_tmax","_prevDateHead","_inCalcTicks","lastVisibleHead","hideLabel","text","setTickLabel","tickVal","tickText","p","t","_minor","_value","noTick","filterRangeBreaks","baseAxis","_mainAxis","_vals","l2p","vali","p2l","majorOnly","tickMin","tickMax","tickVal2l","d2l_noadd","d2l","vals","tickvals","ticktext","roundBase10","roundBase24","roundBase60","roundDays","roundLog1","roundLog2","roundAngles","roundDTick","roughDTick","base","roundingSet","getBase","dateTick0","roughX2","_hasDayOfWeekBreaks","ceil","olddtick","_tickexponent","_tickround","tick0ms","tick0str","replace","tick0len","tick1len","r2d","maxend","rangeexp","minexponent","isSIFormat","exponentformat","beyondSI","axSign","increment","tType","dtSigned","incrementMonth","tickset","x2","frac","mod","sRound","r0","tmin","dtNum","cnt","t0","t1","mult","newDTick","error","hover","noSuffixPrefix","out","tickTextObj","arrayMode","extraPrecision","axType","inbounds","_lBreaks","xbnd","isHidden","showAttr","firstOrLast","first","last","hideexp","showexponent","formatDate","formatLog","formatCategory","formatMultiCategory","formatAngle","formatLinear","tickprefix","showtickprefix","ticksuffix","showticksuffix","labelalias","hasOwnProperty","tickson","showdividers","hoverLabelText","hoverformat","val","val2","logOffScale","tx","c2l","tf","dx","dy","font","family","fontWeight","weight","fontStyle","style","fontVariant","variant","fontTextcase","textcase","fontLineposition","lineposition","fontShadow","shadow","fontColor","color","tr","fmt","y","m","M","S","dateStr","_dateFormat","_extraFormat","headStr","splitIndex","isInside","insideTicklabelposition","side","_trueSide","dtChar0","numFormat","absP","exponentFormat","firstChar","tt","cats","tt2","text2","thetaunit","num","num2frac","deg2rad","isNeg","join","almostEq","findGCD","findPrecision","e","precision","number","gcd","SIPREFIXES","exponent","fmtoverride","tickRound","separatethousands","ah","_numFormat","dp","numSeparate","_separators","signedExponent","convertToMs","compareLogTicks","priority","leftPriority","rightPriority","isProperStop","convert","convertFn","leftDtick","rightDtick","isProperLogStop","isLeftDtickNull","isRightDtickNull","isDtickInRangeLeft","isDtickInRangeRight","tickstop","stopi","tickformatstops","enabled","dtickrange","getSubplots","subplotObj","allSubplots","cartesian","gl2d","findSubplotsWithAxis","aParts","split","bParts","subplots","axMatch","RegExp","subplotsWithAx","sp","makeClipPaths","_hasOnlyLargeSploms","fullWidth","_offset","fullHeight","xaList","yaList","clipList","axClips","_clips","selectAll","enter","append","classed","_uid","exit","remove","each","select","draw","arg","_paper","plotinfo","_plots","xa","xaxis","ya","yaxis","xaxislayer","yaxislayer","minorGridlayer","gridlayer","zerolinelayer","_infolayer","fullAxList","overlayingShiftedAx","autoshift","overlaying","axId","overlayingIndex","findIndex","axis","unshift","shift","axShifts","false","syncOrAsync","axDone","drawOne","_shiftPusher","incrementShift","_fullDepth","_r","_rl","setScale","mainPlotinfo","_mainSubplot","anchor","selfPush","linewidth","ticklen","skipTitle","_shift","setShiftVal","mainAxLayer","mainLinePosition","_mainLinePosition","mainLinePositionShift","mainMirrorPosition","_mainMirrorPosition","axInfo","mirror","_selections","_tickAngles","_prevTickAngles","_depth","llbboxes","getLabelLevelBbox","suffix","cls","calcLabelLevelBbox","visible","transTickFn","makeTransTickFn","transTickLabelFn","makeTransTickLabelFn","valsClipped","insideTicks","outsideTicks","boundaryVals","getBoundaryVals","clipEnds","gridVals","_gridVals","dividerVals","getDividerVals","_subplotsWith","finishedGrids","counterAxis","mainCounterID","gridPath","drawGrid","layer","minorLayer","path","transFn","drawZeroLine","tickPath","majorTickSigns","getTickSigns","minorTickSigns","majorTickPath","makeTickPath","minorTickPath","mirrorMajorTickPath","mirrorMinorTickPath","fullMajorTickPath","fullMinorTickPath","_anchorAxis","dividerLookup","drawTicks","tickSubplots","Object","keys","_linepositions","linepositions","p0","p1","spTickPath","seq","drawLabels","labelFns","makeLabelFns","pad","bboxKey","standoff","getSecondaryLabelVals","repositionOnUpdate","secondary","drawDividers","len","title","hasRangeSlider","drawTitle","s","sMirror","getPxPosition","outsideTickLen","llbbox","mirrorPush","rangeSliderPush","automargin","axDepth","titleDepth","_dfltTitle","_titleStandoff","_titleScoot","approxTitleDepth","domainIndices","reverse","rExtra","xr","lExtra","xl","bExtra","yb","tExtra","yt","position","domain","_counterDomainMin","_counterDomainMax","filterPush","autoMargin","axAutoMarginID","axMirrorAutoMarginID","rangeSliderAutoMarginID","keepMargin","reduce","nextKey","key","_push","bndIndex","xb","lookup","interp","current","reversed","Infinity","thisLabel","selectTickLabel","bb","bBox","node","parentNode","dummyCalc","yFn","xFn","sideOpposite","main","uv","getTickLabelUV","ticklabelshift","ticklabelstandoff","u","labelsInside","ticklabelposition","labelsOutside","shiftSign","standoffSign","getPosX","has","str","isTop","isLeft","isRight","isBottom","isAligned","tickwidth","sgn","angle","insideTickLabels","labelsOverTicks","labelStandoff","labelShift","tickLen","rad","cos","sin","showticklabels","showline","y0","ff","flipIt","xQ","tickangle","endSide","anchorFn","heightFn","h","ang","rA","tickDataFn","crisp","stroke","tickcolor","crispRound","hideCounterAxisInsideTickLabels","minorVals","majorVals","counterAx","shouldShowZeroLine","isArrayMode","xi","_gw","gridwidth","wMinor","majorLayer","grid","gridcolor","dashStyle","griddash","show","zl","da","db","call","zerolinecolor","defaultLine","zerolinewidth","tickAngle","prevAngle","tickLabels","labelsReady","newPromise","_promises","positionText","convertToTspans","then","positionLabels","mathjaxGroup","transform","nLines","lineCount","lineHeight","anchorHeight","empty","thisText","_adjustTickLabelsOverflow","mjWidth","mjShift","ticklabeloverflow","hideOverflow","isX","visibleLabelMin","visibleLabelMax","adjust","subplot","anchorAx","_hideCounterAxisInsideTickLabels","partialOpts","anchoredAxes","idx","isPeriodLabel","sel","w","allLabelsReady","Promise","all","autoangle","fixLabelOverlaps","autotickangles","maxFontSize","lbbArray","maxLines","preventOverlapWithTick","vLen","tickSpacing","_m","adjacent","opposite","hypotenuse","sqrt","maxCos","autoTickAnglesRadians","degrees","PI","angleRadians","find","currentMax","nextAngle","newAngle","gap","lbb","bBoxIntersect","_redrawFromAutoMarginCount","computeTickLabelBoundingBoxes","labelsMaxW","labelsMaxH","insiderange","_insideTickLabelsUpdaterange","BBs","move","otherIndex","newRange","anchorAxRange","r2p","_tempNewRange","q0","q1","dir","dist","p2r","done","dividers","insert","dividercolor","dividerwidth","gs","_size","anchorAxis","extraLines","match","BR_TAG_ALL","titleStandoff","offsetBase","rotate","offset","avoid","selection","translation","getTranslate","offsetLeft","offsetTop","propContainer","propName","placeholder","attributes","zeroline","anyCounterAxLineAtZero","hasBarsOrFill","mainCounterAxis","zeroPosition","lineNearZero","ax2","tolerance","closeEnough","pos2","linePositions","mainplotinfo","overlays","counterLetterAxes","counterAxis2","fullData","_fullData","traceIs","orientation","fill","gTick","mj","allowAutoMargin","swap","traces","axGroups","makeAxisGroups","swapAxisGroup","groups","groupsi","yi","group0","groupj","mergeAxisGroups","intoSet","fromSet","xIds","yIds","xFullAxes","yFullAxes","layout","allAxKeys","noSwapAttrs","numericTypes","keyi","xVal","yVal","allEqual","coerceLinearX","coerceLinearY","xVali","yVali","swapAxisAttrs","annotations","ann","xref","yref","swapAttrs","dfltTitle","np","nestedProperty","get","set","_rangebreaks","brk","shiftVal","normalize","overlay","shiftValAdj","period"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/cartesian/axes.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\n\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\n\nvar constants = require('../../constants/numerical');\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar ONEMILLI = constants.ONEMILLI;\nvar ONEMICROSEC = constants.ONEMICROSEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\n\nvar ZERO_PATH = { K: 'zeroline' };\nvar GRID_PATH = { K: 'gridline', L: 'path' };\nvar MINORGRID_PATH = { K: 'minor-gridline', L: 'path' };\nvar TICK_PATH = { K: 'tick', L: 'path' };\nvar TICK_TEXT = { K: 'tick', L: 'text' };\nvar MARGIN_MAPPING = {\n    width: ['x', 'r', 'l', 'xl', 'xr'],\n    height: ['y', 't', 'b', 'yt', 'yb'],\n    right: ['r', 'xr'],\n    left: ['l', 'xl'],\n    top: ['t', 'yt'],\n    bottom: ['b', 'yb']\n};\n\nvar alignmentConstants = require('../../constants/alignment');\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\n\nvar TEXTPAD = 3;\n\nvar axes = module.exports = {};\n\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\n\nvar axisIds = require('./axis_ids');\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked;\n\n// tight coupling to chart studio\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\n\nvar epsilon = 0.0001;\nfunction expandRange(range) {\n    var delta = (range[1] - range[0]) * epsilon;\n    return [\n        range[0] - delta,\n        range[1] + delta\n    ];\n}\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {\n    var axLetter = attr.charAt(attr.length - 1);\n    var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n    var refAttr = attr + 'ref';\n    var attrDef = {};\n\n    if(!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n    if(!extraOption) extraOption = dflt;\n    axlist = axlist.concat(axlist.map(function(x) { return x + ' domain'; }));\n\n    // data-ref annotations are not supported in gl2d yet\n\n    attrDef[refAttr] = {\n        valType: 'enumerated',\n        values: axlist.concat(extraOption ?\n            (typeof extraOption === 'string' ? [extraOption] : extraOption) :\n            []),\n        dflt: dflt\n    };\n\n    // xref, yref\n    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\naxes.getRefType = function(ar) {\n    if(ar === undefined) { return ar; }\n    if(ar === 'paper') { return 'paper'; }\n    if(ar === 'pixel') { return 'pixel'; }\n    if(/( domain)$/.test(ar)) { return 'domain'; } else { return 'range'; }\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {\n    var cleanPos, pos;\n    var axRefType = axes.getRefType(axRef);\n    if(axRefType !== 'range') {\n        cleanPos = Lib.ensureNumber;\n        pos = coerce(attr, dflt);\n    } else {\n        var ax = axes.getFromId(gd, axRef);\n        dflt = ax.fraction2r(dflt);\n        pos = coerce(attr, dflt);\n        cleanPos = ax.cleanPos;\n    }\n    containerOut[attr] = cleanPos(pos);\n};\n\naxes.cleanPosition = function(pos, gd, axRef) {\n    var cleanPos = (axRef === 'paper' || axRef === 'pixel') ?\n        Lib.ensureNumber :\n        axes.getFromId(gd, axRef).cleanPos;\n\n    return cleanPos(pos);\n};\n\naxes.redrawComponents = function(gd, axIds) {\n    axIds = axIds ? axIds : axes.listIds(gd);\n\n    var fullLayout = gd._fullLayout;\n\n    function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n        var method = Registry.getComponentMethod(moduleName, methodName);\n        var stash = {};\n\n        for(var i = 0; i < axIds.length; i++) {\n            var ax = fullLayout[axes.id2name(axIds[i])];\n            var indices = ax[stashName];\n\n            for(var j = 0; j < indices.length; j++) {\n                var ind = indices[j];\n\n                if(!stash[ind]) {\n                    method(gd, ind);\n                    stash[ind] = 1;\n                    // once is enough for images (which doesn't use the `i` arg anyway)\n                    if(shortCircuit) return;\n                }\n            }\n        }\n    }\n\n    // annotations and shapes 'draw' method is slow,\n    // use the finer-grained 'drawOne' method instead\n    _redrawOneComp('annotations', 'drawOne', '_annIndices');\n    _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n    _redrawOneComp('images', 'draw', '_imgIndices', true);\n    _redrawOneComp('selections', 'drawOne', '_selectionIndices');\n};\n\nvar getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {\n    var ax;\n\n    // If target points to an axis, use the type we already have for that\n    // axis to find the data type. Otherwise use the values to autotype.\n    var d2cTarget = (target === 'x' || target === 'y' || target === 'z') ?\n        target :\n        targetArray;\n\n    // In the case of an array target, make a mock data array\n    // and call supplyDefaults to the data type and\n    // setup the data-to-calc method.\n    if(Lib.isArrayOrTypedArray(d2cTarget)) {\n        ax = {\n            type: autoType(targetArray, undefined, {\n                autotypenumbers: gd._fullLayout.autotypenumbers\n            }),\n            _categories: []\n        };\n        axes.setConvert(ax);\n\n        // build up ax._categories (usually done during ax.makeCalcdata()\n        if(ax.type === 'category') {\n            for(var i = 0; i < targetArray.length; i++) {\n                ax.d2c(targetArray[i]);\n            }\n        }\n        // TODO what to do for transforms?\n    } else {\n        ax = axes.getFromTrace(gd, trace, d2cTarget);\n    }\n\n    // if 'target' has corresponding axis\n    // -> use setConvert method\n    if(ax) return {d2c: ax.d2c, c2d: ax.c2d};\n\n    // special case for 'ids'\n    // -> cast to String\n    if(d2cTarget === 'ids') return {d2c: toString, c2d: toString};\n\n    // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n    // -> cast to Number\n\n    return {d2c: toNum, c2d: toNum};\n};\n\nfunction toNum(v) { return +v; }\nfunction toString(v) { return String(v); }\n\naxes.getDataToCoordFunc = function(gd, trace, target, targetArray) {\n    return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function(id) {\n    var axLetter = id.charAt(0);\n    if(axLetter === 'x') return 'y';\n    if(axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function(ax, newDiff, newFirst, allow) {\n    // doesn't make sense to do forced min dTick on log or category axes,\n    // and the plot itself may decide to cancel (ie non-grouped bars)\n    if(['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n        ax._minDtick = 0;\n    } else if(ax._minDtick === undefined) {\n        // undefined means there's nothing there yet\n\n        ax._minDtick = newDiff;\n        ax._forceTick0 = newFirst;\n    } else if(ax._minDtick) {\n        if((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n            // existing minDtick is an integer multiple of newDiff\n            // (within rounding err)\n            // and forceTick0 can be shifted to newFirst\n\n                (((newFirst - ax._forceTick0) / newDiff % 1) +\n                    1.000001) % 1 < 2e-6) {\n            ax._minDtick = newDiff;\n            ax._forceTick0 = newFirst;\n        } else if((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n            // if the converse is true (newDiff is a multiple of minDtick and\n            // newFirst can be shifted to forceTick0) then do nothing - same\n            // forcing stands. Otherwise, cancel forced minimum\n\n                (((newFirst - ax._forceTick0) / ax._minDtick % 1) +\n                    1.000001) % 1 > 2e-6) {\n            ax._minDtick = 0;\n        }\n    }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew =\n            ax._rangeInitial0 === undefined &&\n            ax._rangeInitial1 === undefined;\n\n        var hasChanged = isNew || (\n            ax.range[0] !== ax._rangeInitial0 ||\n            ax.range[1] !== ax._rangeInitial1\n        );\n\n        var autorange = ax.autorange;\n        if((isNew && autorange !== true) || (overwrite && hasChanged)) {\n            ax._rangeInitial0 = (autorange === 'min' || autorange === 'max reversed') ? undefined : ax.range[0];\n            ax._rangeInitial1 = (autorange === 'max' || autorange === 'min reversed') ? undefined : ax.range[1];\n            ax._autorangeInitial = autorange;\n            hasOneAxisChanged = true;\n        }\n    }\n\n    return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n    var allSpikesEnabled = 'on';\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew = (ax._showSpikeInitial === undefined);\n        var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n\n        if(isNew || (overwrite && hasChanged)) {\n            ax._showSpikeInitial = ax.showspikes;\n            hasOneAxisChanged = true;\n        }\n\n        if(allSpikesEnabled === 'on' && !ax.showspikes) {\n            allSpikesEnabled = 'off';\n        }\n    }\n    gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n    return hasOneAxisChanged;\n};\n\naxes.autoBin = function(data, ax, nbins, is2d, calendar, size) {\n    var dataMin = Lib.aggNums(Math.min, null, data);\n    var dataMax = Lib.aggNums(Math.max, null, data);\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        return {\n            start: dataMin - 0.5,\n            end: dataMax + 0.5,\n            size: Math.max(1, Math.round(size) || 1),\n            _dataSpan: dataMax - dataMin,\n        };\n    }\n\n    if(!calendar) calendar = ax.calendar;\n\n    // piggyback off tick code to make \"nice\" bin sizes and edges\n    var dummyAx;\n    if(ax.type === 'log') {\n        dummyAx = {\n            type: 'linear',\n            range: [dataMin, dataMax]\n        };\n    } else {\n        dummyAx = {\n            type: ax.type,\n            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n            calendar: calendar\n        };\n    }\n    axes.setConvert(dummyAx);\n\n    size = size && cleanTicks.dtick(size, dummyAx.type);\n\n    if(size) {\n        dummyAx.dtick = size;\n        dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n    } else {\n        var size0;\n        if(nbins) size0 = ((dataMax - dataMin) / nbins);\n        else {\n            // totally auto: scale off std deviation so the highest bin is\n            // somewhat taller than the total number of bins, but don't let\n            // the size get smaller than the 'nice' rounded down minimum\n            // difference between values\n            var distinctData = Lib.distinctVals(data);\n            var msexp = Math.pow(10, Math.floor(\n                Math.log(distinctData.minDiff) / Math.LN10));\n            var minSize = msexp * Lib.roundUp(\n                distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n            size0 = Math.max(minSize, 2 * Lib.stdev(data) /\n                Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n            // fallback if ax.d2c output BADNUMs\n            // e.g. when user try to plot categorical bins\n            // on a layout.xaxis.type: 'linear'\n            if(!isNumeric(size0)) size0 = 1;\n        }\n\n        axes.autoTicks(dummyAx, size0);\n    }\n\n    var finalSize = dummyAx.dtick;\n    var binStart = axes.tickIncrement(\n            axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n    var binEnd, bincount;\n\n    // check for too many data points right at the edges of bins\n    // (>50% within 1% of bin edges) or all data points integral\n    // and offset the bins accordingly\n    if(typeof finalSize === 'number') {\n        binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n\n        bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n        binEnd = binStart + bincount * finalSize;\n    } else {\n        // month ticks - should be the only nonlinear kind we have at this point.\n        // dtick (as supplied by axes.autoTick) only has nonlinear values on\n        // date and log axes, but even if you display a histogram on a log axis\n        // we bin it on a linear axis (which one could argue against, but that's\n        // a separate issue)\n        if(dummyAx.dtick.charAt(0) === 'M') {\n            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n        }\n\n        // calculate the endpoint for nonlinear ticks - you have to\n        // just increment until you're done\n        binEnd = binStart;\n        bincount = 0;\n        while(binEnd <= dataMax) {\n            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n            bincount++;\n        }\n    }\n\n    return {\n        start: ax.c2r(binStart, 0, calendar),\n        end: ax.c2r(binEnd, 0, calendar),\n        size: finalSize,\n        _dataSpan: dataMax - dataMin\n    };\n};\n\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n    var edgecount = 0;\n    var midcount = 0;\n    var intcount = 0;\n    var blankCount = 0;\n\n    function nearEdge(v) {\n        // is a value within 1% of a bin edge?\n        return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        if(data[i] % 1 === 0) intcount++;\n        else if(!isNumeric(data[i])) blankCount++;\n\n        if(nearEdge(data[i])) edgecount++;\n        if(nearEdge(data[i] + ax.dtick / 2)) midcount++;\n    }\n    var dataCount = data.length - blankCount;\n\n    if(intcount === dataCount && ax.type !== 'date') {\n        if(ax.dtick < 1) {\n            // all integers: if bin size is <1, it's because\n            // that was specifically requested (large nbins)\n            // so respect that... but center the bins containing\n            // integers on those integers\n\n            binStart = dataMin - 0.5 * ax.dtick;\n        } else {\n            // otherwise start half an integer down regardless of\n            // the bin size, just enough to clear up endpoint\n            // ambiguity about which integers are in which bins.\n\n            binStart -= 0.5;\n            if(binStart + ax.dtick < dataMin) binStart += ax.dtick;\n        }\n    } else if(midcount < dataCount * 0.1) {\n        if(edgecount > dataCount * 0.3 ||\n                nearEdge(dataMin) || nearEdge(dataMax)) {\n            // lots of points at the edge, not many in the middle\n            // shift half a bin\n            var binshift = ax.dtick / 2;\n            binStart += (binStart + binshift < dataMin) ? binshift : -binshift;\n        }\n    }\n    return binStart;\n}\n\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n    var stats = Lib.findExactDates(data, calendar);\n    // number of data points that needs to be an exact value\n    // to shift that increment to (near) the bin center\n    var threshold = 0.8;\n\n    if(stats.exactDays > threshold) {\n        var numMonths = Number(dtick.substr(1));\n\n        if((stats.exactYears > threshold) && (numMonths % 12 === 0)) {\n            // The exact middle of a non-leap-year is 1.5 days into July\n            // so if we start the bins here, all but leap years will\n            // get hover-labeled as exact years.\n            binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n        } else if(stats.exactMonths > threshold) {\n            // Months are not as clean, but if we shift half the *longest*\n            // month (31/2 days) then 31-day months will get labeled exactly\n            // and shorter months will get labeled with the correct month\n            // but shifted 12-36 hours into it.\n            binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n        } else {\n            // Shifting half a day is exact, but since these are month bins it\n            // will always give a somewhat odd-looking label, until we do something\n            // smarter like showing the bin boundaries (or the bounds of the actual\n            // data in each bin)\n            binStart -= HALFDAY;\n        }\n        var nextBinStart = axes.tickIncrement(binStart, dtick);\n\n        if(nextBinStart <= dataMin) return nextBinStart;\n    }\n    return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have minor tick0 and dtick calculated\naxes.prepMinorTicks = function(mockAx, ax, opts) {\n    if(!ax.minor.dtick) {\n        delete mockAx.dtick;\n        var hasMajor = ax.dtick && isNumeric(ax._tmin);\n        var mockMinorRange;\n        if(hasMajor) {\n            var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);\n            // mock range a tiny bit smaller than one major tick interval\n            mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];\n        } else {\n            var rl = Lib.simpleMap(ax.range, ax.r2l);\n            // If we don't have a major dtick, the concept of minor ticks is a little\n            // ambiguous - just take a stab and say minor.nticks should span 1/5 the axis\n            mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];\n        }\n        mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);\n        mockAx._isMinor = true;\n\n        axes.prepTicks(mockAx, opts);\n\n        if(hasMajor) {\n            var numericMajor = isNumeric(ax.dtick);\n            var numericMinor = isNumeric(mockAx.dtick);\n            var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);\n            var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);\n            if(numericMajor && numericMinor) {\n                if(!isMultiple(majorNum, minorNum)) {\n                    // give up on minor ticks - outside the below exceptions,\n                    // this can only happen if minor.nticks is smaller than two jumps\n                    // in the auto-tick scale and the first jump is not an even multiple\n                    // (5 -> 2 or for dates 3 ->2, 15 -> 10 etc)  or if you provided\n                    // an explicit dtick, in which case it's fine to give up,\n                    // you can provide an explicit minor.dtick.\n                    if((majorNum === 2 * ONEWEEK) && (minorNum === 3 * ONEDAY)) {\n                        mockAx.dtick = ONEWEEK;\n                    } else if(majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {\n                        // minor.nticks defaults to 5, but in this one case we want 7,\n                        // so the minor ticks show on all days of the week\n                        mockAx.dtick = ONEDAY;\n                    } else if(isClose(majorNum / minorNum, 2.5)) {\n                        // 5*10^n -> 2*10^n and you've set nticks < 5\n                        // quarters are pretty common, we don't do this by default as it\n                        // would add an extra digit to display, but minor has no labels\n                        mockAx.dtick = majorNum / 2;\n                    } else {\n                        mockAx.dtick = majorNum;\n                    }\n                } else if(majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {\n                    // this is a weird one: we don't want to automatically choose\n                    // 2-day minor ticks for 2-week major, even though it IS an even multiple,\n                    // because people would expect to see the weeks clearly\n                    mockAx.dtick = ONEWEEK;\n                }\n            } else if(String(ax.dtick).charAt(0) === 'M') {\n                if(numericMinor) {\n                    mockAx.dtick = 'M1';\n                } else {\n                    if(!isMultiple(majorNum, minorNum)) {\n                        // unless you provided an explicit ax.dtick (in which case\n                        // it's OK for us to give up, you can provide an explicit\n                        // minor.dtick too), this can only happen with:\n                        // minor.nticks < 3 and dtick === M3, or\n                        // minor.nticks < 5 and dtick === 5 * 10^n years\n                        // so in all cases we just give up.\n                        mockAx.dtick = ax.dtick;\n                    } else if((majorNum >= 12) && (minorNum === 2)) {\n                        // another special carve-out: for year major ticks, don't show\n                        // 2-month minor ticks, bump to quarters\n                        mockAx.dtick = 'M3';\n                    }\n                }\n            } else if(String(mockAx.dtick).charAt(0) === 'L') {\n                if(String(ax.dtick).charAt(0) === 'L') {\n                    if(!isMultiple(majorNum, minorNum)) {\n                        mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? (ax.dtick / 2) : ax.dtick;\n                    }\n                } else {\n                    mockAx.dtick = 'D1';\n                }\n            } else if(mockAx.dtick === 'D2' && +ax.dtick > 1) {\n                // the D2 log axis tick spacing is confusing for unlabeled minor ticks if\n                // the major dtick is more than one order of magnitude.\n                mockAx.dtick = 1;\n            }\n        }\n        // put back the original range, to use to find the full set of minor ticks\n        mockAx.range = ax.range;\n    }\n    if(ax.minor._tick0Init === undefined) {\n        // ensure identical tick0\n        mockAx.tick0 = ax.tick0;\n    }\n};\n\nfunction isMultiple(bigger, smaller) {\n    return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 0.001;\n}\n\nfunction isClose(a, b) {\n    return Math.abs((a / b) - 1) < 0.001;\n}\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function(ax, opts) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n\n    // calculate max number of (auto) ticks to display based on plot size\n    if(ax.tickmode === 'auto' || !ax.dtick) {\n        var nt = ax.nticks;\n        var minPx;\n\n        if(!nt) {\n            if(ax.type === 'category' || ax.type === 'multicategory') {\n                minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n                nt = ax._length / minPx;\n            } else {\n                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n            }\n\n            // radial axes span half their domain,\n            // multiply nticks value by two to get correct number of auto ticks.\n            if(ax._name === 'radialaxis') nt *= 2;\n        }\n\n        if(!(ax.minor && ax.minor.tickmode !== 'array')) {\n            // add a couple of extra digits for filling in ticks when we\n            // have explicit tickvals without tick text\n            if(ax.tickmode === 'array') nt *= 100;\n        }\n\n        ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n        axes.autoTicks(ax, ax._roughDTick);\n\n        // check for a forced minimum dtick\n        if(ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n            ax.dtick = ax._minDtick;\n            ax.tick0 = ax.l2r(ax._forceTick0);\n        }\n    }\n\n    if(ax.ticklabelmode === 'period') {\n        adjustPeriodDelta(ax);\n    }\n\n    // check for missing tick0\n    if(!ax.tick0) {\n        ax.tick0 = (ax.type === 'date') ? '2000-01-01' : 0;\n    }\n\n    // ensure we don't try to make ticks below our minimum precision\n    // see https://github.com/plotly/plotly.js/issues/2892\n    if(ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n    // now figure out rounding of tick values\n    autoTickRound(ax);\n};\n\nfunction nMonths(dtick) {\n    return +(dtick.substring(1));\n}\n\nfunction adjustPeriodDelta(ax) { // adjusts ax.dtick and sets ax._definedDelta\n    var definedDelta;\n\n    function mDate() {\n        return !(\n            isNumeric(ax.dtick) ||\n            ax.dtick.charAt(0) !== 'M'\n        );\n    }\n    var isMDate = mDate();\n    var tickformat = axes.getTickFormat(ax);\n    if(tickformat) {\n        var noDtick = ax._dtickInit !== ax.dtick;\n        if(\n            !(/%[fLQsSMX]/.test(tickformat))\n            // %f: microseconds as a decimal number [000000, 999999]\n            // %L: milliseconds as a decimal number [000, 999]\n            // %Q: milliseconds since UNIX epoch\n            // %s: seconds since UNIX epoch\n            // %S: second as a decimal number [00,61]\n            // %M: minute as a decimal number [00,59]\n            // %X: the locale’s time, such as %-I:%M:%S %p\n        ) {\n            if(\n                /%[HI]/.test(tickformat)\n                // %H: hour (24-hour clock) as a decimal number [00,23]\n                // %I: hour (12-hour clock) as a decimal number [01,12]\n            ) {\n                definedDelta = ONEHOUR;\n                if(noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n            } else if(\n                /%p/.test(tickformat) // %p: either AM or PM\n            ) {\n                definedDelta = HALFDAY;\n                if(noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n            } else if(\n                /%[Aadejuwx]/.test(tickformat)\n                // %A: full weekday name\n                // %a: abbreviated weekday name\n                // %d: zero-padded day of the month as a decimal number [01,31]\n                // %e: space-padded day of the month as a decimal number [ 1,31]\n                // %j: day of the year as a decimal number [001,366]\n                // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n                // %w: Sunday-based weekday as a decimal number [0,6]\n                // %x: the locale’s date, such as %-m/%-d/%Y\n            ) {\n                definedDelta = ONEDAY;\n                if(noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n            } else if(\n                /%[UVW]/.test(tickformat)\n                // %U: Sunday-based week of the year as a decimal number [00,53]\n                // %V: ISO 8601 week of the year as a decimal number [01, 53]\n                // %W: Monday-based week of the year as a decimal number [00,53]\n            ) {\n                definedDelta = ONEWEEK;\n                if(noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n            } else if(\n                /%[Bbm]/.test(tickformat)\n                // %B: full month name\n                // %b: abbreviated month name\n                // %m: month as a decimal number [01,12]\n            ) {\n                definedDelta = ONEAVGMONTH;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)\n                ) ax.dtick = 'M1';\n            } else if(\n                /%[q]/.test(tickformat)\n                // %q: quarter of the year as a decimal number [1,4]\n            ) {\n                definedDelta = ONEAVGQUARTER;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)\n                ) ax.dtick = 'M3';\n            } else if(\n                /%[Yy]/.test(tickformat)\n                // %Y: year with century as a decimal number, such as 1999\n                // %y: year without century as a decimal number [00,99]\n            ) {\n                definedDelta = ONEAVGYEAR;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)\n                ) ax.dtick = 'M12';\n            }\n        }\n    }\n\n    isMDate = mDate();\n    if(isMDate && ax.tick0 === ax._dowTick0) {\n        // discard Sunday/Monday tweaks\n        ax.tick0 = ax._rawTick0;\n    }\n\n    ax._definedDelta = definedDelta;\n}\n\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n    for(var i = 0; i < tickVals.length; i++) {\n        var v = tickVals[i].value;\n\n        var a = i;\n        var b = i + 1;\n        if(i < tickVals.length - 1) {\n            a = i;\n            b = i + 1;\n        } else if(i > 0) {\n            a = i - 1;\n            b = i;\n        } else {\n            a = i;\n            b = i;\n        }\n\n        var A = tickVals[a].value;\n        var B = tickVals[b].value;\n        var actualDelta = Math.abs(B - A);\n        var delta = definedDelta || actualDelta;\n        var periodLength = 0;\n\n        if(delta >= ONEMINYEAR) {\n            if(actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGYEAR;\n            }\n        } else if(definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n            if(actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGQUARTER;\n            }\n        } else if(delta >= ONEMINMONTH) {\n            if(actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGMONTH;\n            }\n        } else if(definedDelta === ONEWEEK && delta >= ONEWEEK) {\n            periodLength = ONEWEEK;\n        } else if(delta >= ONEDAY) {\n            periodLength = ONEDAY;\n        } else if(definedDelta === HALFDAY && delta >= HALFDAY) {\n            periodLength = HALFDAY;\n        } else if(definedDelta === ONEHOUR && delta >= ONEHOUR) {\n            periodLength = ONEHOUR;\n        }\n\n        var inBetween;\n        if(periodLength >= actualDelta) {\n            // ensure new label positions remain between ticks\n            periodLength = actualDelta;\n            inBetween = true;\n        }\n\n        var endPeriod = v + periodLength;\n        if(ax.rangebreaks && periodLength > 0) {\n            var nAll = 84; // highly divisible 7 * 12\n            var n = 0;\n            for(var c = 0; c < nAll; c++) {\n                var r = (c + 0.5) / nAll;\n                if(ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n            }\n            periodLength *= n / nAll;\n\n            if(!periodLength) {\n                tickVals[i].drop = true;\n            }\n\n            if(inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n        }\n\n        if(\n            periodLength > 0 || // not instant\n            i === 0 // taking care first tick added\n        ) {\n            tickVals[i].periodX = v + periodLength / 2;\n        }\n    }\n}\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax, opts) {\n    var type = ax.type;\n    var calendar = ax.calendar;\n    var ticklabelstep = ax.ticklabelstep;\n    var isPeriod = ax.ticklabelmode === 'period';\n    var isReversed = ax.range[0] > ax.range[1];\n    var ticklabelIndex = (!ax.ticklabelindex || Lib.isArrayOrTypedArray(ax.ticklabelindex)) ?\n        ax.ticklabelindex : [ax.ticklabelindex];\n    var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n    var axrev = (rng[1] < rng[0]);\n    var minRange = Math.min(rng[0], rng[1]);\n    var maxRange = Math.max(rng[0], rng[1]);\n\n    var maxTicks = Math.max(1000, ax._length || 0);\n\n    var ticksOut = [];\n    var minorTicks = [];\n\n    var tickVals = [];\n    var minorTickVals = [];\n    // all ticks for which labels are drawn which is not necessarily the major ticks when\n    // `ticklabelindex` is set.\n    var allTicklabelVals = [];\n\n    var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);\n\n    // calc major first\n    for(var major = 1; major >= (hasMinor ? 0 : 1); major--) {\n        var isMinor = !major;\n\n        if(major) {\n            ax._dtickInit = ax.dtick;\n            ax._tick0Init = ax.tick0;\n        } else {\n            ax.minor._dtickInit = ax.minor.dtick;\n            ax.minor._tick0Init = ax.minor.tick0;\n        }\n\n        var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);\n\n        if(isMinor) {\n            axes.prepMinorTicks(mockAx, ax, opts);\n        } else {\n            axes.prepTicks(mockAx, opts);\n        }\n\n        // now that we've figured out the auto values for formatting\n        // in case we're missing some ticktext, we can break out for array ticks\n        if(mockAx.tickmode === 'array') {\n            if(major) {\n                tickVals = [];\n                ticksOut = arrayTicks(ax, !isMinor);\n            } else {\n                minorTickVals = [];\n                minorTicks = arrayTicks(ax, !isMinor);\n            }\n            continue;\n        }\n\n        // fill tickVals based on overlaying axis\n        if(mockAx.tickmode === 'sync') {\n            tickVals = [];\n            ticksOut = syncTicks(ax);\n            continue;\n        }\n\n        // add a tiny bit so we get ticks which may have rounded out\n        var exRng = expandRange(rng);\n        var startTick = exRng[0];\n        var endTick = exRng[1];\n\n        var numDtick = isNumeric(mockAx.dtick);\n        var isDLog = (type === 'log') && !(numDtick || mockAx.dtick.charAt(0) === 'L');\n\n        // find the first tick\n        var x0 = axes.tickFirst(mockAx, opts);\n\n        if(major) {\n            ax._tmin = x0;\n\n            // No visible ticks? Quit.\n            // I've only seen this on category axes with all categories off the edge.\n            if((x0 < startTick) !== axrev) break;\n\n            // return the full set of tick vals\n            if(type === 'category' || type === 'multicategory') {\n                endTick = (axrev) ? Math.max(-0.5, endTick) :\n                    Math.min(ax._categories.length - 0.5, endTick);\n            }\n        }\n\n        var prevX = null;\n        var x = x0;\n        var majorId;\n\n        if(major) {\n            // ids for ticklabelstep\n            var _dTick;\n            if(numDtick) {\n                _dTick = ax.dtick;\n            } else {\n                if(type === 'date') {\n                    if(typeof ax.dtick === 'string' && ax.dtick.charAt(0) === 'M') {\n                        _dTick = ONEAVGMONTH * ax.dtick.substring(1);\n                    }\n                } else {\n                    _dTick = ax._roughDTick;\n                }\n            }\n\n            majorId = Math.round((\n                ax.r2l(x) -\n                ax.r2l(ax.tick0)\n            ) / _dTick) - 1;\n        }\n\n        var dtick = mockAx.dtick;\n\n        if(mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {\n            // adjust tick0\n            x = moveOutsideBreak(x, ax);\n            if(!axrev) {\n                x = axes.tickIncrement(x, dtick, !axrev, calendar);\n            }\n        }\n\n        if(major && isPeriod) {\n            // add one item to label period before tick0\n            x = axes.tickIncrement(x, dtick, !axrev, calendar);\n            majorId--;\n        }\n\n        for(;\n            axrev ?\n                (x >= endTick) :\n                (x <= endTick);\n            x = axes.tickIncrement(\n                x,\n                dtick,\n                axrev,\n                calendar\n            )\n        ) {\n            if(major) majorId++;\n\n            if(mockAx.rangebreaks) {\n                if(!axrev) {\n                    if(x < startTick) continue;\n                    if(mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;\n                }\n            }\n\n            // prevent infinite loops - no more than one tick per pixel,\n            // and make sure each value is different from the previous\n            if(tickVals.length > maxTicks || x === prevX) break;\n            prevX = x;\n\n            var obj = { value: x };\n\n            if(major) {\n                if(isDLog && (x !== (x | 0))) {\n                    obj.simpleLabel = true;\n                }\n\n                if(ticklabelstep > 1 && majorId % ticklabelstep) {\n                    obj.skipLabel = true;\n                }\n\n                tickVals.push(obj);\n            } else {\n                obj.minor = true;\n\n                minorTickVals.push(obj);\n            }\n        }\n    }\n\n    // check if ticklabelIndex makes sense, otherwise ignore it\n    if(!minorTickVals || minorTickVals.length < 2) {\n        ticklabelIndex = false;\n    } else {\n        var diff = (minorTickVals[1].value - minorTickVals[0].value) * (isReversed ? -1 : 1);\n        if(!periodCompatibleWithTickformat(diff, ax.tickformat)) {\n            ticklabelIndex = false;\n        }\n    }\n    // Determine for which ticks to draw labels\n    if(!ticklabelIndex) {\n        allTicklabelVals = tickVals;\n    } else {\n        // Collect and sort all major and minor ticks, to find the minor ticks `ticklabelIndex`\n        // steps away from each major tick. For those minor ticks we want to draw the label.\n\n        var allTickVals = tickVals.concat(minorTickVals);\n        if(isPeriod && tickVals.length) {\n            // first major tick was just added for period handling\n            allTickVals = allTickVals.slice(1);\n        }\n\n        allTickVals =\n            allTickVals\n            .sort(function(a, b) { return a.value - b.value; })\n            .filter(function(tick, index, self) {\n                return index === 0 || tick.value !== self[index - 1].value;\n            });\n\n        var majorTickIndices =\n            allTickVals\n            .map(function(item, index) {\n                return item.minor === undefined && !item.skipLabel ? index : null;\n            })\n            .filter(function(index) { return index !== null; });\n\n        majorTickIndices.forEach(function(majorIdx) {\n            ticklabelIndex.map(function(nextLabelIdx) {\n                var minorIdx = majorIdx + nextLabelIdx;\n                if(minorIdx >= 0 && minorIdx < allTickVals.length) {\n                    Lib.pushUnique(allTicklabelVals, allTickVals[minorIdx]);\n                }\n            });\n        });\n    }\n\n    if(hasMinor) {\n        var canOverlap =\n            (ax.minor.ticks === 'inside' && ax.ticks === 'outside') ||\n            (ax.minor.ticks === 'outside' && ax.ticks === 'inside');\n\n        if(!canOverlap) {\n            // remove duplicate minors\n\n            var majorValues = tickVals.map(function(d) { return d.value; });\n\n            var list = [];\n            for(var k = 0; k < minorTickVals.length; k++) {\n                var T = minorTickVals[k];\n                var v = T.value;\n                if(majorValues.indexOf(v) !== -1) {\n                    continue;\n                }\n                var found = false;\n                for(var q = 0; !found && (q < tickVals.length); q++) {\n                    if(\n                        // add 10e6 to eliminate problematic digits\n                        10e6 + tickVals[q].value ===\n                        10e6 + v\n                    ) {\n                        found = true;\n                    }\n                }\n                if(!found) list.push(T);\n            }\n            minorTickVals = list;\n        }\n    }\n\n    if(isPeriod) positionPeriodTicks(allTicklabelVals, ax, ax._definedDelta);\n\n    var i;\n    if(ax.rangebreaks) {\n        var flip = ax._id.charAt(0) === 'y';\n\n        var fontSize = 1; // one pixel minimum\n        if(ax.tickmode === 'auto') {\n            fontSize = ax.tickfont ? ax.tickfont.size : 12;\n        }\n\n        var prevL = NaN;\n        for(i = tickVals.length - 1; i > -1; i--) {\n            if(tickVals[i].drop) {\n                tickVals.splice(i, 1);\n                continue;\n            }\n\n            tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);\n\n            // avoid overlaps\n            var l = ax.c2p(tickVals[i].value);\n            if(flip ?\n                (prevL > l - fontSize) :\n                (prevL < l + fontSize)\n            ) { // ensure one pixel minimum\n                tickVals.splice(axrev ? i + 1 : i, 1);\n            } else {\n                prevL = l;\n            }\n        }\n    }\n\n    // If same angle over a full circle, the last tick vals is a duplicate.\n    // TODO must do something similar for angular date axes.\n    if(isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n        tickVals.pop();\n    }\n\n    // save the last tick as well as first, so we can\n    // show the exponent only on the last one\n    ax._tmax = (tickVals[tickVals.length - 1] || {}).value;\n\n    // for showing the rest of a date when the main tick label is only the\n    // latter part: ax._prevDateHead holds what we showed most recently.\n    // Start with it cleared and mark that we're in calcTicks (ie calculating a\n    // whole string of these so we should care what the previous date head was!)\n    ax._prevDateHead = '';\n    ax._inCalcTicks = true;\n\n    var lastVisibleHead;\n    var hideLabel = function(tick) {\n        tick.text = '';\n        ax._prevDateHead = lastVisibleHead;\n    };\n\n    tickVals = tickVals.concat(minorTickVals);\n\n    function setTickLabel(ax, tickVal) {\n        var text = axes.tickText(\n            ax,\n            tickVal.value,\n            false, // hover\n            tickVal.simpleLabel // noSuffixPrefix\n        );\n        var p = tickVal.periodX;\n        if(p !== undefined) {\n            text.periodX = p;\n            if(p > maxRange || p < minRange) { // hide label if outside the range\n                if(p > maxRange) text.periodX = maxRange;\n                if(p < minRange) text.periodX = minRange;\n\n                hideLabel(text);\n            }\n        }\n        return text;\n    }\n\n    var t;\n    for(i = 0; i < tickVals.length; i++) {\n        var _minor = tickVals[i].minor;\n        var _value = tickVals[i].value;\n\n        if(_minor) {\n            if(ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) !== -1) {\n                t = setTickLabel(ax, tickVals[i]);\n            } else {\n                t = { x: _value };\n            }\n            t.minor = true;\n            minorTicks.push(t);\n        } else {\n            lastVisibleHead = ax._prevDateHead;\n            t = setTickLabel(ax, tickVals[i]);\n            if(tickVals[i].skipLabel ||\n                ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) === -1) {\n                hideLabel(t);\n            }\n\n            ticksOut.push(t);\n        }\n    }\n    ticksOut = ticksOut.concat(minorTicks);\n\n    ax._inCalcTicks = false;\n\n    if(isPeriod && ticksOut.length) {\n        // drop very first tick that we added to handle period\n        ticksOut[0].noTick = true;\n    }\n\n    return ticksOut;\n};\n\nfunction filterRangeBreaks(ax, ticksOut) {\n    if(ax.rangebreaks) {\n        // remove ticks falling inside rangebreaks\n        ticksOut = ticksOut.filter(function(d) {\n            return ax.maskBreaks(d.x) !== BADNUM;\n        });\n    }\n\n    return ticksOut;\n}\n\nfunction syncTicks(ax) {\n    // get the overlaying axis\n    var baseAxis = ax._mainAxis;\n\n    var ticksOut = [];\n    if(baseAxis._vals) {\n        for(var i = 0; i < baseAxis._vals.length; i++) {\n            // filter vals with noTick flag\n            if(baseAxis._vals[i].noTick) {\n                continue;\n            }\n\n            // get the position of the every tick\n            var pos = baseAxis.l2p(baseAxis._vals[i].x);\n\n            // get the tick for the current axis based on position\n            var vali = ax.p2l(pos);\n            var obj = axes.tickText(ax, vali);\n\n            // assign minor ticks\n            if(baseAxis._vals[i].minor) {\n                obj.minor = true;\n                obj.text = '';\n            }\n\n            ticksOut.push(obj);\n        }\n    }\n\n    ticksOut = filterRangeBreaks(ax, ticksOut);\n\n    return ticksOut;\n}\n\nfunction arrayTicks(ax, majorOnly) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var exRng = expandRange(rng);\n    var tickMin = Math.min(exRng[0], exRng[1]);\n    var tickMax = Math.max(exRng[0], exRng[1]);\n\n    // make sure showing ticks doesn't accidentally add new categories\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n    // array ticks on log axes always show the full number\n    // (if no explicit ticktext overrides it)\n    if(ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n        ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n    }\n\n    var ticksOut = [];\n    for(var isMinor = 0; isMinor <= 1; isMinor++) {\n        if((majorOnly !== undefined) && ((majorOnly && isMinor) || (majorOnly === false && !isMinor))) continue;\n        if(isMinor && !ax.minor) continue;\n        var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;\n        var text = !isMinor ? ax.ticktext : [];\n        if(!vals) continue;\n\n\n        // without a text array, just format the given values as any other ticks\n        // except with more precision to the numbers\n        if(!Lib.isArrayOrTypedArray(text)) text = [];\n\n        for(var i = 0; i < vals.length; i++) {\n            var vali = tickVal2l(vals[i]);\n            if(vali > tickMin && vali < tickMax) {\n                var obj = axes.tickText(ax, vali, false, String(text[i]));\n                if(isMinor) {\n                    obj.minor = true;\n                    obj.text = '';\n                }\n\n                ticksOut.push(obj);\n            }\n        }\n    }\n\n    ticksOut = filterRangeBreaks(ax, ticksOut);\n\n    return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n    return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function(ax, roughDTick, isMinor) {\n    var base;\n\n    function getBase(v) {\n        return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n    }\n\n    if(ax.type === 'date') {\n        ax.tick0 = Lib.dateTick0(ax.calendar, 0);\n\n        // the criteria below are all based on the rough spacing we calculate\n        // being > half of the final unit - so precalculate twice the rough val\n        var roughX2 = 2 * roughDTick;\n\n        if(roughX2 > ONEAVGYEAR) {\n            roughDTick /= ONEAVGYEAR;\n            base = getBase(10);\n            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));\n        } else if(roughX2 > ONEAVGMONTH) {\n            roughDTick /= ONEAVGMONTH;\n            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n        } else if(roughX2 > ONEDAY) {\n            ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);\n            if(!isMinor) {\n                // get week ticks on sunday\n                // this will also move the base tick off 2000-01-01 if dtick is\n                // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n                var tickformat = axes.getTickFormat(ax);\n                var isPeriod = ax.ticklabelmode === 'period';\n                if(isPeriod) ax._rawTick0 = ax.tick0;\n\n                if(/%[uVW]/.test(tickformat)) {\n                    ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n                } else {\n                    ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n                }\n\n                if(isPeriod) ax._dowTick0 = ax.tick0;\n            }\n        } else if(roughX2 > ONEHOUR) {\n            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n        } else if(roughX2 > ONEMIN) {\n            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n        } else if(roughX2 > ONESEC) {\n            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n        } else {\n            // milliseconds\n            base = getBase(10);\n            ax.dtick = roundDTick(roughDTick, base, roundBase10);\n        }\n    } else if(ax.type === 'log') {\n        ax.tick0 = 0;\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        if(ax._isMinor) {\n            // Log axes by default get MORE than nTicks based on the metrics below\n            // But for minor ticks we don't want this increase, we already have\n            // the major ticks.\n            roughDTick *= 1.5;\n        }\n        if(roughDTick > 0.7) {\n            // only show powers of 10\n            ax.dtick = Math.ceil(roughDTick);\n        } else if(Math.abs(rng[1] - rng[0]) < 1) {\n            // span is less than one power of 10\n            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n            // ticks on a linear scale, labeled fully\n            roughDTick = Math.abs(Math.pow(10, rng[1]) -\n                Math.pow(10, rng[0])) / nt;\n            base = getBase(10);\n            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n        } else {\n            // include intermediates between powers of 10,\n            // labeled with small digits\n            // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n            ax.dtick = (roughDTick > 0.3) ? 'D2' : 'D1';\n        }\n    } else if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax.tick0 = 0;\n        ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n    } else if(isAngular(ax)) {\n        ax.tick0 = 0;\n        base = 1;\n        ax.dtick = roundDTick(roughDTick, base, roundAngles);\n    } else {\n        // auto ticks always start at 0\n        ax.tick0 = 0;\n        base = getBase(10);\n        ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n\n    // prevent infinite loops\n    if(ax.dtick === 0) ax.dtick = 1;\n\n    // TODO: this is from log axis histograms with autorange off\n    if(!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n        var olddtick = ax.dtick;\n        ax.dtick = 1;\n        throw 'ax.dtick error: ' + String(olddtick);\n    }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n    var dtick = ax.dtick;\n\n    ax._tickexponent = 0;\n    if(!isNumeric(dtick) && typeof dtick !== 'string') {\n        dtick = 1;\n    }\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax._tickround = null;\n    }\n    if(ax.type === 'date') {\n        // If tick0 is unusual, give tickround a bit more information\n        // not necessarily *all* the information in tick0 though, if it's really odd\n        // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n        // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n        var tick0ms = ax.r2l(ax.tick0);\n        var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n        var tick0len = tick0str.length;\n\n        if(String(dtick).charAt(0) === 'M') {\n            // any tick0 more specific than a year: alway show the full date\n            if(tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n            // show the month unless ticks are full multiples of a year\n            else ax._tickround = (+(dtick.substr(1)) % 12 === 0) ? 'y' : 'm';\n        } else if((dtick >= ONEDAY && tick0len <= 10) || (dtick >= ONEDAY * 15)) ax._tickround = 'd';\n        else if((dtick >= ONEMIN && tick0len <= 16) || (dtick >= ONEHOUR)) ax._tickround = 'M';\n        else if((dtick >= ONESEC && tick0len <= 19) || (dtick >= ONEMIN)) ax._tickround = 'S';\n        else {\n            // tickround is a number of digits of fractional seconds\n            // of any two adjacent ticks, at least one will have the maximum fractional digits\n            // of all possible ticks - so take the max. length of tick0 and the next one\n            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n            ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n            // We shouldn't get here... but in case there's a situation I'm\n            // not thinking of where tick0str and tick1str are identical or\n            // something, fall back on maximum precision\n            if(ax._tickround < 0) ax._tickround = 4;\n        }\n    } else if(isNumeric(dtick) || dtick.charAt(0) === 'L') {\n        // linear or log (except D1, D2)\n        var rng = ax.range.map(ax.r2d || Number);\n        if(!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n        // 2 digits past largest digit of dtick\n        ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n\n        var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n        var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n        var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n        if(Math.abs(rangeexp) > minexponent) {\n            if(isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n                ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n            } else ax._tickexponent = rangeexp;\n        }\n    } else {\n        // D1 or D2 (log)\n        ax._tickround = null;\n    }\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function(x, dtick, axrev, calendar) {\n    var axSign = axrev ? -1 : 1;\n\n    // includes linear, all dates smaller than month, and pure 10^n in log\n    if(isNumeric(dtick)) return Lib.increment(x, axSign * dtick);\n\n    // everything else is a string, one character plus a number\n    var tType = dtick.charAt(0);\n    var dtSigned = axSign * Number(dtick.substr(1));\n\n    // Dates: months (or years - see Lib.incrementMonth)\n    if(tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n    // Log scales: Linear, Digits\n    if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n    // log10 of 2,5,10, or all digits (logs just have to be\n    // close enough to round)\n    if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var x2 = x + axSign * 0.01;\n        var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n\n        return Math.floor(x2) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n\n    throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function(ax, opts) {\n    var r2l = ax.r2l || Number;\n    var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n    var axrev = rng[1] < rng[0];\n    var sRound = axrev ? Math.floor : Math.ceil;\n    // add a tiny extra bit to make sure we get ticks\n    // that may have been rounded out\n    var r0 = expandRange(rng)[0];\n    var dtick = ax.dtick;\n    var tick0 = r2l(ax.tick0);\n\n    if(isNumeric(dtick)) {\n        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n        // make sure no ticks outside the category list\n        if(ax.type === 'category' || ax.type === 'multicategory') {\n            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n        }\n        return tmin;\n    }\n\n    var tType = dtick.charAt(0);\n    var dtNum = Number(dtick.substr(1));\n\n    // Dates: months (or years)\n    if(tType === 'M') {\n        var cnt = 0;\n        var t0 = tick0;\n        var t1, mult, newDTick;\n\n        // This algorithm should work for *any* nonlinear (but close to linear!)\n        // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n        while(cnt < 10) {\n            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n            if((t1 - r0) * (t0 - r0) <= 0) {\n                // t1 and t0 are on opposite sides of r0! we've succeeded!\n                if(axrev) return Math.min(t0, t1);\n                return Math.max(t0, t1);\n            }\n            mult = (r0 - ((t0 + t1) / 2)) / (t1 - t0);\n            newDTick = tType + ((Math.abs(Math.round(mult)) || 1) * dtNum);\n            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n            cnt++;\n        }\n        Lib.error('tickFirst did not converge', ax);\n        return t0;\n    } else if(tType === 'L') {\n        // Log scales: Linear, Digits\n\n        return Math.log(sRound(\n            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n    } else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n\n        return Math.floor(r0) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function(ax, x, hover, noSuffixPrefix) {\n    var out = tickTextObj(ax, x);\n    var arrayMode = ax.tickmode === 'array';\n    var extraPrecision = hover || arrayMode;\n    var axType = ax.type;\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n    var i;\n\n    var inbounds = function(v) {\n        var p = ax.l2p(v);\n        return p >= 0 && p <= ax._length ? v : null;\n    };\n    if(arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n\n        for(i = 0; i < ax.ticktext.length; i++) {\n            if(Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n        }\n        if(i < ax.ticktext.length) {\n            out.text = String(ax.ticktext[i]);\n\n            out.xbnd = [\n                inbounds(out.x - 0.5),\n                inbounds(out.x + ax.dtick - 0.5)\n            ];\n            return out;\n        }\n    }\n\n    function isHidden(showAttr) {\n        if(showAttr === undefined) return true;\n        if(hover) return showAttr === 'none';\n\n        var firstOrLast = {\n            first: ax._tmin,\n            last: ax._tmax\n        }[showAttr];\n\n        return showAttr !== 'all' && x !== firstOrLast;\n    }\n\n    var hideexp = hover ?\n        'never' :\n        ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n\n    if(axType === 'date') formatDate(ax, out, hover, extraPrecision);\n    else if(axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);\n    else if(axType === 'category') formatCategory(ax, out);\n    else if(axType === 'multicategory') formatMultiCategory(ax, out, hover);\n    else if(isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);\n    else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n    // add prefix and suffix\n    if(!noSuffixPrefix) {\n        if(ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n        if(ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n    }\n\n    if(ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {\n        var t = ax.labelalias[out.text];\n        if(typeof t === 'string') out.text = t;\n    }\n\n    // Setup ticks and grid lines boundaries\n    // at 1/2 a 'category' to the left/bottom\n    if(ax.tickson === 'boundaries' || ax.showdividers) {\n        out.xbnd = [\n            inbounds(out.x - 0.5),\n            inbounds(out.x + ax.dtick - 0.5)\n        ];\n    }\n\n    return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\naxes.hoverLabelText = function(ax, values, hoverformat) {\n    if(hoverformat) ax = Lib.extendFlat({}, ax, {hoverformat: hoverformat});\n\n    var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;\n    var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : undefined;\n    if(val2 !== undefined && val2 !== val) {\n        return (\n            axes.hoverLabelText(ax, val, hoverformat) + ' - ' +\n            axes.hoverLabelText(ax, val2, hoverformat)\n        );\n    }\n\n    var logOffScale = (ax.type === 'log' && val <= 0);\n    var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n\n    if(logOffScale) {\n        return val === 0 ? '0' : MINUS_SIGN + tx;\n    }\n\n    // TODO: should we do something special if the axis calendar and\n    // the data calendar are different? Somehow display both dates with\n    // their system names? Right now it will just display in the axis calendar\n    // but users could add the other one as text.\n    return tx;\n};\n\nfunction tickTextObj(ax, x, text) {\n    var tf = ax.tickfont || {};\n\n    return {\n        x: x,\n        dx: 0,\n        dy: 0,\n        text: text || '',\n        fontSize: tf.size,\n        font: tf.family,\n        fontWeight: tf.weight,\n        fontStyle: tf.style,\n        fontVariant: tf.variant,\n        fontTextcase: tf.textcase,\n        fontLineposition: tf.lineposition,\n        fontShadow: tf.shadow,\n        fontColor: tf.color\n    };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n    var tr = ax._tickround;\n    var fmt = (hover && ax.hoverformat) || axes.getTickFormat(ax);\n\n    // Only apply extra precision if no explicit format was provided.\n    extraPrecision = !fmt && extraPrecision;\n\n    if(extraPrecision) {\n        // second or sub-second precision: extra always shows max digits.\n        // for other fields, extra precision just adds one field.\n        if(isNumeric(tr)) tr = 4;\n        else tr = {y: 'm', m: 'd', d: 'M', M: 'S', S: 4}[tr];\n    }\n\n    var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n    var headStr;\n\n    var splitIndex = dateStr.indexOf('\\n');\n    if(splitIndex !== -1) {\n        headStr = dateStr.substr(splitIndex + 1);\n        dateStr = dateStr.substr(0, splitIndex);\n    }\n\n    if(extraPrecision) {\n        // if extraPrecision led to trailing zeros, strip them off\n        // actually, this can lead to removing even more zeros than\n        // in the original rounding, but that's fine because in these\n        // contexts uniformity is not so important (if there's even\n        // anything to be uniform with!)\n\n        // can we remove the whole time part?\n        if(headStr !== undefined && (dateStr === '00:00:00' || dateStr === '00:00')) {\n            dateStr = headStr;\n            headStr = '';\n        } else if(dateStr.length === 8) {\n            // strip off seconds if they're zero (zero fractional seconds\n            // are already omitted)\n            // but we never remove minutes and leave just hours\n            dateStr = dateStr.replace(/:00$/, '');\n        }\n    }\n\n    if(headStr) {\n        if(hover) {\n            // hover puts it all on one line, so headPart works best up front\n            // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n            if(tr === 'd') dateStr += ', ' + headStr;\n            else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n        } else {\n            if(\n                !ax._inCalcTicks ||\n                ax._prevDateHead !== headStr\n            ) {\n                ax._prevDateHead = headStr;\n                dateStr += '<br>' + headStr;\n            } else {\n                var isInside = insideTicklabelposition(ax);\n                var side = ax._trueSide || ax.side; // polar mocks the side of the radial axis\n                if(\n                    (!isInside && side === 'top') ||\n                    (isInside && side === 'bottom')\n                ) {\n                    dateStr += '<br> ';\n                }\n            }\n        }\n    }\n\n    out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n    var dtick = ax.dtick;\n    var x = out.x;\n    var tickformat = ax.tickformat;\n    var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    }\n\n    if(extraPrecision && (dtChar0 !== 'L')) {\n        dtick = 'L3';\n        dtChar0 = 'L';\n    }\n\n    if(tickformat || (dtChar0 === 'L')) {\n        out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n    } else if(isNumeric(dtick) || ((dtChar0 === 'D') && (Lib.mod(x + 0.01, 1) < 0.1))) {\n        var p = Math.round(x);\n        var absP = Math.abs(p);\n        var exponentFormat = ax.exponentformat;\n        if(exponentFormat === 'power' || (isSIFormat(exponentFormat) && beyondSI(p))) {\n            if(p === 0) out.text = 1;\n            else if(p === 1) out.text = '10';\n            else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n\n            out.fontSize *= 1.25;\n        } else if((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n            out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n        } else {\n            out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n            if(dtick === 'D1' && ax._id.charAt(0) === 'y') {\n                out.dy -= out.fontSize / 6;\n            }\n        }\n    } else if(dtChar0 === 'D') {\n        out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n        out.fontSize *= 0.75;\n    } else throw 'unrecognized dtick ' + String(dtick);\n\n    // if 9's are printed on log scale, move the 10's away a bit\n    if(ax.dtick === 'D1') {\n        var firstChar = String(out.text).charAt(0);\n        if(firstChar === '0' || firstChar === '1') {\n            if(ax._id.charAt(0) === 'y') {\n                out.dx -= out.fontSize / 4;\n            } else {\n                out.dy += out.fontSize / 2;\n                out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) *\n                    out.fontSize * (x < 0 ? 0.5 : 0.25);\n            }\n        }\n    }\n}\n\nfunction formatCategory(ax, out) {\n    var tt = ax._categories[Math.round(out.x)];\n    if(tt === undefined) tt = '';\n    out.text = String(tt);\n}\n\nfunction formatMultiCategory(ax, out, hover) {\n    var v = Math.round(out.x);\n    var cats = ax._categories[v] || [];\n    var tt = cats[1] === undefined ? '' : String(cats[1]);\n    var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n\n    if(hover) {\n        // TODO is this what we want?\n        out.text = tt2 + ' - ' + tt;\n    } else {\n        // setup for secondary labels\n        out.text = tt;\n        out.text2 = tt2;\n    }\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    } else if(ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n        // don't add an exponent to zero if we're showing all exponents\n        // so the only reason you'd show an exponent on zero is if it's the\n        // ONLY tick to get an exponent (first or last)\n        hideexp = 'hide';\n    }\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n    if(ax.thetaunit === 'radians' && !hover) {\n        var num = out.x / 180;\n\n        if(num === 0) {\n            out.text = '0';\n        } else {\n            var frac = num2frac(num);\n\n            if(frac[1] >= 100) {\n                out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n            } else {\n                var isNeg = out.x < 0;\n\n                if(frac[1] === 1) {\n                    if(frac[0] === 1) out.text = 'π';\n                    else out.text = frac[0] + 'π';\n                } else {\n                    out.text = [\n                        '<sup>', frac[0], '</sup>',\n                        '⁄',\n                        '<sub>', frac[1], '</sub>',\n                        'π'\n                    ].join('');\n                }\n\n                if(isNeg) out.text = MINUS_SIGN + out.text;\n            }\n        }\n    } else {\n        out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n    }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n    function almostEq(a, b) {\n        return Math.abs(a - b) <= 1e-6;\n    }\n\n    function findGCD(a, b) {\n        return almostEq(b, 0) ? a : findGCD(b, a % b);\n    }\n\n    function findPrecision(n) {\n        var e = 1;\n        while(!almostEq(Math.round(n * e) / e, n)) {\n            e *= 10;\n        }\n        return e;\n    }\n\n    var precision = findPrecision(num);\n    var number = num * precision;\n    var gcd = Math.abs(findGCD(number, precision));\n\n    return [\n        // numerator\n        Math.round(number / gcd),\n        // denominator\n        Math.round(precision / gcd)\n    ];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction isSIFormat(exponentFormat) {\n    return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n    return exponent > 14 || exponent < -15;\n}\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n    var isNeg = v < 0;\n    // max number of digits past decimal point to show\n    var tickRound = ax._tickround;\n    var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n    var exponent = ax._tickexponent;\n    var tickformat = axes.getTickFormat(ax);\n    var separatethousands = ax.separatethousands;\n\n    // special case for hover: set exponent just for this value, and\n    // add a couple more digits of precision over tick labels\n    if(hover) {\n        // make a dummy axis obj to get the auto rounding and exponent\n        var ah = {\n            exponentformat: exponentFormat,\n            minexponent: ax.minexponent,\n            dtick: ax.showexponent === 'none' ? ax.dtick :\n                (isNumeric(v) ? Math.abs(v) || 1 : 1),\n            // if not showing any exponents, don't change the exponent\n            // from what we calculate\n            range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n        };\n        autoTickRound(ah);\n        tickRound = (Number(ah._tickround) || 0) + 4;\n        exponent = ah._tickexponent;\n        if(ax.hoverformat) tickformat = ax.hoverformat;\n    }\n\n    if(tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n    // 'epsilon' - rounding increment\n    var e = Math.pow(10, -tickRound) / 2;\n\n    // exponentFormat codes:\n    // 'e' (1.2e+6, default)\n    // 'E' (1.2E+6)\n    // 'SI' (1.2M)\n    // 'B' (same as SI except 10^9=B not G)\n    // 'none' (1200000)\n    // 'power' (1.2x10^6)\n    // 'hide' (1.2, use 3rd argument=='hide' to eg\n    //      only show exponent on last tick)\n    if(exponentFormat === 'none') exponent = 0;\n\n    // take the sign out, put it back manually at the end\n    // - makes cases easier\n    v = Math.abs(v);\n    if(v < e) {\n        // 0 is just 0, but may get exponent if it's the last tick\n        v = '0';\n        isNeg = false;\n    } else {\n        v += e;\n        // take out a common exponent, if any\n        if(exponent) {\n            v *= Math.pow(10, -exponent);\n            tickRound += exponent;\n        }\n        // round the mantissa\n        if(tickRound === 0) v = String(Math.floor(v));\n        else if(tickRound < 0) {\n            v = String(Math.round(v));\n            v = v.substr(0, v.length + tickRound);\n            for(var i = tickRound; i < 0; i++) v += '0';\n        } else {\n            v = String(v);\n            var dp = v.indexOf('.') + 1;\n            if(dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n        }\n        // insert appropriate decimal point and thousands separator\n        v = Lib.numSeparate(v, ax._separators, separatethousands);\n    }\n\n    // add exponent\n    if(exponent && exponentFormat !== 'hide') {\n        if(isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n\n        var signedExponent;\n        if(exponent < 0) signedExponent = MINUS_SIGN + -exponent;\n        else if(exponentFormat !== 'power') signedExponent = '+' + exponent;\n        else signedExponent = String(exponent);\n\n        if(exponentFormat === 'e' || exponentFormat === 'E') {\n            v += exponentFormat + signedExponent;\n        } else if(exponentFormat === 'power') {\n            v += '×10<sup>' + signedExponent + '</sup>';\n        } else if(exponentFormat === 'B' && exponent === 9) {\n            v += 'B';\n        } else if(isSIFormat(exponentFormat)) {\n            v += SIPREFIXES[exponent / 3 + 5];\n        }\n    }\n\n    // put sign back in and return\n    // replace standard minus character (which is technically a hyphen)\n    // with a true minus sign\n    if(isNeg) return MINUS_SIGN + v;\n    return v;\n}\n\naxes.getTickFormat = function(ax) {\n    var i;\n\n    function convertToMs(dtick) {\n        return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n    }\n\n    function compareLogTicks(left, right) {\n        var priority = ['L', 'D'];\n        if(typeof left === typeof right) {\n            if(typeof left === 'number') {\n                return left - right;\n            } else {\n                var leftPriority = priority.indexOf(left.charAt(0));\n                var rightPriority = priority.indexOf(right.charAt(0));\n                if(leftPriority === rightPriority) {\n                    return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n                } else {\n                    return leftPriority - rightPriority;\n                }\n            }\n        } else {\n            return typeof left === 'number' ? 1 : -1;\n        }\n    }\n\n    function isProperStop(dtick, range, convert) {\n        var convertFn = convert || function(x) { return x;};\n        var leftDtick = range[0];\n        var rightDtick = range[1];\n        return ((!leftDtick && typeof leftDtick !== 'number') || convertFn(leftDtick) <= convertFn(dtick)) &&\n               ((!rightDtick && typeof rightDtick !== 'number') || convertFn(rightDtick) >= convertFn(dtick));\n    }\n\n    function isProperLogStop(dtick, range) {\n        var isLeftDtickNull = range[0] === null;\n        var isRightDtickNull = range[1] === null;\n        var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n        var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n        return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n    }\n\n    var tickstop, stopi;\n    if(ax.tickformatstops && ax.tickformatstops.length > 0) {\n        switch(ax.type) {\n            case 'date':\n            case 'linear': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            case 'log': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            default:\n        }\n    }\n    return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function(gd, ax) {\n    var subplotObj = gd._fullLayout._subplots;\n    var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n\n    var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n\n    out.sort(function(a, b) {\n        var aParts = a.substr(1).split('y');\n        var bParts = b.substr(1).split('y');\n\n        if(aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n        return +aParts[0] - +bParts[0];\n    });\n\n    return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function(subplots, ax) {\n    var axMatch = new RegExp(\n        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')\n    );\n    var subplotsWithAx = [];\n\n    for(var i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        if(axMatch.test(sp)) subplotsWithAx.push(sp);\n    }\n\n    return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // for more info: https://github.com/plotly/plotly.js/issues/2595\n    if(fullLayout._hasOnlyLargeSploms) return;\n\n    var fullWidth = {_offset: 0, _length: fullLayout.width, _id: ''};\n    var fullHeight = {_offset: 0, _length: fullLayout.height, _id: ''};\n    var xaList = axes.list(gd, 'x', true);\n    var yaList = axes.list(gd, 'y', true);\n    var clipList = [];\n    var i, j;\n\n    for(i = 0; i < xaList.length; i++) {\n        clipList.push({x: xaList[i], y: fullHeight});\n        for(j = 0; j < yaList.length; j++) {\n            if(i === 0) clipList.push({x: fullWidth, y: yaList[j]});\n            clipList.push({x: xaList[i], y: yaList[j]});\n        }\n    }\n\n    // selectors don't work right with camelCase tags,\n    // have to use class instead\n    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n    var axClips = fullLayout._clips.selectAll('.axesclip')\n        .data(clipList, function(d) { return d.x._id + d.y._id; });\n\n    axClips.enter().append('clipPath')\n        .classed('axesclip', true)\n        .attr('id', function(d) { return 'clip' + fullLayout._uid + d.x._id + d.y._id; })\n      .append('rect');\n\n    axClips.exit().remove();\n\n    axClips.each(function(d) {\n        d3.select(this).select('rect').attr({\n            x: d.x._offset || 0,\n            y: d.y._offset || 0,\n            width: d.x._length || 1,\n            height: d.y._length || 1\n        });\n    });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function(gd, arg, opts) {\n    var fullLayout = gd._fullLayout;\n\n    if(arg === 'redraw') {\n        fullLayout._paper.selectAll('g.subplot').each(function(d) {\n            var id = d[0];\n            var plotinfo = fullLayout._plots[id];\n            if(plotinfo) {\n                var xa = plotinfo.xaxis;\n                var ya = plotinfo.yaxis;\n\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n\n                if(plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll('path').remove();\n                if(plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n                if(plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n\n                fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n                fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n            }\n        });\n    }\n\n    var axList = (!arg || arg === 'redraw') ? axes.listIds(gd) : arg;\n\n    var fullAxList = axes.list(gd);\n    // Get the list of the overlaying axis for all 'shift' axes\n    var overlayingShiftedAx = fullAxList.filter(function(ax) {\n        return ax.autoshift;\n    }).map(function(ax) {\n        return ax.overlaying;\n    });\n\n    // order axes that have dependency to other axes\n    axList.map(function(axId) {\n        var ax = axes.getFromId(gd, axId);\n\n        if(ax.tickmode === 'sync' && ax.overlaying) {\n            var overlayingIndex = axList.findIndex(function(axis) {return axis === ax.overlaying;});\n\n            if(overlayingIndex >= 0) {\n                axList.unshift(axList.splice(overlayingIndex, 1).shift());\n            }\n        }\n    });\n\n    var axShifts = {false: {left: 0, right: 0}};\n\n    return Lib.syncOrAsync(axList.map(function(axId) {\n        return function() {\n            if(!axId) return;\n\n            var ax = axes.getFromId(gd, axId);\n\n            if(!opts) opts = {};\n            opts.axShifts = axShifts;\n            opts.overlayingShiftedAx = overlayingShiftedAx;\n\n            var axDone = axes.drawOne(gd, ax, opts);\n\n            if(ax._shiftPusher) {\n                incrementShift(ax, ax._fullDepth || 0, axShifts, true);\n            }\n            ax._r = ax.range.slice();\n            ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n            return axDone;\n        };\n    }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\naxes.drawOne = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var axShifts = opts.axShifts || {};\n    var overlayingShiftedAx = opts.overlayingShiftedAx || [];\n\n    var i, sp, plotinfo;\n\n    ax.setScale();\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var counterLetter = axes.counterLetter(axId);\n    var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n    // this happens when updating matched group with 'missing' axes\n    if(!mainPlotinfo) return;\n\n    ax._shiftPusher = ax.autoshift ||\n        overlayingShiftedAx.indexOf(ax._id) !== -1 ||\n        overlayingShiftedAx.indexOf(ax.overlaying) !== -1;\n    // An axis is also shifted by 1/2 of its own linewidth and inside tick length if applicable\n    // as well as its manually specified `shift` val if we're in the context of `autoshift`\n    if(ax._shiftPusher & ax.anchor === 'free') {\n        var selfPush = (ax.linewidth / 2 || 0);\n        if(ax.ticks === 'inside') {\n            selfPush += ax.ticklen;\n        }\n        incrementShift(ax, selfPush, axShifts, true);\n        incrementShift(ax, (ax.shift || 0), axShifts, false);\n    }\n\n    // Somewhat inelegant way of making sure that the shift value is only updated when the\n    // Axes.DrawOne() function is called from the right context. An issue when redrawing the\n    // axis as result of using the dragbox, for example.\n    if(opts.skipTitle !== true || ax._shift === undefined) ax._shift = setShiftVal(ax, axShifts);\n\n    var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n    var mainLinePosition = ax._mainLinePosition;\n    var mainLinePositionShift = mainLinePosition += ax._shift;\n    var mainMirrorPosition = ax._mainMirrorPosition;\n\n    var vals = ax._vals = axes.calcTicks(ax);\n\n    // Add a couple of axis properties that should cause us to recreate\n    // elements. Used in d3 data function.\n    var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join('_');\n    for(i = 0; i < vals.length; i++) {\n        vals[i].axInfo = axInfo;\n    }\n\n    // stash selections to avoid DOM queries e.g.\n    // - stash tickLabels selection, so that drawTitle can use it to scoot title\n    ax._selections = {};\n    // stash tick angle (including the computed 'auto' values) per tick-label class\n    // linkup 'previous' tick angles on redraws\n    if(ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n    ax._tickAngles = {};\n    // measure [in px] between axis position and outward-most part of bounding box\n    // (touching either the tick label or ticks)\n    // depth can be expansive to compute, so we only do so when required\n    ax._depth = null;\n\n    // calcLabelLevelBbox can be expensive,\n    // so make sure to not call it twice during the same Axes.drawOne call\n    // by stashing label-level bounding boxes per tick-label class\n    var llbboxes = {};\n    function getLabelLevelBbox(suffix) {\n        var cls = axId + (suffix || 'tick');\n        if(!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);\n        return llbboxes[cls];\n    }\n\n    if(!ax.visible) return;\n\n    var transTickFn = axes.makeTransTickFn(ax);\n    var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n\n    var tickVals;\n    // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n    // The key case here is removing zero lines when the axis bound is zero\n    var valsClipped;\n\n    var insideTicks = ax.ticks === 'inside';\n    var outsideTicks = ax.ticks === 'outside';\n\n    if(ax.tickson === 'boundaries') {\n        var boundaryVals = getBoundaryVals(ax, vals);\n        valsClipped = axes.clipEnds(ax, boundaryVals);\n        tickVals = insideTicks ? valsClipped : boundaryVals;\n    } else {\n        valsClipped = axes.clipEnds(ax, vals);\n        tickVals = (insideTicks && ax.ticklabelmode !== 'period') ? valsClipped : vals;\n    }\n\n    var gridVals = ax._gridVals = valsClipped;\n    var dividerVals = getDividerVals(ax, vals);\n\n    if(!fullLayout._hasOnlyLargeSploms) {\n        var subplotsWithAx = ax._subplotsWith;\n\n        // keep track of which subplots (by main counter axis) we've already\n        // drawn grids for, so we don't overdraw overlaying subplots\n        var finishedGrids = {};\n\n        for(i = 0; i < subplotsWithAx.length; i++) {\n            sp = subplotsWithAx[i];\n            plotinfo = fullLayout._plots[sp];\n\n            var counterAxis = plotinfo[counterLetter + 'axis'];\n            var mainCounterID = counterAxis._mainAxis._id;\n            if(finishedGrids[mainCounterID]) continue;\n            finishedGrids[mainCounterID] = 1;\n\n            var gridPath = axLetter === 'x' ?\n                'M0,' + counterAxis._offset + 'v' + counterAxis._length :\n                'M' + counterAxis._offset + ',0h' + counterAxis._length;\n\n            axes.drawGrid(gd, ax, {\n                vals: gridVals,\n                counterAxis: counterAxis,\n                layer: plotinfo.gridlayer.select('.' + axId),\n                minorLayer: plotinfo.minorGridlayer.select('.' + axId),\n                path: gridPath,\n                transFn: transTickFn\n            });\n            axes.drawZeroLine(gd, ax, {\n                counterAxis: counterAxis,\n                layer: plotinfo.zerolinelayer,\n                path: gridPath,\n                transFn: transTickFn\n            });\n        }\n    }\n\n    var tickPath;\n\n    var majorTickSigns = axes.getTickSigns(ax);\n    var minorTickSigns = axes.getTickSigns(ax, 'minor');\n\n    if(ax.ticks || (ax.minor && ax.minor.ticks)) {\n        var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);\n        var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], { minor: true });\n\n        var mirrorMajorTickPath;\n        var mirrorMinorTickPath;\n\n        var fullMajorTickPath;\n        var fullMinorTickPath;\n\n        if(ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n            mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);\n            mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], { minor: true });\n\n            fullMajorTickPath = majorTickPath + mirrorMajorTickPath;\n            fullMinorTickPath = minorTickPath + mirrorMinorTickPath;\n        } else {\n            mirrorMajorTickPath = '';\n            mirrorMinorTickPath = '';\n            fullMajorTickPath = majorTickPath;\n            fullMinorTickPath = minorTickPath;\n        }\n\n        if(ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n            var dividerLookup = {};\n            for(i = 0; i < dividerVals.length; i++) {\n                dividerLookup[dividerVals[i].x] = 1;\n            }\n            tickPath = function(d) {\n                return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;\n            };\n        } else {\n            tickPath = function(d) {\n                return d.minor ? fullMinorTickPath : fullMajorTickPath;\n            };\n        }\n    }\n\n    axes.drawTicks(gd, ax, {\n        vals: tickVals,\n        layer: mainAxLayer,\n        path: tickPath,\n        transFn: transTickFn\n    });\n\n    if(ax.mirror === 'allticks') {\n        var tickSubplots = Object.keys(ax._linepositions || {});\n\n        for(i = 0; i < tickSubplots.length; i++) {\n            sp = tickSubplots[i];\n            plotinfo = fullLayout._plots[sp];\n            // [bottom or left, top or right], free and main are handled above\n            var linepositions = ax._linepositions[sp] || [];\n\n            var p0 = linepositions[0];\n            var p1 = linepositions[1];\n            var isMinor = linepositions[2];\n\n            var spTickPath =\n                axes.makeTickPath(ax, p0,\n                    isMinor ? majorTickSigns[0] : minorTickSigns[0],\n                    { minor: isMinor }\n                ) +\n                axes.makeTickPath(ax, p1,\n                    isMinor ? majorTickSigns[1] : minorTickSigns[1],\n                    { minor: isMinor }\n                );\n\n            axes.drawTicks(gd, ax, {\n                vals: tickVals,\n                layer: plotinfo[axLetter + 'axislayer'],\n                path: spTickPath,\n                transFn: transTickFn\n            });\n        }\n    }\n\n    var seq = [];\n\n    // tick labels - for now just the main labels.\n    // TODO: mirror labels, esp for subplots\n\n    seq.push(function() {\n        return axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: mainAxLayer,\n            plotinfo: plotinfo,\n            transFn: transTickLabelFn,\n            labelFns: axes.makeLabelFns(ax, mainLinePositionShift)\n        });\n    });\n\n    if(ax.type === 'multicategory') {\n        var pad = {x: 2, y: 10}[axLetter];\n\n        seq.push(function() {\n            var bboxKey = {x: 'height', y: 'width'}[axLetter];\n            var standoff = getLabelLevelBbox()[bboxKey] + pad +\n                (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n\n            return axes.drawLabels(gd, ax, {\n                vals: getSecondaryLabelVals(ax, vals),\n                layer: mainAxLayer,\n                cls: axId + 'tick2',\n                repositionOnUpdate: true,\n                secondary: true,\n                transFn: transTickFn,\n                labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])\n            });\n        });\n\n        seq.push(function() {\n            ax._depth = majorTickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePositionShift);\n\n            return drawDividers(gd, ax, {\n                vals: dividerVals,\n                layer: mainAxLayer,\n                path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], { len: ax._depth }),\n                transFn: transTickFn\n            });\n        });\n    } else if(ax.title.hasOwnProperty('standoff')) {\n        seq.push(function() {\n            ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);\n        });\n    }\n\n    var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n\n    if(!opts.skipTitle &&\n        !(hasRangeSlider && ax.side === 'bottom')\n    ) {\n        seq.push(function() { return drawTitle(gd, ax); });\n    }\n\n    seq.push(function() {\n        var s = ax.side.charAt(0);\n        var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n        var pos = axes.getPxPosition(gd, ax);\n        var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n        var llbbox;\n\n        var push;\n        var mirrorPush;\n        var rangeSliderPush;\n\n        if(ax.automargin || hasRangeSlider || ax._shiftPusher) {\n            if(ax.type === 'multicategory') {\n                llbbox = getLabelLevelBbox('tick2');\n            } else {\n                llbbox = getLabelLevelBbox();\n                if(axLetter === 'x' && s === 'b') {\n                    ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n                }\n            }\n        }\n\n        var axDepth = 0;\n        var titleDepth = 0;\n        if(ax._shiftPusher) {\n            axDepth = Math.max(\n                outsideTickLen,\n                llbbox.height > 0 ? (s === 'l' ? pos - llbbox.left : llbbox.right - pos) : 0\n            );\n            if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n                titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);\n                if(s === 'l') {\n                    titleDepth += approxTitleDepth(ax);\n                }\n            }\n\n            ax._fullDepth = Math.max(axDepth, titleDepth);\n        }\n\n        if(ax.automargin) {\n            push = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n            var domainIndices = [0, 1];\n            var shift = typeof ax._shift === 'number' ? ax._shift : 0;\n            if(axLetter === 'x') {\n                if(s === 'b') {\n                    push[s] = ax._depth;\n                } else {\n                    push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n                    domainIndices.reverse();\n                }\n\n                if(llbbox.width > 0) {\n                    var rExtra = llbbox.right - (ax._offset + ax._length);\n                    if(rExtra > 0) {\n                        push.xr = 1;\n                        push.r = rExtra;\n                    }\n                    var lExtra = ax._offset - llbbox.left;\n                    if(lExtra > 0) {\n                        push.xl = 0;\n                        push.l = lExtra;\n                    }\n                }\n            } else {\n                if(s === 'l') {\n                    ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n                    push[s] = ax._depth - shift;\n                } else {\n                    ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n                    push[s] = ax._depth + shift;\n                    domainIndices.reverse();\n                }\n\n                if(llbbox.height > 0) {\n                    var bExtra = llbbox.bottom - (ax._offset + ax._length);\n                    if(bExtra > 0) {\n                        push.yb = 0;\n                        push.b = bExtra;\n                    }\n                    var tExtra = ax._offset - llbbox.top;\n                    if(tExtra > 0) {\n                        push.yt = 1;\n                        push.t = tExtra;\n                    }\n                }\n            }\n\n            push[counterLetter] = ax.anchor === 'free' ?\n                ax.position :\n                ax._anchorAxis.domain[domainIndices[0]];\n\n            if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n                push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n            }\n\n            if(ax.mirror && ax.anchor !== 'free') {\n                mirrorPush = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n\n                mirrorPush[sMirror] = ax.linewidth;\n                if(ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n\n                if(ax.mirror === true || ax.mirror === 'ticks') {\n                    mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n                } else if(ax.mirror === 'all' || ax.mirror === 'allticks') {\n                    mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n                }\n            }\n        }\n        if(hasRangeSlider) {\n            rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n        }\n\n        if(typeof ax.automargin === 'string') {\n            filterPush(push, ax.automargin);\n            filterPush(mirrorPush, ax.automargin);\n        }\n\n        Plots.autoMargin(gd, axAutoMarginID(ax), push);\n        Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n        Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n    });\n\n    return Lib.syncOrAsync(seq);\n};\n\nfunction filterPush(push, automargin) {\n    if(!push) return;\n\n    var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function(data, nextKey) {\n        if(automargin.indexOf(nextKey) !== -1) {\n            MARGIN_MAPPING[nextKey].forEach(function(key) { data[key] = 1;});\n        }\n        return data;\n    }, {});\n    Object.keys(push).forEach(function(key) {\n        if(!keepMargin[key]) {\n            if(key.length === 1) push[key] = 0;\n            else delete push[key];\n        }\n    });\n}\n\nfunction getBoundaryVals(ax, vals) {\n    var out = [];\n    var i;\n\n    // boundaryVals are never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            _push(vals[i], 0);\n        }\n        _push(vals[i - 1], 1);\n    }\n\n    return out;\n}\n\nfunction getSecondaryLabelVals(ax, vals) {\n    var out = [];\n    var lookup = {};\n\n    for(var i = 0; i < vals.length; i++) {\n        var d = vals[i];\n        if(lookup[d.text2]) {\n            lookup[d.text2].push(d.x);\n        } else {\n            lookup[d.text2] = [d.x];\n        }\n    }\n\n    for(var k in lookup) {\n        out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n    }\n\n    return out;\n}\n\nfunction getDividerVals(ax, vals) {\n    var out = [];\n    var i, current;\n\n    var reversed = (vals.length && vals[vals.length - 1].x < vals[0].x);\n\n    // never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(ax.showdividers && vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            var d = vals[i];\n            if(d.text2 !== current) {\n                _push(d, reversed ? 1 : 0);\n            }\n            current = d.text2;\n        }\n        _push(vals[i - 1], reversed ? 0 : 1);\n    }\n\n    return out;\n}\n\nfunction calcLabelLevelBbox(ax, cls, mainLinePositionShift) {\n    var top, bottom;\n    var left, right;\n\n    if(ax._selections[cls].size()) {\n        top = Infinity;\n        bottom = -Infinity;\n        left = Infinity;\n        right = -Infinity;\n        ax._selections[cls].each(function() {\n            var thisLabel = selectTickLabel(this);\n            // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n            // retrieve a bbox computed with transform info\n            //\n            // To improve perf, it would be nice to use `thisLabel.node()`\n            // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n            // together with the makeLabelFns outputs and `tickangle`\n            // to compute one bbox per (tick value x tick style)\n            var bb = Drawing.bBox(thisLabel.node().parentNode);\n            top = Math.min(top, bb.top);\n            bottom = Math.max(bottom, bb.bottom);\n            left = Math.min(left, bb.left);\n            right = Math.max(right, bb.right);\n        });\n    } else {\n        var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);\n        top = bottom = dummyCalc.yFn({dx: 0, dy: 0, fontSize: 0});\n        left = right = dummyCalc.xFn({dx: 0, dy: 0, fontSize: 0});\n    }\n\n    return {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right,\n        height: bottom - top,\n        width: right - left\n    };\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\naxes.getTickSigns = function(ax, minor) {\n    var axLetter = ax._id.charAt(0);\n    var sideOpposite = {x: 'top', y: 'right'}[axLetter];\n    var main = ax.side === sideOpposite ? 1 : -1;\n    var out = [-1, 1, main, -main];\n    // then we flip if outside XOR y axis\n\n    var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;\n    if((ticks !== 'inside') === (axLetter === 'x')) {\n        out = out.map(function(v) { return -v; });\n    }\n    // independent of `ticks`; do not flip this one\n    if(ax.side) {\n        out.push({l: -1, t: -1, r: 1, b: 1}[ax.side.charAt(0)]);\n    }\n    return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransTickFn = function(ax) {\n    return ax._id.charAt(0) === 'x' ?\n        function(d) { return strTranslate(ax._offset + ax.l2p(d.x), 0); } :\n        function(d) { return strTranslate(0, ax._offset + ax.l2p(d.x)); };\n};\n\naxes.makeTransTickLabelFn = function(ax) {\n    var uv = getTickLabelUV(ax);\n    var shift = ax.ticklabelshift || 0;\n    var standoff = ax.ticklabelstandoff || 0;\n\n    var u = uv[0];\n    var v = uv[1];\n\n    var isReversed = ax.range[0] > ax.range[1];\n    var labelsInside = ax.ticklabelposition && ax.ticklabelposition.indexOf('inside') !== -1;\n    var labelsOutside = !labelsInside;\n\n    if(shift) {\n        var shiftSign = isReversed ? -1 : 1;\n        shift = shift * shiftSign;\n    }\n    if(standoff) {\n        var side = ax.side;\n        var standoffSign = (\n            (labelsInside && (side === 'top' || side === 'left')) ||\n            (labelsOutside && (side === 'bottom' || side === 'right'))\n        ) ? 1 : -1;\n        standoff = standoff * standoffSign;\n    }\n    return ax._id.charAt(0) === 'x' ?\n        function(d) {\n            return strTranslate(\n                u + ax._offset + ax.l2p(getPosX(d)) + shift,\n                v + standoff\n            );\n        } :\n        function(d) {\n            return strTranslate(\n                v + standoff,\n                u + ax._offset + ax.l2p(getPosX(d)) + shift\n            );\n        };\n};\n\nfunction getPosX(d) {\n    return d.periodX !== undefined ? d.periodX : d.x;\n}\n\n// u is a shift along the axis,\n// v is a shift perpendicular to the axis\nfunction getTickLabelUV(ax) {\n    var ticklabelposition = ax.ticklabelposition || '';\n    var has = function(str) {\n        return ticklabelposition.indexOf(str) !== -1;\n    };\n\n    var isTop = has('top');\n    var isLeft = has('left');\n    var isRight = has('right');\n    var isBottom = has('bottom');\n    var isInside = has('inside');\n\n    var isAligned = isBottom || isLeft || isTop || isRight;\n\n    // early return\n    if(!isAligned && !isInside) return [0, 0];\n\n    var side = ax.side;\n\n    var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n    var v = TEXTPAD;\n\n    var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    if(isBottom || isTop) {\n        u += fontSize * CAP_SHIFT;\n        v += (ax.linewidth || 0) / 2;\n    }\n    if(isLeft || isRight) {\n        u += (ax.linewidth || 0) / 2;\n        v += TEXTPAD;\n    }\n    if(isInside && side === 'top') {\n        v -= fontSize * (1 - CAP_SHIFT);\n    }\n\n    if(isLeft || isTop) u = -u;\n    if(side === 'bottom' || side === 'right') v = -v;\n\n    return [\n        isAligned ? u : 0,\n        isInside ? v : 0\n    ];\n}\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {object} opts\n * - {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function(ax, shift, sgn, opts) {\n    if(!opts) opts = {};\n    var minor = opts.minor;\n    if(minor && !ax.minor) return '';\n\n    var len = opts.len !== undefined ? opts.len :\n        minor ? ax.minor.ticklen : ax.ticklen;\n\n    var axLetter = ax._id.charAt(0);\n    var pad = (ax.linewidth || 1) / 2;\n\n    return axLetter === 'x' ?\n        'M0,' + (shift + pad * sgn) + 'v' + (len * sgn) :\n        'M' + (shift + pad * sgn) + ',0h' + (len * sgn);\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\naxes.makeLabelFns = function(ax, shift, angle) {\n    var ticklabelposition = ax.ticklabelposition || '';\n    var has = function(str) {\n        return ticklabelposition.indexOf(str) !== -1;\n    };\n\n    var isTop = has('top');\n    var isLeft = has('left');\n    var isRight = has('right');\n    var isBottom = has('bottom');\n    var isAligned = isBottom || isLeft || isTop || isRight;\n\n    var insideTickLabels = has('inside');\n    var labelsOverTicks =\n        (ticklabelposition === 'inside' && ax.ticks === 'inside') ||\n        (!insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries');\n\n    var labelStandoff = 0;\n    var labelShift = 0;\n\n    var tickLen = labelsOverTicks ? ax.ticklen : 0;\n    if(insideTickLabels) {\n        tickLen *= -1;\n    } else if(isAligned) {\n        tickLen = 0;\n    }\n\n    if(labelsOverTicks) {\n        labelStandoff += tickLen;\n        if(angle) {\n            var rad = Lib.deg2rad(angle);\n            labelStandoff = tickLen * Math.cos(rad) + 1;\n            labelShift = tickLen * Math.sin(rad);\n        }\n    }\n\n    if(ax.showticklabels && (labelsOverTicks || ax.showline)) {\n        labelStandoff += 0.2 * ax.tickfont.size;\n    }\n    labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n\n    var out = {\n        labelStandoff: labelStandoff,\n        labelShift: labelShift\n    };\n\n    var x0, y0, ff, flipIt;\n    var xQ = 0;\n\n    var side = ax.side;\n    var axLetter = ax._id.charAt(0);\n    var tickangle = ax.tickangle;\n    var endSide;\n    if(axLetter === 'x') {\n        endSide =\n            (!insideTickLabels && side === 'bottom') ||\n            (insideTickLabels && side === 'top');\n\n        flipIt = endSide ? 1 : -1;\n        if(insideTickLabels) flipIt *= -1;\n\n        x0 = labelShift * flipIt;\n        y0 = shift + labelStandoff * flipIt;\n        ff = endSide ? 1 : -0.2;\n        if(Math.abs(tickangle) === 90) {\n            if(insideTickLabels) {\n                ff += MID_SHIFT;\n            } else {\n                if(tickangle === -90 && side === 'bottom') {\n                    ff = CAP_SHIFT;\n                } else if(tickangle === 90 && side === 'top') {\n                    ff = MID_SHIFT;\n                } else {\n                    ff = 0.5;\n                }\n            }\n\n            xQ = (MID_SHIFT / 2) * (tickangle / 90);\n        }\n\n        out.xFn = function(d) { return d.dx + x0 + xQ * d.fontSize; };\n        out.yFn = function(d) { return d.dy + y0 + d.fontSize * ff; };\n        out.anchorFn = function(d, a) {\n            if(isAligned) {\n                if(isLeft) return 'end';\n                if(isRight) return 'start';\n            }\n\n            if(!isNumeric(a) || a === 0 || a === 180) {\n                return 'middle';\n            }\n\n            return ((a * flipIt < 0) !== insideTickLabels) ? 'end' : 'start';\n        };\n        out.heightFn = function(d, a, h) {\n            return (a < -60 || a > 60) ? -0.5 * h :\n                ((ax.side === 'top') !== insideTickLabels) ? -h :\n                0;\n        };\n    } else if(axLetter === 'y') {\n        endSide =\n            (!insideTickLabels && side === 'left') ||\n            (insideTickLabels && side === 'right');\n\n        flipIt = endSide ? 1 : -1;\n        if(insideTickLabels) flipIt *= -1;\n\n        x0 = labelStandoff;\n        y0 = labelShift * flipIt;\n        ff = 0;\n        if(!insideTickLabels && Math.abs(tickangle) === 90) {\n            if(\n                (tickangle === -90 && side === 'left') ||\n                (tickangle === 90 && side === 'right')\n            ) {\n                ff = CAP_SHIFT;\n            } else {\n                ff = 0.5;\n            }\n        }\n\n        if(insideTickLabels) {\n            var ang = isNumeric(tickangle) ? +tickangle : 0;\n            if(ang !== 0) {\n                var rA = Lib.deg2rad(ang);\n                xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n                ff = 0;\n            }\n        }\n\n        out.xFn = function(d) { return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize; };\n        out.yFn = function(d) { return d.dy + y0 + d.fontSize * MID_SHIFT; };\n        out.anchorFn = function(d, a) {\n            if(isNumeric(a) && Math.abs(a) === 90) {\n                return 'middle';\n            }\n\n            return endSide ? 'end' : 'start';\n        };\n        out.heightFn = function(d, a, h) {\n            if(ax.side === 'right') a *= -1;\n\n            return a < -30 ? -h :\n                a < 30 ? -0.5 * h :\n                0;\n        };\n    }\n\n    return out;\n};\n\nfunction tickDataFn(d) {\n    return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var cls = ax._id + 'tick';\n\n    var vals = []\n        .concat(ax.minor && ax.minor.ticks ?\n            // minor vals\n            opts.vals.filter(function(d) { return d.minor && !d.noTick; }) :\n            []\n        )\n        .concat(ax.ticks ?\n            // major vals\n            opts.vals.filter(function(d) { return !d.minor && !d.noTick; }) :\n            []\n        );\n\n    var ticks = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    ticks.exit().remove();\n\n    ticks.enter().append('path')\n        .classed(cls, 1)\n        .classed('ticks', 1)\n        .classed('crisp', opts.crisp !== false)\n        .each(function(d) {\n            return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);\n        })\n        .style('stroke-width', function(d) {\n            return Drawing.crispRound(\n                gd,\n                d.minor ? ax.minor.tickwidth : ax.tickwidth,\n                1\n            ) + 'px';\n        })\n        .attr('d', opts.path)\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n\n    ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {string} griddash\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function(gd, ax, opts) {\n    opts = opts || {};\n\n    if(ax.tickmode === 'sync') {\n        // for tickmode sync we use the overlaying axis grid\n        return;\n    }\n\n    var cls = ax._id + 'grid';\n\n    var hasMinor = ax.minor && ax.minor.showgrid;\n    var minorVals = hasMinor ? opts.vals.filter(function(d) { return d.minor; }) : [];\n    var majorVals = ax.showgrid ? opts.vals.filter(function(d) { return !d.minor; }) : [];\n\n    var counterAx = opts.counterAxis;\n    if(counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n        var isArrayMode = ax.tickmode === 'array';\n        for(var i = 0; i < majorVals.length; i++) {\n            var xi = majorVals[i].x;\n            if(isArrayMode ? !xi : (Math.abs(xi) < ax.dtick / 100)) {\n                majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));\n                // In array mode you can in principle have multiple\n                // ticks at 0, so test them all. Otherwise once we found\n                // one we can stop.\n                if(isArrayMode) i--;\n                else break;\n            }\n        }\n    }\n\n    ax._gw =\n        Drawing.crispRound(gd, ax.gridwidth, 1);\n\n    var wMinor = !hasMinor ? 0 :\n        Drawing.crispRound(gd, ax.minor.gridwidth, 1);\n\n    var majorLayer = opts.layer;\n    var minorLayer = opts.minorLayer;\n    for(var major = 1; major >= 0; major--) {\n        var layer = major ? majorLayer : minorLayer;\n        if(!layer) continue;\n\n        var grid = layer.selectAll('path.' + cls)\n            .data(major ? majorVals : minorVals, tickDataFn);\n\n        grid.exit().remove();\n\n        grid.enter().append('path')\n            .classed(cls, 1)\n            .classed('crisp', opts.crisp !== false);\n\n        grid.attr('transform', opts.transFn)\n            .attr('d', opts.path)\n            .each(function(d) {\n                return Color.stroke(d3.select(this), d.minor ?\n                    ax.minor.gridcolor :\n                    (ax.gridcolor || '#ddd')\n                );\n            })\n            .style('stroke-dasharray', function(d) {\n                return Drawing.dashStyle(\n                    d.minor ? ax.minor.griddash : ax.griddash,\n                    d.minor ? ax.minor.gridwidth : ax.gridwidth\n                );\n            })\n            .style('stroke-width', function(d) {\n                return (d.minor ? wMinor : ax._gw) + 'px';\n            })\n            .style('display', null); // visible\n\n        if(typeof opts.path === 'function') grid.attr('d', opts.path);\n    }\n\n    hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function(gd, ax, opts) {\n    opts = opts || opts;\n\n    var cls = ax._id + 'zl';\n    var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n\n    var zl = opts.layer.selectAll('path.' + cls)\n        .data(show ? [{x: 0, id: ax._id}] : []);\n\n    zl.exit().remove();\n\n    zl.enter().append('path')\n        .classed(cls, 1)\n        .classed('zl', 1)\n        .classed('crisp', opts.crisp !== false)\n        .each(function() {\n            // use the fact that only one element can enter to trigger a sort.\n            // If several zerolines enter at the same time we will sort once per,\n            // but generally this should be a minimal overhead.\n            opts.layer.selectAll('path').sort(function(da, db) {\n                return idSort(da.id, db.id);\n            });\n        });\n\n    zl.attr('transform', opts.transFn)\n        .attr('d', opts.path)\n        .call(Color.stroke, ax.zerolinecolor || Color.defaultLine)\n        .style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px')\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\naxes.drawLabels = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var cls = opts.cls || axId + 'tick';\n\n    var vals = opts.vals.filter(function(d) { return d.text; });\n\n    var labelFns = opts.labelFns;\n    var tickAngle = opts.secondary ? 0 : ax.tickangle;\n\n    var prevAngle = (ax._prevTickAngles || {})[cls];\n\n    var tickLabels = opts.layer.selectAll('g.' + cls)\n        .data(ax.showticklabels ? vals : [], tickDataFn);\n\n    var labelsReady = [];\n\n    tickLabels.enter().append('g')\n        .classed(cls, 1)\n        .append('text')\n            // only so tex has predictable alignment that we can\n            // alter later\n            .attr('text-anchor', 'middle')\n            .each(function(d) {\n                var thisLabel = d3.select(this);\n                var newPromise = gd._promises.length;\n\n                thisLabel\n                    .call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d))\n                    .call(Drawing.font, {\n                        family: d.font,\n                        size: d.fontSize,\n                        color: d.fontColor,\n                        weight: d.fontWeight,\n                        style: d.fontStyle,\n                        variant: d.fontVariant,\n                        textcase: d.fontTextcase,\n                        lineposition: d.fontLineposition,\n                        shadow: d.fontShadow,\n                    })\n                    .text(d.text)\n                    .call(svgTextUtils.convertToTspans, gd);\n\n                if(gd._promises[newPromise]) {\n                    // if we have an async label, we'll deal with that\n                    // all here so take it out of gd._promises and\n                    // instead position the label and promise this in\n                    // labelsReady\n                    labelsReady.push(gd._promises.pop().then(function() {\n                        positionLabels(thisLabel, tickAngle);\n                    }));\n                } else {\n                    // sync label: just position it now.\n                    positionLabels(thisLabel, tickAngle);\n                }\n            });\n\n    hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n\n    tickLabels.exit().remove();\n\n    if(opts.repositionOnUpdate) {\n        tickLabels.each(function(d) {\n            d3.select(this).select('text')\n                .call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n        });\n    }\n\n    function positionLabels(s, angle) {\n        s.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n            var anchor = labelFns.anchorFn(d, angle);\n\n            var transform = opts.transFn.call(thisLabel.node(), d) +\n                ((isNumeric(angle) && +angle !== 0) ?\n                (' rotate(' + angle + ',' + labelFns.xFn(d) + ',' +\n                    (labelFns.yFn(d) - d.fontSize / 2) + ')') :\n                '');\n\n            // how much to shift a multi-line label to center it vertically.\n            var nLines = svgTextUtils.lineCount(thisLabel);\n            var lineHeight = LINE_SPACING * d.fontSize;\n            var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n\n            if(anchorHeight) {\n                transform += strTranslate(0, anchorHeight);\n            }\n\n            if(mathjaxGroup.empty()) {\n                var thisText = thisLabel.select('text');\n                thisText.attr({\n                    transform: transform,\n                    'text-anchor': anchor\n                });\n\n                thisText.style('opacity', 1); // visible\n\n                if(ax._adjustTickLabelsOverflow) {\n                    ax._adjustTickLabelsOverflow();\n                }\n            } else {\n                var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n                var mjShift = mjWidth * {end: -0.5, start: 0.5}[anchor];\n                mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n            }\n        });\n    }\n\n    ax._adjustTickLabelsOverflow = function() {\n        var ticklabeloverflow = ax.ticklabeloverflow;\n        if(!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n\n        var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n\n        var isX = ax._id.charAt(0) === 'x';\n        // div positions\n        var p0 = 0;\n        var p1 = isX ?\n            gd._fullLayout.width :\n            gd._fullLayout.height;\n\n        if(ticklabeloverflow.indexOf('domain') !== -1) {\n            // domain positions\n            var rl = Lib.simpleMap(ax.range, ax.r2l);\n            p0 = ax.l2p(rl[0]) + ax._offset;\n            p1 = ax.l2p(rl[1]) + ax._offset;\n        }\n\n        var min = Math.min(p0, p1);\n        var max = Math.max(p0, p1);\n\n        var side = ax.side;\n\n        var visibleLabelMin = Infinity;\n        var visibleLabelMax = -Infinity;\n\n        tickLabels.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n\n            if(mathjaxGroup.empty()) {\n                var bb = Drawing.bBox(thisLabel.node());\n                var adjust = 0;\n                if(isX) {\n                    if(bb.right > max) adjust = 1;\n                    else if(bb.left < min) adjust = 1;\n                } else {\n                    if(bb.bottom > max) adjust = 1;\n                    else if(bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n                }\n\n                var t = thisLabel.select('text');\n                if(adjust) {\n                    if(hideOverflow) t.style('opacity', 0); // hidden\n                } else {\n                    t.style('opacity', 1); // visible\n\n                    if(side === 'bottom' || side === 'right') {\n                        visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n                    } else {\n                        visibleLabelMin = -Infinity;\n                    }\n\n                    if(side === 'top' || side === 'left') {\n                        visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n                    } else {\n                        visibleLabelMax = Infinity;\n                    }\n                }\n            } // TODO: hide mathjax?\n        });\n\n        for(var subplot in fullLayout._plots) {\n            var plotinfo = fullLayout._plots[subplot];\n            if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n            var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n            if(anchorAx) {\n                anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n                anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n            }\n        }\n    };\n\n    ax._hideCounterAxisInsideTickLabels = function(partialOpts) {\n        var isX = ax._id.charAt(0) === 'x';\n\n        var anchoredAxes = [];\n        for(var subplot in fullLayout._plots) {\n            var plotinfo = fullLayout._plots[subplot];\n            if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n            anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n        }\n\n        anchoredAxes.forEach(function(anchorAx, idx) {\n            if(anchorAx && insideTicklabelposition(anchorAx)) {\n                (partialOpts || [\n                    ZERO_PATH,\n                    MINORGRID_PATH,\n                    GRID_PATH,\n                    TICK_PATH,\n                    TICK_TEXT\n                ]).forEach(function(e) {\n                    var isPeriodLabel =\n                        e.K === 'tick' &&\n                        e.L === 'text' &&\n                        ax.ticklabelmode === 'period';\n\n                    var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n                    var sel;\n                    if(e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');\n                    else if(e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll('.' + ax._id);\n                    else if(e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);\n                    else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n\n                    sel.each(function() {\n                        var w = d3.select(this);\n                        if(e.L) w = w.selectAll(e.L);\n\n                        w.each(function(d) {\n                            var q = ax.l2p(\n                                isPeriodLabel ? getPosX(d) : d.x\n                            ) + ax._offset;\n\n                            var t = d3.select(this);\n                            if(\n                                q < ax['_visibleLabelMax_' + anchorAx._id] &&\n                                q > ax['_visibleLabelMin_' + anchorAx._id]\n                            ) {\n                                t.style('display', 'none'); // hidden\n                            } else if(e.K === 'tick' && !idx) {\n                                t.style('display', null); // visible\n                            }\n                        });\n                    });\n                });\n            }\n        });\n    };\n\n    // make sure all labels are correctly positioned at their base angle\n    // the positionLabels call above is only for newly drawn labels.\n    // do this without waiting, using the last calculated angle to\n    // minimize flicker, then do it again when we know all labels are\n    // there, putting back the prescribed angle to check for overlaps.\n    positionLabels(tickLabels, (prevAngle + 1) ? prevAngle : tickAngle);\n\n    function allLabelsReady() {\n        return labelsReady.length && Promise.all(labelsReady);\n    }\n\n    var autoangle = null;\n\n    function fixLabelOverlaps() {\n        positionLabels(tickLabels, tickAngle);\n\n        // check for auto-angling if x labels overlap\n        // don't auto-angle at all for log axes with\n        // base and digit format\n        if(vals.length && ax.autotickangles &&\n            (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')\n        ) {\n            autoangle = ax.autotickangles[0];\n\n            var maxFontSize = 0;\n            var lbbArray = [];\n            var i;\n            var maxLines = 1;\n            tickLabels.each(function(d) {\n                maxFontSize = Math.max(maxFontSize, d.fontSize);\n\n                var x = ax.l2p(d.x);\n                var thisLabel = selectTickLabel(this);\n                var bb = Drawing.bBox(thisLabel.node());\n                maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));\n\n                lbbArray.push({\n                    // ignore about y, just deal with x overlaps\n                    top: 0,\n                    bottom: 10,\n                    height: 10,\n                    left: x - bb.width / 2,\n                    // impose a 2px gap\n                    right: x + bb.width / 2 + 2,\n                    width: bb.width + 2\n                });\n            });\n\n            // autotickangles\n            // if there are dividers or ticks on boundaries, the labels will be in between and\n            // we need to prevent overlap with the next divider/tick. Else the labels will be on\n            // the ticks and we need to prevent overlap with the next label.\n\n            // TODO should secondary labels also fall into this fix-overlap regime?\n            var preventOverlapWithTick = (ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary;\n\n            var vLen = vals.length;\n            var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n\n            var adjacent = preventOverlapWithTick ? tickSpacing / 2 : tickSpacing;\n            var opposite = preventOverlapWithTick ? ax.ticklen : maxFontSize * 1.25 * maxLines;\n            var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));\n            var maxCos = adjacent / hypotenuse;\n            var autoTickAnglesRadians = ax.autotickangles.map(\n                function(degrees) { return degrees * Math.PI / 180; }\n            );\n            var angleRadians = autoTickAnglesRadians.find(\n                function(angle) { return Math.abs(Math.cos(angle)) <= maxCos; }\n            );\n            if(angleRadians === undefined) {\n                // no angle with smaller cosine than maxCos, just pick the angle with smallest cosine\n                angleRadians = autoTickAnglesRadians.reduce(\n                    function(currentMax, nextAngle) {\n                        return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;\n                    }\n                    , autoTickAnglesRadians[0]\n                );\n            }\n            var newAngle = angleRadians * (180 / Math.PI /* to degrees */);\n\n            if(preventOverlapWithTick) {\n                var gap = 2;\n                if(ax.ticks) gap += ax.tickwidth / 2;\n\n                for(i = 0; i < lbbArray.length; i++) {\n                    var xbnd = vals[i].xbnd;\n                    var lbb = lbbArray[i];\n                    if(\n                        (xbnd[0] !== null && (lbb.left - ax.l2p(xbnd[0])) < gap) ||\n                        (xbnd[1] !== null && (ax.l2p(xbnd[1]) - lbb.right) < gap)\n                    ) {\n                        autoangle = newAngle;\n                        break;\n                    }\n                }\n            } else {\n                var ticklabelposition = ax.ticklabelposition || '';\n                var has = function(str) {\n                    return ticklabelposition.indexOf(str) !== -1;\n                };\n                var isTop = has('top');\n                var isLeft = has('left');\n                var isRight = has('right');\n                var isBottom = has('bottom');\n                var isAligned = isBottom || isLeft || isTop || isRight;\n                var pad = !isAligned ? 0 :\n                (ax.tickwidth || 0) + 2 * TEXTPAD;\n\n                for(i = 0; i < lbbArray.length - 1; i++) {\n                    if(Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n                        autoangle = newAngle;\n                        break;\n                    }\n                }\n            }\n\n            if(autoangle) {\n                positionLabels(tickLabels, autoangle);\n            }\n        }\n    }\n\n    if(ax._selections) {\n        ax._selections[cls] = tickLabels;\n    }\n\n    var seq = [allLabelsReady];\n\n    // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n    // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n    // as this can lead to infinite redraw loops!\n    if(ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n        autoangle = prevAngle;\n        seq.push(function() {\n            positionLabels(tickLabels, prevAngle);\n        });\n    } else {\n        seq.push(fixLabelOverlaps);\n    }\n\n    // save current tick angle for future redraws\n    if(ax._tickAngles) {\n        seq.push(function() {\n            ax._tickAngles[cls] = autoangle === null ?\n                (isNumeric(tickAngle) ? tickAngle : 0) :\n                autoangle;\n        });\n    }\n\n    var computeTickLabelBoundingBoxes = function() {\n        var labelsMaxW = 0;\n        var labelsMaxH = 0;\n        tickLabels.each(function(d, i) {\n            var thisLabel = selectTickLabel(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n\n            if(mathjaxGroup.empty()) {\n                var bb;\n\n                if(ax._vals[i]) {\n                    bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());\n                    ax._vals[i].bb = bb;\n                }\n\n                labelsMaxW = Math.max(labelsMaxW, bb.width);\n                labelsMaxH = Math.max(labelsMaxH, bb.height);\n            }\n        });\n\n        return {\n            labelsMaxW: labelsMaxW,\n            labelsMaxH: labelsMaxH\n        };\n    };\n\n    var anchorAx = ax._anchorAxis;\n    if(\n        anchorAx && (anchorAx.autorange || anchorAx.insiderange) &&\n        insideTicklabelposition(ax) &&\n        !isLinked(fullLayout, ax._id)\n    ) {\n        if(!fullLayout._insideTickLabelsUpdaterange) {\n            fullLayout._insideTickLabelsUpdaterange = {};\n        }\n\n        if(anchorAx.autorange) {\n            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n\n            seq.push(computeTickLabelBoundingBoxes);\n        }\n\n        if(anchorAx.insiderange) {\n            var BBs = computeTickLabelBoundingBoxes();\n            var move = ax._id.charAt(0) === 'y' ?\n                BBs.labelsMaxW :\n                BBs.labelsMaxH;\n\n            move += 2 * TEXTPAD;\n\n            if(ax.ticklabelposition === 'inside') {\n                move += ax.ticklen || 0;\n            }\n\n            var sgn = (ax.side === 'right' || ax.side === 'top') ? 1 : -1;\n            var index = sgn === 1 ? 1 : 0;\n            var otherIndex = sgn === 1 ? 0 : 1;\n\n            var newRange = [];\n            newRange[otherIndex] = anchorAx.range[otherIndex];\n\n            var anchorAxRange = anchorAx.range;\n\n            var p0 = anchorAx.r2p(anchorAxRange[index]);\n            var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);\n\n            var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'];\n            if(_tempNewRange) { // case of having multiple anchored axes having insideticklabel\n                var q0 = anchorAx.r2p(_tempNewRange[index]);\n                var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);\n\n                var dir = sgn * (ax._id.charAt(0) === 'y' ? 1 : -1);\n\n                if(dir * p0 < dir * q0) {\n                    p0 = q0;\n                    newRange[index] = anchorAxRange[index] = _tempNewRange[index];\n                }\n\n                if(dir * p1 > dir * q1) {\n                    p1 = q1;\n                    newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];\n                }\n            }\n\n            var dist = Math.abs(p1 - p0);\n            if(dist - move > 0) {\n                dist -= move;\n                move *= 1 + move / dist;\n            } else {\n                move = 0;\n            }\n\n            if(ax._id.charAt(0) !== 'y') move = -move;\n\n            newRange[index] = anchorAx.p2r(\n                anchorAx.r2p(anchorAxRange[index]) +\n                sgn * move\n            );\n\n            // handle partial ranges in insiderange\n            if(\n                anchorAx.autorange === 'min' ||\n                anchorAx.autorange === 'max reversed'\n            ) {\n                newRange[0] = null;\n\n                anchorAx._rangeInitial0 = undefined;\n                anchorAx._rangeInitial1 = undefined;\n            } else if(\n                anchorAx.autorange === 'max' ||\n                anchorAx.autorange === 'min reversed'\n            ) {\n                newRange[1] = null;\n\n                anchorAx._rangeInitial0 = undefined;\n                anchorAx._rangeInitial1 = undefined;\n            }\n\n            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'] = newRange;\n        }\n    }\n\n    var done = Lib.syncOrAsync(seq);\n    if(done && done.then) gd._promises.push(done);\n    return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n    var cls = ax._id + 'divider';\n    var vals = opts.vals;\n\n    var dividers = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    dividers.exit().remove();\n\n    dividers.enter().insert('path', ':first-child')\n        .classed(cls, 1)\n        .classed('crisp', 1)\n        .call(Color.stroke, ax.dividercolor)\n        .style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n\n    dividers\n        .attr('transform', opts.transFn)\n        .attr('d', opts.path);\n}\n\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\naxes.getPxPosition = function(gd, ax) {\n    var gs = gd._fullLayout._size;\n    var axLetter = ax._id.charAt(0);\n    var side = ax.side;\n    var anchorAxis;\n\n    if(ax.anchor !== 'free') {\n        anchorAxis = ax._anchorAxis;\n    } else if(axLetter === 'x') {\n        anchorAxis = {\n            _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n            _length: 0\n        };\n    } else if(axLetter === 'y') {\n        anchorAxis = {\n            _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,\n            _length: 0\n        };\n    }\n\n    if(side === 'top' || side === 'left') {\n        return anchorAxis._offset;\n    } else if(side === 'bottom' || side === 'right') {\n        return anchorAxis._offset + anchorAxis._length;\n    }\n};\n\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\nfunction approxTitleDepth(ax) {\n    var fontSize = ax.title.font.size;\n    var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n    if(ax.title.hasOwnProperty('standoff')) {\n        return fontSize * (CAP_SHIFT + (extraLines * LINE_SPACING));\n    } else {\n        return extraLines ?\n            fontSize * (extraLines + 1) * LINE_SPACING :\n            fontSize;\n    }\n}\n\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\nfunction drawTitle(gd, ax) {\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var fontSize = ax.title.font.size;\n    var titleStandoff;\n    var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n\n    if(ax.title.hasOwnProperty('standoff')) {\n        // With ax._depth the initial drawing baseline is at the outer axis border (where the\n        // ticklabels are drawn). Since the title text will be drawn above the baseline,\n        // bottom/right axes must be shifted by 1 text line to draw below ticklabels instead of on\n        // top of them, whereas for top/left axes, the first line would be drawn\n        // before the ticklabels, but we need an offset for the descender portion of the first line\n        // and all subsequent lines.\n        if(ax.side === 'bottom' || ax.side === 'right') {\n            titleStandoff = ax._depth + ax.title.standoff + fontSize * CAP_SHIFT;\n        } else if(ax.side === 'top' || ax.side === 'left') {\n            titleStandoff = ax._depth + ax.title.standoff + fontSize * (MID_SHIFT + (extraLines * LINE_SPACING));\n        }\n    } else {\n        var isInside = insideTicklabelposition(ax);\n\n        if(ax.type === 'multicategory') {\n            titleStandoff = ax._depth;\n        } else {\n            var offsetBase = 1.5 * fontSize;\n            if(isInside) {\n                offsetBase = 0.5 * fontSize;\n                if(ax.ticks === 'outside') {\n                    offsetBase += ax.ticklen;\n                }\n            }\n            titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n        }\n\n        if(!isInside) {\n            if(axLetter === 'x') {\n                titleStandoff += ax.side === 'top' ?\n                    fontSize * (ax.showticklabels ? 1 : 0) :\n                    fontSize * (ax.showticklabels ? 1.5 : 0.5);\n            } else {\n                titleStandoff += ax.side === 'right' ?\n                    fontSize * (ax.showticklabels ? 1 : 0.5) :\n                    fontSize * (ax.showticklabels ? 0.5 : 0);\n            }\n        }\n    }\n\n    var pos = axes.getPxPosition(gd, ax);\n    var transform, x, y;\n\n    if(axLetter === 'x') {\n        x = ax._offset + ax._length / 2;\n        y = (ax.side === 'top') ? pos - titleStandoff : pos + titleStandoff;\n    } else {\n        y = ax._offset + ax._length / 2;\n        x = (ax.side === 'right') ? pos + titleStandoff : pos - titleStandoff;\n        transform = {rotate: '-90', offset: 0};\n    }\n\n    var avoid;\n\n    if(ax.type !== 'multicategory') {\n        var tickLabels = ax._selections[ax._id + 'tick'];\n\n        avoid = {\n            selection: tickLabels,\n            side: ax.side\n        };\n\n        if(tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n            var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n            avoid.offsetLeft = translation.x;\n            avoid.offsetTop = translation.y;\n        }\n\n        if(ax.title.hasOwnProperty('standoff')) {\n            avoid.pad = 0;\n        }\n    }\n\n    ax._titleStandoff = titleStandoff;\n\n    return Titles.draw(gd, axId + 'title', {\n        propContainer: ax,\n        propName: ax._name + '.title.text',\n        placeholder: fullLayout._dfltTitle[axLetter],\n        avoid: avoid,\n        transform: transform,\n        attributes: {x: x, y: y, 'text-anchor': 'middle'}\n    });\n}\n\naxes.shouldShowZeroLine = function(gd, ax, counterAxis) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    return (\n        (rng[0] * rng[1] <= 0) &&\n        ax.zeroline &&\n        (ax.type === 'linear' || ax.type === '-') &&\n        !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) &&\n        (\n            clipEnds(ax, 0) ||\n            !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) ||\n            hasBarsOrFill(gd, ax)\n        )\n    );\n};\n\naxes.clipEnds = function(ax, vals) {\n    return vals.filter(function(d) { return clipEnds(ax, d.x); });\n};\n\nfunction clipEnds(ax, l) {\n    var p = ax.l2p(l);\n    return (p > 1 && p < ax._length - 1);\n}\n\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n    var mainCounterAxis = counterAxis._mainAxis;\n    if(!mainCounterAxis) return;\n\n    var fullLayout = gd._fullLayout;\n    var axLetter = ax._id.charAt(0);\n    var counterLetter = axes.counterLetter(ax._id);\n\n    var zeroPosition = ax._offset + (\n        ((Math.abs(rng[0]) < Math.abs(rng[1])) === (axLetter === 'x')) ?\n        0 : ax._length\n    );\n\n    function lineNearZero(ax2) {\n        if(!ax2.showline || !ax2.linewidth) return false;\n        var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n\n        function closeEnough(pos2) {\n            return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n        }\n\n        if(closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n            return true;\n        }\n        var linePositions = ax2._linepositions || {};\n        for(var k in linePositions) {\n            if(closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n                return true;\n            }\n        }\n    }\n\n    var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n    if(!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n        return lineNearZero(counterAxis, zeroPosition);\n    }\n\n    var counterLetterAxes = axes.list(gd, counterLetter);\n    for(var i = 0; i < counterLetterAxes.length; i++) {\n        var counterAxis2 = counterLetterAxes[i];\n        if(\n            counterAxis2._mainAxis === mainCounterAxis &&\n            lineNearZero(counterAxis2, zeroPosition)\n        ) {\n            return true;\n        }\n    }\n}\n\nfunction hasBarsOrFill(gd, ax) {\n    var fullData = gd._fullData;\n    var subplot = ax._mainSubplot;\n    var axLetter = ax._id.charAt(0);\n\n    for(var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if(trace.visible === true && (trace.xaxis + trace.yaxis) === subplot) {\n            if(\n                Registry.traceIs(trace, 'bar-like') &&\n                trace.orientation === {x: 'h', y: 'v'}[axLetter]\n            ) return true;\n\n            if(\n                trace.fill &&\n                trace.fill.charAt(trace.fill.length - 1) === axLetter\n            ) return true;\n        }\n    }\n    return false;\n}\n\nfunction selectTickLabel(gTick) {\n    var s = d3.select(gTick);\n    var mj = s.select('.text-math-group');\n    return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function(gd) {\n    var axList = axes.list(gd, '', true);\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        if(ax.automargin) {\n            Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n            if(ax.mirror) {\n                Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n            }\n        }\n        if(Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n        }\n    }\n};\n\nfunction axAutoMarginID(ax) { return ax._id + '.automargin'; }\nfunction axMirrorAutoMarginID(ax) { return axAutoMarginID(ax) + '.mirror'; }\nfunction rangeSliderAutoMarginID(ax) { return ax._id + '.rangeslider'; }\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function(gd, traces) {\n    var axGroups = makeAxisGroups(gd, traces);\n\n    for(var i = 0; i < axGroups.length; i++) {\n        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n    }\n};\n\nfunction makeAxisGroups(gd, traces) {\n    var groups = [];\n    var i, j;\n\n    for(i = 0; i < traces.length; i++) {\n        var groupsi = [];\n        var xi = gd._fullData[traces[i]].xaxis;\n        var yi = gd._fullData[traces[i]].yaxis;\n        if(!xi || !yi) continue; // not a 2D cartesian trace?\n\n        for(j = 0; j < groups.length; j++) {\n            if(groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n                groupsi.push(j);\n            }\n        }\n\n        if(!groupsi.length) {\n            groups.push({x: [xi], y: [yi]});\n            continue;\n        }\n\n        var group0 = groups[groupsi[0]];\n        var groupj;\n\n        if(groupsi.length > 1) {\n            for(j = 1; j < groupsi.length; j++) {\n                groupj = groups[groupsi[j]];\n                mergeAxisGroups(group0.x, groupj.x);\n                mergeAxisGroups(group0.y, groupj.y);\n            }\n        }\n        mergeAxisGroups(group0.x, [xi]);\n        mergeAxisGroups(group0.y, [yi]);\n    }\n\n    return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n    for(var i = 0; i < fromSet.length; i++) {\n        if(intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n    }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n    var xFullAxes = [];\n    var yFullAxes = [];\n    var layout = gd.layout;\n    var i, j;\n\n    for(i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n    for(i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n\n    var allAxKeys = Object.keys(axAttrs);\n\n    var noSwapAttrs = [\n        'anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'\n    ];\n    var numericTypes = ['linear', 'log'];\n\n    for(i = 0; i < allAxKeys.length; i++) {\n        var keyi = allAxKeys[i];\n        var xVal = xFullAxes[0][keyi];\n        var yVal = yFullAxes[0][keyi];\n        var allEqual = true;\n        var coerceLinearX = false;\n        var coerceLinearY = false;\n        if(keyi.charAt(0) === '_' || typeof xVal === 'function' ||\n                noSwapAttrs.indexOf(keyi) !== -1) {\n            continue;\n        }\n        for(j = 1; j < xFullAxes.length && allEqual; j++) {\n            var xVali = xFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(xVal) !== -1 &&\n                    numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearX = true;\n            } else if(xVali !== xVal) allEqual = false;\n        }\n        for(j = 1; j < yFullAxes.length && allEqual; j++) {\n            var yVali = yFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(yVal) !== -1 &&\n                    numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearY = true;\n            } else if(yFullAxes[j][keyi] !== yVal) allEqual = false;\n        }\n        if(allEqual) {\n            if(coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n            if(coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n        }\n    }\n\n    // now swap x&y for any annotations anchored to these x & y\n    for(i = 0; i < gd._fullLayout.annotations.length; i++) {\n        var ann = gd._fullLayout.annotations[i];\n        if(xIds.indexOf(ann.xref) !== -1 &&\n                yIds.indexOf(ann.yref) !== -1) {\n            Lib.swapAttrs(layout.annotations[i], ['?']);\n        }\n    }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n    // in case the value is the default for either axis,\n    // look at the first axis in each list and see if\n    // this key's value is undefined\n    var np = Lib.nestedProperty;\n    var xVal = np(layout[xFullAxes[0]._name], key).get();\n    var yVal = np(layout[yFullAxes[0]._name], key).get();\n    var i;\n\n    if(key === 'title') {\n        // special handling of placeholder titles\n        if(xVal && xVal.text === dfltTitle.x) {\n            xVal.text = dfltTitle.y;\n        }\n        if(yVal && yVal.text === dfltTitle.y) {\n            yVal.text = dfltTitle.x;\n        }\n    }\n\n    for(i = 0; i < xFullAxes.length; i++) {\n        np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n    }\n    for(i = 0; i < yFullAxes.length; i++) {\n        np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n    }\n}\n\nfunction isAngular(ax) {\n    return ax._id === 'angularaxis';\n}\n\nfunction moveOutsideBreak(v, ax) {\n    var len = ax._rangebreaks.length;\n    for(var k = 0; k < len; k++) {\n        var brk = ax._rangebreaks[k];\n        if(v >= brk.min && v < brk.max) {\n            return brk.max;\n        }\n    }\n    return v;\n}\n\nfunction insideTicklabelposition(ax) {\n    return ((ax.ticklabelposition || '').indexOf('inside') !== -1);\n}\n\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n    if(insideTicklabelposition(ax._anchorAxis || {})) {\n        if(ax._hideCounterAxisInsideTickLabels) {\n            ax._hideCounterAxisInsideTickLabels(opts);\n        }\n    }\n}\n\nfunction incrementShift(ax, shiftVal, axShifts, normalize) {\n    // Need to set 'overlay' for anchored axis\n    var overlay = ((ax.anchor !== 'free') && ((ax.overlaying === undefined) || (ax.overlaying === false))) ? ax._id : ax.overlaying;\n    var shiftValAdj;\n    if(normalize) {\n        shiftValAdj = ax.side === 'right' ? shiftVal : -shiftVal;\n    } else {\n        shiftValAdj = shiftVal;\n    }\n    if(!(overlay in axShifts)) {\n        axShifts[overlay] = {};\n    }\n    if(!(ax.side in axShifts[overlay])) {\n        axShifts[overlay][ax.side] = 0;\n    }\n    axShifts[overlay][ax.side] += shiftValAdj;\n}\n\nfunction setShiftVal(ax, axShifts) {\n    return ax.autoshift ?\n        axShifts[ax.overlaying][ax.side] :\n        (ax.shift || 0);\n}\n\n/**\n * Checks if the given period is at least the period described by the tickformat or larger. If that\n * is the case, they are compatible, because then the tickformat can be used to describe the period.\n * E.g. it doesn't make sense to put a year label on a period spanning only a month.\n * @param {number} period in ms\n * @param {string} tickformat\n * @returns {boolean}\n */\nfunction periodCompatibleWithTickformat(period, tickformat) {\n    return (\n        /%f/.test(tickformat) ? period >= ONEMICROSEC :\n        /%L/.test(tickformat) ? period >= ONEMILLI :\n        /%[SX]/.test(tickformat) ? period >= ONESEC :\n        /%M/.test(tickformat) ? period >= ONEMIN :\n        /%[HI]/.test(tickformat) ? period >= ONEHOUR :\n        /%p/.test(tickformat) ? period >= HALFDAY :\n        /%[Aadejuwx]/.test(tickformat) ? period >= ONEDAY :\n        /%[UVW]/.test(tickformat) ? period >= ONEWEEK :\n        /%[Bbm]/.test(tickformat) ? period >= ONEMINMONTH :\n        /%[q]/.test(tickformat) ? period >= ONEMINQUARTER :\n        /%[Yy]/.test(tickformat) ? period >= ONEMINYEAR :\n        true\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}