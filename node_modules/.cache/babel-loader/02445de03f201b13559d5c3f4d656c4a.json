{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar utcFormat = require('d3-time-format').utcFormat;\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar numConstants = require('../../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar ONEWEEK = numConstants.ONEWEEK;\nvar ONEDAY = numConstants.ONEDAY;\nvar ONEHOUR = numConstants.ONEHOUR;\nvar ONEMIN = numConstants.ONEMIN;\nvar ONESEC = numConstants.ONESEC;\nvar axisIds = require('./axis_ids');\nvar constants = require('./constants');\nvar HOUR_PATTERN = constants.HOUR_PATTERN;\nvar WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;\nfunction fromLog(v) {\n  return Math.pow(10, v);\n}\nfunction isValidCategory(v) {\n  return v !== null && v !== undefined;\n}\n\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v3.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\nmodule.exports = function setConvert(ax, fullLayout) {\n  fullLayout = fullLayout || {};\n  var axId = ax._id || 'x';\n  var axLetter = axId.charAt(0);\n  function toLog(v, clip) {\n    if (v > 0) return Math.log(v) / Math.LN10;else if (v <= 0 && clip && ax.range && ax.range.length === 2) {\n      // clip NaN (ie past negative infinity) to LOG_CLIP axis\n      // length past the negative edge\n      var r0 = ax.range[0];\n      var r1 = ax.range[1];\n      return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n    } else return BADNUM;\n  }\n\n  /*\n   * wrapped dateTime2ms that:\n   * - accepts ms numbers for backward compatibility\n   * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n   * - defaults to ax.calendar\n   */\n  function dt2ms(v, _, calendar, opts) {\n    if ((opts || {}).msUTC && isNumeric(v)) {\n      // For now it is only used\n      // to fix bar length in milliseconds & gl3d ticks\n      // It could be applied in other places in v3\n      return +v;\n    }\n\n    // NOTE: Changed this behavior: previously we took any numeric value\n    // to be a ms, even if it was a string that could be a bare year.\n    // Now we convert it as a date if at all possible, and only try\n    // as (local) ms if that fails.\n    var ms = dateTime2ms(v, calendar || ax.calendar);\n    if (ms === BADNUM) {\n      if (isNumeric(v)) {\n        v = +v;\n        // keep track of tenths of ms, that `new Date` will drop\n        // same logic as in Lib.ms2DateTime\n        var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n        var msRounded = Math.round(v - msecTenths / 10);\n        ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n      } else return BADNUM;\n    }\n    return ms;\n  }\n\n  // wrapped ms2DateTime to insert default ax.calendar\n  function ms2dt(v, r, calendar) {\n    return ms2DateTime(v, r, calendar || ax.calendar);\n  }\n  function getCategoryName(v) {\n    return ax._categories[Math.round(v)];\n  }\n\n  /*\n   * setCategoryIndex: return the index of category v,\n   * inserting it in the list if it's not already there\n   *\n   * this will enter the categories in the order it\n   * encounters them, ie all the categories from the\n   * first data set, then all the ones from the second\n   * that aren't in the first etc.\n   *\n   * it is assumed that this function is being invoked in the\n   * already sorted category order; otherwise there would be\n   * a disconnect between the array and the index returned\n   */\n  function setCategoryIndex(v) {\n    if (isValidCategory(v)) {\n      if (ax._categoriesMap === undefined) {\n        ax._categoriesMap = {};\n      }\n      if (ax._categoriesMap[v] !== undefined) {\n        return ax._categoriesMap[v];\n      } else {\n        ax._categories.push(typeof v === 'number' ? String(v) : v);\n        var curLength = ax._categories.length - 1;\n        ax._categoriesMap[v] = curLength;\n        return curLength;\n      }\n    }\n    return BADNUM;\n  }\n  function setMultiCategoryIndex(arrayIn, len) {\n    var arrayOut = new Array(len);\n    for (var i = 0; i < len; i++) {\n      var v0 = (arrayIn[0] || [])[i];\n      var v1 = (arrayIn[1] || [])[i];\n      arrayOut[i] = getCategoryIndex([v0, v1]);\n    }\n    return arrayOut;\n  }\n  function getCategoryIndex(v) {\n    if (ax._categoriesMap) {\n      return ax._categoriesMap[v];\n    }\n  }\n  function getCategoryPosition(v) {\n    // d2l/d2c variant that that won't add categories but will also\n    // allow numbers to be mapped to the linearized axis positions\n    var index = getCategoryIndex(v);\n    if (index !== undefined) return index;\n    if (isNumeric(v)) return +v;\n  }\n  function getRangePosition(v) {\n    return isNumeric(v) ? +v : getCategoryIndex(v);\n  }\n\n  // include 2 fractional digits on pixel, for PDF zooming etc\n  function _l2p(v, m, b) {\n    return d3.round(b + m * v, 2);\n  }\n  function _p2l(px, m, b) {\n    return (px - b) / m;\n  }\n  var l2p = function l2p(v) {\n    if (!isNumeric(v)) return BADNUM;\n    return _l2p(v, ax._m, ax._b);\n  };\n  var p2l = function (px) {\n    return _p2l(px, ax._m, ax._b);\n  };\n  if (ax.rangebreaks) {\n    var isY = axLetter === 'y';\n    l2p = function (v) {\n      if (!isNumeric(v)) return BADNUM;\n      var len = ax._rangebreaks.length;\n      if (!len) return _l2p(v, ax._m, ax._b);\n      var flip = isY;\n      if (ax.range[0] > ax.range[1]) flip = !flip;\n      var signAx = flip ? -1 : 1;\n      var pos = signAx * v;\n      var q = 0;\n      for (var i = 0; i < len; i++) {\n        var min = signAx * ax._rangebreaks[i].min;\n        var max = signAx * ax._rangebreaks[i].max;\n        if (pos < min) break;\n        if (pos > max) q = i + 1;else {\n          // when falls into break, pick 'closest' offset\n          q = pos < (min + max) / 2 ? i : i + 1;\n          break;\n        }\n      }\n      var b2 = ax._B[q] || 0;\n      if (!isFinite(b2)) return 0; // avoid NaN translate e.g. in positionLabels if one keep zooming exactly into a break\n      return _l2p(v, ax._m2, b2);\n    };\n    p2l = function (px) {\n      var len = ax._rangebreaks.length;\n      if (!len) return _p2l(px, ax._m, ax._b);\n      var q = 0;\n      for (var i = 0; i < len; i++) {\n        if (px < ax._rangebreaks[i].pmin) break;\n        if (px > ax._rangebreaks[i].pmax) q = i + 1;\n      }\n      return _p2l(px, ax._m2, ax._B[q]);\n    };\n  }\n\n  // conversions among c/l/p are fairly simple - do them together for all axis types\n  ax.c2l = ax.type === 'log' ? toLog : ensureNumber;\n  ax.l2c = ax.type === 'log' ? fromLog : ensureNumber;\n  ax.l2p = l2p;\n  ax.p2l = p2l;\n  ax.c2p = ax.type === 'log' ? function (v, clip) {\n    return l2p(toLog(v, clip));\n  } : l2p;\n  ax.p2c = ax.type === 'log' ? function (px) {\n    return fromLog(p2l(px));\n  } : p2l;\n\n  /*\n   * now type-specific conversions for **ALL** other combinations\n   * they're all written out, instead of being combinations of each other, for\n   * both clarity and speed.\n   */\n  if (['linear', '-'].indexOf(ax.type) !== -1) {\n    // all are data vals, but d and r need cleaning\n    ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n    ax.d2p = ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n    ax.p2d = ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'log') {\n    // d and c are data vals, r and l are logged (but d and r need cleaning)\n    ax.d2r = ax.d2l = function (v, clip) {\n      return toLog(cleanNumber(v), clip);\n    };\n    ax.r2d = ax.r2c = function (v) {\n      return fromLog(cleanNumber(v));\n    };\n    ax.d2c = ax.r2l = cleanNumber;\n    ax.c2d = ax.l2r = ensureNumber;\n    ax.c2r = toLog;\n    ax.l2d = fromLog;\n    ax.d2p = function (v, clip) {\n      return ax.l2p(ax.d2r(v, clip));\n    };\n    ax.p2d = function (px) {\n      return fromLog(p2l(px));\n    };\n    ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n    ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'date') {\n    // r and d are date strings, l and c are ms\n\n    /*\n     * Any of these functions with r and d on either side, calendar is the\n     * **3rd** argument. log has reserved the second argument.\n     *\n     * Unless you need the special behavior of the second arg (ms2DateTime\n     * uses this to limit precision, toLog uses true to clip negatives\n     * to offscreen low rather than undefined), it's safe to pass 0.\n     */\n    ax.d2r = ax.r2d = Lib.identity;\n    ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n    ax.d2p = ax.r2p = function (v, _, calendar) {\n      return ax.l2p(dt2ms(v, 0, calendar));\n    };\n    ax.p2d = ax.p2r = function (px, r, calendar) {\n      return ms2dt(p2l(px), r, calendar);\n    };\n    ax.cleanPos = function (v) {\n      return Lib.cleanDate(v, BADNUM, ax.calendar);\n    };\n  } else if (ax.type === 'category') {\n    // d is categories (string)\n    // c and l are indices (numbers)\n    // r is categories or numbers\n\n    ax.d2c = ax.d2l = setCategoryIndex;\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n    ax.r2c = function (v) {\n      var index = getRangePosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getRangePosition;\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n    ax.cleanPos = function (v) {\n      if (typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n  } else if (ax.type === 'multicategory') {\n    // N.B. multicategory axes don't define d2c and d2l,\n    // as 'data-to-calcdata' conversion needs to take into\n    // account all data array items as in ax.makeCalcdata.\n\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n    ax.r2c = function (v) {\n      var index = getCategoryPosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n    ax.r2c_just_indices = getCategoryIndex;\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getCategoryPosition;\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n    ax.cleanPos = function (v) {\n      if (Array.isArray(v) || typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n    ax.setupMultiCategory = function (fullData) {\n      var traceIndices = ax._traceIndices;\n      var i, j;\n      var group = ax._matchGroup;\n      if (group && ax._categories.length === 0) {\n        for (var axId2 in group) {\n          if (axId2 !== axId) {\n            var ax2 = fullLayout[axisIds.id2name(axId2)];\n            traceIndices = traceIndices.concat(ax2._traceIndices);\n          }\n        }\n      }\n\n      // [ [cnt, {$cat: index}], for 1,2 ]\n      var seen = [[0, {}], [0, {}]];\n      // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n      var list = [];\n      for (i = 0; i < traceIndices.length; i++) {\n        var trace = fullData[traceIndices[i]];\n        if (axLetter in trace) {\n          var arrayIn = trace[axLetter];\n          var len = trace._length || Lib.minRowLength(arrayIn);\n          if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n            for (j = 0; j < len; j++) {\n              var v0 = arrayIn[0][j];\n              var v1 = arrayIn[1][j];\n              if (isValidCategory(v0) && isValidCategory(v1)) {\n                list.push([v0, v1]);\n                if (!(v0 in seen[0][1])) {\n                  seen[0][1][v0] = seen[0][0]++;\n                }\n                if (!(v1 in seen[1][1])) {\n                  seen[1][1][v1] = seen[1][0]++;\n                }\n              }\n            }\n          }\n        }\n      }\n      list.sort(function (a, b) {\n        var ind0 = seen[0][1];\n        var d = ind0[a[0]] - ind0[b[0]];\n        if (d) return d;\n        var ind1 = seen[1][1];\n        return ind1[a[1]] - ind1[b[1]];\n      });\n      for (i = 0; i < list.length; i++) {\n        setCategoryIndex(list[i]);\n      }\n    };\n  }\n\n  // find the range value at the specified (linear) fraction of the axis\n  ax.fraction2r = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return ax.l2r(rl0 + v * (rl1 - rl0));\n  };\n\n  // find the fraction of the range at the specified range value\n  ax.r2fraction = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return (ax.r2l(v) - rl0) / (rl1 - rl0);\n  };\n  ax.limitRange = function (rangeAttr) {\n    var minallowed = ax.minallowed;\n    var maxallowed = ax.maxallowed;\n    if (minallowed === undefined && maxallowed === undefined) return;\n    if (!rangeAttr) rangeAttr = 'range';\n    var range = Lib.nestedProperty(ax, rangeAttr).get();\n    var rng = Lib.simpleMap(range, ax.r2l);\n    var axrev = rng[1] < rng[0];\n    if (axrev) rng.reverse();\n    var bounds = Lib.simpleMap([minallowed, maxallowed], ax.r2l);\n    if (minallowed !== undefined && rng[0] < bounds[0]) range[axrev ? 1 : 0] = minallowed;\n    if (maxallowed !== undefined && rng[1] > bounds[1]) range[axrev ? 0 : 1] = maxallowed;\n    if (range[0] === range[1]) {\n      var minL = ax.l2r(minallowed);\n      var maxL = ax.l2r(maxallowed);\n      if (minallowed !== undefined) {\n        var _max = minL + 1;\n        if (maxallowed !== undefined) _max = Math.min(_max, maxL);\n        range[axrev ? 1 : 0] = _max;\n      }\n      if (maxallowed !== undefined) {\n        var _min = maxL + 1;\n        if (minallowed !== undefined) _min = Math.max(_min, minL);\n        range[axrev ? 0 : 1] = _min;\n      }\n    }\n  };\n\n  /*\n   * cleanRange: make sure range is a couplet of valid & distinct values\n   * keep numbers away from the limits of floating point numbers,\n   * and dates away from the ends of our date system (+/- 9999 years)\n   *\n   * optional param rangeAttr: operate on a different attribute, like\n   * ax._r, rather than ax.range\n   */\n  ax.cleanRange = function (rangeAttr, opts) {\n    ax._cleanRange(rangeAttr, opts);\n    ax.limitRange(rangeAttr);\n  };\n  ax._cleanRange = function (rangeAttr, opts) {\n    if (!opts) opts = {};\n    if (!rangeAttr) rangeAttr = 'range';\n    var range = Lib.nestedProperty(ax, rangeAttr).get();\n    var i, dflt;\n    if (ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);else if (axLetter === 'y') dflt = constants.DFLTRANGEY;else if (ax._name === 'realaxis') dflt = [0, 1];else dflt = opts.dfltRange || constants.DFLTRANGEX;\n\n    // make sure we don't later mutate the defaults\n    dflt = dflt.slice();\n    if (ax.rangemode === 'tozero' || ax.rangemode === 'nonnegative') {\n      dflt[0] = 0;\n    }\n    if (!range || range.length !== 2) {\n      Lib.nestedProperty(ax, rangeAttr).set(dflt);\n      return;\n    }\n    var nullRange0 = range[0] === null;\n    var nullRange1 = range[1] === null;\n    if (ax.type === 'date' && !ax.autorange) {\n      // check if milliseconds or js date objects are provided for range\n      // and convert to date strings\n      range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n      range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n    }\n    for (i = 0; i < 2; i++) {\n      if (ax.type === 'date') {\n        if (!Lib.isDateTime(range[i], ax.calendar)) {\n          ax[rangeAttr] = dflt;\n          break;\n        }\n        if (ax.r2l(range[0]) === ax.r2l(range[1])) {\n          // split by +/- 1 second\n          var linCenter = Lib.constrain(ax.r2l(range[0]), Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n          range[0] = ax.l2r(linCenter - 1000);\n          range[1] = ax.l2r(linCenter + 1000);\n          break;\n        }\n      } else {\n        if (!isNumeric(range[i])) {\n          if (!(nullRange0 || nullRange1) && isNumeric(range[1 - i])) {\n            range[i] = range[1 - i] * (i ? 10 : 0.1);\n          } else {\n            ax[rangeAttr] = dflt;\n            break;\n          }\n        }\n        if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;else if (range[i] > FP_SAFE) range[i] = FP_SAFE;\n        if (range[0] === range[1]) {\n          // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n          var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n          range[0] -= inc;\n          range[1] += inc;\n        }\n      }\n    }\n  };\n\n  // set scaling to pixels\n  ax.setScale = function (usePrivateRange) {\n    var gs = fullLayout._size;\n\n    // make sure we have a domain (pull it in from the axis\n    // this one is overlaying if necessary)\n    if (ax.overlaying) {\n      var ax2 = axisIds.getFromId({\n        _fullLayout: fullLayout\n      }, ax.overlaying);\n      ax.domain = ax2.domain;\n    }\n\n    // While transitions are occurring, we get a double-transform\n    // issue if we transform the drawn layer *and* use the new axis range to\n    // draw the data. This allows us to construct setConvert using the pre-\n    // interaction values of the range:\n    var rangeAttr = usePrivateRange && ax._r ? '_r' : 'range';\n    var calendar = ax.calendar;\n    ax.cleanRange(rangeAttr);\n    var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n    var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n    var isY = axLetter === 'y';\n    if (isY) {\n      ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n      ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl0 - rl1);\n      ax._b = -ax._m * rl1;\n    } else {\n      ax._offset = gs.l + ax.domain[0] * gs.w;\n      ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl1 - rl0);\n      ax._b = -ax._m * rl0;\n    }\n\n    // set of \"N\" disjoint rangebreaks inside the range\n    ax._rangebreaks = [];\n    // length of these rangebreaks in value space - negative on reversed axes\n    ax._lBreaks = 0;\n    // l2p slope (same for all intervals)\n    ax._m2 = 0;\n    // set of l2p offsets (one for each of the (N+1) piecewise intervals)\n    ax._B = [];\n    if (ax.rangebreaks) {\n      var i, brk;\n      ax._rangebreaks = ax.locateBreaks(Math.min(rl0, rl1), Math.max(rl0, rl1));\n      if (ax._rangebreaks.length) {\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          ax._lBreaks += Math.abs(brk.max - brk.min);\n        }\n        var flip = isY;\n        if (rl0 > rl1) flip = !flip;\n        if (flip) ax._rangebreaks.reverse();\n        var sign = flip ? -1 : 1;\n        ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);\n        ax._B.push(-ax._m2 * (isY ? rl1 : rl0));\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          ax._B.push(ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min));\n        }\n\n        // fill pixel (i.e. 'p') min/max here,\n        // to not have to loop through the _rangebreaks twice during `p2l`\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          brk.pmin = l2p(brk.min);\n          brk.pmax = l2p(brk.max);\n        }\n      }\n    }\n    if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {\n      fullLayout._replotting = false;\n      throw new Error('Something went wrong with axis scaling');\n    }\n  };\n  ax.maskBreaks = function (v) {\n    var rangebreaksIn = ax.rangebreaks || [];\n    var bnds, b0, b1, vb, vDate;\n    if (!rangebreaksIn._cachedPatterns) {\n      rangebreaksIn._cachedPatterns = rangebreaksIn.map(function (brk) {\n        return brk.enabled && brk.bounds ? Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.d2c // case of pattern: ''\n        ) : null;\n      });\n    }\n    if (!rangebreaksIn._cachedValues) {\n      rangebreaksIn._cachedValues = rangebreaksIn.map(function (brk) {\n        return brk.enabled && brk.values ? Lib.simpleMap(brk.values, ax.d2c).sort(Lib.sorterAsc) : null;\n      });\n    }\n    for (var i = 0; i < rangebreaksIn.length; i++) {\n      var brk = rangebreaksIn[i];\n      if (brk.enabled) {\n        if (brk.bounds) {\n          var pattern = brk.pattern;\n          bnds = rangebreaksIn._cachedPatterns[i];\n          b0 = bnds[0];\n          b1 = bnds[1];\n          switch (pattern) {\n            case WEEKDAY_PATTERN:\n              vDate = new Date(v);\n              vb = vDate.getUTCDay();\n              if (b0 > b1) {\n                b1 += 7;\n                if (vb < b0) vb += 7;\n              }\n              break;\n            case HOUR_PATTERN:\n              vDate = new Date(v);\n              var hours = vDate.getUTCHours();\n              var minutes = vDate.getUTCMinutes();\n              var seconds = vDate.getUTCSeconds();\n              var milliseconds = vDate.getUTCMilliseconds();\n              vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 3600000);\n              if (b0 > b1) {\n                b1 += 24;\n                if (vb < b0) vb += 24;\n              }\n              break;\n            case '':\n              // N.B. should work on date axes as well!\n              // e.g. { bounds: ['2020-01-04', '2020-01-05 23:59'] }\n              // TODO should work with reversed-range axes\n              vb = v;\n              break;\n          }\n          if (vb >= b0 && vb < b1) return BADNUM;\n        } else {\n          var vals = rangebreaksIn._cachedValues[i];\n          for (var j = 0; j < vals.length; j++) {\n            b0 = vals[j];\n            b1 = b0 + brk.dvalue;\n            if (v >= b0 && v < b1) return BADNUM;\n          }\n        }\n      }\n    }\n    return v;\n  };\n  ax.locateBreaks = function (r0, r1) {\n    var i, bnds, b0, b1;\n    var rangebreaksOut = [];\n    if (!ax.rangebreaks) return rangebreaksOut;\n    var rangebreaksIn = ax.rangebreaks.slice().sort(function (a, b) {\n      if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;\n      if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;\n      return 0;\n    });\n    var addBreak = function (min, max) {\n      min = Lib.constrain(min, r0, r1);\n      max = Lib.constrain(max, r0, r1);\n      if (min === max) return;\n      var isNewBreak = true;\n      for (var j = 0; j < rangebreaksOut.length; j++) {\n        var brkj = rangebreaksOut[j];\n        if (min < brkj.max && max >= brkj.min) {\n          if (min < brkj.min) {\n            brkj.min = min;\n          }\n          if (max > brkj.max) {\n            brkj.max = max;\n          }\n          isNewBreak = false;\n        }\n      }\n      if (isNewBreak) {\n        rangebreaksOut.push({\n          min: min,\n          max: max\n        });\n      }\n    };\n    for (i = 0; i < rangebreaksIn.length; i++) {\n      var brk = rangebreaksIn[i];\n      if (brk.enabled) {\n        if (brk.bounds) {\n          var t0 = r0;\n          var t1 = r1;\n          if (brk.pattern) {\n            // to remove decimal (most often found in auto ranges)\n            t0 = Math.floor(t0);\n          }\n          bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);\n          b0 = bnds[0];\n          b1 = bnds[1];\n\n          // r0 value as date\n          var t0Date = new Date(t0);\n          // r0 value for break pattern\n          var bndDelta;\n          // step in ms between rangebreaks\n          var step;\n          switch (brk.pattern) {\n            case WEEKDAY_PATTERN:\n              step = ONEWEEK;\n              bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;\n              t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());\n              break;\n            case HOUR_PATTERN:\n              step = ONEDAY;\n              bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;\n              t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());\n              break;\n            default:\n              t0 = Math.min(bnds[0], bnds[1]);\n              t1 = Math.max(bnds[0], bnds[1]);\n              step = t1 - t0;\n              bndDelta = step;\n          }\n          for (var t = t0; t < t1; t += step) {\n            addBreak(t, t + bndDelta);\n          }\n        } else {\n          var vals = Lib.simpleMap(brk.values, ax.d2c);\n          for (var j = 0; j < vals.length; j++) {\n            b0 = vals[j];\n            b1 = b0 + brk.dvalue;\n            addBreak(b0, b1);\n          }\n        }\n      }\n    }\n    rangebreaksOut.sort(function (a, b) {\n      return a.min - b.min;\n    });\n    return rangebreaksOut;\n  };\n\n  // makeCalcdata: takes an x or y array and converts it\n  // to a position on the axis object \"ax\"\n  // inputs:\n  //      trace - a data object from gd.data\n  //      axLetter - a string, either 'x' or 'y', for which item\n  //          to convert (TODO: is this now always the same as\n  //          the first letter of ax._id?)\n  // in case the expected data isn't there, make a list of\n  // integers based on the opposite data\n  ax.makeCalcdata = function (trace, axLetter, opts) {\n    var arrayIn, arrayOut, i, len;\n    var axType = ax.type;\n    var cal = axType === 'date' && trace[axLetter + 'calendar'];\n    if (axLetter in trace) {\n      arrayIn = trace[axLetter];\n      len = trace._length || Lib.minRowLength(arrayIn);\n      if (Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n      if (axType === 'multicategory') {\n        return setMultiCategoryIndex(arrayIn, len);\n      }\n      arrayOut = new Array(len);\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);\n      }\n    } else {\n      var v0 = axLetter + '0' in trace ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n      var dv = trace['d' + axLetter] ? Number(trace['d' + axLetter]) : 1;\n\n      // the opposing data, for size if we have x and dx etc\n      arrayIn = trace[{\n        x: 'y',\n        y: 'x'\n      }[axLetter]];\n      len = trace._length || arrayIn.length;\n      arrayOut = new Array(len);\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    }\n\n    // mask (i.e. set to BADNUM) coords that fall inside rangebreaks\n    if (ax.rangebreaks) {\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.maskBreaks(arrayOut[i]);\n      }\n    }\n    return arrayOut;\n  };\n  ax.isValidRange = function (range, nullOk) {\n    return Array.isArray(range) && range.length === 2 && (nullOk && range[0] === null || isNumeric(ax.r2l(range[0]))) && (nullOk && range[1] === null || isNumeric(ax.r2l(range[1])));\n  };\n  ax.getAutorangeDflt = function (range, options) {\n    var autorangeDflt = !ax.isValidRange(range, 'nullOk');\n    if (autorangeDflt && options && options.reverseDflt) autorangeDflt = 'reversed';else if (range) {\n      if (range[0] === null && range[1] === null) {\n        autorangeDflt = true;\n      } else if (range[0] === null && range[1] !== null) {\n        autorangeDflt = 'min';\n      } else if (range[0] !== null && range[1] === null) {\n        autorangeDflt = 'max';\n      }\n    }\n    return autorangeDflt;\n  };\n  ax.isReversed = function () {\n    var autorange = ax.autorange;\n    return autorange === 'reversed' || autorange === 'min reversed' || autorange === 'max reversed';\n  };\n  ax.isPtWithinRange = function (d, calendar) {\n    var coord = ax.c2l(d[axLetter], null, calendar);\n    var r0 = ax.r2l(ax.range[0]);\n    var r1 = ax.r2l(ax.range[1]);\n    if (r0 < r1) {\n      return r0 <= coord && coord <= r1;\n    } else {\n      // Reversed axis case.\n      return r1 <= coord && coord <= r0;\n    }\n  };\n  ax._emptyCategories = function () {\n    ax._categories = [];\n    ax._categoriesMap = {};\n  };\n\n  // should skip if not category nor multicategory\n  ax.clearCalc = function () {\n    var group = ax._matchGroup;\n    if (group) {\n      var categories = null;\n      var categoriesMap = null;\n      for (var axId2 in group) {\n        var ax2 = fullLayout[axisIds.id2name(axId2)];\n        if (ax2._categories) {\n          categories = ax2._categories;\n          categoriesMap = ax2._categoriesMap;\n          break;\n        }\n      }\n      if (categories && categoriesMap) {\n        ax._categories = categories;\n        ax._categoriesMap = categoriesMap;\n      } else {\n        ax._emptyCategories();\n      }\n    } else {\n      ax._emptyCategories();\n    }\n    if (ax._initialCategories) {\n      for (var j = 0; j < ax._initialCategories.length; j++) {\n        setCategoryIndex(ax._initialCategories[j]);\n      }\n    }\n  };\n\n  // sort the axis (and all the matching ones) by _initialCategories\n  // returns the indices of the traces affected by the reordering\n  ax.sortByInitialCategories = function () {\n    var affectedTraces = [];\n    ax._emptyCategories();\n    if (ax._initialCategories) {\n      for (var j = 0; j < ax._initialCategories.length; j++) {\n        setCategoryIndex(ax._initialCategories[j]);\n      }\n    }\n    affectedTraces = affectedTraces.concat(ax._traceIndices);\n\n    // Propagate to matching axes\n    var group = ax._matchGroup;\n    for (var axId2 in group) {\n      if (axId === axId2) continue;\n      var ax2 = fullLayout[axisIds.id2name(axId2)];\n      ax2._categories = ax._categories;\n      ax2._categoriesMap = ax._categoriesMap;\n      affectedTraces = affectedTraces.concat(ax2._traceIndices);\n    }\n    return affectedTraces;\n  };\n\n  // Propagate localization into the axis so that\n  // methods in Axes can use it w/o having to pass fullLayout\n  // Default (non-d3) number formatting uses separators directly\n  // dates and d3-formatted numbers use the d3 locale\n  // Fall back on default format for dummy axes that don't care about formatting\n  var locale = fullLayout._d3locale;\n  if (ax.type === 'date') {\n    ax._dateFormat = locale ? locale.timeFormat : utcFormat;\n    ax._extraFormat = fullLayout._extraFormat;\n  }\n  // occasionally we need _numFormat to pass through\n  // even though it won't be needed by this axis\n  ax._separators = fullLayout.separators;\n  ax._numFormat = locale ? locale.numberFormat : numberFormat;\n\n  // and for bar charts and box plots: reset forced minimum tick spacing\n  delete ax._minDtick;\n  delete ax._forceTick0;\n};","map":{"version":3,"names":["d3","require","utcFormat","Lib","numberFormat","isNumeric","cleanNumber","ms2DateTime","dateTime2ms","ensureNumber","isArrayOrTypedArray","numConstants","FP_SAFE","BADNUM","LOG_CLIP","ONEWEEK","ONEDAY","ONEHOUR","ONEMIN","ONESEC","axisIds","constants","HOUR_PATTERN","WEEKDAY_PATTERN","fromLog","v","Math","pow","isValidCategory","undefined","module","exports","setConvert","ax","fullLayout","axId","_id","axLetter","charAt","toLog","clip","log","LN10","range","length","r0","r1","abs","dt2ms","_","calendar","opts","msUTC","ms","msecTenths","floor","mod","msRounded","round","Date","ms2dt","r","getCategoryName","_categories","setCategoryIndex","_categoriesMap","push","String","curLength","setMultiCategoryIndex","arrayIn","len","arrayOut","Array","i","v0","v1","getCategoryIndex","getCategoryPosition","index","getRangePosition","_l2p","m","b","_p2l","px","l2p","_m","_b","p2l","rangebreaks","isY","_rangebreaks","flip","signAx","pos","q","min","max","b2","_B","isFinite","_m2","pmin","pmax","c2l","type","l2c","c2p","p2c","indexOf","d2r","r2d","d2c","r2c","d2l","r2l","c2d","c2r","l2d","l2r","d2p","r2p","p2d","p2r","cleanPos","identity","cleanDate","d2l_noadd","fraction2r","r2c_just_indices","isArray","setupMultiCategory","fullData","traceIndices","_traceIndices","j","group","_matchGroup","axId2","ax2","id2name","concat","seen","list","trace","_length","minRowLength","sort","a","ind0","d","ind1","rl0","rl1","r2fraction","limitRange","rangeAttr","minallowed","maxallowed","nestedProperty","get","rng","simpleMap","axrev","reverse","bounds","minL","maxL","_max","_min","cleanRange","_cleanRange","dflt","dfltRange","DFLTRANGEY","_name","DFLTRANGEX","slice","rangemode","set","nullRange0","nullRange1","autorange","isDateTime","linCenter","constrain","MIN_MS","MAX_MS","inc","setScale","usePrivateRange","gs","_size","overlaying","getFromId","_fullLayout","domain","_r","_offset","t","h","l","w","_lBreaks","brk","locateBreaks","sign","_replotting","Error","maskBreaks","rangebreaksIn","bnds","b0","b1","vb","vDate","_cachedPatterns","map","enabled","pattern","_cachedValues","values","sorterAsc","getUTCDay","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","vals","dvalue","rangebreaksOut","addBreak","isNewBreak","brkj","t0","t1","t0Date","bndDelta","step","makeCalcdata","axType","cal","isTypedArray","subarray","dv","Number","x","y","isValidRange","nullOk","getAutorangeDflt","options","autorangeDflt","reverseDflt","isReversed","isPtWithinRange","coord","_emptyCategories","clearCalc","categories","categoriesMap","_initialCategories","sortByInitialCategories","affectedTraces","locale","_d3locale","_dateFormat","timeFormat","_extraFormat","_separators","separators","_numFormat","_minDtick","_forceTick0"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/cartesian/set_convert.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar utcFormat = require('d3-time-format').utcFormat;\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\n\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\nvar numConstants = require('../../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar ONEWEEK = numConstants.ONEWEEK;\nvar ONEDAY = numConstants.ONEDAY;\nvar ONEHOUR = numConstants.ONEHOUR;\nvar ONEMIN = numConstants.ONEMIN;\nvar ONESEC = numConstants.ONESEC;\n\nvar axisIds = require('./axis_ids');\nvar constants = require('./constants');\nvar HOUR_PATTERN = constants.HOUR_PATTERN;\nvar WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;\n\nfunction fromLog(v) {\n    return Math.pow(10, v);\n}\n\nfunction isValidCategory(v) {\n    return v !== null && v !== undefined;\n}\n\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v3.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\nmodule.exports = function setConvert(ax, fullLayout) {\n    fullLayout = fullLayout || {};\n\n    var axId = (ax._id || 'x');\n    var axLetter = axId.charAt(0);\n\n    function toLog(v, clip) {\n        if(v > 0) return Math.log(v) / Math.LN10;\n\n        else if(v <= 0 && clip && ax.range && ax.range.length === 2) {\n            // clip NaN (ie past negative infinity) to LOG_CLIP axis\n            // length past the negative edge\n            var r0 = ax.range[0];\n            var r1 = ax.range[1];\n            return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n        } else return BADNUM;\n    }\n\n    /*\n     * wrapped dateTime2ms that:\n     * - accepts ms numbers for backward compatibility\n     * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n     * - defaults to ax.calendar\n     */\n    function dt2ms(v, _, calendar, opts) {\n        if((opts || {}).msUTC && isNumeric(v)) {\n            // For now it is only used\n            // to fix bar length in milliseconds & gl3d ticks\n            // It could be applied in other places in v3\n            return +v;\n        }\n\n        // NOTE: Changed this behavior: previously we took any numeric value\n        // to be a ms, even if it was a string that could be a bare year.\n        // Now we convert it as a date if at all possible, and only try\n        // as (local) ms if that fails.\n        var ms = dateTime2ms(v, calendar || ax.calendar);\n        if(ms === BADNUM) {\n            if(isNumeric(v)) {\n                v = +v;\n                // keep track of tenths of ms, that `new Date` will drop\n                // same logic as in Lib.ms2DateTime\n                var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n                var msRounded = Math.round(v - msecTenths / 10);\n                ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n            } else return BADNUM;\n        }\n        return ms;\n    }\n\n    // wrapped ms2DateTime to insert default ax.calendar\n    function ms2dt(v, r, calendar) {\n        return ms2DateTime(v, r, calendar || ax.calendar);\n    }\n\n    function getCategoryName(v) {\n        return ax._categories[Math.round(v)];\n    }\n\n    /*\n     * setCategoryIndex: return the index of category v,\n     * inserting it in the list if it's not already there\n     *\n     * this will enter the categories in the order it\n     * encounters them, ie all the categories from the\n     * first data set, then all the ones from the second\n     * that aren't in the first etc.\n     *\n     * it is assumed that this function is being invoked in the\n     * already sorted category order; otherwise there would be\n     * a disconnect between the array and the index returned\n     */\n    function setCategoryIndex(v) {\n        if(isValidCategory(v)) {\n            if(ax._categoriesMap === undefined) {\n                ax._categoriesMap = {};\n            }\n\n            if(ax._categoriesMap[v] !== undefined) {\n                return ax._categoriesMap[v];\n            } else {\n                ax._categories.push(typeof v === 'number' ? String(v) : v);\n\n                var curLength = ax._categories.length - 1;\n                ax._categoriesMap[v] = curLength;\n\n                return curLength;\n            }\n        }\n        return BADNUM;\n    }\n\n    function setMultiCategoryIndex(arrayIn, len) {\n        var arrayOut = new Array(len);\n\n        for(var i = 0; i < len; i++) {\n            var v0 = (arrayIn[0] || [])[i];\n            var v1 = (arrayIn[1] || [])[i];\n            arrayOut[i] = getCategoryIndex([v0, v1]);\n        }\n\n        return arrayOut;\n    }\n\n    function getCategoryIndex(v) {\n        if(ax._categoriesMap) {\n            return ax._categoriesMap[v];\n        }\n    }\n\n    function getCategoryPosition(v) {\n        // d2l/d2c variant that that won't add categories but will also\n        // allow numbers to be mapped to the linearized axis positions\n        var index = getCategoryIndex(v);\n        if(index !== undefined) return index;\n        if(isNumeric(v)) return +v;\n    }\n\n    function getRangePosition(v) {\n        return isNumeric(v) ? +v : getCategoryIndex(v);\n    }\n\n    // include 2 fractional digits on pixel, for PDF zooming etc\n    function _l2p(v, m, b) { return d3.round(b + m * v, 2); }\n\n    function _p2l(px, m, b) { return (px - b) / m; }\n\n    var l2p = function l2p(v) {\n        if(!isNumeric(v)) return BADNUM;\n        return _l2p(v, ax._m, ax._b);\n    };\n\n    var p2l = function(px) {\n        return _p2l(px, ax._m, ax._b);\n    };\n\n    if(ax.rangebreaks) {\n        var isY = axLetter === 'y';\n\n        l2p = function(v) {\n            if(!isNumeric(v)) return BADNUM;\n            var len = ax._rangebreaks.length;\n            if(!len) return _l2p(v, ax._m, ax._b);\n\n            var flip = isY;\n            if(ax.range[0] > ax.range[1]) flip = !flip;\n            var signAx = flip ? -1 : 1;\n            var pos = signAx * v;\n\n            var q = 0;\n            for(var i = 0; i < len; i++) {\n                var min = signAx * ax._rangebreaks[i].min;\n                var max = signAx * ax._rangebreaks[i].max;\n\n                if(pos < min) break;\n                if(pos > max) q = i + 1;\n                else {\n                    // when falls into break, pick 'closest' offset\n                    q = pos < (min + max) / 2 ? i : i + 1;\n                    break;\n                }\n            }\n            var b2 = ax._B[q] || 0;\n            if(!isFinite(b2)) return 0; // avoid NaN translate e.g. in positionLabels if one keep zooming exactly into a break\n            return _l2p(v, ax._m2, b2);\n        };\n\n        p2l = function(px) {\n            var len = ax._rangebreaks.length;\n            if(!len) return _p2l(px, ax._m, ax._b);\n\n            var q = 0;\n            for(var i = 0; i < len; i++) {\n                if(px < ax._rangebreaks[i].pmin) break;\n                if(px > ax._rangebreaks[i].pmax) q = i + 1;\n            }\n            return _p2l(px, ax._m2, ax._B[q]);\n        };\n    }\n\n    // conversions among c/l/p are fairly simple - do them together for all axis types\n    ax.c2l = (ax.type === 'log') ? toLog : ensureNumber;\n    ax.l2c = (ax.type === 'log') ? fromLog : ensureNumber;\n\n    ax.l2p = l2p;\n    ax.p2l = p2l;\n\n    ax.c2p = (ax.type === 'log') ? function(v, clip) { return l2p(toLog(v, clip)); } : l2p;\n    ax.p2c = (ax.type === 'log') ? function(px) { return fromLog(p2l(px)); } : p2l;\n\n    /*\n     * now type-specific conversions for **ALL** other combinations\n     * they're all written out, instead of being combinations of each other, for\n     * both clarity and speed.\n     */\n    if(['linear', '-'].indexOf(ax.type) !== -1) {\n        // all are data vals, but d and r need cleaning\n        ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n\n        ax.d2p = ax.r2p = function(v) { return ax.l2p(cleanNumber(v)); };\n        ax.p2d = ax.p2r = p2l;\n\n        ax.cleanPos = ensureNumber;\n    } else if(ax.type === 'log') {\n        // d and c are data vals, r and l are logged (but d and r need cleaning)\n        ax.d2r = ax.d2l = function(v, clip) { return toLog(cleanNumber(v), clip); };\n        ax.r2d = ax.r2c = function(v) { return fromLog(cleanNumber(v)); };\n\n        ax.d2c = ax.r2l = cleanNumber;\n        ax.c2d = ax.l2r = ensureNumber;\n\n        ax.c2r = toLog;\n        ax.l2d = fromLog;\n\n        ax.d2p = function(v, clip) { return ax.l2p(ax.d2r(v, clip)); };\n        ax.p2d = function(px) { return fromLog(p2l(px)); };\n\n        ax.r2p = function(v) { return ax.l2p(cleanNumber(v)); };\n        ax.p2r = p2l;\n\n        ax.cleanPos = ensureNumber;\n    } else if(ax.type === 'date') {\n        // r and d are date strings, l and c are ms\n\n        /*\n         * Any of these functions with r and d on either side, calendar is the\n         * **3rd** argument. log has reserved the second argument.\n         *\n         * Unless you need the special behavior of the second arg (ms2DateTime\n         * uses this to limit precision, toLog uses true to clip negatives\n         * to offscreen low rather than undefined), it's safe to pass 0.\n         */\n        ax.d2r = ax.r2d = Lib.identity;\n\n        ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n\n        ax.d2p = ax.r2p = function(v, _, calendar) { return ax.l2p(dt2ms(v, 0, calendar)); };\n        ax.p2d = ax.p2r = function(px, r, calendar) { return ms2dt(p2l(px), r, calendar); };\n\n        ax.cleanPos = function(v) { return Lib.cleanDate(v, BADNUM, ax.calendar); };\n    } else if(ax.type === 'category') {\n        // d is categories (string)\n        // c and l are indices (numbers)\n        // r is categories or numbers\n\n        ax.d2c = ax.d2l = setCategoryIndex;\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n\n        ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n        ax.r2c = function(v) {\n            var index = getRangePosition(v);\n            return index !== undefined ? index : ax.fraction2r(0.5);\n        };\n\n        ax.l2r = ax.c2r = ensureNumber;\n        ax.r2l = getRangePosition;\n\n        ax.d2p = function(v) { return ax.l2p(ax.r2c(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = ax.d2p;\n        ax.p2r = p2l;\n\n        ax.cleanPos = function(v) {\n            if(typeof v === 'string' && v !== '') return v;\n            return ensureNumber(v);\n        };\n    } else if(ax.type === 'multicategory') {\n        // N.B. multicategory axes don't define d2c and d2l,\n        // as 'data-to-calcdata' conversion needs to take into\n        // account all data array items as in ax.makeCalcdata.\n\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n        ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n        ax.r2c = function(v) {\n            var index = getCategoryPosition(v);\n            return index !== undefined ? index : ax.fraction2r(0.5);\n        };\n\n        ax.r2c_just_indices = getCategoryIndex;\n\n        ax.l2r = ax.c2r = ensureNumber;\n        ax.r2l = getCategoryPosition;\n\n        ax.d2p = function(v) { return ax.l2p(ax.r2c(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = ax.d2p;\n        ax.p2r = p2l;\n\n        ax.cleanPos = function(v) {\n            if(Array.isArray(v) || (typeof v === 'string' && v !== '')) return v;\n            return ensureNumber(v);\n        };\n\n        ax.setupMultiCategory = function(fullData) {\n            var traceIndices = ax._traceIndices;\n            var i, j;\n\n            var group = ax._matchGroup;\n            if(group && ax._categories.length === 0) {\n                for(var axId2 in group) {\n                    if(axId2 !== axId) {\n                        var ax2 = fullLayout[axisIds.id2name(axId2)];\n                        traceIndices = traceIndices.concat(ax2._traceIndices);\n                    }\n                }\n            }\n\n            // [ [cnt, {$cat: index}], for 1,2 ]\n            var seen = [[0, {}], [0, {}]];\n            // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n            var list = [];\n\n            for(i = 0; i < traceIndices.length; i++) {\n                var trace = fullData[traceIndices[i]];\n\n                if(axLetter in trace) {\n                    var arrayIn = trace[axLetter];\n                    var len = trace._length || Lib.minRowLength(arrayIn);\n\n                    if(isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n                        for(j = 0; j < len; j++) {\n                            var v0 = arrayIn[0][j];\n                            var v1 = arrayIn[1][j];\n\n                            if(isValidCategory(v0) && isValidCategory(v1)) {\n                                list.push([v0, v1]);\n\n                                if(!(v0 in seen[0][1])) {\n                                    seen[0][1][v0] = seen[0][0]++;\n                                }\n                                if(!(v1 in seen[1][1])) {\n                                    seen[1][1][v1] = seen[1][0]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            list.sort(function(a, b) {\n                var ind0 = seen[0][1];\n                var d = ind0[a[0]] - ind0[b[0]];\n                if(d) return d;\n\n                var ind1 = seen[1][1];\n                return ind1[a[1]] - ind1[b[1]];\n            });\n\n            for(i = 0; i < list.length; i++) {\n                setCategoryIndex(list[i]);\n            }\n        };\n    }\n\n    // find the range value at the specified (linear) fraction of the axis\n    ax.fraction2r = function(v) {\n        var rl0 = ax.r2l(ax.range[0]);\n        var rl1 = ax.r2l(ax.range[1]);\n        return ax.l2r(rl0 + v * (rl1 - rl0));\n    };\n\n    // find the fraction of the range at the specified range value\n    ax.r2fraction = function(v) {\n        var rl0 = ax.r2l(ax.range[0]);\n        var rl1 = ax.r2l(ax.range[1]);\n        return (ax.r2l(v) - rl0) / (rl1 - rl0);\n    };\n\n    ax.limitRange = function(rangeAttr) {\n        var minallowed = ax.minallowed;\n        var maxallowed = ax.maxallowed;\n        if(minallowed === undefined && maxallowed === undefined) return;\n\n        if(!rangeAttr) rangeAttr = 'range';\n        var range = Lib.nestedProperty(ax, rangeAttr).get();\n        var rng = Lib.simpleMap(range, ax.r2l);\n        var axrev = rng[1] < rng[0];\n        if(axrev) rng.reverse();\n\n        var bounds = Lib.simpleMap([minallowed, maxallowed], ax.r2l);\n\n        if(minallowed !== undefined && rng[0] < bounds[0]) range[axrev ? 1 : 0] = minallowed;\n        if(maxallowed !== undefined && rng[1] > bounds[1]) range[axrev ? 0 : 1] = maxallowed;\n\n        if(range[0] === range[1]) {\n            var minL = ax.l2r(minallowed);\n            var maxL = ax.l2r(maxallowed);\n\n            if(minallowed !== undefined) {\n                var _max = minL + 1;\n                if(maxallowed !== undefined) _max = Math.min(_max, maxL);\n                range[axrev ? 1 : 0] = _max;\n            }\n\n            if(maxallowed !== undefined) {\n                var _min = maxL + 1;\n                if(minallowed !== undefined) _min = Math.max(_min, minL);\n                range[axrev ? 0 : 1] = _min;\n            }\n        }\n    };\n\n    /*\n     * cleanRange: make sure range is a couplet of valid & distinct values\n     * keep numbers away from the limits of floating point numbers,\n     * and dates away from the ends of our date system (+/- 9999 years)\n     *\n     * optional param rangeAttr: operate on a different attribute, like\n     * ax._r, rather than ax.range\n     */\n    ax.cleanRange = function(rangeAttr, opts) {\n        ax._cleanRange(rangeAttr, opts);\n        ax.limitRange(rangeAttr);\n    };\n\n    ax._cleanRange = function(rangeAttr, opts) {\n        if(!opts) opts = {};\n        if(!rangeAttr) rangeAttr = 'range';\n\n        var range = Lib.nestedProperty(ax, rangeAttr).get();\n        var i, dflt;\n\n        if(ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);\n        else if(axLetter === 'y') dflt = constants.DFLTRANGEY;\n        else if(ax._name === 'realaxis') dflt = [0, 1];\n        else dflt = opts.dfltRange || constants.DFLTRANGEX;\n\n        // make sure we don't later mutate the defaults\n        dflt = dflt.slice();\n\n        if(ax.rangemode === 'tozero' || ax.rangemode === 'nonnegative') {\n            dflt[0] = 0;\n        }\n\n        if(!range || range.length !== 2) {\n            Lib.nestedProperty(ax, rangeAttr).set(dflt);\n            return;\n        }\n\n        var nullRange0 = range[0] === null;\n        var nullRange1 = range[1] === null;\n\n        if(ax.type === 'date' && !ax.autorange) {\n            // check if milliseconds or js date objects are provided for range\n            // and convert to date strings\n            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n        }\n\n        for(i = 0; i < 2; i++) {\n            if(ax.type === 'date') {\n                if(!Lib.isDateTime(range[i], ax.calendar)) {\n                    ax[rangeAttr] = dflt;\n                    break;\n                }\n\n                if(ax.r2l(range[0]) === ax.r2l(range[1])) {\n                    // split by +/- 1 second\n                    var linCenter = Lib.constrain(ax.r2l(range[0]),\n                        Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n                    range[0] = ax.l2r(linCenter - 1000);\n                    range[1] = ax.l2r(linCenter + 1000);\n                    break;\n                }\n            } else {\n                if(!isNumeric(range[i])) {\n                    if(!(nullRange0 || nullRange1) && isNumeric(range[1 - i])) {\n                        range[i] = range[1 - i] * (i ? 10 : 0.1);\n                    } else {\n                        ax[rangeAttr] = dflt;\n                        break;\n                    }\n                }\n\n                if(range[i] < -FP_SAFE) range[i] = -FP_SAFE;\n                else if(range[i] > FP_SAFE) range[i] = FP_SAFE;\n\n                if(range[0] === range[1]) {\n                    // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n                    var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n                    range[0] -= inc;\n                    range[1] += inc;\n                }\n            }\n        }\n    };\n\n    // set scaling to pixels\n    ax.setScale = function(usePrivateRange) {\n        var gs = fullLayout._size;\n\n        // make sure we have a domain (pull it in from the axis\n        // this one is overlaying if necessary)\n        if(ax.overlaying) {\n            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);\n            ax.domain = ax2.domain;\n        }\n\n        // While transitions are occurring, we get a double-transform\n        // issue if we transform the drawn layer *and* use the new axis range to\n        // draw the data. This allows us to construct setConvert using the pre-\n        // interaction values of the range:\n        var rangeAttr = (usePrivateRange && ax._r) ? '_r' : 'range';\n        var calendar = ax.calendar;\n        ax.cleanRange(rangeAttr);\n\n        var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n        var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n\n        var isY = axLetter === 'y';\n        if(isY) {\n            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl0 - rl1);\n            ax._b = -ax._m * rl1;\n        } else {\n            ax._offset = gs.l + ax.domain[0] * gs.w;\n            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl1 - rl0);\n            ax._b = -ax._m * rl0;\n        }\n\n        // set of \"N\" disjoint rangebreaks inside the range\n        ax._rangebreaks = [];\n        // length of these rangebreaks in value space - negative on reversed axes\n        ax._lBreaks = 0;\n        // l2p slope (same for all intervals)\n        ax._m2 = 0;\n        // set of l2p offsets (one for each of the (N+1) piecewise intervals)\n        ax._B = [];\n\n        if(ax.rangebreaks) {\n            var i, brk;\n\n            ax._rangebreaks = ax.locateBreaks(\n                Math.min(rl0, rl1),\n                Math.max(rl0, rl1)\n            );\n\n            if(ax._rangebreaks.length) {\n                for(i = 0; i < ax._rangebreaks.length; i++) {\n                    brk = ax._rangebreaks[i];\n                    ax._lBreaks += Math.abs(brk.max - brk.min);\n                }\n\n                var flip = isY;\n                if(rl0 > rl1) flip = !flip;\n                if(flip) ax._rangebreaks.reverse();\n                var sign = flip ? -1 : 1;\n\n                ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);\n                ax._B.push(-ax._m2 * (isY ? rl1 : rl0));\n                for(i = 0; i < ax._rangebreaks.length; i++) {\n                    brk = ax._rangebreaks[i];\n                    ax._B.push(\n                        ax._B[ax._B.length - 1] -\n                        sign * ax._m2 * (brk.max - brk.min)\n                    );\n                }\n\n                // fill pixel (i.e. 'p') min/max here,\n                // to not have to loop through the _rangebreaks twice during `p2l`\n                for(i = 0; i < ax._rangebreaks.length; i++) {\n                    brk = ax._rangebreaks[i];\n                    brk.pmin = l2p(brk.min);\n                    brk.pmax = l2p(brk.max);\n                }\n            }\n        }\n\n        if(!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {\n            fullLayout._replotting = false;\n            throw new Error('Something went wrong with axis scaling');\n        }\n    };\n\n    ax.maskBreaks = function(v) {\n        var rangebreaksIn = ax.rangebreaks || [];\n        var bnds, b0, b1, vb, vDate;\n\n\n        if(!rangebreaksIn._cachedPatterns) {\n            rangebreaksIn._cachedPatterns = rangebreaksIn.map(function(brk) {\n                return brk.enabled && brk.bounds ? Lib.simpleMap(brk.bounds, brk.pattern ?\n                    cleanNumber :\n                    ax.d2c // case of pattern: ''\n                ) : null;\n            });\n        }\n        if(!rangebreaksIn._cachedValues) {\n            rangebreaksIn._cachedValues = rangebreaksIn.map(function(brk) {\n                return brk.enabled && brk.values ? Lib.simpleMap(brk.values, ax.d2c).sort(Lib.sorterAsc) : null;\n            });\n        }\n\n\n        for(var i = 0; i < rangebreaksIn.length; i++) {\n            var brk = rangebreaksIn[i];\n\n            if(brk.enabled) {\n                if(brk.bounds) {\n                    var pattern = brk.pattern;\n                    bnds = rangebreaksIn._cachedPatterns[i];\n                    b0 = bnds[0];\n                    b1 = bnds[1];\n\n                    switch(pattern) {\n                        case WEEKDAY_PATTERN:\n                            vDate = new Date(v);\n                            vb = vDate.getUTCDay();\n\n                            if(b0 > b1) {\n                                b1 += 7;\n                                if(vb < b0) vb += 7;\n                            }\n\n                            break;\n                        case HOUR_PATTERN:\n                            vDate = new Date(v);\n                            var hours = vDate.getUTCHours();\n                            var minutes = vDate.getUTCMinutes();\n                            var seconds = vDate.getUTCSeconds();\n                            var milliseconds = vDate.getUTCMilliseconds();\n\n                            vb = hours + (\n                                minutes / 60 +\n                                seconds / 3600 +\n                                milliseconds / 3600000\n                            );\n\n                            if(b0 > b1) {\n                                b1 += 24;\n                                if(vb < b0) vb += 24;\n                            }\n\n                            break;\n                        case '':\n                            // N.B. should work on date axes as well!\n                            // e.g. { bounds: ['2020-01-04', '2020-01-05 23:59'] }\n                            // TODO should work with reversed-range axes\n                            vb = v;\n                            break;\n                    }\n\n                    if(vb >= b0 && vb < b1) return BADNUM;\n                } else {\n                    var vals = rangebreaksIn._cachedValues[i];\n                    for(var j = 0; j < vals.length; j++) {\n                        b0 = vals[j];\n                        b1 = b0 + brk.dvalue;\n                        if(v >= b0 && v < b1) return BADNUM;\n                    }\n                }\n            }\n        }\n        return v;\n    };\n\n    ax.locateBreaks = function(r0, r1) {\n        var i, bnds, b0, b1;\n\n        var rangebreaksOut = [];\n        if(!ax.rangebreaks) return rangebreaksOut;\n\n        var rangebreaksIn = ax.rangebreaks.slice().sort(function(a, b) {\n            if(a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;\n            if(b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;\n            return 0;\n        });\n\n        var addBreak = function(min, max) {\n            min = Lib.constrain(min, r0, r1);\n            max = Lib.constrain(max, r0, r1);\n            if(min === max) return;\n\n            var isNewBreak = true;\n            for(var j = 0; j < rangebreaksOut.length; j++) {\n                var brkj = rangebreaksOut[j];\n                if(min < brkj.max && max >= brkj.min) {\n                    if(min < brkj.min) {\n                        brkj.min = min;\n                    }\n                    if(max > brkj.max) {\n                        brkj.max = max;\n                    }\n                    isNewBreak = false;\n                }\n            }\n            if(isNewBreak) {\n                rangebreaksOut.push({min: min, max: max});\n            }\n        };\n\n        for(i = 0; i < rangebreaksIn.length; i++) {\n            var brk = rangebreaksIn[i];\n\n            if(brk.enabled) {\n                if(brk.bounds) {\n                    var t0 = r0;\n                    var t1 = r1;\n                    if(brk.pattern) {\n                        // to remove decimal (most often found in auto ranges)\n                        t0 = Math.floor(t0);\n                    }\n\n                    bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);\n                    b0 = bnds[0];\n                    b1 = bnds[1];\n\n                    // r0 value as date\n                    var t0Date = new Date(t0);\n                    // r0 value for break pattern\n                    var bndDelta;\n                    // step in ms between rangebreaks\n                    var step;\n\n                    switch(brk.pattern) {\n                        case WEEKDAY_PATTERN:\n                            step = ONEWEEK;\n\n                            bndDelta = (\n                                (b1 < b0 ? 7 : 0) +\n                                (b1 - b0)\n                            ) * ONEDAY;\n\n                            t0 += b0 * ONEDAY - (\n                                t0Date.getUTCDay() * ONEDAY +\n                                t0Date.getUTCHours() * ONEHOUR +\n                                t0Date.getUTCMinutes() * ONEMIN +\n                                t0Date.getUTCSeconds() * ONESEC +\n                                t0Date.getUTCMilliseconds()\n                            );\n                            break;\n                        case HOUR_PATTERN:\n                            step = ONEDAY;\n\n                            bndDelta = (\n                                (b1 < b0 ? 24 : 0) +\n                                (b1 - b0)\n                            ) * ONEHOUR;\n\n                            t0 += b0 * ONEHOUR - (\n                                t0Date.getUTCHours() * ONEHOUR +\n                                t0Date.getUTCMinutes() * ONEMIN +\n                                t0Date.getUTCSeconds() * ONESEC +\n                                t0Date.getUTCMilliseconds()\n                            );\n                            break;\n                        default:\n                            t0 = Math.min(bnds[0], bnds[1]);\n                            t1 = Math.max(bnds[0], bnds[1]);\n                            step = t1 - t0;\n                            bndDelta = step;\n                    }\n\n                    for(var t = t0; t < t1; t += step) {\n                        addBreak(t, t + bndDelta);\n                    }\n                } else {\n                    var vals = Lib.simpleMap(brk.values, ax.d2c);\n                    for(var j = 0; j < vals.length; j++) {\n                        b0 = vals[j];\n                        b1 = b0 + brk.dvalue;\n                        addBreak(b0, b1);\n                    }\n                }\n            }\n        }\n\n        rangebreaksOut.sort(function(a, b) { return a.min - b.min; });\n\n        return rangebreaksOut;\n    };\n\n    // makeCalcdata: takes an x or y array and converts it\n    // to a position on the axis object \"ax\"\n    // inputs:\n    //      trace - a data object from gd.data\n    //      axLetter - a string, either 'x' or 'y', for which item\n    //          to convert (TODO: is this now always the same as\n    //          the first letter of ax._id?)\n    // in case the expected data isn't there, make a list of\n    // integers based on the opposite data\n    ax.makeCalcdata = function(trace, axLetter, opts) {\n        var arrayIn, arrayOut, i, len;\n\n        var axType = ax.type;\n        var cal = axType === 'date' && trace[axLetter + 'calendar'];\n\n        if(axLetter in trace) {\n            arrayIn = trace[axLetter];\n            len = trace._length || Lib.minRowLength(arrayIn);\n\n            if(Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n                if(len === arrayIn.length) {\n                    return arrayIn;\n                } else if(arrayIn.subarray) {\n                    return arrayIn.subarray(0, len);\n                }\n            }\n\n            if(axType === 'multicategory') {\n                return setMultiCategoryIndex(arrayIn, len);\n            }\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);\n            }\n        } else {\n            var v0 = ((axLetter + '0') in trace) ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n            var dv = (trace['d' + axLetter]) ? Number(trace['d' + axLetter]) : 1;\n\n            // the opposing data, for size if we have x and dx etc\n            arrayIn = trace[{x: 'y', y: 'x'}[axLetter]];\n            len = trace._length || arrayIn.length;\n            arrayOut = new Array(len);\n\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = v0 + i * dv;\n            }\n        }\n\n        // mask (i.e. set to BADNUM) coords that fall inside rangebreaks\n        if(ax.rangebreaks) {\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = ax.maskBreaks(arrayOut[i]);\n            }\n        }\n\n        return arrayOut;\n    };\n\n    ax.isValidRange = function(range, nullOk) {\n        return (\n            Array.isArray(range) &&\n            range.length === 2 &&\n            ((nullOk && range[0] === null) || isNumeric(ax.r2l(range[0]))) &&\n            ((nullOk && range[1] === null) || isNumeric(ax.r2l(range[1])))\n        );\n    };\n\n    ax.getAutorangeDflt = function(range, options) {\n        var autorangeDflt = !ax.isValidRange(range, 'nullOk');\n        if(autorangeDflt && options && options.reverseDflt) autorangeDflt = 'reversed';\n        else if(range) {\n            if(range[0] === null && range[1] === null) {\n                autorangeDflt = true;\n            } else if(range[0] === null && range[1] !== null) {\n                autorangeDflt = 'min';\n            } else if(range[0] !== null && range[1] === null) {\n                autorangeDflt = 'max';\n            }\n        }\n        return autorangeDflt;\n    };\n\n    ax.isReversed = function() {\n        var autorange = ax.autorange;\n        return (\n            autorange === 'reversed' ||\n            autorange === 'min reversed' ||\n            autorange === 'max reversed'\n        );\n    };\n\n    ax.isPtWithinRange = function(d, calendar) {\n        var coord = ax.c2l(d[axLetter], null, calendar);\n        var r0 = ax.r2l(ax.range[0]);\n        var r1 = ax.r2l(ax.range[1]);\n\n        if(r0 < r1) {\n            return r0 <= coord && coord <= r1;\n        } else {\n            // Reversed axis case.\n            return r1 <= coord && coord <= r0;\n        }\n    };\n\n    ax._emptyCategories = function() {\n        ax._categories = [];\n        ax._categoriesMap = {};\n    };\n\n    // should skip if not category nor multicategory\n    ax.clearCalc = function() {\n        var group = ax._matchGroup;\n        if(group) {\n            var categories = null;\n            var categoriesMap = null;\n\n            for(var axId2 in group) {\n                var ax2 = fullLayout[axisIds.id2name(axId2)];\n                if(ax2._categories) {\n                    categories = ax2._categories;\n                    categoriesMap = ax2._categoriesMap;\n                    break;\n                }\n            }\n\n            if(categories && categoriesMap) {\n                ax._categories = categories;\n                ax._categoriesMap = categoriesMap;\n            } else {\n                ax._emptyCategories();\n            }\n        } else {\n            ax._emptyCategories();\n        }\n\n        if(ax._initialCategories) {\n            for(var j = 0; j < ax._initialCategories.length; j++) {\n                setCategoryIndex(ax._initialCategories[j]);\n            }\n        }\n    };\n\n    // sort the axis (and all the matching ones) by _initialCategories\n    // returns the indices of the traces affected by the reordering\n    ax.sortByInitialCategories = function() {\n        var affectedTraces = [];\n\n        ax._emptyCategories();\n\n        if(ax._initialCategories) {\n            for(var j = 0; j < ax._initialCategories.length; j++) {\n                setCategoryIndex(ax._initialCategories[j]);\n            }\n        }\n\n        affectedTraces = affectedTraces.concat(ax._traceIndices);\n\n        // Propagate to matching axes\n        var group = ax._matchGroup;\n        for(var axId2 in group) {\n            if(axId === axId2) continue;\n            var ax2 = fullLayout[axisIds.id2name(axId2)];\n            ax2._categories = ax._categories;\n            ax2._categoriesMap = ax._categoriesMap;\n            affectedTraces = affectedTraces.concat(ax2._traceIndices);\n        }\n        return affectedTraces;\n    };\n\n    // Propagate localization into the axis so that\n    // methods in Axes can use it w/o having to pass fullLayout\n    // Default (non-d3) number formatting uses separators directly\n    // dates and d3-formatted numbers use the d3 locale\n    // Fall back on default format for dummy axes that don't care about formatting\n    var locale = fullLayout._d3locale;\n    if(ax.type === 'date') {\n        ax._dateFormat = locale ? locale.timeFormat : utcFormat;\n        ax._extraFormat = fullLayout._extraFormat;\n    }\n    // occasionally we need _numFormat to pass through\n    // even though it won't be needed by this axis\n    ax._separators = fullLayout.separators;\n    ax._numFormat = locale ? locale.numberFormat : numberFormat;\n\n    // and for bar charts and box plots: reset forced minimum tick spacing\n    delete ax._minDtick;\n    delete ax._forceTick0;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}