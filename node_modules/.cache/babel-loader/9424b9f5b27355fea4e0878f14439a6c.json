{"ast":null,"code":"'use strict';\n\nvar polybool = require('polybooljs');\nvar pointInPolygon = require('point-in-polygon/nested'); // could we use contains lib/polygon instead?\n\nvar Registry = require('../../registry');\nvar dashStyle = require('../drawing').dashStyle;\nvar Color = require('../color');\nvar Fx = require('../fx');\nvar makeEventData = require('../fx/helpers').makeEventData;\nvar dragHelpers = require('../dragelement/helpers');\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\nvar shapeHelpers = require('../shapes/helpers');\nvar shapeConstants = require('../shapes/constants');\nvar displayOutlines = require('../shapes/display_outlines');\nvar clearOutline = require('../shapes/handle_outline').clearOutline;\nvar newShapeHelpers = require('../shapes/draw_newshape/helpers');\nvar handleEllipse = newShapeHelpers.handleEllipse;\nvar readPaths = newShapeHelpers.readPaths;\nvar newShapes = require('../shapes/draw_newshape/newshapes').newShapes;\nvar newSelections = require('./draw_newselection/newselections');\nvar activateLastSelection = require('./draw').activateLastSelection;\nvar Lib = require('../../lib');\nvar ascending = Lib.sorterAsc;\nvar libPolygon = require('../../lib/polygon');\nvar throttle = require('../../lib/throttle');\nvar getFromId = require('../../plots/cartesian/axis_ids').getFromId;\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\nvar constants = require('./constants');\nvar MINSELECT = constants.MINSELECT;\nvar filteredPolygon = libPolygon.filter;\nvar polygonTester = libPolygon.tester;\nvar helpers = require('./helpers');\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\nfunction hasSubplot(dragOptions) {\n  // N.B. subplot may be falsy e.g zero sankey index!\n  return dragOptions.subplot !== undefined;\n}\nfunction prepSelect(evt, startX, startY, dragOptions, mode) {\n  var isCartesian = !hasSubplot(dragOptions);\n  var isFreeMode = freeMode(mode);\n  var isRectMode = rectMode(mode);\n  var isOpenMode = openMode(mode);\n  var isDrawMode = drawMode(mode);\n  var isSelectMode = selectMode(mode);\n  var isLine = mode === 'drawline';\n  var isEllipse = mode === 'drawcircle';\n  var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n  var gd = dragOptions.gd;\n  var fullLayout = gd._fullLayout;\n  var immediateSelect = isSelectMode && fullLayout.newselection.mode === 'immediate' && isCartesian; // N.B. only cartesian subplots have persistent selection\n\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragBBox = dragOptions.element.getBoundingClientRect();\n  var plotinfo = dragOptions.plotinfo;\n  var transform = getTransform(plotinfo);\n  var x0 = startX - dragBBox.left;\n  var y0 = startY - dragBBox.top;\n  fullLayout._calcInverseTransform(gd);\n  var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  x0 = transformedCoords[0];\n  y0 = transformedCoords[1];\n  var scaleX = fullLayout._invScaleX;\n  var scaleY = fullLayout._invScaleY;\n  var x1 = x0;\n  var y1 = y0;\n  var path0 = 'M' + x0 + ',' + y0;\n  var xAxis = dragOptions.xaxes[0];\n  var yAxis = dragOptions.yaxes[0];\n  var pw = xAxis._length;\n  var ph = yAxis._length;\n  var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);\n  var filterPoly, selectionTesters, mergedPolygons, currentPolygon;\n  var i, searchInfo, eventData;\n  coerceSelectionsCache(evt, gd, dragOptions);\n  if (isFreeMode) {\n    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n  }\n  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1]);\n  var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;\n  if (isDrawMode) {\n    dragOptions.hasText = newStyle.label.text || newStyle.label.texttemplate;\n  }\n  var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : 'rgba(0,0,0,0)';\n  var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : '#7f7f7f' // non-cartesian subplot\n  );\n  outlines.enter().append('path').attr('class', 'select-outline select-outline-' + plotinfo.id).style({\n    opacity: isDrawMode ? newStyle.opacity / 2 : 1,\n    'stroke-dasharray': dashStyle(newStyle.line.dash, newStyle.line.width),\n    'stroke-width': newStyle.line.width + 'px',\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr('fill-rule', 'evenodd').classed('cursor-move', isDrawMode ? true : false).attr('transform', transform).attr('d', path0 + 'Z');\n  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1\n  }).attr('transform', transform).attr('d', 'M0,0Z');\n\n  // create & style group for text label\n  if (isDrawMode && dragOptions.hasText) {\n    var shapeGroup = zoomLayer.select('.label-temp');\n    if (shapeGroup.empty()) {\n      shapeGroup = zoomLayer.append('g').classed('label-temp', true).classed('select-outline', true).style({\n        opacity: 0.8\n      });\n    }\n  }\n  var throttleID = fullLayout._uid + constants.SELECTID;\n  var selection = [];\n\n  // find the traces to search for selection points\n  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot);\n  if (immediateSelect && !evt.shiftKey) {\n    dragOptions._clearSubplotSelections = function () {\n      if (!isCartesian) return;\n      var xRef = xAxis._id;\n      var yRef = yAxis._id;\n      deselectSubplot(gd, xRef, yRef, searchTraces);\n      var selections = (gd.layout || {}).selections || [];\n      var list = [];\n      var selectionErased = false;\n      for (var q = 0; q < selections.length; q++) {\n        var s = fullLayout.selections[q];\n        if (s.xref !== xRef || s.yref !== yRef) {\n          list.push(selections[q]);\n        } else {\n          selectionErased = true;\n        }\n      }\n      if (selectionErased) {\n        gd._fullLayout._noEmitSelectedAtStart = true;\n        Registry.call('_guiRelayout', gd, {\n          selections: list\n        });\n      }\n    };\n  }\n  var fillRangeItems = getFillRangeItems(dragOptions);\n  dragOptions.moveFn = function (dx0, dy0) {\n    if (dragOptions._clearSubplotSelections) {\n      dragOptions._clearSubplotSelections();\n      dragOptions._clearSubplotSelections = undefined;\n    }\n    x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n    y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n    if (isRectMode) {\n      var direction;\n      var start, end;\n      if (isSelectMode) {\n        var q = fullLayout.selectdirection;\n        if (q === 'any') {\n          if (dy < Math.min(dx * 0.6, MINSELECT)) {\n            direction = 'h';\n          } else if (dx < Math.min(dy * 0.6, MINSELECT)) {\n            direction = 'v';\n          } else {\n            direction = 'd';\n          }\n        } else {\n          direction = q;\n        }\n        switch (direction) {\n          case 'h':\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n          case 'v':\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n        }\n      }\n      if (isDrawMode) {\n        switch (fullLayout.newshape.drawdirection) {\n          case 'vertical':\n            direction = 'h';\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n          case 'horizontal':\n            direction = 'v';\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n          case 'ortho':\n            if (dx < dy) {\n              direction = 'h';\n              start = y0;\n              end = y1;\n            } else {\n              direction = 'v';\n              start = x0;\n              end = x1;\n            }\n            break;\n          default:\n            // i.e. case of 'diagonal'\n            direction = 'd';\n        }\n      }\n      if (direction === 'h') {\n        // horizontal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) :\n        // using x1 instead of x0 allows adjusting the line while drawing\n        [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n        currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n        currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(start, end);\n        currentPolygon.ymax = Math.max(start, end);\n        // extras to guide users in keeping a straight selection\n        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');\n      } else if (direction === 'v') {\n        // vertical motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) :\n        // using y1 instead of y0 allows adjusting the line while drawing\n        [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n        currentPolygon.xmin = Math.min(start, end);\n        currentPolygon.xmax = Math.max(start, end);\n        currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n        currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');\n      } else if (direction === 'd') {\n        // diagonal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M0,0Z');\n      }\n    } else if (isFreeMode) {\n      filterPoly.addPt([x1, y1]);\n      currentPolygon = filterPoly.filtered;\n    }\n\n    // create outline & tester\n    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n      currentPolygon.subtract = subtract;\n      selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTesters = polygonTester(currentPolygon);\n    }\n\n    // display polygons on the screen\n    displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n    if (isSelectMode) {\n      var _res = reselect(gd, false);\n      var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];\n      _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);\n      selectionTesters = _res.selectionTesters;\n      eventData = _res.eventData;\n      var poly;\n      if (filterPoly) {\n        poly = filterPoly.filtered;\n      } else {\n        poly = castMultiPolygon(mergedPolygons);\n      }\n      throttle.throttle(throttleID, constants.SELECTDELAY, function () {\n        selection = _doSelect(selectionTesters, searchTraces);\n        var newPoints = selection.slice();\n        for (var w = 0; w < extraPoints.length; w++) {\n          var p = extraPoints[w];\n          var found = false;\n          for (var u = 0; u < newPoints.length; u++) {\n            if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) newPoints.push(p);\n        }\n        if (newPoints.length) {\n          if (!eventData) eventData = {};\n          eventData.points = newPoints;\n        }\n        fillRangeItems(eventData, poly);\n        emitSelecting(gd, eventData);\n      });\n    }\n  };\n  dragOptions.clickFn = function (numClicks, evt) {\n    corners.remove();\n    if (gd._fullLayout._activeShapeIndex >= 0) {\n      gd._fullLayout._deactivateShape(gd);\n      return;\n    }\n    if (isDrawMode) return;\n    var clickmode = fullLayout.clickmode;\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      if (numClicks === 2) {\n        // clear selection on doubleclick\n        outlines.remove();\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n          searchInfo._module.selectPoints(searchInfo, false);\n        }\n        updateSelectedState(gd, searchTraces);\n        clearSelectionsCache(dragOptions);\n        emitDeselect(gd);\n        if (searchTraces.length) {\n          var clickedXaxis = searchTraces[0].xaxis;\n          var clickedYaxis = searchTraces[0].yaxis;\n          if (clickedXaxis && clickedYaxis) {\n            // drop selections in the clicked subplot\n            var subSelections = [];\n            var allSelections = gd._fullLayout.selections;\n            for (var k = 0; k < allSelections.length; k++) {\n              var s = allSelections[k];\n              if (!s) continue; // also drop null selections if any\n\n              if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {\n                subSelections.push(s);\n              }\n            }\n            if (subSelections.length < allSelections.length) {\n              gd._fullLayout._noEmitSelectedAtStart = true;\n              Registry.call('_guiRelayout', gd, {\n                selections: subSelections\n              });\n            }\n          }\n        }\n      } else {\n        if (clickmode.indexOf('select') > -1) {\n          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);\n        }\n        if (clickmode === 'event') {\n          // TODO: remove in v3 - this was probably never intended to work as it does,\n          // but in case anyone depends on it we don't want to break it now.\n          // Note that click-to-select introduced pre v3 also emitts proper\n          // event data when clickmode is having 'select' in its flag list.\n          emitSelected(gd, undefined);\n        }\n      }\n      Fx.click(gd, evt, plotinfo.id);\n    }).catch(Lib.error);\n  };\n  dragOptions.doneFn = function () {\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {\n        // save last polygons\n        currentPolygon.subtract = subtract;\n        dragOptions.selectionDefs.push(currentPolygon);\n\n        // we have to keep reference to arrays container\n        dragOptions.mergedPolygons.length = 0;\n        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n      }\n      if (immediateSelect || isDrawMode) {\n        clearSelectionsCache(dragOptions, immediateSelect);\n      }\n      if (dragOptions.doneFnCompleted) {\n        dragOptions.doneFnCompleted(selection);\n      }\n      if (isSelectMode) {\n        emitSelected(gd, eventData);\n      }\n    }).catch(Lib.error);\n  };\n}\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n  var hoverData = gd._hoverdata;\n  var fullLayout = gd._fullLayout;\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1;\n  var selection = [];\n  var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;\n  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n  if (isHoverDataSet(hoverData)) {\n    coerceSelectionsCache(evt, gd, dragOptions);\n    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;\n\n    // Note: potentially costly operation isPointOrBinSelected is\n    // called as late as possible through the use of an assignment\n    // in an if condition.\n    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n      if (polygonOutlines) polygonOutlines.remove();\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        searchInfo._module.selectPoints(searchInfo, false);\n      }\n      updateSelectedState(gd, searchTraces);\n      clearSelectionsCache(dragOptions);\n      if (sendEvents) {\n        emitDeselect(gd);\n      }\n    } else {\n      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));\n      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n      selectionTesters = multiTester(allSelectionDefs, selectionTesters);\n      for (i = 0; i < searchTraces.length; i++) {\n        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);\n        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n        if (selection.length) {\n          for (var j = 0; j < thisTracesSelection.length; j++) {\n            selection.push(thisTracesSelection[j]);\n          }\n        } else selection = thisTracesSelection;\n      }\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n      if (currentSelectionDef && dragOptions) {\n        dragOptions.selectionDefs.push(currentSelectionDef);\n      }\n      if (polygonOutlines) {\n        var polygons = dragOptions.mergedPolygons;\n        var isOpenMode = openMode(dragOptions.dragmode);\n\n        // display polygons on the screen\n        displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n      }\n      if (sendEvents) {\n        emitSelected(gd, eventData);\n      }\n    }\n  }\n}\n\n/**\n * Constructs a new point selection definition object.\n */\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n  return {\n    pointNumber: pointNumber,\n    searchInfo: searchInfo,\n    subtract: !!subtract\n  };\n}\nfunction isPointSelectionDef(o) {\n  return 'pointNumber' in o && 'searchInfo' in o;\n}\n\n/*\n * Constructs a new point number tester.\n */\nfunction newPointNumTester(pointSelectionDef) {\n  return {\n    xmin: 0,\n    xmax: 0,\n    ymin: 0,\n    ymax: 0,\n    pts: [],\n    contains: function (pt, omitFirstEdge, pointNumber, searchInfo) {\n      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;\n    },\n    isRect: false,\n    degenerate: false,\n    subtract: !!pointSelectionDef.subtract\n  };\n}\n\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\nfunction multiTester(list) {\n  if (!list.length) return;\n  var testers = [];\n  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n  var xmax = xmin;\n  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n  var ymax = ymin;\n  for (var i = 0; i < list.length; i++) {\n    if (isPointSelectionDef(list[i])) {\n      testers.push(newPointNumTester(list[i]));\n    } else {\n      var tester = polygonTester(list[i]);\n      tester.subtract = !!list[i].subtract;\n      testers.push(tester);\n      xmin = Math.min(xmin, tester.xmin);\n      xmax = Math.max(xmax, tester.xmax);\n      ymin = Math.min(ymin, tester.ymin);\n      ymax = Math.max(ymax, tester.ymax);\n    }\n  }\n\n  /**\n   * Tests if the given point is within this tester.\n   *\n   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n   * @param {*} arg - An optional parameter to pass down to wrapped testers.\n   * @param {number} pointNumber - The point number of the point within the underlying data array.\n   * @param {number} searchInfo - An object identifying the trace the point is contained in.\n   *\n   * @return {boolean} true if point is considered to be selected, false otherwise.\n   */\n  function contains(pt, arg, pointNumber, searchInfo) {\n    var contained = false;\n    for (var i = 0; i < testers.length; i++) {\n      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n        // if contained by subtract tester - exclude the point\n        contained = !testers[i].subtract;\n      }\n    }\n    return contained;\n  }\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: [],\n    contains: contains,\n    isRect: false,\n    degenerate: false\n  };\n}\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n  var fullLayout = gd._fullLayout;\n  var plotinfo = dragOptions.plotinfo;\n  var dragmode = dragOptions.dragmode;\n  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;\n  var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));\n  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {\n    // take over selection definitions from prev mode, if any\n    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n  } else if (!hasModifierKey || !plotinfo.selection) {\n    clearSelectionsCache(dragOptions);\n  }\n\n  // clear selection outline when selecting a different subplot\n  if (!selectingOnSameSubplot) {\n    clearOutline(gd);\n    fullLayout._lastSelectedSubplot = plotinfo.id;\n  }\n}\nfunction hasActiveShape(gd) {\n  return gd._fullLayout._activeShapeIndex >= 0;\n}\nfunction hasActiveSelection(gd) {\n  return gd._fullLayout._activeSelectionIndex >= 0;\n}\nfunction clearSelectionsCache(dragOptions, immediateSelect) {\n  var dragmode = dragOptions.dragmode;\n  var plotinfo = dragOptions.plotinfo;\n  var gd = dragOptions.gd;\n  if (hasActiveShape(gd)) {\n    gd._fullLayout._deactivateShape(gd);\n  }\n  if (hasActiveSelection(gd)) {\n    gd._fullLayout._deactivateSelection(gd);\n  }\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var isDrawMode = drawMode(dragmode);\n  var isSelectMode = selectMode(dragmode);\n  if (isDrawMode || isSelectMode) {\n    var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n    if (outlines && gd._fullLayout._outlining) {\n      // add shape\n      var shapes;\n      if (isDrawMode) {\n        shapes = newShapes(outlines, dragOptions);\n      }\n      if (shapes) {\n        Registry.call('_guiRelayout', gd, {\n          shapes: shapes\n        });\n      }\n\n      // add selection\n      var selections;\n      if (isSelectMode && !hasSubplot(dragOptions) // only allow cartesian - no maps for now\n      ) {\n        selections = newSelections(outlines, dragOptions);\n      }\n      if (selections) {\n        gd._fullLayout._noEmitSelectedAtStart = true;\n        Registry.call('_guiRelayout', gd, {\n          selections: selections\n        }).then(function () {\n          if (immediateSelect) {\n            activateLastSelection(gd);\n          }\n        });\n      }\n      gd._fullLayout._outlining = false;\n    }\n  }\n  plotinfo.selection = {};\n  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\nfunction getAxId(ax) {\n  return ax._id;\n}\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n  if (!gd.calcdata) return [];\n  var searchTraces = [];\n  var xAxisIds = xAxes.map(getAxId);\n  var yAxisIds = yAxes.map(getAxId);\n  var cd, trace, i;\n  for (i = 0; i < gd.calcdata.length; i++) {\n    cd = gd.calcdata[i];\n    trace = cd[0].trace;\n    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n    if (hasSubplot({\n      subplot: subplot\n    }) && (trace.subplot === subplot || trace.geo === subplot)) {\n      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n    } else if (trace.type === 'splom') {\n      // FIXME: make sure we don't have more than single axis for splom\n      if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n        var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n        info.scene = gd._fullLayout._splomScenes[trace.uid];\n        searchTraces.push(info);\n      }\n    } else if (trace.type === 'sankey') {\n      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      searchTraces.push(sankeyInfo);\n    } else {\n      if (xAxisIds.indexOf(trace.xaxis) === -1 && (!trace._xA || !trace._xA.overlaying)) continue;\n      if (yAxisIds.indexOf(trace.yaxis) === -1 && (!trace._yA || !trace._yA.overlaying)) continue;\n      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n    }\n  }\n  return searchTraces;\n}\nfunction createSearchInfo(module, calcData, xaxis, yaxis) {\n  return {\n    _module: module,\n    cd: calcData,\n    xaxis: xaxis,\n    yaxis: yaxis\n  };\n}\nfunction isHoverDataSet(hoverData) {\n  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;\n}\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n  var hoverDatum = hoverData[0];\n  var pointNumber = -1;\n  var pointNumbers = [];\n  var searchInfo, i;\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n      // Special case for box (and violin)\n      if (hoverDatum.hoverOnBox === true) {\n        break;\n      }\n\n      // Hint: in some traces like histogram, one graphical element\n      // doesn't correspond to one particular data point, but to\n      // bins of data points. Thus, hoverDatum can have a binNumber\n      // property instead of pointNumber.\n      if (hoverDatum.pointNumber !== undefined) {\n        pointNumber = hoverDatum.pointNumber;\n      } else if (hoverDatum.binNumber !== undefined) {\n        pointNumber = hoverDatum.binNumber;\n        pointNumbers = hoverDatum.pointNumbers;\n      }\n      break;\n    }\n  }\n  return {\n    pointNumber: pointNumber,\n    pointNumbers: pointNumbers,\n    searchInfo: searchInfo\n  };\n}\nfunction isPointOrBinSelected(clickedPtInfo) {\n  var trace = clickedPtInfo.searchInfo.cd[0].trace;\n  var ptNum = clickedPtInfo.pointNumber;\n  var ptNums = clickedPtInfo.pointNumbers;\n  var ptNumsSet = ptNums.length > 0;\n\n  // When pointsNumbers is set (e.g. histogram's binning),\n  // it is assumed that when the first point of\n  // a bin is selected, all others are as well\n  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;\n\n  // TODO potential performance improvement\n  // Primarily we need this function to determine if a click adds\n  // or subtracts from a selection.\n  // In cases `trace.selectedpoints` is a huge array, indexOf\n  // might be slow. One remedy would be to introduce a hash somewhere.\n  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n  var tracesWithSelectedPts = [];\n  var searchInfo, trace, isSameTrace, i;\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n      tracesWithSelectedPts.push(searchInfo);\n    }\n  }\n  if (tracesWithSelectedPts.length === 1) {\n    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n    if (isSameTrace) {\n      trace = clickedPtInfo.searchInfo.cd[0].trace;\n      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isOnlyOnePointSelected(searchTraces) {\n  var len = 0;\n  var searchInfo, trace, i;\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    trace = searchInfo.cd[0].trace;\n    if (trace.selectedpoints) {\n      if (trace.selectedpoints.length > 1) return false;\n      len += trace.selectedpoints.length;\n      if (len > 1) return false;\n    }\n  }\n  return len === 1;\n}\nfunction updateSelectedState(gd, searchTraces, eventData) {\n  var i;\n\n  // before anything else, update preGUI if necessary\n  for (i = 0; i < searchTraces.length; i++) {\n    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n    if (tracePreGUI.selectedpoints === undefined) {\n      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n    }\n  }\n  var trace;\n  if (eventData) {\n    var pts = eventData.points || [];\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n      if (trace._fullInput !== trace) trace.selectedpoints = [];\n    }\n    for (var k = 0; k < pts.length; k++) {\n      var pt = pts[k];\n      var data = pt.data;\n      var fullData = pt.fullData;\n      var pointIndex = pt.pointIndex;\n      var pointIndices = pt.pointIndices;\n      if (pointIndices) {\n        [].push.apply(data.selectedpoints, pointIndices);\n        if (trace._fullInput !== trace) {\n          [].push.apply(fullData.selectedpoints, pointIndices);\n        }\n      } else {\n        data.selectedpoints.push(pointIndex);\n        if (trace._fullInput !== trace) {\n          fullData.selectedpoints.push(pointIndex);\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      delete trace.selectedpoints;\n      delete trace._input.selectedpoints;\n      if (trace._fullInput !== trace) {\n        delete trace._fullInput.selectedpoints;\n      }\n    }\n  }\n  updateReglSelectedState(gd, searchTraces);\n}\nfunction updateReglSelectedState(gd, searchTraces) {\n  var hasRegl = false;\n  for (var i = 0; i < searchTraces.length; i++) {\n    var searchInfo = searchTraces[i];\n    var cd = searchInfo.cd;\n    if (Registry.traceIs(cd[0].trace, 'regl')) {\n      hasRegl = true;\n    }\n    var _module = searchInfo._module;\n    var fn = _module.styleOnSelect || _module.style;\n    if (fn) {\n      fn(gd, cd, cd[0].node3);\n      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n    }\n  }\n  if (hasRegl) {\n    clearGlCanvases(gd);\n    redrawReglTraces(gd);\n  }\n}\nfunction mergePolygons(list, poly, subtract) {\n  var fn = subtract ? polybool.difference : polybool.union;\n  var res = fn({\n    regions: list\n  }, {\n    regions: [poly]\n  });\n  var allPolygons = res.regions.reverse();\n  for (var i = 0; i < allPolygons.length; i++) {\n    var polygon = allPolygons[i];\n    polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));\n  }\n  return allPolygons;\n}\nfunction fillSelectionItem(selection, searchInfo) {\n  if (Array.isArray(selection)) {\n    var cd = searchInfo.cd;\n    var trace = searchInfo.cd[0].trace;\n    for (var i = 0; i < selection.length; i++) {\n      selection[i] = makeEventData(selection[i], trace, cd);\n    }\n  }\n  return selection;\n}\nfunction convertPoly(polygonsIn, isOpenMode) {\n  // add M and L command to draft positions\n  var polygonsOut = [];\n  for (var i = 0; i < polygonsIn.length; i++) {\n    polygonsOut[i] = [];\n    for (var j = 0; j < polygonsIn[i].length; j++) {\n      polygonsOut[i][j] = [];\n      polygonsOut[i][j][0] = j ? 'L' : 'M';\n      for (var k = 0; k < polygonsIn[i][j].length; k++) {\n        polygonsOut[i][j].push(polygonsIn[i][j][k]);\n      }\n    }\n    if (!isOpenMode) {\n      polygonsOut[i].push(['Z', polygonsOut[i][0][1],\n      // initial x\n      polygonsOut[i][0][2] // initial y\n      ]);\n    }\n  }\n  return polygonsOut;\n}\nfunction _doSelect(selectionTesters, searchTraces) {\n  var allSelections = [];\n  var thisSelection;\n  var traceSelections = [];\n  var traceSelection;\n  for (var i = 0; i < searchTraces.length; i++) {\n    var searchInfo = searchTraces[i];\n    traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);\n    traceSelections.push(traceSelection);\n    thisSelection = fillSelectionItem(traceSelection, searchInfo);\n    allSelections = allSelections.concat(thisSelection);\n  }\n  return allSelections;\n}\nfunction reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {\n  var hadSearchTraces = !!searchTraces;\n  var plotinfo, xRef, yRef;\n  if (dragOptions) {\n    plotinfo = dragOptions.plotinfo;\n    xRef = dragOptions.xaxes[0]._id;\n    yRef = dragOptions.yaxes[0]._id;\n  }\n  var allSelections = [];\n  var allSearchTraces = [];\n\n  // select layout.selection polygons\n  var layoutPolygons = getLayoutPolygons(gd);\n\n  // add draft outline polygons to layoutPolygons\n  var fullLayout = gd._fullLayout;\n  if (plotinfo) {\n    var zoomLayer = fullLayout._zoomlayer;\n    var mode = fullLayout.dragmode;\n    var isDrawMode = drawMode(mode);\n    var isSelectMode = selectMode(mode);\n    if (isDrawMode || isSelectMode) {\n      var xaxis = getFromId(gd, xRef, 'x');\n      var yaxis = getFromId(gd, yRef, 'y');\n      if (xaxis && yaxis) {\n        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n        if (outlines && gd._fullLayout._outlining) {\n          if (outlines.length) {\n            var e = outlines[0][0]; // pick first\n            var d = e.getAttribute('d');\n            var outlinePolys = readPaths(d, gd, plotinfo);\n            var draftPolygons = [];\n            for (var u = 0; u < outlinePolys.length; u++) {\n              var p = outlinePolys[u];\n              var polygon = [];\n              for (var t = 0; t < p.length; t++) {\n                polygon.push([convert(xaxis, p[t][1]), convert(yaxis, p[t][2])]);\n              }\n              polygon.xref = xRef;\n              polygon.yref = yRef;\n              polygon.subtract = getSubtract(polygon, draftPolygons);\n              draftPolygons.push(polygon);\n            }\n            layoutPolygons = layoutPolygons.concat(draftPolygons);\n          }\n        }\n      }\n    }\n  }\n  var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;\n  epmtySplomSelectionBatch(gd);\n  var seenSplom = {};\n  for (var i = 0; i < subplots.length; i++) {\n    var subplot = subplots[i];\n    var yAt = subplot.indexOf('y');\n    var _xRef = subplot.slice(0, yAt);\n    var _yRef = subplot.slice(yAt);\n    var _selectionTesters = xRef && yRef ? selectionTesters : undefined;\n    _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);\n    if (_selectionTesters) {\n      var _searchTraces = searchTraces;\n      if (!hadSearchTraces) {\n        var _xA = getFromId(gd, _xRef, 'x');\n        var _yA = getFromId(gd, _yRef, 'y');\n        _searchTraces = determineSearchTraces(gd, [_xA], [_yA], subplot);\n        for (var w = 0; w < _searchTraces.length; w++) {\n          var s = _searchTraces[w];\n          var cd0 = s.cd[0];\n          var trace = cd0.trace;\n          if (s._module.name === 'scattergl' && !cd0.t.xpx) {\n            var x = trace.x;\n            var y = trace.y;\n            var len = trace._length;\n            // generate stash for scattergl\n            cd0.t.xpx = [];\n            cd0.t.ypx = [];\n            for (var j = 0; j < len; j++) {\n              cd0.t.xpx[j] = _xA.c2p(x[j]);\n              cd0.t.ypx[j] = _yA.c2p(y[j]);\n            }\n          }\n          if (s._module.name === 'splom') {\n            if (!seenSplom[trace.uid]) {\n              seenSplom[trace.uid] = true;\n            }\n          }\n        }\n      }\n      var selection = _doSelect(_selectionTesters, _searchTraces);\n      allSelections = allSelections.concat(selection);\n      allSearchTraces = allSearchTraces.concat(_searchTraces);\n    }\n  }\n  var eventData = {\n    points: allSelections\n  };\n  updateSelectedState(gd, allSearchTraces, eventData);\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1 && mayEmitSelected;\n  if (!plotinfo &&\n  // get called from plot_api & plots\n  mayEmitSelected) {\n    var activePolygons = getLayoutPolygons(gd, true);\n    if (activePolygons.length) {\n      var xref = activePolygons[0].xref;\n      var yref = activePolygons[0].yref;\n      if (xref && yref) {\n        var poly = castMultiPolygon(activePolygons);\n        var fillRangeItems = makeFillRangeItems([getFromId(gd, xref, 'x'), getFromId(gd, yref, 'y')]);\n        fillRangeItems(eventData, poly);\n      }\n    }\n    if (gd._fullLayout._noEmitSelectedAtStart) {\n      gd._fullLayout._noEmitSelectedAtStart = false;\n    } else {\n      if (sendEvents) emitSelected(gd, eventData);\n    }\n    fullLayout._reselect = false;\n  }\n  if (!plotinfo &&\n  // get called from plot_api & plots\n  fullLayout._deselect) {\n    var deselect = fullLayout._deselect;\n    xRef = deselect.xref;\n    yRef = deselect.yref;\n    if (!subplotSelected(xRef, yRef, allSearchTraces)) {\n      deselectSubplot(gd, xRef, yRef, searchTraces);\n    }\n    if (sendEvents) {\n      if (eventData.points.length) {\n        emitSelected(gd, eventData);\n      } else {\n        emitDeselect(gd);\n      }\n    }\n    fullLayout._deselect = false;\n  }\n  return {\n    eventData: eventData,\n    selectionTesters: selectionTesters\n  };\n}\nfunction epmtySplomSelectionBatch(gd) {\n  var cd = gd.calcdata;\n  if (!cd) return;\n  for (var i = 0; i < cd.length; i++) {\n    var cd0 = cd[i][0];\n    var trace = cd0.trace;\n    var splomScenes = gd._fullLayout._splomScenes;\n    if (splomScenes) {\n      var scene = splomScenes[trace.uid];\n      if (scene) {\n        scene.selectBatch = [];\n      }\n    }\n  }\n}\nfunction subplotSelected(xRef, yRef, searchTraces) {\n  for (var i = 0; i < searchTraces.length; i++) {\n    var s = searchTraces[i];\n    if (s.xaxis && s.xaxis._id === xRef && s.yaxis && s.yaxis._id === yRef) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction deselectSubplot(gd, xRef, yRef, searchTraces) {\n  searchTraces = determineSearchTraces(gd, [getFromId(gd, xRef, 'x')], [getFromId(gd, yRef, 'y')], xRef + yRef);\n  for (var k = 0; k < searchTraces.length; k++) {\n    var searchInfo = searchTraces[k];\n    searchInfo._module.selectPoints(searchInfo, false);\n  }\n  updateSelectedState(gd, searchTraces);\n}\nfunction addTester(layoutPolygons, xRef, yRef, selectionTesters) {\n  var mergedPolygons;\n  for (var i = 0; i < layoutPolygons.length; i++) {\n    var currentPolygon = layoutPolygons[i];\n    if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;\n    if (mergedPolygons) {\n      var subtract = !!currentPolygon.subtract;\n      mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);\n      selectionTesters = multiTester(mergedPolygons);\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTesters = polygonTester(currentPolygon);\n    }\n  }\n  return selectionTesters;\n}\nfunction getLayoutPolygons(gd, onlyActiveOnes) {\n  var allPolygons = [];\n  var fullLayout = gd._fullLayout;\n  var allSelections = fullLayout.selections;\n  var len = allSelections.length;\n  for (var i = 0; i < len; i++) {\n    if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;\n    var selection = allSelections[i];\n    if (!selection) continue;\n    var xref = selection.xref;\n    var yref = selection.yref;\n    var xaxis = getFromId(gd, xref, 'x');\n    var yaxis = getFromId(gd, yref, 'y');\n    var xmin, xmax, ymin, ymax;\n    var polygon;\n    if (selection.type === 'rect') {\n      polygon = [];\n      var x0 = convert(xaxis, selection.x0);\n      var x1 = convert(xaxis, selection.x1);\n      var y0 = convert(yaxis, selection.y0);\n      var y1 = convert(yaxis, selection.y1);\n      polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n      xmin = Math.min(x0, x1);\n      xmax = Math.max(x0, x1);\n      ymin = Math.min(y0, y1);\n      ymax = Math.max(y0, y1);\n      polygon.xmin = xmin;\n      polygon.xmax = xmax;\n      polygon.ymin = ymin;\n      polygon.ymax = ymax;\n      polygon.xref = xref;\n      polygon.yref = yref;\n      polygon.subtract = false;\n      polygon.isRect = true;\n      allPolygons.push(polygon);\n    } else if (selection.type === 'path') {\n      var segments = selection.path.split('Z');\n      var multiPolygons = [];\n      for (var j = 0; j < segments.length; j++) {\n        var path = segments[j];\n        if (!path) continue;\n        path += 'Z';\n        var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, 'raw');\n        var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, 'raw');\n        xmin = Infinity;\n        xmax = -Infinity;\n        ymin = Infinity;\n        ymax = -Infinity;\n        polygon = [];\n        for (var k = 0; k < allX.length; k++) {\n          var x = convert(xaxis, allX[k]);\n          var y = convert(yaxis, allY[k]);\n          polygon.push([x, y]);\n          xmin = Math.min(x, xmin);\n          xmax = Math.max(x, xmax);\n          ymin = Math.min(y, ymin);\n          ymax = Math.max(y, ymax);\n        }\n        polygon.xmin = xmin;\n        polygon.xmax = xmax;\n        polygon.ymin = ymin;\n        polygon.ymax = ymax;\n        polygon.xref = xref;\n        polygon.yref = yref;\n        polygon.subtract = getSubtract(polygon, multiPolygons);\n        multiPolygons.push(polygon);\n        allPolygons.push(polygon);\n      }\n    }\n  }\n  return allPolygons;\n}\nfunction getSubtract(polygon, previousPolygons) {\n  var subtract = false;\n  for (var i = 0; i < previousPolygons.length; i++) {\n    var previousPolygon = previousPolygons[i];\n\n    // find out if a point of polygon is inside previous polygons\n    for (var k = 0; k < polygon.length; k++) {\n      if (pointInPolygon(polygon[k], previousPolygon)) {\n        subtract = !subtract;\n        break;\n      }\n    }\n  }\n  return subtract;\n}\nfunction convert(ax, d) {\n  if (ax.type === 'date') d = d.replace('_', ' ');\n  return ax.type === 'log' ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);\n}\nfunction castMultiPolygon(allPolygons) {\n  var len = allPolygons.length;\n\n  // descibe multi polygons in one polygon\n  var p = [];\n  for (var i = 0; i < len; i++) {\n    var polygon = allPolygons[i];\n    p = p.concat(polygon);\n\n    // add starting vertex to close\n    // which indicates next polygon\n    p = p.concat([polygon[0]]);\n  }\n  return computeRectAndRanges(p);\n}\nfunction computeRectAndRanges(poly) {\n  poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1] || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];\n  if (poly.isRect) {\n    poly.xmin = Math.min(poly[0][0], poly[2][0]);\n    poly.xmax = Math.max(poly[0][0], poly[2][0]);\n    poly.ymin = Math.min(poly[0][1], poly[2][1]);\n    poly.ymax = Math.max(poly[0][1], poly[2][1]);\n  }\n  return poly;\n}\nfunction makeFillRangeItems(allAxes) {\n  return function (eventData, poly) {\n    var range;\n    var lassoPoints;\n    for (var i = 0; i < allAxes.length; i++) {\n      var ax = allAxes[i];\n      var id = ax._id;\n      var axLetter = id.charAt(0);\n      if (poly.isRect) {\n        if (!range) range = {};\n        var min = poly[axLetter + 'min'];\n        var max = poly[axLetter + 'max'];\n        if (min !== undefined && max !== undefined) {\n          range[id] = [p2r(ax, min), p2r(ax, max)].sort(ascending);\n        }\n      } else {\n        if (!lassoPoints) lassoPoints = {};\n        lassoPoints[id] = poly.map(axValue(ax));\n      }\n    }\n    if (range) {\n      eventData.range = range;\n    }\n    if (lassoPoints) {\n      eventData.lassoPoints = lassoPoints;\n    }\n  };\n}\nfunction getFillRangeItems(dragOptions) {\n  var plotinfo = dragOptions.plotinfo;\n  return plotinfo.fillRangeItems ||\n  // allow subplots (i.e. geo, mapbox, map, sankey) to override fillRangeItems routine\n  makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));\n}\nfunction emitSelecting(gd, eventData) {\n  gd.emit('plotly_selecting', eventData);\n}\nfunction emitSelected(gd, eventData) {\n  if (eventData) {\n    eventData.selections = (gd.layout || {}).selections || [];\n  }\n  gd.emit('plotly_selected', eventData);\n}\nfunction emitDeselect(gd) {\n  gd.emit('plotly_deselect', null);\n}\nmodule.exports = {\n  reselect: reselect,\n  prepSelect: prepSelect,\n  clearOutline: clearOutline,\n  clearSelectionsCache: clearSelectionsCache,\n  selectOnClick: selectOnClick\n};","map":{"version":3,"names":["polybool","require","pointInPolygon","Registry","dashStyle","Color","Fx","makeEventData","dragHelpers","freeMode","rectMode","drawMode","openMode","selectMode","shapeHelpers","shapeConstants","displayOutlines","clearOutline","newShapeHelpers","handleEllipse","readPaths","newShapes","newSelections","activateLastSelection","Lib","ascending","sorterAsc","libPolygon","throttle","getFromId","clearGlCanvases","redrawReglTraces","constants","MINSELECT","filteredPolygon","filter","polygonTester","tester","helpers","p2r","axValue","getTransform","hasSubplot","dragOptions","subplot","undefined","prepSelect","evt","startX","startY","mode","isCartesian","isFreeMode","isRectMode","isOpenMode","isDrawMode","isSelectMode","isLine","isEllipse","isLineOrEllipse","gd","fullLayout","_fullLayout","immediateSelect","newselection","zoomLayer","_zoomlayer","dragBBox","element","getBoundingClientRect","plotinfo","transform","x0","left","y0","top","_calcInverseTransform","transformedCoords","apply3DTransform","_invTransform","scaleX","_invScaleX","scaleY","_invScaleY","x1","y1","path0","xAxis","xaxes","yAxis","yaxes","pw","_length","ph","subtract","altKey","filterPoly","selectionTesters","mergedPolygons","currentPolygon","i","searchInfo","eventData","coerceSelectionsCache","BENDPX","outlines","selectAll","id","data","newStyle","newshape","hasText","label","text","texttemplate","fillC","fillcolor","strokeC","line","color","contrast","plot_bgcolor","enter","append","attr","style","opacity","dash","width","call","stroke","fill","classed","corners","background","defaultLine","shapeGroup","select","empty","throttleID","_uid","SELECTID","selection","searchTraces","determineSearchTraces","shiftKey","_clearSubplotSelections","xRef","_id","yRef","deselectSubplot","selections","layout","list","selectionErased","q","length","s","xref","yref","push","_noEmitSelectedAtStart","fillRangeItems","getFillRangeItems","moveFn","dx0","dy0","Math","max","min","dx","abs","dy","direction","start","end","selectdirection","drawdirection","xmin","xmax","ymin","ymax","addPt","filtered","selectionDefs","mergePolygons","multiTester","concat","convertPoly","_res","reselect","extraPoints","points","slice","poly","castMultiPolygon","SELECTDELAY","_doSelect","newPoints","w","p","found","u","curveNumber","pointNumber","emitSelecting","clickFn","numClicks","remove","_activeShapeIndex","_deactivateShape","clickmode","done","then","clear","_module","selectPoints","updateSelectedState","clearSelectionsCache","emitDeselect","clickedXaxis","xaxis","clickedYaxis","yaxis","subSelections","allSelections","k","indexOf","selectOnClick","emitSelected","click","catch","error","doneFn","apply","doneFnCompleted","xAxes","yAxes","polygonOutlines","hoverData","_hoverdata","sendEvents","currentSelectionDef","traceSelection","thisTracesSelection","pointOrBinSelected","isHoverDataSet","clickedPtInfo","extractClickedPtInfo","isBinnedTrace","pointNumbers","isOnlyThisBinSelected","isOnlyOnePointSelected","isPointOrBinSelected","newPointSelectionDef","allSelectionDefs","fillSelectionItem","j","polygons","dragmode","isPointSelectionDef","o","newPointNumTester","pointSelectionDef","pts","contains","pt","omitFirstEdge","idxWantedTrace","cd","trace","_expandedIndex","idxActualTrace","isRect","degenerate","testers","arg","contained","selectingOnSameSubplot","_lastSelectedSubplot","hasModifierKey","hasActiveShape","hasActiveSelection","_activeSelectionIndex","_deactivateSelection","_outlining","shapes","getAxId","ax","calcdata","xAxisIds","map","yAxisIds","visible","geo","createSearchInfo","type","_xaxes","_yaxes","info","scene","_splomScenes","uid","sankeyInfo","_xA","overlaying","_yA","module","calcData","Array","isArray","hoverOnBox","hoverDatum","fullData","binNumber","ptNum","ptNums","ptNumsSet","ptNumToTest","selectedpoints","tracesWithSelectedPts","isSameTrace","len","fullInputTrace","_fullInput","tracePreGUI","_tracePreGUI","_input","pointIndex","pointIndices","updateReglSelectedState","hasRegl","traceIs","fn","styleOnSelect","node3","nodeRangePlot3","difference","union","res","regions","allPolygons","reverse","polygon","getSubtract","polygonsIn","polygonsOut","thisSelection","traceSelections","mayEmitSelected","hadSearchTraces","allSearchTraces","layoutPolygons","getLayoutPolygons","e","d","getAttribute","outlinePolys","draftPolygons","t","convert","subplots","_subplots","cartesian","epmtySplomSelectionBatch","seenSplom","yAt","_xRef","_yRef","_selectionTesters","addTester","_searchTraces","cd0","name","xpx","x","y","ypx","c2p","activePolygons","makeFillRangeItems","_reselect","_deselect","deselect","subplotSelected","splomScenes","selectBatch","onlyActiveOnes","segments","path","split","multiPolygons","allX","extractPathCoords","paramIsX","allY","paramIsY","Infinity","previousPolygons","previousPolygon","replace","r2p","calendar","computeRectAndRanges","allAxes","range","lassoPoints","axLetter","charAt","sort","emit","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/selections/select.js"],"sourcesContent":["'use strict';\n\nvar polybool = require('polybooljs');\nvar pointInPolygon = require('point-in-polygon/nested'); // could we use contains lib/polygon instead?\n\nvar Registry = require('../../registry');\nvar dashStyle = require('../drawing').dashStyle;\nvar Color = require('../color');\nvar Fx = require('../fx');\nvar makeEventData = require('../fx/helpers').makeEventData;\nvar dragHelpers = require('../dragelement/helpers');\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar shapeHelpers = require('../shapes/helpers');\nvar shapeConstants = require('../shapes/constants');\n\nvar displayOutlines = require('../shapes/display_outlines');\nvar clearOutline = require('../shapes/handle_outline').clearOutline;\n\nvar newShapeHelpers = require('../shapes/draw_newshape/helpers');\nvar handleEllipse = newShapeHelpers.handleEllipse;\nvar readPaths = newShapeHelpers.readPaths;\n\nvar newShapes = require('../shapes/draw_newshape/newshapes').newShapes;\n\nvar newSelections = require('./draw_newselection/newselections');\nvar activateLastSelection = require('./draw').activateLastSelection;\n\nvar Lib = require('../../lib');\nvar ascending = Lib.sorterAsc;\nvar libPolygon = require('../../lib/polygon');\nvar throttle = require('../../lib/throttle');\nvar getFromId = require('../../plots/cartesian/axis_ids').getFromId;\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\nvar MINSELECT = constants.MINSELECT;\n\nvar filteredPolygon = libPolygon.filter;\nvar polygonTester = libPolygon.tester;\n\nvar helpers = require('./helpers');\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\n\nfunction hasSubplot(dragOptions) {\n    // N.B. subplot may be falsy e.g zero sankey index!\n    return dragOptions.subplot !== undefined;\n}\n\nfunction prepSelect(evt, startX, startY, dragOptions, mode) {\n    var isCartesian = !hasSubplot(dragOptions);\n\n    var isFreeMode = freeMode(mode);\n    var isRectMode = rectMode(mode);\n    var isOpenMode = openMode(mode);\n    var isDrawMode = drawMode(mode);\n    var isSelectMode = selectMode(mode);\n\n    var isLine = mode === 'drawline';\n    var isEllipse = mode === 'drawcircle';\n    var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n    var gd = dragOptions.gd;\n    var fullLayout = gd._fullLayout;\n    var immediateSelect = isSelectMode && fullLayout.newselection.mode === 'immediate' &&\n        isCartesian; // N.B. only cartesian subplots have persistent selection\n\n    var zoomLayer = fullLayout._zoomlayer;\n    var dragBBox = dragOptions.element.getBoundingClientRect();\n    var plotinfo = dragOptions.plotinfo;\n    var transform = getTransform(plotinfo);\n    var x0 = startX - dragBBox.left;\n    var y0 = startY - dragBBox.top;\n\n    fullLayout._calcInverseTransform(gd);\n    var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    var scaleX = fullLayout._invScaleX;\n    var scaleY = fullLayout._invScaleY;\n\n    var x1 = x0;\n    var y1 = y0;\n    var path0 = 'M' + x0 + ',' + y0;\n    var xAxis = dragOptions.xaxes[0];\n    var yAxis = dragOptions.yaxes[0];\n    var pw = xAxis._length;\n    var ph = yAxis._length;\n\n    var subtract = evt.altKey &&\n        !(drawMode(mode) && isOpenMode);\n\n    var filterPoly, selectionTesters, mergedPolygons, currentPolygon;\n    var i, searchInfo, eventData;\n\n    coerceSelectionsCache(evt, gd, dragOptions);\n\n    if(isFreeMode) {\n        filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n    }\n\n    var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1]);\n    var newStyle = isDrawMode ?\n        fullLayout.newshape :\n        fullLayout.newselection;\n\n    if(isDrawMode) {\n        dragOptions.hasText = newStyle.label.text || newStyle.label.texttemplate;\n    }\n\n    var fillC = (isDrawMode && !isOpenMode) ? newStyle.fillcolor : 'rgba(0,0,0,0)';\n\n    var strokeC = newStyle.line.color || (\n        isCartesian ?\n            Color.contrast(gd._fullLayout.plot_bgcolor) :\n            '#7f7f7f' // non-cartesian subplot\n    );\n\n    outlines.enter()\n        .append('path')\n        .attr('class', 'select-outline select-outline-' + plotinfo.id)\n        .style({\n            opacity: isDrawMode ? newStyle.opacity / 2 : 1,\n            'stroke-dasharray': dashStyle(newStyle.line.dash, newStyle.line.width),\n            'stroke-width': newStyle.line.width + 'px',\n            'shape-rendering': 'crispEdges'\n        })\n        .call(Color.stroke, strokeC)\n        .call(Color.fill, fillC)\n        .attr('fill-rule', 'evenodd')\n        .classed('cursor-move', isDrawMode ? true : false)\n        .attr('transform', transform)\n        .attr('d', path0 + 'Z');\n\n    var corners = zoomLayer.append('path')\n        .attr('class', 'zoombox-corners')\n        .style({\n            fill: Color.background,\n            stroke: Color.defaultLine,\n            'stroke-width': 1\n        })\n        .attr('transform', transform)\n        .attr('d', 'M0,0Z');\n\n    // create & style group for text label\n    if(isDrawMode && dragOptions.hasText) {\n        var shapeGroup = zoomLayer.select('.label-temp');\n        if(shapeGroup.empty()) {\n            shapeGroup = zoomLayer.append('g')\n                .classed('label-temp', true)\n                .classed('select-outline', true)\n                .style({ opacity: 0.8 });\n        }\n    }\n\n    var throttleID = fullLayout._uid + constants.SELECTID;\n    var selection = [];\n\n    // find the traces to search for selection points\n    var searchTraces = determineSearchTraces(gd, dragOptions.xaxes,\n      dragOptions.yaxes, dragOptions.subplot);\n\n    if(immediateSelect && !evt.shiftKey) {\n        dragOptions._clearSubplotSelections = function() {\n            if(!isCartesian) return;\n\n            var xRef = xAxis._id;\n            var yRef = yAxis._id;\n            deselectSubplot(gd, xRef, yRef, searchTraces);\n\n            var selections = (gd.layout || {}).selections || [];\n            var list = [];\n            var selectionErased = false;\n            for(var q = 0; q < selections.length; q++) {\n                var s = fullLayout.selections[q];\n                if(\n                    s.xref !== xRef ||\n                    s.yref !== yRef\n                ) {\n                    list.push(selections[q]);\n                } else {\n                    selectionErased = true;\n                }\n            }\n\n            if(selectionErased) {\n                gd._fullLayout._noEmitSelectedAtStart = true;\n\n                Registry.call('_guiRelayout', gd, {\n                    selections: list\n                });\n            }\n        };\n    }\n\n    var fillRangeItems = getFillRangeItems(dragOptions);\n\n    dragOptions.moveFn = function(dx0, dy0) {\n        if(dragOptions._clearSubplotSelections) {\n            dragOptions._clearSubplotSelections();\n            dragOptions._clearSubplotSelections = undefined;\n        }\n\n        x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n        y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n\n        var dx = Math.abs(x1 - x0);\n        var dy = Math.abs(y1 - y0);\n\n        if(isRectMode) {\n            var direction;\n            var start, end;\n\n            if(isSelectMode) {\n                var q = fullLayout.selectdirection;\n\n                if(q === 'any') {\n                    if(dy < Math.min(dx * 0.6, MINSELECT)) {\n                        direction = 'h';\n                    } else if(dx < Math.min(dy * 0.6, MINSELECT)) {\n                        direction = 'v';\n                    } else {\n                        direction = 'd';\n                    }\n                } else {\n                    direction = q;\n                }\n\n                switch(direction) {\n                    case 'h':\n                        start = isEllipse ? ph / 2 : 0;\n                        end = ph;\n                        break;\n                    case 'v':\n                        start = isEllipse ? pw / 2 : 0;\n                        end = pw;\n                        break;\n                }\n            }\n\n            if(isDrawMode) {\n                switch(fullLayout.newshape.drawdirection) {\n                    case 'vertical':\n                        direction = 'h';\n                        start = isEllipse ? ph / 2 : 0;\n                        end = ph;\n                        break;\n                    case 'horizontal':\n                        direction = 'v';\n                        start = isEllipse ? pw / 2 : 0;\n                        end = pw;\n                        break;\n                    case 'ortho':\n                        if(dx < dy) {\n                            direction = 'h';\n                            start = y0;\n                            end = y1;\n                        } else {\n                            direction = 'v';\n                            start = x0;\n                            end = x1;\n                        }\n                        break;\n                    default: // i.e. case of 'diagonal'\n                        direction = 'd';\n                }\n            }\n\n            if(direction === 'h') {\n                // horizontal motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [x1, start], [x1, end]) : // using x1 instead of x0 allows adjusting the line while drawing\n                    [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n                currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n                currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(start, end);\n                currentPolygon.ymax = Math.max(start, end);\n                // extras to guide users in keeping a straight selection\n                corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) +\n                    'h-4v' + (2 * MINSELECT) + 'h4Z' +\n                    'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) +\n                    'h4v' + (2 * MINSELECT) + 'h-4Z');\n            } else if(direction === 'v') {\n                // vertical motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [start, y1], [end, y1]) : // using y1 instead of y0 allows adjusting the line while drawing\n                    [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n                currentPolygon.xmin = Math.min(start, end);\n                currentPolygon.xmax = Math.max(start, end);\n                currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n                currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n                corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin +\n                    'v-4h' + (2 * MINSELECT) + 'v4Z' +\n                    'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) +\n                    'v4h' + (2 * MINSELECT) + 'v-4Z');\n            } else if(direction === 'd') {\n                // diagonal motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [x0, y0], [x1, y1]) :\n                    [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n\n                currentPolygon.xmin = Math.min(x0, x1);\n                currentPolygon.xmax = Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(y0, y1);\n                currentPolygon.ymax = Math.max(y0, y1);\n                corners.attr('d', 'M0,0Z');\n            }\n        } else if(isFreeMode) {\n            filterPoly.addPt([x1, y1]);\n            currentPolygon = filterPoly.filtered;\n        }\n\n        // create outline & tester\n        if(dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n\n            currentPolygon.subtract = subtract;\n            selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n        } else {\n            mergedPolygons = [currentPolygon];\n            selectionTesters = polygonTester(currentPolygon);\n        }\n\n        // display polygons on the screen\n        displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n\n        if(isSelectMode) {\n            var _res = reselect(gd, false);\n            var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];\n\n            _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);\n            selectionTesters = _res.selectionTesters;\n            eventData = _res.eventData;\n\n            var poly;\n            if(filterPoly) {\n                poly = filterPoly.filtered;\n            } else {\n                poly = castMultiPolygon(mergedPolygons);\n            }\n\n            throttle.throttle(\n                throttleID,\n                constants.SELECTDELAY,\n                function() {\n                    selection = _doSelect(selectionTesters, searchTraces);\n\n                    var newPoints = selection.slice();\n\n                    for(var w = 0; w < extraPoints.length; w++) {\n                        var p = extraPoints[w];\n                        var found = false;\n                        for(var u = 0; u < newPoints.length; u++) {\n                            if(\n                                newPoints[u].curveNumber === p.curveNumber &&\n                                newPoints[u].pointNumber === p.pointNumber\n                            ) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if(!found) newPoints.push(p);\n                    }\n\n                    if(newPoints.length) {\n                        if(!eventData) eventData = {};\n                        eventData.points = newPoints;\n                    }\n\n                    fillRangeItems(eventData, poly);\n\n                    emitSelecting(gd, eventData);\n                }\n            );\n        }\n    };\n\n    dragOptions.clickFn = function(numClicks, evt) {\n        corners.remove();\n\n        if(gd._fullLayout._activeShapeIndex >= 0) {\n            gd._fullLayout._deactivateShape(gd);\n            return;\n        }\n        if(isDrawMode) return;\n\n        var clickmode = fullLayout.clickmode;\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n            if(numClicks === 2) {\n                // clear selection on doubleclick\n                outlines.remove();\n                for(i = 0; i < searchTraces.length; i++) {\n                    searchInfo = searchTraces[i];\n                    searchInfo._module.selectPoints(searchInfo, false);\n                }\n\n                updateSelectedState(gd, searchTraces);\n\n                clearSelectionsCache(dragOptions);\n\n                emitDeselect(gd);\n\n                if(searchTraces.length) {\n                    var clickedXaxis = searchTraces[0].xaxis;\n                    var clickedYaxis = searchTraces[0].yaxis;\n\n                    if(clickedXaxis && clickedYaxis) {\n                        // drop selections in the clicked subplot\n                        var subSelections = [];\n                        var allSelections = gd._fullLayout.selections;\n                        for(var k = 0; k < allSelections.length; k++) {\n                            var s = allSelections[k];\n                            if(!s) continue; // also drop null selections if any\n\n                            if(\n                                s.xref !== clickedXaxis._id ||\n                                s.yref !== clickedYaxis._id\n                            ) {\n                                subSelections.push(s);\n                            }\n                        }\n\n                        if(subSelections.length < allSelections.length) {\n                            gd._fullLayout._noEmitSelectedAtStart = true;\n\n                            Registry.call('_guiRelayout', gd, {\n                                selections: subSelections\n                            });\n                        }\n                    }\n                }\n            } else {\n                if(clickmode.indexOf('select') > -1) {\n                    selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes,\n                      dragOptions.subplot, dragOptions, outlines);\n                }\n\n                if(clickmode === 'event') {\n                    // TODO: remove in v3 - this was probably never intended to work as it does,\n                    // but in case anyone depends on it we don't want to break it now.\n                    // Note that click-to-select introduced pre v3 also emitts proper\n                    // event data when clickmode is having 'select' in its flag list.\n                    emitSelected(gd, undefined);\n                }\n            }\n\n            Fx.click(gd, evt, plotinfo.id);\n        }).catch(Lib.error);\n    };\n\n    dragOptions.doneFn = function() {\n        corners.remove();\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n\n            if(!immediateSelect && currentPolygon && dragOptions.selectionDefs) {\n                // save last polygons\n                currentPolygon.subtract = subtract;\n                dragOptions.selectionDefs.push(currentPolygon);\n\n                // we have to keep reference to arrays container\n                dragOptions.mergedPolygons.length = 0;\n                [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n            }\n\n            if(immediateSelect || isDrawMode) {\n                clearSelectionsCache(dragOptions, immediateSelect);\n            }\n\n            if(dragOptions.doneFnCompleted) {\n                dragOptions.doneFnCompleted(selection);\n            }\n\n            if(isSelectMode) {\n                emitSelected(gd, eventData);\n            }\n        }).catch(Lib.error);\n    };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n    var hoverData = gd._hoverdata;\n    var fullLayout = gd._fullLayout;\n    var clickmode = fullLayout.clickmode;\n    var sendEvents = clickmode.indexOf('event') > -1;\n    var selection = [];\n    var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;\n    var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n    if(isHoverDataSet(hoverData)) {\n        coerceSelectionsCache(evt, gd, dragOptions);\n        searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n        var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n        var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;\n\n\n        // Note: potentially costly operation isPointOrBinSelected is\n        // called as late as possible through the use of an assignment\n        // in an if condition.\n        if(isBinnedTrace ?\n            isOnlyThisBinSelected(searchTraces, clickedPtInfo) :\n            isOnlyOnePointSelected(searchTraces) &&\n                (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n            if(polygonOutlines) polygonOutlines.remove();\n            for(i = 0; i < searchTraces.length; i++) {\n                searchInfo = searchTraces[i];\n                searchInfo._module.selectPoints(searchInfo, false);\n            }\n\n            updateSelectedState(gd, searchTraces);\n\n            clearSelectionsCache(dragOptions);\n\n            if(sendEvents) {\n                emitDeselect(gd);\n            }\n        } else {\n            subtract = evt.shiftKey &&\n              (pointOrBinSelected !== undefined ?\n                pointOrBinSelected :\n                isPointOrBinSelected(clickedPtInfo));\n            currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n\n            var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n            selectionTesters = multiTester(allSelectionDefs, selectionTesters);\n\n            for(i = 0; i < searchTraces.length; i++) {\n                traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);\n                thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n                if(selection.length) {\n                    for(var j = 0; j < thisTracesSelection.length; j++) {\n                        selection.push(thisTracesSelection[j]);\n                    }\n                } else selection = thisTracesSelection;\n            }\n\n            eventData = {points: selection};\n            updateSelectedState(gd, searchTraces, eventData);\n\n            if(currentSelectionDef && dragOptions) {\n                dragOptions.selectionDefs.push(currentSelectionDef);\n            }\n\n            if(polygonOutlines) {\n                var polygons = dragOptions.mergedPolygons;\n                var isOpenMode = openMode(dragOptions.dragmode);\n\n                // display polygons on the screen\n                displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n            }\n\n            if(sendEvents) {\n                emitSelected(gd, eventData);\n            }\n        }\n    }\n}\n\n/**\n * Constructs a new point selection definition object.\n */\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n    return {\n        pointNumber: pointNumber,\n        searchInfo: searchInfo,\n        subtract: !!subtract\n    };\n}\n\nfunction isPointSelectionDef(o) {\n    return 'pointNumber' in o && 'searchInfo' in o;\n}\n\n/*\n * Constructs a new point number tester.\n */\nfunction newPointNumTester(pointSelectionDef) {\n    return {\n        xmin: 0,\n        xmax: 0,\n        ymin: 0,\n        ymax: 0,\n        pts: [],\n        contains: function(pt, omitFirstEdge, pointNumber, searchInfo) {\n            var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n            var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n            return idxActualTrace === idxWantedTrace &&\n              pointNumber === pointSelectionDef.pointNumber;\n        },\n        isRect: false,\n        degenerate: false,\n        subtract: !!pointSelectionDef.subtract\n    };\n}\n\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\nfunction multiTester(list) {\n    if(!list.length) return;\n\n    var testers = [];\n    var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n    var xmax = xmin;\n    var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n    var ymax = ymin;\n\n    for(var i = 0; i < list.length; i++) {\n        if(isPointSelectionDef(list[i])) {\n            testers.push(newPointNumTester(list[i]));\n        } else {\n            var tester = polygonTester(list[i]);\n            tester.subtract = !!list[i].subtract;\n            testers.push(tester);\n\n            xmin = Math.min(xmin, tester.xmin);\n            xmax = Math.max(xmax, tester.xmax);\n            ymin = Math.min(ymin, tester.ymin);\n            ymax = Math.max(ymax, tester.ymax);\n        }\n    }\n\n    /**\n     * Tests if the given point is within this tester.\n     *\n     * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n     * @param {*} arg - An optional parameter to pass down to wrapped testers.\n     * @param {number} pointNumber - The point number of the point within the underlying data array.\n     * @param {number} searchInfo - An object identifying the trace the point is contained in.\n     *\n     * @return {boolean} true if point is considered to be selected, false otherwise.\n     */\n    function contains(pt, arg, pointNumber, searchInfo) {\n        var contained = false;\n        for(var i = 0; i < testers.length; i++) {\n            if(testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n                // if contained by subtract tester - exclude the point\n                contained = !testers[i].subtract;\n            }\n        }\n\n        return contained;\n    }\n\n    return {\n        xmin: xmin,\n        xmax: xmax,\n        ymin: ymin,\n        ymax: ymax,\n        pts: [],\n        contains: contains,\n        isRect: false,\n        degenerate: false\n    };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n    var fullLayout = gd._fullLayout;\n    var plotinfo = dragOptions.plotinfo;\n    var dragmode = dragOptions.dragmode;\n\n    var selectingOnSameSubplot = (\n        fullLayout._lastSelectedSubplot &&\n        fullLayout._lastSelectedSubplot === plotinfo.id\n    );\n\n    var hasModifierKey = (evt.shiftKey || evt.altKey) &&\n        !(drawMode(dragmode) && openMode(dragmode));\n\n    if(\n        selectingOnSameSubplot &&\n        hasModifierKey &&\n        plotinfo.selection &&\n        plotinfo.selection.selectionDefs &&\n        !dragOptions.selectionDefs\n    ) {\n        // take over selection definitions from prev mode, if any\n        dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n        dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n    } else if(!hasModifierKey || !plotinfo.selection) {\n        clearSelectionsCache(dragOptions);\n    }\n\n    // clear selection outline when selecting a different subplot\n    if(!selectingOnSameSubplot) {\n        clearOutline(gd);\n        fullLayout._lastSelectedSubplot = plotinfo.id;\n    }\n}\n\nfunction hasActiveShape(gd) {\n    return gd._fullLayout._activeShapeIndex >= 0;\n}\n\nfunction hasActiveSelection(gd) {\n    return gd._fullLayout._activeSelectionIndex >= 0;\n}\n\nfunction clearSelectionsCache(dragOptions, immediateSelect) {\n    var dragmode = dragOptions.dragmode;\n    var plotinfo = dragOptions.plotinfo;\n\n    var gd = dragOptions.gd;\n    if(hasActiveShape(gd)) {\n        gd._fullLayout._deactivateShape(gd);\n    }\n    if(hasActiveSelection(gd)) {\n        gd._fullLayout._deactivateSelection(gd);\n    }\n\n    var fullLayout = gd._fullLayout;\n    var zoomLayer = fullLayout._zoomlayer;\n\n    var isDrawMode = drawMode(dragmode);\n    var isSelectMode = selectMode(dragmode);\n\n    if(isDrawMode || isSelectMode) {\n        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n        if(outlines && gd._fullLayout._outlining) {\n            // add shape\n            var shapes;\n            if(isDrawMode) {\n                shapes = newShapes(outlines, dragOptions);\n            }\n            if(shapes) {\n                Registry.call('_guiRelayout', gd, {\n                    shapes: shapes\n                });\n            }\n\n            // add selection\n            var selections;\n            if(\n                isSelectMode &&\n                !hasSubplot(dragOptions) // only allow cartesian - no maps for now\n            ) {\n                selections = newSelections(outlines, dragOptions);\n            }\n            if(selections) {\n                gd._fullLayout._noEmitSelectedAtStart = true;\n\n                Registry.call('_guiRelayout', gd, {\n                    selections: selections\n                }).then(function() {\n                    if(immediateSelect) { activateLastSelection(gd); }\n                });\n            }\n\n            gd._fullLayout._outlining = false;\n        }\n    }\n\n    plotinfo.selection = {};\n    plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n    plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction getAxId(ax) {\n    return ax._id;\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n    if(!gd.calcdata) return [];\n\n    var searchTraces = [];\n    var xAxisIds = xAxes.map(getAxId);\n    var yAxisIds = yAxes.map(getAxId);\n    var cd, trace, i;\n\n    for(i = 0; i < gd.calcdata.length; i++) {\n        cd = gd.calcdata[i];\n        trace = cd[0].trace;\n\n        if(trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n        if(\n            hasSubplot({subplot: subplot}) &&\n            (trace.subplot === subplot || trace.geo === subplot)\n        ) {\n            searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n        } else if(trace.type === 'splom') {\n            // FIXME: make sure we don't have more than single axis for splom\n            if(trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n                var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n                info.scene = gd._fullLayout._splomScenes[trace.uid];\n                searchTraces.push(info);\n            }\n        } else if(trace.type === 'sankey') {\n            var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n            searchTraces.push(sankeyInfo);\n        } else {\n            if(xAxisIds.indexOf(trace.xaxis) === -1 && (!trace._xA || !trace._xA.overlaying)) continue;\n            if(yAxisIds.indexOf(trace.yaxis) === -1 && (!trace._yA || !trace._yA.overlaying)) continue;\n\n            searchTraces.push(createSearchInfo(trace._module, cd,\n              getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n        }\n    }\n\n    return searchTraces;\n}\n\nfunction createSearchInfo(module, calcData, xaxis, yaxis) {\n    return {\n        _module: module,\n        cd: calcData,\n        xaxis: xaxis,\n        yaxis: yaxis\n    };\n}\n\nfunction isHoverDataSet(hoverData) {\n    return hoverData &&\n      Array.isArray(hoverData) &&\n      hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n    var hoverDatum = hoverData[0];\n    var pointNumber = -1;\n    var pointNumbers = [];\n    var searchInfo, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        if(hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n            // Special case for box (and violin)\n            if(hoverDatum.hoverOnBox === true) {\n                break;\n            }\n\n            // Hint: in some traces like histogram, one graphical element\n            // doesn't correspond to one particular data point, but to\n            // bins of data points. Thus, hoverDatum can have a binNumber\n            // property instead of pointNumber.\n            if(hoverDatum.pointNumber !== undefined) {\n                pointNumber = hoverDatum.pointNumber;\n            } else if(hoverDatum.binNumber !== undefined) {\n                pointNumber = hoverDatum.binNumber;\n                pointNumbers = hoverDatum.pointNumbers;\n            }\n\n            break;\n        }\n    }\n\n    return {\n        pointNumber: pointNumber,\n        pointNumbers: pointNumbers,\n        searchInfo: searchInfo\n    };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n    var trace = clickedPtInfo.searchInfo.cd[0].trace;\n    var ptNum = clickedPtInfo.pointNumber;\n    var ptNums = clickedPtInfo.pointNumbers;\n    var ptNumsSet = ptNums.length > 0;\n\n    // When pointsNumbers is set (e.g. histogram's binning),\n    // it is assumed that when the first point of\n    // a bin is selected, all others are as well\n    var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;\n\n    // TODO potential performance improvement\n    // Primarily we need this function to determine if a click adds\n    // or subtracts from a selection.\n    // In cases `trace.selectedpoints` is a huge array, indexOf\n    // might be slow. One remedy would be to introduce a hash somewhere.\n    return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n    var tracesWithSelectedPts = [];\n    var searchInfo, trace, isSameTrace, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        if(searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n            tracesWithSelectedPts.push(searchInfo);\n        }\n    }\n\n    if(tracesWithSelectedPts.length === 1) {\n        isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n        if(isSameTrace) {\n            trace = clickedPtInfo.searchInfo.cd[0].trace;\n            if(trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n                for(i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n                    if(trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n    var len = 0;\n    var searchInfo, trace, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        trace = searchInfo.cd[0].trace;\n        if(trace.selectedpoints) {\n            if(trace.selectedpoints.length > 1) return false;\n\n            len += trace.selectedpoints.length;\n            if(len > 1) return false;\n        }\n    }\n\n    return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n    var i;\n\n    // before anything else, update preGUI if necessary\n    for(i = 0; i < searchTraces.length; i++) {\n        var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n        var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n        if(tracePreGUI.selectedpoints === undefined) {\n            tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n        }\n    }\n\n    var trace;\n    if(eventData) {\n        var pts = eventData.points || [];\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n            if(trace._fullInput !== trace) trace.selectedpoints = [];\n        }\n\n        for(var k = 0; k < pts.length; k++) {\n            var pt = pts[k];\n            var data = pt.data;\n            var fullData = pt.fullData;\n            var pointIndex = pt.pointIndex;\n            var pointIndices = pt.pointIndices;\n            if(pointIndices) {\n                [].push.apply(data.selectedpoints, pointIndices);\n                if(trace._fullInput !== trace) {\n                    [].push.apply(fullData.selectedpoints, pointIndices);\n                }\n            } else {\n                data.selectedpoints.push(pointIndex);\n                if(trace._fullInput !== trace) {\n                    fullData.selectedpoints.push(pointIndex);\n                }\n            }\n        }\n    } else {\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            delete trace.selectedpoints;\n            delete trace._input.selectedpoints;\n            if(trace._fullInput !== trace) {\n                delete trace._fullInput.selectedpoints;\n            }\n        }\n    }\n\n    updateReglSelectedState(gd, searchTraces);\n}\n\nfunction updateReglSelectedState(gd, searchTraces) {\n    var hasRegl = false;\n\n    for(var i = 0; i < searchTraces.length; i++) {\n        var searchInfo = searchTraces[i];\n        var cd = searchInfo.cd;\n\n        if(Registry.traceIs(cd[0].trace, 'regl')) {\n            hasRegl = true;\n        }\n\n        var _module = searchInfo._module;\n        var fn = _module.styleOnSelect || _module.style;\n        if(fn) {\n            fn(gd, cd, cd[0].node3);\n            if(cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n        }\n    }\n\n    if(hasRegl) {\n        clearGlCanvases(gd);\n        redrawReglTraces(gd);\n    }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n    var fn = subtract ?\n        polybool.difference :\n        polybool.union;\n\n    var res = fn({\n        regions: list\n    }, {\n        regions: [poly]\n    });\n\n    var allPolygons = res.regions.reverse();\n\n    for(var i = 0; i < allPolygons.length; i++) {\n        var polygon = allPolygons[i];\n\n        polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));\n    }\n\n    return allPolygons;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n    if(Array.isArray(selection)) {\n        var cd = searchInfo.cd;\n        var trace = searchInfo.cd[0].trace;\n\n        for(var i = 0; i < selection.length; i++) {\n            selection[i] = makeEventData(selection[i], trace, cd);\n        }\n    }\n\n    return selection;\n}\n\nfunction convertPoly(polygonsIn, isOpenMode) { // add M and L command to draft positions\n    var polygonsOut = [];\n    for(var i = 0; i < polygonsIn.length; i++) {\n        polygonsOut[i] = [];\n        for(var j = 0; j < polygonsIn[i].length; j++) {\n            polygonsOut[i][j] = [];\n            polygonsOut[i][j][0] = j ? 'L' : 'M';\n            for(var k = 0; k < polygonsIn[i][j].length; k++) {\n                polygonsOut[i][j].push(\n                    polygonsIn[i][j][k]\n                );\n            }\n        }\n\n        if(!isOpenMode) {\n            polygonsOut[i].push([\n                'Z',\n                polygonsOut[i][0][1], // initial x\n                polygonsOut[i][0][2]  // initial y\n            ]);\n        }\n    }\n\n    return polygonsOut;\n}\n\nfunction _doSelect(selectionTesters, searchTraces) {\n    var allSelections = [];\n\n    var thisSelection;\n    var traceSelections = [];\n    var traceSelection;\n    for(var i = 0; i < searchTraces.length; i++) {\n        var searchInfo = searchTraces[i];\n\n        traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);\n        traceSelections.push(traceSelection);\n\n        thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n        allSelections = allSelections.concat(thisSelection);\n    }\n\n    return allSelections;\n}\n\nfunction reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {\n    var hadSearchTraces = !!searchTraces;\n    var plotinfo, xRef, yRef;\n    if(dragOptions) {\n        plotinfo = dragOptions.plotinfo;\n        xRef = dragOptions.xaxes[0]._id;\n        yRef = dragOptions.yaxes[0]._id;\n    }\n\n    var allSelections = [];\n    var allSearchTraces = [];\n\n    // select layout.selection polygons\n    var layoutPolygons = getLayoutPolygons(gd);\n\n    // add draft outline polygons to layoutPolygons\n    var fullLayout = gd._fullLayout;\n    if(plotinfo) {\n        var zoomLayer = fullLayout._zoomlayer;\n        var mode = fullLayout.dragmode;\n        var isDrawMode = drawMode(mode);\n        var isSelectMode = selectMode(mode);\n        if(isDrawMode || isSelectMode) {\n            var xaxis = getFromId(gd, xRef, 'x');\n            var yaxis = getFromId(gd, yRef, 'y');\n            if(xaxis && yaxis) {\n                var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n                if(outlines && gd._fullLayout._outlining) {\n                    if(outlines.length) {\n                        var e = outlines[0][0]; // pick first\n                        var d = e.getAttribute('d');\n                        var outlinePolys = readPaths(d, gd, plotinfo);\n\n                        var draftPolygons = [];\n                        for(var u = 0; u < outlinePolys.length; u++) {\n                            var p = outlinePolys[u];\n                            var polygon = [];\n                            for(var t = 0; t < p.length; t++) {\n                                polygon.push([\n                                    convert(xaxis, p[t][1]),\n                                    convert(yaxis, p[t][2])\n                                ]);\n                            }\n\n                            polygon.xref = xRef;\n                            polygon.yref = yRef;\n                            polygon.subtract = getSubtract(polygon, draftPolygons);\n\n                            draftPolygons.push(polygon);\n                        }\n\n                        layoutPolygons = layoutPolygons.concat(draftPolygons);\n                    }\n                }\n            }\n        }\n    }\n\n    var subplots = (xRef && yRef) ? [xRef + yRef] :\n        fullLayout._subplots.cartesian;\n\n    epmtySplomSelectionBatch(gd);\n\n    var seenSplom = {};\n\n    for(var i = 0; i < subplots.length; i++) {\n        var subplot = subplots[i];\n        var yAt = subplot.indexOf('y');\n        var _xRef = subplot.slice(0, yAt);\n        var _yRef = subplot.slice(yAt);\n\n        var _selectionTesters = (xRef && yRef) ? selectionTesters : undefined;\n        _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);\n\n        if(_selectionTesters) {\n            var _searchTraces = searchTraces;\n            if(!hadSearchTraces) {\n                var _xA = getFromId(gd, _xRef, 'x');\n                var _yA = getFromId(gd, _yRef, 'y');\n\n                _searchTraces = determineSearchTraces(\n                    gd,\n                    [_xA],\n                    [_yA],\n                    subplot\n                );\n\n                for(var w = 0; w < _searchTraces.length; w++) {\n                    var s = _searchTraces[w];\n                    var cd0 = s.cd[0];\n                    var trace = cd0.trace;\n\n                    if(s._module.name === 'scattergl' && !cd0.t.xpx) {\n                        var x = trace.x;\n                        var y = trace.y;\n                        var len = trace._length;\n                        // generate stash for scattergl\n                        cd0.t.xpx = [];\n                        cd0.t.ypx = [];\n                        for(var j = 0; j < len; j++) {\n                            cd0.t.xpx[j] = _xA.c2p(x[j]);\n                            cd0.t.ypx[j] = _yA.c2p(y[j]);\n                        }\n                    }\n\n                    if(s._module.name === 'splom') {\n                        if(!seenSplom[trace.uid]) {\n                            seenSplom[trace.uid] = true;\n                        }\n                    }\n                }\n            }\n            var selection = _doSelect(_selectionTesters, _searchTraces);\n\n            allSelections = allSelections.concat(selection);\n            allSearchTraces = allSearchTraces.concat(_searchTraces);\n        }\n    }\n\n    var eventData = {points: allSelections};\n    updateSelectedState(gd, allSearchTraces, eventData);\n\n    var clickmode = fullLayout.clickmode;\n    var sendEvents = clickmode.indexOf('event') > -1 && mayEmitSelected;\n\n    if(\n        !plotinfo && // get called from plot_api & plots\n        mayEmitSelected\n    ) {\n        var activePolygons = getLayoutPolygons(gd, true);\n\n        if(activePolygons.length) {\n            var xref = activePolygons[0].xref;\n            var yref = activePolygons[0].yref;\n            if(xref && yref) {\n                var poly = castMultiPolygon(activePolygons);\n\n                var fillRangeItems = makeFillRangeItems([\n                    getFromId(gd, xref, 'x'),\n                    getFromId(gd, yref, 'y')\n                ]);\n\n                fillRangeItems(eventData, poly);\n            }\n        }\n\n        if(gd._fullLayout._noEmitSelectedAtStart) {\n            gd._fullLayout._noEmitSelectedAtStart = false;\n        } else {\n            if(sendEvents) emitSelected(gd, eventData);\n        }\n\n        fullLayout._reselect = false;\n    }\n\n    if(\n        !plotinfo && // get called from plot_api & plots\n        fullLayout._deselect\n    ) {\n        var deselect = fullLayout._deselect;\n        xRef = deselect.xref;\n        yRef = deselect.yref;\n\n        if(!subplotSelected(xRef, yRef, allSearchTraces)) {\n            deselectSubplot(gd, xRef, yRef, searchTraces);\n        }\n\n        if(sendEvents) {\n            if(eventData.points.length) {\n                emitSelected(gd, eventData);\n            } else {\n                emitDeselect(gd);\n            }\n        }\n\n        fullLayout._deselect = false;\n    }\n\n    return {\n        eventData: eventData,\n        selectionTesters: selectionTesters\n    };\n}\n\nfunction epmtySplomSelectionBatch(gd) {\n    var cd = gd.calcdata;\n    if(!cd) return;\n\n    for(var i = 0; i < cd.length; i++) {\n        var cd0 = cd[i][0];\n        var trace = cd0.trace;\n        var splomScenes = gd._fullLayout._splomScenes;\n        if(splomScenes) {\n            var scene = splomScenes[trace.uid];\n            if(scene) {\n                scene.selectBatch = [];\n            }\n        }\n    }\n}\n\nfunction subplotSelected(xRef, yRef, searchTraces) {\n    for(var i = 0; i < searchTraces.length; i++) {\n        var s = searchTraces[i];\n        if(\n            (s.xaxis && s.xaxis._id === xRef) &&\n            (s.yaxis && s.yaxis._id === yRef)\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction deselectSubplot(gd, xRef, yRef, searchTraces) {\n    searchTraces = determineSearchTraces(\n        gd,\n        [getFromId(gd, xRef, 'x')],\n        [getFromId(gd, yRef, 'y')],\n        xRef + yRef\n    );\n\n    for(var k = 0; k < searchTraces.length; k++) {\n        var searchInfo = searchTraces[k];\n        searchInfo._module.selectPoints(searchInfo, false);\n    }\n\n    updateSelectedState(gd, searchTraces);\n}\n\nfunction addTester(layoutPolygons, xRef, yRef, selectionTesters) {\n    var mergedPolygons;\n\n    for(var i = 0; i < layoutPolygons.length; i++) {\n        var currentPolygon = layoutPolygons[i];\n        if(xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;\n\n        if(mergedPolygons) {\n            var subtract = !!currentPolygon.subtract;\n            mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);\n            selectionTesters = multiTester(mergedPolygons);\n        } else {\n            mergedPolygons = [currentPolygon];\n            selectionTesters = polygonTester(currentPolygon);\n        }\n    }\n\n    return selectionTesters;\n}\n\nfunction getLayoutPolygons(gd, onlyActiveOnes) {\n    var allPolygons = [];\n\n    var fullLayout = gd._fullLayout;\n    var allSelections = fullLayout.selections;\n    var len = allSelections.length;\n\n    for(var i = 0; i < len; i++) {\n        if(onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;\n\n        var selection = allSelections[i];\n        if(!selection) continue;\n\n        var xref = selection.xref;\n        var yref = selection.yref;\n\n        var xaxis = getFromId(gd, xref, 'x');\n        var yaxis = getFromId(gd, yref, 'y');\n\n        var xmin, xmax, ymin, ymax;\n\n        var polygon;\n        if(selection.type === 'rect') {\n            polygon = [];\n\n            var x0 = convert(xaxis, selection.x0);\n            var x1 = convert(xaxis, selection.x1);\n            var y0 = convert(yaxis, selection.y0);\n            var y1 = convert(yaxis, selection.y1);\n            polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n\n            xmin = Math.min(x0, x1);\n            xmax = Math.max(x0, x1);\n            ymin = Math.min(y0, y1);\n            ymax = Math.max(y0, y1);\n\n            polygon.xmin = xmin;\n            polygon.xmax = xmax;\n            polygon.ymin = ymin;\n            polygon.ymax = ymax;\n\n            polygon.xref = xref;\n            polygon.yref = yref;\n\n            polygon.subtract = false;\n            polygon.isRect = true;\n\n            allPolygons.push(polygon);\n        } else if(selection.type === 'path') {\n            var segments = selection.path.split('Z');\n\n            var multiPolygons = [];\n            for(var j = 0; j < segments.length; j++) {\n                var path = segments[j];\n                if(!path) continue;\n                path += 'Z';\n\n                var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, 'raw');\n                var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, 'raw');\n\n                xmin = Infinity;\n                xmax = -Infinity;\n                ymin = Infinity;\n                ymax = -Infinity;\n\n                polygon = [];\n\n                for(var k = 0; k < allX.length; k++) {\n                    var x = convert(xaxis, allX[k]);\n                    var y = convert(yaxis, allY[k]);\n\n                    polygon.push([x, y]);\n\n                    xmin = Math.min(x, xmin);\n                    xmax = Math.max(x, xmax);\n                    ymin = Math.min(y, ymin);\n                    ymax = Math.max(y, ymax);\n                }\n\n                polygon.xmin = xmin;\n                polygon.xmax = xmax;\n                polygon.ymin = ymin;\n                polygon.ymax = ymax;\n\n                polygon.xref = xref;\n                polygon.yref = yref;\n                polygon.subtract = getSubtract(polygon, multiPolygons);\n\n                multiPolygons.push(polygon);\n                allPolygons.push(polygon);\n            }\n        }\n    }\n\n    return allPolygons;\n}\n\nfunction getSubtract(polygon, previousPolygons) {\n    var subtract = false;\n    for(var i = 0; i < previousPolygons.length; i++) {\n        var previousPolygon = previousPolygons[i];\n\n        // find out if a point of polygon is inside previous polygons\n        for(var k = 0; k < polygon.length; k++) {\n            if(pointInPolygon(polygon[k], previousPolygon)) {\n                subtract = !subtract;\n                break;\n            }\n        }\n    }\n    return subtract;\n}\n\nfunction convert(ax, d) {\n    if(ax.type === 'date') d = d.replace('_', ' ');\n    return ax.type === 'log' ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);\n}\n\nfunction castMultiPolygon(allPolygons) {\n    var len = allPolygons.length;\n\n    // descibe multi polygons in one polygon\n    var p = [];\n    for(var i = 0; i < len; i++) {\n        var polygon = allPolygons[i];\n        p = p.concat(polygon);\n\n        // add starting vertex to close\n        // which indicates next polygon\n        p = p.concat([polygon[0]]);\n    }\n\n    return computeRectAndRanges(p);\n}\n\nfunction computeRectAndRanges(poly) {\n    poly.isRect = poly.length === 5 &&\n        poly[0][0] === poly[4][0] &&\n        poly[0][1] === poly[4][1] &&\n        (\n            poly[0][0] === poly[1][0] &&\n            poly[2][0] === poly[3][0] &&\n            poly[0][1] === poly[3][1] &&\n            poly[1][1] === poly[2][1]\n        ) ||\n        (\n            poly[0][1] === poly[1][1] &&\n            poly[2][1] === poly[3][1] &&\n            poly[0][0] === poly[3][0] &&\n            poly[1][0] === poly[2][0]\n        );\n\n    if(poly.isRect) {\n        poly.xmin = Math.min(poly[0][0], poly[2][0]);\n        poly.xmax = Math.max(poly[0][0], poly[2][0]);\n        poly.ymin = Math.min(poly[0][1], poly[2][1]);\n        poly.ymax = Math.max(poly[0][1], poly[2][1]);\n    }\n\n    return poly;\n}\n\nfunction makeFillRangeItems(allAxes) {\n    return function(eventData, poly) {\n        var range;\n        var lassoPoints;\n\n        for(var i = 0; i < allAxes.length; i++) {\n            var ax = allAxes[i];\n            var id = ax._id;\n            var axLetter = id.charAt(0);\n\n            if(poly.isRect) {\n                if(!range) range = {};\n                var min = poly[axLetter + 'min'];\n                var max = poly[axLetter + 'max'];\n\n                if(min !== undefined && max !== undefined) {\n                    range[id] = [\n                        p2r(ax, min),\n                        p2r(ax, max)\n                    ].sort(ascending);\n                }\n            } else {\n                if(!lassoPoints) lassoPoints = {};\n                lassoPoints[id] = poly.map(axValue(ax));\n            }\n        }\n\n        if(range) {\n            eventData.range = range;\n        }\n\n        if(lassoPoints) {\n            eventData.lassoPoints = lassoPoints;\n        }\n    };\n}\n\nfunction getFillRangeItems(dragOptions) {\n    var plotinfo = dragOptions.plotinfo;\n\n    return (\n        plotinfo.fillRangeItems || // allow subplots (i.e. geo, mapbox, map, sankey) to override fillRangeItems routine\n        makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes))\n    );\n}\n\nfunction emitSelecting(gd, eventData) {\n    gd.emit('plotly_selecting', eventData);\n}\n\nfunction emitSelected(gd, eventData) {\n    if(eventData) {\n        eventData.selections = (gd.layout || {}).selections || [];\n    }\n\n    gd.emit('plotly_selected', eventData);\n}\n\nfunction emitDeselect(gd) {\n    gd.emit('plotly_deselect', null);\n}\n\nmodule.exports = {\n    reselect: reselect,\n    prepSelect: prepSelect,\n    clearOutline: clearOutline,\n    clearSelectionsCache: clearSelectionsCache,\n    selectOnClick: selectOnClick\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}