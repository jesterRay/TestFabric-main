{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strRotate = Lib.strRotate;\nvar strTranslate = Lib.strTranslate;\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Plots = require('../plots');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvertCartesian = require('../cartesian/set_convert');\nvar setConvertPolar = require('./set_convert');\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\nvar dragBox = require('../cartesian/dragbox');\nvar dragElement = require('../../components/dragelement');\nvar Fx = require('../../components/fx');\nvar Titles = require('../../components/titles');\nvar prepSelect = require('../../components/selections').prepSelect;\nvar selectOnClick = require('../../components/selections').selectOnClick;\nvar clearOutline = require('../../components/selections').clearOutline;\nvar setCursor = require('../../lib/setcursor');\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nvar smithHelpers = require('../smith/helpers');\nvar smith = smithHelpers.smith;\nvar reactanceArc = smithHelpers.reactanceArc;\nvar resistanceArc = smithHelpers.resistanceArc;\nvar smithTransform = smithHelpers.smithTransform;\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\nfunction Polar(gd, id, isSmith) {\n  this.isSmith = isSmith || false;\n  this.id = id;\n  this.gd = gd;\n  this._hasClipOnAxisFalse = null;\n  this.vangles = null;\n  this.radialAxisAngle = null;\n  this.traceHash = {};\n  this.layers = {};\n  this.clipPaths = {};\n  this.clipIds = {};\n  this.viewInitial = {};\n  var fullLayout = gd._fullLayout;\n  var clipIdBase = 'clip' + fullLayout._uid + id;\n  this.clipIds.forTraces = clipIdBase + '-for-traces';\n  this.clipPaths.forTraces = fullLayout._clips.append('clipPath').attr('id', this.clipIds.forTraces);\n  this.clipPaths.forTraces.append('path');\n  this.framework = fullLayout['_' + (isSmith ? 'smith' : 'polar') + 'layer'].append('g').attr('class', id);\n  this.getHole = function (s) {\n    return this.isSmith ? 0 : s.hole;\n  };\n  this.getSector = function (s) {\n    return this.isSmith ? [0, 360] : s.sector;\n  };\n  this.getRadial = function (s) {\n    return this.isSmith ? s.realaxis : s.radialaxis;\n  };\n  this.getAngular = function (s) {\n    return this.isSmith ? s.imaginaryaxis : s.angularaxis;\n  };\n  if (!isSmith) {\n    // unfortunately, we have to keep track of some axis tick settings\n    // as polar subplots do not implement the 'ticks' editType\n    this.radialTickLayout = null;\n    this.angularTickLayout = null;\n  }\n}\nvar proto = Polar.prototype;\nmodule.exports = function createPolar(gd, id, isSmith) {\n  return new Polar(gd, id, isSmith);\n};\nproto.plot = function (polarCalcData, fullLayout) {\n  var _this = this;\n  var polarLayout = fullLayout[_this.id];\n  var found = false;\n  for (var i = 0; i < polarCalcData.length; i++) {\n    var trace = polarCalcData[i][0].trace;\n    if (trace.cliponaxis === false) {\n      found = true;\n      break;\n    }\n  }\n  _this._hasClipOnAxisFalse = found;\n  _this.updateLayers(fullLayout, polarLayout);\n  _this.updateLayout(fullLayout, polarLayout);\n  Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n  _this.updateFx(fullLayout, polarLayout);\n  if (_this.isSmith) {\n    delete polarLayout.realaxis.range;\n    delete polarLayout.imaginaryaxis.range;\n  }\n};\nproto.updateLayers = function (fullLayout, polarLayout) {\n  var _this = this;\n  var isSmith = _this.isSmith;\n  var layers = _this.layers;\n  var radialLayout = _this.getRadial(polarLayout);\n  var angularLayout = _this.getAngular(polarLayout);\n  var layerNames = constants.layerNames;\n  var frontPlotIndex = layerNames.indexOf('frontplot');\n  var layerData = layerNames.slice(0, frontPlotIndex);\n  var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n  var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n  if (isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (isRadialAxisBelowTraces) layerData.push('radial-axis');\n  layerData.push('frontplot');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-axis');\n  var subLayer = (isSmith ? 'smith' : 'polar') + 'sublayer';\n  var join = _this.framework.selectAll('.' + subLayer).data(layerData, String);\n  join.enter().append('g').attr('class', function (d) {\n    return subLayer + ' ' + d;\n  }).each(function (d) {\n    var sel = layers[d] = d3.select(this);\n    switch (d) {\n      case 'frontplot':\n        // TODO add option to place in 'backplot' layer??\n        if (!isSmith) {\n          sel.append('g').classed('barlayer', true);\n        }\n        sel.append('g').classed('scatterlayer', true);\n        break;\n      case 'backplot':\n        sel.append('g').classed('maplayer', true);\n        break;\n      case 'plotbg':\n        layers.bg = sel.append('path');\n        break;\n      case 'radial-grid':\n        sel.style('fill', 'none');\n        break;\n      case 'angular-grid':\n        sel.style('fill', 'none');\n        break;\n      case 'radial-line':\n        sel.append('line').style('fill', 'none');\n        break;\n      case 'angular-line':\n        sel.append('path').style('fill', 'none');\n        break;\n    }\n  });\n  join.order();\n};\n\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - getRadial(polarLayout) (aka radialLayout in this file):\n * - getAngular(polarLayout) (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends getRadial(polarLayout), adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends getAngular(polarLayout), adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\nproto.updateLayout = function (fullLayout, polarLayout) {\n  var _this = this;\n  var layers = _this.layers;\n  var gs = fullLayout._size;\n\n  // axis attributes\n  var radialLayout = _this.getRadial(polarLayout);\n  var angularLayout = _this.getAngular(polarLayout);\n  // layout domains\n  var xDomain = polarLayout.domain.x;\n  var yDomain = polarLayout.domain.y;\n  // offsets from paper edge to layout domain box\n  _this.xOffset = gs.l + gs.w * xDomain[0];\n  _this.yOffset = gs.t + gs.h * (1 - yDomain[1]);\n  // lengths of the layout domain box\n  var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n  var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]);\n  // sector to plot\n  var sector = _this.getSector(polarLayout);\n  _this.sectorInRad = sector.map(deg2rad);\n  var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n  var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n  var dySectorBBox = sectorBBox[3] - sectorBBox[1];\n  // aspect ratios\n  var arDomain = yLength / xLength;\n  var arSector = Math.abs(dySectorBBox / dxSectorBBox);\n  // actual lengths and domains of subplot box\n  var xLength2, yLength2;\n  var xDomain2, yDomain2;\n  var gap;\n  if (arDomain > arSector) {\n    xLength2 = xLength;\n    yLength2 = xLength * arSector;\n    gap = (yLength - yLength2) / gs.h / 2;\n    xDomain2 = [xDomain[0], xDomain[1]];\n    yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n  } else {\n    xLength2 = yLength / arSector;\n    yLength2 = yLength;\n    gap = (xLength - xLength2) / gs.w / 2;\n    xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n    yDomain2 = [yDomain[0], yDomain[1]];\n  }\n  _this.xLength2 = xLength2;\n  _this.yLength2 = yLength2;\n  _this.xDomain2 = xDomain2;\n  _this.yDomain2 = yDomain2;\n  // actual offsets from paper edge to the subplot box top-left corner\n  var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n  var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]);\n  // circle radius in px\n  var radius = _this.radius = xLength2 / dxSectorBBox;\n  // 'inner' radius in px (when polar.hole is set)\n  var innerRadius = _this.innerRadius = _this.getHole(polarLayout) * radius;\n  // circle center position in px\n  var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n  var cy = _this.cy = yOffset2 + radius * sectorBBox[3];\n  // circle center in the coordinate system of plot area\n  var cxx = _this.cxx = cx - xOffset2;\n  var cyy = _this.cyy = cy - yOffset2;\n  var side = radialLayout.side;\n  var trueSide;\n  if (side === 'counterclockwise') {\n    trueSide = side;\n    side = 'top';\n  } else if (side === 'clockwise') {\n    trueSide = side;\n    side = 'bottom';\n  }\n  _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n    // make this an 'x' axis to make positioning (especially rotation) easier\n    _id: 'x',\n    // convert to 'x' axis equivalent\n    side: side,\n    // keep track of real side\n    _trueSide: trueSide,\n    // spans length 1 radius\n    domain: [innerRadius / gs.w, radius / gs.w]\n  });\n  _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n    side: 'right',\n    // to get auto nticks right\n    domain: [0, Math.PI],\n    // don't pass through autorange logic\n    autorange: false\n  });\n  _this.doAutoRange(fullLayout, polarLayout);\n  // N.B. this sets _this.vangles\n  _this.updateAngularAxis(fullLayout, polarLayout);\n  // N.B. this sets _this.radialAxisAngle\n  _this.updateRadialAxis(fullLayout, polarLayout);\n  _this.updateRadialAxisTitle(fullLayout, polarLayout);\n  _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'x',\n    domain: xDomain2\n  });\n  _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'y',\n    domain: yDomain2\n  });\n  var dPath = _this.pathSubplot();\n  _this.clipPaths.forTraces.select('path').attr('d', dPath).attr('transform', strTranslate(cxx, cyy));\n  layers.frontplot.attr('transform', strTranslate(xOffset2, yOffset2)).call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n  layers.bg.attr('d', dPath).attr('transform', strTranslate(cx, cy)).call(Color.fill, polarLayout.bgcolor);\n};\nproto.mockAxis = function (fullLayout, polarLayout, axLayout, opts) {\n  var ax = Lib.extendFlat({}, axLayout, opts);\n  setConvertPolar(ax, polarLayout, fullLayout);\n  return ax;\n};\nproto.mockCartesianAxis = function (fullLayout, polarLayout, opts) {\n  var _this = this;\n  var isSmith = _this.isSmith;\n  var axId = opts._id;\n  var ax = Lib.extendFlat({\n    type: 'linear'\n  }, opts);\n  setConvertCartesian(ax, fullLayout);\n  var bboxIndices = {\n    x: [0, 2],\n    y: [1, 3]\n  };\n  ax.setRange = function () {\n    var sectorBBox = _this.sectorBBox;\n    var ind = bboxIndices[axId];\n    var rl = _this.radialAxis._rl;\n    var drl = (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout));\n    ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n  };\n  ax.isPtWithinRange = axId === 'x' && !isSmith ? function (d) {\n    return _this.isPtInside(d);\n  } : function () {\n    return true;\n  };\n  ax.setRange();\n  ax.setScale();\n  return ax;\n};\nproto.doAutoRange = function (fullLayout, polarLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var radialAxis = _this.radialAxis;\n  var radialLayout = _this.getRadial(polarLayout);\n  doAutoRange(gd, radialAxis);\n  var rng = radialAxis.range;\n  radialLayout.range = rng.slice();\n  radialLayout._input.range = rng.slice();\n  radialAxis._rl = [radialAxis.r2l(rng[0], null, 'gregorian'), radialAxis.r2l(rng[1], null, 'gregorian')];\n  if (radialAxis.minallowed !== undefined) {\n    var minallowed = radialAxis.r2l(radialAxis.minallowed);\n    if (radialAxis._rl[0] > radialAxis._rl[1]) {\n      radialAxis._rl[1] = Math.max(radialAxis._rl[1], minallowed);\n    } else {\n      radialAxis._rl[0] = Math.max(radialAxis._rl[0], minallowed);\n    }\n  }\n  if (radialAxis.maxallowed !== undefined) {\n    var maxallowed = radialAxis.r2l(radialAxis.maxallowed);\n    if (radialAxis._rl[0] < radialAxis._rl[1]) {\n      radialAxis._rl[1] = Math.min(radialAxis._rl[1], maxallowed);\n    } else {\n      radialAxis._rl[0] = Math.min(radialAxis._rl[0], maxallowed);\n    }\n  }\n};\nproto.updateRadialAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialLayout = _this.getRadial(polarLayout);\n  var a0 = mod(_this.getSector(polarLayout)[0], 360);\n  var ax = _this.radialAxis;\n  var hasRoomForIt = innerRadius < radius;\n  var isSmith = _this.isSmith;\n  if (!isSmith) {\n    _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n    _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n    ax.setGeometry();\n  }\n\n  // rotate auto tick labels by 180 if in quadrant II and III to make them\n  // readable from left-to-right\n  //\n  // TODO try moving deeper in Axes.drawLabels for better results?\n  if (ax.tickangle === 'auto' && a0 > 90 && a0 <= 270) {\n    ax.tickangle = 180;\n  }\n\n  // easier to set rotate angle with custom translate function\n  var transFn = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([d.x, 0]));\n    return strTranslate(t[0] - cx, t[1] - cy);\n  } : function (d) {\n    return strTranslate(ax.l2p(d.x) + innerRadius, 0);\n  };\n\n  // set special grid path function\n  var gridPathFn = isSmith ? function (d) {\n    return resistanceArc(_this, d.x, -Infinity, Infinity);\n  } : function (d) {\n    return _this.pathArc(ax.r2p(d.x) + innerRadius);\n  };\n  var newTickLayout = strTickLayout(radialLayout);\n  if (_this.radialTickLayout !== newTickLayout) {\n    layers['radial-axis'].selectAll('.xtick').remove();\n    _this.radialTickLayout = newTickLayout;\n  }\n  if (hasRoomForIt) {\n    ax.setScale();\n    var labelShift = 0;\n    var vals = isSmith ? (ax.tickvals || []).filter(function (x) {\n      // filter negative\n      return x >= 0;\n    }).map(function (x) {\n      return Axes.tickText(ax, x, true, false);\n    }) : Axes.calcTicks(ax);\n    var valsClipped = isSmith ? vals : Axes.clipEnds(ax, vals);\n    var tickSign = Axes.getTickSigns(ax)[2];\n    if (isSmith) {\n      if (ax.ticks === 'top' && ax.side === 'bottom' || ax.ticks === 'bottom' && ax.side === 'top') {\n        // invert sign\n        tickSign = -tickSign;\n      }\n      if (ax.ticks === 'top' && ax.side === 'top') labelShift = -ax.ticklen;\n      if (ax.ticks === 'bottom' && ax.side === 'bottom') labelShift = ax.ticklen;\n    }\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      path: Axes.makeTickPath(ax, 0, tickSign),\n      transFn: transFn,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: valsClipped,\n      layer: layers['radial-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      transFn: transFn,\n      labelFns: Axes.makeLabelFns(ax, labelShift)\n    });\n  }\n\n  // stash 'actual' radial axis angle for drag handlers (in degrees)\n  var angle = _this.radialAxisAngle = _this.vangles ? rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) : radialLayout.angle;\n  var tLayer = strTranslate(cx, cy);\n  var tLayer2 = tLayer + strRotate(-angle);\n  updateElement(layers['radial-axis'], hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks), {\n    transform: tLayer2\n  });\n  updateElement(layers['radial-grid'], hasRoomForIt && radialLayout.showgrid, {\n    transform: isSmith ? '' : tLayer\n  });\n  updateElement(layers['radial-line'].select('line'), hasRoomForIt && radialLayout.showline, {\n    x1: isSmith ? -radius : innerRadius,\n    y1: 0,\n    x2: radius,\n    y2: 0,\n    transform: tLayer2\n  }).attr('stroke-width', radialLayout.linewidth).call(Color.stroke, radialLayout.linecolor);\n};\nproto.updateRadialAxisTitle = function (fullLayout, polarLayout, _angle) {\n  if (this.isSmith) return;\n  var _this = this;\n  var gd = _this.gd;\n  var radius = _this.radius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialLayout = _this.getRadial(polarLayout);\n  var titleClass = _this.id + 'title';\n  var pad = 0;\n\n  // Hint: no need to check if there is in fact a title.text set\n  // because if plot is editable, pad needs to be calculated anyways\n  // to properly show placeholder text when title is empty.\n  if (radialLayout.title) {\n    var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n    var ts = radialLayout.title.font.size;\n    var side = radialLayout.side;\n    pad = side === 'top' ? ts : side === 'counterclockwise' ? -(h + ts * 0.4) : h + ts * 0.8;\n  }\n  var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n  var angleRad = deg2rad(angle);\n  var cosa = Math.cos(angleRad);\n  var sina = Math.sin(angleRad);\n  var x = cx + radius / 2 * cosa + pad * sina;\n  var y = cy - radius / 2 * sina + pad * cosa;\n  _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n    propContainer: radialLayout,\n    propName: _this.id + '.radialaxis.title',\n    placeholder: _(gd, 'Click to enter radial axis title'),\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    },\n    transform: {\n      rotate: -angle\n    }\n  });\n};\nproto.updateAngularAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var angularLayout = _this.getAngular(polarLayout);\n  var ax = _this.angularAxis;\n  var isSmith = _this.isSmith;\n  if (!isSmith) {\n    _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n    ax.setGeometry();\n    ax.setScale();\n  }\n\n  // 't'ick to 'g'eometric radians is used all over the place here\n  var t2g = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    return Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n  } : function (d) {\n    return ax.t2g(d.x);\n  };\n\n  // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n  if (ax.type === 'linear' && ax.thetaunit === 'radians') {\n    ax.tick0 = rad2deg(ax.tick0);\n    ax.dtick = rad2deg(ax.dtick);\n  }\n  var _transFn = function (rad) {\n    return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n  };\n  var transFn = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    return strTranslate(t[0], t[1]);\n  } : function (d) {\n    return _transFn(t2g(d));\n  };\n  var transFn2 = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    var rad = Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n    return strTranslate(t[0], t[1]) + strRotate(-rad2deg(rad));\n  } : function (d) {\n    var rad = t2g(d);\n    return _transFn(rad) + strRotate(-rad2deg(rad));\n  };\n  var gridPathFn = isSmith ? function (d) {\n    return reactanceArc(_this, d.x, 0, Infinity);\n  } : function (d) {\n    var rad = t2g(d);\n    var cosRad = Math.cos(rad);\n    var sinRad = Math.sin(rad);\n    return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] + 'L' + [cx + radius * cosRad, cy - radius * sinRad];\n  };\n  var out = Axes.makeLabelFns(ax, 0);\n  var labelStandoff = out.labelStandoff;\n  var labelFns = {};\n  labelFns.xFn = function (d) {\n    var rad = t2g(d);\n    return Math.cos(rad) * labelStandoff;\n  };\n  labelFns.yFn = function (d) {\n    var rad = t2g(d);\n    var ff = Math.sin(rad) > 0 ? 0.2 : 1;\n    return -Math.sin(rad) * (labelStandoff + d.fontSize * ff) + Math.abs(Math.cos(rad)) * (d.fontSize * MID_SHIFT);\n  };\n  labelFns.anchorFn = function (d) {\n    var rad = t2g(d);\n    var cos = Math.cos(rad);\n    return Math.abs(cos) < 0.1 ? 'middle' : cos > 0 ? 'start' : 'end';\n  };\n  labelFns.heightFn = function (d, a, h) {\n    var rad = t2g(d);\n    return -0.5 * (1 + Math.sin(rad)) * h;\n  };\n  var newTickLayout = strTickLayout(angularLayout);\n  if (_this.angularTickLayout !== newTickLayout) {\n    layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n    _this.angularTickLayout = newTickLayout;\n  }\n  var vals = isSmith ? [Infinity].concat(ax.tickvals || []).map(function (x) {\n    return Axes.tickText(ax, x, true, false);\n  }) : Axes.calcTicks(ax);\n  if (isSmith) {\n    vals[0].text = '∞';\n    vals[0].fontSize *= 1.75;\n  }\n\n  // angle of polygon vertices in geometric radians (null means circles)\n  // TODO what to do when ax.period > ax._categories ??\n  var vangles;\n  if (polarLayout.gridshape === 'linear') {\n    vangles = vals.map(t2g);\n\n    // ax._vals should be always ordered, make them\n    // always turn counterclockwise for convenience here\n    if (Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n      vangles = vangles.slice().reverse();\n    }\n  } else {\n    vangles = null;\n  }\n  _this.vangles = vangles;\n\n  // Use tickval filter for category axes instead of tweaking\n  // the range w.r.t sector, so that sectors that cross 360 can\n  // show all their ticks.\n  if (ax.type === 'category') {\n    vals = vals.filter(function (d) {\n      return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n    });\n  }\n  if (ax.visible) {\n    var tickSign = ax.ticks === 'inside' ? -1 : 1;\n    var pad = (ax.linewidth || 1) / 2;\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      path: 'M' + tickSign * pad + ',0h' + tickSign * ax.ticklen,\n      transFn: transFn2,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: vals,\n      layer: layers['angular-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      repositionOnUpdate: true,\n      transFn: transFn,\n      labelFns: labelFns\n    });\n  }\n\n  // TODO maybe two arcs is better here?\n  // maybe split style attributes between inner and outer angular axes?\n\n  updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n    d: _this.pathSubplot(),\n    transform: strTranslate(cx, cy)\n  }).attr('stroke-width', angularLayout.linewidth).call(Color.stroke, angularLayout.linecolor);\n};\nproto.updateFx = function (fullLayout, polarLayout) {\n  if (!this.gd._context.staticPlot) {\n    var hasDrag = !this.isSmith;\n    if (hasDrag) {\n      this.updateAngularDrag(fullLayout);\n      this.updateRadialDrag(fullLayout, polarLayout, 0);\n      this.updateRadialDrag(fullLayout, polarLayout, 1);\n    }\n    this.updateHoverAndMainDrag(fullLayout);\n  }\n};\nproto.updateHoverAndMainDrag = function (fullLayout) {\n  var _this = this;\n  var isSmith = _this.isSmith;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var zoomlayer = fullLayout._zoomlayer;\n  var MINZOOM = constants.MINZOOM;\n  var OFFEDGE = constants.OFFEDGE;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var sectorInRad = _this.sectorInRad;\n  var vangles = _this.vangles;\n  var radialAxis = _this.radialAxis;\n  var clampTiny = helpers.clampTiny;\n  var findXYatLength = helpers.findXYatLength;\n  var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n  var chw = constants.cornerHalfWidth;\n  var chl = constants.cornerLen / 2;\n  var scaleX;\n  var scaleY;\n  var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', fullLayout.dragmode === false ? 'none' : 'crosshair');\n  d3.select(mainDrag).attr('d', _this.pathSubplot()).attr('transform', strTranslate(cx, cy));\n  mainDrag.onmousemove = function (evt) {\n    Fx.hover(gd, evt, _this.id);\n    gd._fullLayout._lasthover = mainDrag;\n    gd._fullLayout._hoversubplot = _this.id;\n  };\n  mainDrag.onmouseout = function (evt) {\n    if (gd._dragging) return;\n    dragElement.unhover(gd, evt);\n  };\n  var dragOpts = {\n    element: mainDrag,\n    gd: gd,\n    subplot: _this.id,\n    plotinfo: {\n      id: _this.id,\n      xaxis: _this.xaxis,\n      yaxis: _this.yaxis\n    },\n    xaxes: [_this.xaxis],\n    yaxes: [_this.yaxis]\n  };\n\n  // mouse px position at drag start (0), move (1)\n  var x0, y0;\n  // radial distance from circle center at drag start (0), move (1)\n  var r0, r1;\n  // zoombox persistent quantities\n  var path0, dimmed, lum;\n  // zoombox, corners elements\n  var zb, corners;\n  function norm(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n  function xy2r(x, y) {\n    return norm(x - cxx, y - cyy);\n  }\n  function xy2a(x, y) {\n    return Math.atan2(cyy - y, x - cxx);\n  }\n  function ra2xy(r, a) {\n    return [r * Math.cos(a), r * Math.sin(-a)];\n  }\n  function pathCorner(r, a) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var da = chl / r;\n    var am = a - da;\n    var ap = a + da;\n    var rb = Math.max(0, Math.min(r, radius));\n    var rm = rb - chw;\n    var rp = rb + chw;\n    return 'M' + ra2xy(rm, am) + 'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) + 'L' + ra2xy(rp, ap) + 'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) + 'Z';\n  }\n\n  // (x,y) is the pt at middle of the va0 <-> va1 edge\n  //\n  // ... we could eventually add another mode for cursor\n  // angles 'close to' enough to a particular vertex.\n  function pathCornerForPolygons(r, va0, va1) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var xy0 = ra2xy(r, va0);\n    var xy1 = ra2xy(r, va1);\n    var x = clampTiny((xy0[0] + xy1[0]) / 2);\n    var y = clampTiny((xy0[1] + xy1[1]) / 2);\n    var innerPts, outerPts;\n    if (x && y) {\n      var m = y / x;\n      var mperp = -1 / m;\n      var midPts = findXYatLength(chw, m, x, y);\n      innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n      outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n    } else {\n      var dx, dy;\n      if (y) {\n        // horizontal handles\n        dx = chl;\n        dy = chw;\n      } else {\n        // vertical handles\n        dx = chw;\n        dy = chl;\n      }\n      innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n      outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n    }\n    return 'M' + innerPts.join('L') + 'L' + outerPts.reverse().join('L') + 'Z';\n  }\n  function zoomPrep() {\n    r0 = null;\n    r1 = null;\n    path0 = _this.pathSubplot();\n    dimmed = false;\n    var polarLayoutNow = gd._fullLayout[_this.id];\n    lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n    zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n    zb.attr('fill-rule', 'evenodd');\n    corners = dragBox.makeCorners(zoomlayer, cx, cy);\n    clearOutline(gd);\n  }\n\n  // N.B. this sets scoped 'r0' and 'r1'\n  // return true if 'valid' zoom distance, false otherwise\n  function clampAndSetR0R1(rr0, rr1) {\n    rr1 = Math.max(Math.min(rr1, radius), innerRadius);\n\n    // starting or ending drag near center (outer edge),\n    // clamps radial distance at origin (at r=radius)\n    if (rr0 < OFFEDGE) rr0 = 0;else if (radius - rr0 < OFFEDGE) rr0 = radius;else if (rr1 < OFFEDGE) rr1 = 0;else if (radius - rr1 < OFFEDGE) rr1 = radius;\n\n    // make sure r0 < r1,\n    // to get correct fill pattern in path1 below\n    if (Math.abs(rr1 - rr0) > MINZOOM) {\n      if (rr0 < rr1) {\n        r0 = rr0;\n        r1 = rr1;\n      } else {\n        r0 = rr1;\n        r1 = rr0;\n      }\n      return true;\n    } else {\n      r0 = null;\n      r1 = null;\n      return false;\n    }\n  }\n  function applyZoomMove(path1, cpath) {\n    path1 = path1 || path0;\n    cpath = cpath || 'M0,0Z';\n    zb.attr('d', path1);\n    corners.attr('d', cpath);\n    dragBox.transitionZoombox(zb, corners, dimmed, lum);\n    dimmed = true;\n    var updateObj = {};\n    computeZoomUpdates(updateObj);\n    gd.emit('plotly_relayouting', updateObj);\n  }\n  function zoomMove(dx, dy) {\n    dx = dx * scaleX;\n    dy = dy * scaleY;\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var rr0 = xy2r(x0, y0);\n    var rr1 = Math.min(xy2r(x1, y1), radius);\n    var a0 = xy2a(x0, y0);\n    var path1;\n    var cpath;\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0);\n      // keep 'starting' angle\n      cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n    }\n    applyZoomMove(path1, cpath);\n  }\n  function findPolygonRadius(x, y, va0, va1) {\n    var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n    return norm(xy[0], xy[1]);\n  }\n  function zoomMoveForPolygons(dx, dy) {\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var a0 = xy2a(x0, y0);\n    var a1 = xy2a(x1, y1);\n    var vangles0 = findEnclosingVertexAngles(a0, vangles);\n    var vangles1 = findEnclosingVertexAngles(a1, vangles);\n    var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n    var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n    var path1;\n    var cpath;\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0);\n      // keep 'starting' angle here too\n      cpath = [pathCornerForPolygons(r0, vangles0[0], vangles0[1]), pathCornerForPolygons(r1, vangles0[0], vangles0[1])].join(' ');\n    }\n    applyZoomMove(path1, cpath);\n  }\n  function zoomDone() {\n    dragBox.removeZoombox(gd);\n    if (r0 === null || r1 === null) return;\n    var updateObj = {};\n    computeZoomUpdates(updateObj);\n    dragBox.showDoubleClickNotifier(gd);\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n  function computeZoomUpdates(update) {\n    var rl = radialAxis._rl;\n    var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n    var newRng = [rl[0] + (r0 - innerRadius) * m, rl[0] + (r1 - innerRadius) * m];\n    update[_this.id + '.radialaxis.range'] = newRng;\n  }\n  function zoomClick(numClicks, evt) {\n    var clickMode = gd._fullLayout.clickmode;\n    dragBox.removeZoombox(gd);\n\n    // TODO double once vs twice logic (autorange vs fixed range)\n    if (numClicks === 2) {\n      var updateObj = {};\n      for (var k in _this.viewInitial) {\n        updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n      }\n      gd.emit('plotly_doubleclick', null);\n      Registry.call('_guiRelayout', gd, updateObj);\n    }\n    if (clickMode.indexOf('select') > -1 && numClicks === 1) {\n      selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n    }\n    if (clickMode.indexOf('event') > -1) {\n      Fx.click(gd, evt, _this.id);\n    }\n  }\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var dragModeNow = gd._fullLayout.dragmode;\n    var bbox = mainDrag.getBoundingClientRect();\n    gd._fullLayout._calcInverseTransform(gd);\n    var inverse = gd._fullLayout._invTransform;\n    scaleX = gd._fullLayout._invScaleX;\n    scaleY = gd._fullLayout._invScaleY;\n    var transformedCoords = Lib.apply3DTransform(inverse)(startX - bbox.left, startY - bbox.top);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n\n    // need to offset x/y as bbox center does not\n    // match origin for asymmetric polygons\n    if (vangles) {\n      var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n      x0 += cxx + offset[0];\n      y0 += cyy + offset[1];\n    }\n    switch (dragModeNow) {\n      case 'zoom':\n        dragOpts.clickFn = zoomClick;\n        if (!isSmith) {\n          if (vangles) {\n            dragOpts.moveFn = zoomMoveForPolygons;\n          } else {\n            dragOpts.moveFn = zoomMove;\n          }\n          dragOpts.doneFn = zoomDone;\n          zoomPrep(evt, startX, startY);\n        }\n        break;\n      case 'select':\n      case 'lasso':\n        prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n        break;\n    }\n  };\n  dragElement.init(dragOpts);\n};\nproto.updateRadialDrag = function (fullLayout, polarLayout, rngIndex) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialAxis = _this.radialAxis;\n  var bl = constants.radialDragBoxSize;\n  var bl2 = bl / 2;\n  if (!radialAxis.visible) return;\n  var angle0 = deg2rad(_this.radialAxisAngle);\n  var rl = radialAxis._rl;\n  var rl0 = rl[0];\n  var rl1 = rl[1];\n  var rbase = rl[rngIndex];\n  var m = 0.75 * (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout)) / radius;\n  var tx, ty, className;\n  if (rngIndex) {\n    tx = cx + (radius + bl2) * Math.cos(angle0);\n    ty = cy - (radius + bl2) * Math.sin(angle0);\n    className = 'radialdrag';\n  } else {\n    // the 'inner' box can get called:\n    // - when polar.hole>0\n    // - when polar.sector isn't a full circle\n    // otherwise it is hidden behind the main drag.\n    tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n    ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n    className = 'radialdrag-inner';\n  }\n  var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n  var dragOpts = {\n    element: radialDrag,\n    gd: gd\n  };\n  if (fullLayout.dragmode === false) {\n    dragOpts.dragmode = false;\n  }\n  updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n    transform: strTranslate(tx, ty)\n  });\n\n  // move function (either rotate or re-range flavor)\n  var moveFn2;\n  // rotate angle on done\n  var angle1;\n  // re-range range[1] (or range[0]) on done\n  var rprime;\n  function moveFn(dx, dy) {\n    if (moveFn2) {\n      moveFn2(dx, dy);\n    } else {\n      var dvec = [dx, -dy];\n      var rvec = [Math.cos(angle0), Math.sin(angle0)];\n      var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec)));\n\n      // mostly perpendicular motions rotate,\n      // mostly parallel motions re-range\n      if (!isNaN(comp)) {\n        moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n      }\n    }\n    var update = {};\n    computeRadialAxisUpdates(update);\n    gd.emit('plotly_relayouting', update);\n  }\n  function computeRadialAxisUpdates(update) {\n    if (angle1 !== null) {\n      update[_this.id + '.radialaxis.angle'] = angle1;\n    } else if (rprime !== null) {\n      update[_this.id + '.radialaxis.range[' + rngIndex + ']'] = rprime;\n    }\n  }\n  function doneFn() {\n    if (angle1 !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n    } else if (rprime !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n    }\n  }\n  function rotateMove(dx, dy) {\n    // disable for inner drag boxes\n    if (rngIndex === 0) return;\n    var x1 = tx + dx;\n    var y1 = ty + dy;\n    angle1 = Math.atan2(cy - y1, x1 - cx);\n    if (_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n    angle1 = rad2deg(angle1);\n    var transform = strTranslate(cx, cy) + strRotate(-angle1);\n    layers['radial-axis'].attr('transform', transform);\n    layers['radial-line'].select('line').attr('transform', transform);\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n    _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n  }\n  function rerangeMove(dx, dy) {\n    // project (dx, dy) unto unit radial axis vector\n    var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n    rprime = rbase - m * dr;\n\n    // make sure rprime does not change the range[0] -> range[1] sign\n    if (m > 0 !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n      rprime = null;\n      return;\n    }\n    var fullLayoutNow = gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n\n    // update radial range -> update c2g -> update _m,_b\n    radialAxis.range[rngIndex] = rprime;\n    radialAxis._rl[rngIndex] = rprime;\n    _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n    _this.xaxis.setRange();\n    _this.xaxis.setScale();\n    _this.yaxis.setRange();\n    _this.yaxis.setScale();\n    var hasRegl = false;\n    for (var traceType in _this.traceHash) {\n      var moduleCalcData = _this.traceHash[traceType];\n      var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n      var _module = moduleCalcData[0][0].trace._module;\n      _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n      if (Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n    }\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n  }\n  dragOpts.prepFn = function () {\n    moveFn2 = null;\n    angle1 = null;\n    rprime = null;\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearOutline(gd);\n  };\n  dragOpts.clampFn = function (dx, dy) {\n    if (Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n      dx = 0;\n      dy = 0;\n    }\n    return [dx, dy];\n  };\n  dragElement.init(dragOpts);\n};\nproto.updateAngularDrag = function (fullLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var angularAxis = _this.angularAxis;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var dbs = constants.angularDragBoxSize;\n  var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', fullLayout.dragmode === false ? 'none' : 'move');\n  var dragOpts = {\n    element: angularDrag,\n    gd: gd\n  };\n  if (fullLayout.dragmode === false) {\n    dragOpts.dragmode = false;\n  } else {\n    d3.select(angularDrag).attr('d', _this.pathAnnulus(radius, radius + dbs)).attr('transform', strTranslate(cx, cy)).call(setCursor, 'move');\n  }\n  function xy2a(x, y) {\n    return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n  }\n\n  // scatter trace, points and textpoints selections\n  var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n  var scatterPoints = scatterTraces.selectAll('.point');\n  var scatterTextPoints = scatterTraces.selectAll('.textpoint');\n\n  // mouse px position at drag start (0), move (1)\n  var x0, y0;\n  // angular axis angle rotation at drag start (0), move (1)\n  var rot0, rot1;\n  // induced radial axis rotation (only used on polygon grids)\n  var rrot1;\n  // angle about circle center at drag start\n  var a0;\n  function moveFn(dx, dy) {\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n    var x1 = x0 + dx * fullLayout._invScaleX;\n    var y1 = y0 + dy * fullLayout._invScaleY;\n    var a1 = xy2a(x1, y1);\n    var da = rad2deg(a1 - a0);\n    rot1 = rot0 + da;\n    layers.frontplot.attr('transform', strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy]));\n    if (_this.vangles) {\n      rrot1 = _this.radialAxisAngle + da;\n      var trans = strTranslate(cx, cy) + strRotate(-da);\n      var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n      layers.bg.attr('transform', trans);\n      layers['radial-grid'].attr('transform', trans);\n      layers['radial-axis'].attr('transform', trans2);\n      layers['radial-line'].select('line').attr('transform', trans2);\n      _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n    } else {\n      _this.clipPaths.forTraces.select('path').attr('transform', strTranslate(cxx, cyy) + strRotate(da));\n    }\n\n    // 'un-rotate' marker and text points\n    scatterPoints.each(function () {\n      var sel = d3.select(this);\n      var xy = Drawing.getTranslate(sel);\n      sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n    });\n    scatterTextPoints.each(function () {\n      var sel = d3.select(this);\n      var tx = sel.select('text');\n      var xy = Drawing.getTranslate(sel);\n      // N.B rotate -> translate ordering matters\n      sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n    });\n\n    // update rotation -> range -> _m,_b\n    angularAxis.rotation = Lib.modHalf(rot1, 360);\n    _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n    if (_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n      scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n    }\n    var hasRegl = false;\n    for (var traceType in _this.traceHash) {\n      if (Registry.traceIs(traceType, 'gl')) {\n        var moduleCalcData = _this.traceHash[traceType];\n        var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n        var _module = moduleCalcData[0][0].trace._module;\n        _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n        if (moduleCalcDataVisible.length) hasRegl = true;\n      }\n    }\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n    var update = {};\n    computeRotationUpdates(update);\n    gd.emit('plotly_relayouting', update);\n  }\n  function computeRotationUpdates(updateObj) {\n    updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n    if (_this.vangles) {\n      updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n    }\n  }\n  function doneFn() {\n    scatterTextPoints.select('text').attr('transform', null);\n    var updateObj = {};\n    computeRotationUpdates(updateObj);\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var polarLayoutNow = fullLayout[_this.id];\n    rot0 = polarLayoutNow.angularaxis.rotation;\n    var bbox = angularDrag.getBoundingClientRect();\n    x0 = startX - bbox.left;\n    y0 = startY - bbox.top;\n    gd._fullLayout._calcInverseTransform(gd);\n    var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    a0 = xy2a(x0, y0);\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearOutline(gd);\n  };\n\n  // I don't what we should do in this case, skip we now\n  if (_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n    dragOpts.prepFn = Lib.noop;\n    setCursor(d3.select(angularDrag), null);\n  }\n  dragElement.init(dragOpts);\n};\nproto.isPtInside = function (d) {\n  if (this.isSmith) return true;\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var thetag = this.angularAxis.c2g(d.theta);\n  var radialAxis = this.radialAxis;\n  var r = radialAxis.c2l(d.r);\n  var rl = radialAxis._rl;\n  var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n  return fn(r, thetag, rl, sectorInRad, vangles);\n};\nproto.pathArc = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\nproto.pathSector = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\nproto.pathAnnulus = function (r0, r1) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n  return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\nproto.pathSubplot = function () {\n  var r0 = this.innerRadius;\n  var r1 = this.radius;\n  return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\nproto.fillViewInitialKey = function (key, val) {\n  if (!(key in this.viewInitial)) {\n    this.viewInitial[key] = val;\n  }\n};\nfunction strTickLayout(axLayout) {\n  var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n  if ('side' in axLayout) out += axLayout.side;\n  return out;\n}\n\n// Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\nfunction computeSectorBBox(sector) {\n  var s0 = sector[0];\n  var s1 = sector[1];\n  var arc = s1 - s0;\n  var a0 = mod(s0, 360);\n  var a1 = a0 + arc;\n  var ax0 = Math.cos(deg2rad(a0));\n  var ay0 = Math.sin(deg2rad(a0));\n  var ax1 = Math.cos(deg2rad(a1));\n  var ay1 = Math.sin(deg2rad(a1));\n  var x0, y0, x1, y1;\n  if (a0 <= 90 && a1 >= 90 || a0 > 90 && a1 >= 450) {\n    y1 = 1;\n  } else if (ay0 <= 0 && ay1 <= 0) {\n    y1 = 0;\n  } else {\n    y1 = Math.max(ay0, ay1);\n  }\n  if (a0 <= 180 && a1 >= 180 || a0 > 180 && a1 >= 540) {\n    x0 = -1;\n  } else if (ax0 >= 0 && ax1 >= 0) {\n    x0 = 0;\n  } else {\n    x0 = Math.min(ax0, ax1);\n  }\n  if (a0 <= 270 && a1 >= 270 || a0 > 270 && a1 >= 630) {\n    y0 = -1;\n  } else if (ay0 >= 0 && ay1 >= 0) {\n    y0 = 0;\n  } else {\n    y0 = Math.min(ay0, ay1);\n  }\n  if (a1 >= 360) {\n    x1 = 1;\n  } else if (ax0 <= 0 && ax1 <= 0) {\n    x1 = 0;\n  } else {\n    x1 = Math.max(ax0, ax1);\n  }\n  return [x0, y0, x1, y1];\n}\nfunction snapToVertexAngle(a, vangles) {\n  var fn = function (v) {\n    return Lib.angleDist(a, v);\n  };\n  var ind = Lib.findIndexOfMin(vangles, fn);\n  return vangles[ind];\n}\nfunction updateElement(sel, showAttr, attrs) {\n  if (showAttr) {\n    sel.attr('display', null);\n    sel.attr(attrs);\n  } else if (sel) {\n    sel.attr('display', 'none');\n  }\n  return sel;\n}","map":{"version":3,"names":["d3","require","tinycolor","Registry","Lib","strRotate","strTranslate","Color","Drawing","Plots","Axes","setConvertCartesian","setConvertPolar","doAutoRange","dragBox","dragElement","Fx","Titles","prepSelect","selectOnClick","clearOutline","setCursor","clearGlCanvases","redrawReglTraces","MID_SHIFT","constants","helpers","smithHelpers","smith","reactanceArc","resistanceArc","smithTransform","_","mod","deg2rad","rad2deg","Polar","gd","id","isSmith","_hasClipOnAxisFalse","vangles","radialAxisAngle","traceHash","layers","clipPaths","clipIds","viewInitial","fullLayout","_fullLayout","clipIdBase","_uid","forTraces","_clips","append","attr","framework","getHole","s","hole","getSector","sector","getRadial","realaxis","radialaxis","getAngular","imaginaryaxis","angularaxis","radialTickLayout","angularTickLayout","proto","prototype","module","exports","createPolar","plot","polarCalcData","_this","polarLayout","found","i","length","trace","cliponaxis","updateLayers","updateLayout","generalUpdatePerTraceModule","updateFx","range","radialLayout","angularLayout","layerNames","frontPlotIndex","indexOf","layerData","slice","isAngularAxisBelowTraces","layer","isRadialAxisBelowTraces","push","subLayer","join","selectAll","data","String","enter","d","each","sel","select","classed","bg","style","order","gs","_size","xDomain","domain","x","yDomain","y","xOffset","l","w","yOffset","t","h","xLength","yLength","sectorInRad","map","sectorBBox","computeSectorBBox","dxSectorBBox","dySectorBBox","arDomain","arSector","Math","abs","xLength2","yLength2","xDomain2","yDomain2","gap","xOffset2","yOffset2","radius","innerRadius","cx","cy","cxx","cyy","side","trueSide","radialAxis","mockAxis","_id","_trueSide","angularAxis","PI","autorange","updateAngularAxis","updateRadialAxis","updateRadialAxisTitle","xaxis","mockCartesianAxis","yaxis","dPath","pathSubplot","frontplot","call","setClipUrl","fill","bgcolor","axLayout","opts","ax","extendFlat","axId","type","bboxIndices","setRange","ind","rl","_rl","drl","isPtWithinRange","isPtInside","setScale","rng","_input","r2l","minallowed","undefined","max","maxallowed","min","a0","hasRoomForIt","fillViewInitialKey","angle","setGeometry","tickangle","transFn","l2p","gridPathFn","Infinity","pathArc","r2p","newTickLayout","strTickLayout","remove","labelShift","vals","tickvals","filter","tickText","calcTicks","valsClipped","clipEnds","tickSign","getTickSigns","ticks","ticklen","drawTicks","path","makeTickPath","crisp","drawGrid","noop","drawLabels","labelFns","makeLabelFns","snapToVertexAngle","tLayer","tLayer2","updateElement","showticklabels","transform","showgrid","showline","x1","y1","x2","y2","linewidth","stroke","linecolor","_angle","titleClass","pad","title","bBox","node","height","ts","font","size","angleRad","cosa","cos","sina","sin","draw","propContainer","propName","placeholder","attributes","rotate","rotation","t2g","atan2","thetaunit","tick0","dtick","_transFn","rad","transFn2","cosRad","sinRad","out","labelStandoff","xFn","yFn","ff","fontSize","anchorFn","heightFn","a","concat","text","gridshape","angleDelta","reverse","isAngleInsideSector","visible","repositionOnUpdate","_context","staticPlot","hasDrag","updateAngularDrag","updateRadialDrag","updateHoverAndMainDrag","zoomlayer","_zoomlayer","MINZOOM","OFFEDGE","clampTiny","findXYatLength","findEnclosingVertexAngles","chw","cornerHalfWidth","chl","cornerLen","scaleX","scaleY","mainDrag","makeDragger","dragmode","onmousemove","evt","hover","_lasthover","_hoversubplot","onmouseout","_dragging","unhover","dragOpts","element","subplot","plotinfo","xaxes","yaxes","x0","y0","r0","r1","path0","dimmed","lum","zb","corners","norm","sqrt","xy2r","xy2a","ra2xy","r","pathCorner","pathSector","da","am","ap","rb","rm","rp","pathCornerForPolygons","va0","va1","xy0","xy1","innerPts","outerPts","m","mperp","midPts","dx","dy","zoomPrep","polarLayoutNow","getLuminance","makeZoombox","makeCorners","clampAndSetR0R1","rr0","rr1","applyZoomMove","path1","cpath","transitionZoombox","updateObj","computeZoomUpdates","emit","zoomMove","findPolygonRadius","xy","findIntersectionXY","zoomMoveForPolygons","a1","vangles0","vangles1","zoomDone","removeZoombox","showDoubleClickNotifier","update","newRng","zoomClick","numClicks","clickMode","clickmode","k","click","prepFn","startX","startY","dragModeNow","bbox","getBoundingClientRect","_calcInverseTransform","inverse","_invTransform","_invScaleX","_invScaleY","transformedCoords","apply3DTransform","left","top","offset","findPolygonOffset","clickFn","moveFn","doneFn","init","rngIndex","bl","radialDragBoxSize","bl2","angle0","rl0","rl1","rbase","tx","ty","className","radialDrag","makeRectDragger","moveFn2","angle1","rprime","dvec","rvec","comp","dot","isNaN","rotateMove","rerangeMove","computeRadialAxisUpdates","fullLayoutNow","dr","hasRegl","traceType","moduleCalcData","moduleCalcDataVisible","filterVisible","_module","traceIs","clampFn","MINDRAG","dbs","angularDragBoxSize","angularDrag","pathAnnulus","scatterTraces","scatterPoints","scatterTextPoints","rot0","rot1","rrot1","trans","trans2","getTranslate","modHalf","isFullCircle","hideOutsideRangePoints","computeRotationUpdates","thetag","c2g","theta","c2l","fn","isPtInsidePolygon","isPtInsideSector","pathPolygon","pathPolygonAnnulus","key","val","s0","s1","arc","ax0","ay0","ax1","ay1","v","angleDist","findIndexOfMin","showAttr","attrs"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/polar/polar.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strRotate = Lib.strRotate;\nvar strTranslate = Lib.strTranslate;\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Plots = require('../plots');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvertCartesian = require('../cartesian/set_convert');\nvar setConvertPolar = require('./set_convert');\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\nvar dragBox = require('../cartesian/dragbox');\nvar dragElement = require('../../components/dragelement');\nvar Fx = require('../../components/fx');\nvar Titles = require('../../components/titles');\nvar prepSelect = require('../../components/selections').prepSelect;\nvar selectOnClick = require('../../components/selections').selectOnClick;\nvar clearOutline = require('../../components/selections').clearOutline;\nvar setCursor = require('../../lib/setcursor');\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\nvar smithHelpers = require('../smith/helpers');\nvar smith = smithHelpers.smith;\nvar reactanceArc = smithHelpers.reactanceArc;\nvar resistanceArc = smithHelpers.resistanceArc;\nvar smithTransform = smithHelpers.smithTransform;\n\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\nfunction Polar(gd, id, isSmith) {\n    this.isSmith = isSmith || false;\n    this.id = id;\n    this.gd = gd;\n\n    this._hasClipOnAxisFalse = null;\n    this.vangles = null;\n    this.radialAxisAngle = null;\n    this.traceHash = {};\n    this.layers = {};\n    this.clipPaths = {};\n    this.clipIds = {};\n    this.viewInitial = {};\n\n    var fullLayout = gd._fullLayout;\n    var clipIdBase = 'clip' + fullLayout._uid + id;\n\n    this.clipIds.forTraces = clipIdBase + '-for-traces';\n    this.clipPaths.forTraces = fullLayout._clips.append('clipPath')\n        .attr('id', this.clipIds.forTraces);\n    this.clipPaths.forTraces.append('path');\n\n    this.framework = fullLayout['_' + (isSmith ? 'smith' : 'polar') + 'layer'].append('g')\n        .attr('class', id);\n\n    this.getHole = function(s) {\n        return this.isSmith ? 0 : s.hole;\n    };\n\n    this.getSector = function(s) {\n        return this.isSmith ? [0, 360] : s.sector;\n    };\n\n    this.getRadial = function(s) {\n        return this.isSmith ? s.realaxis : s.radialaxis;\n    };\n\n    this.getAngular = function(s) {\n        return this.isSmith ? s.imaginaryaxis : s.angularaxis;\n    };\n\n    if(!isSmith) {\n        // unfortunately, we have to keep track of some axis tick settings\n        // as polar subplots do not implement the 'ticks' editType\n        this.radialTickLayout = null;\n        this.angularTickLayout = null;\n    }\n}\n\nvar proto = Polar.prototype;\n\nmodule.exports = function createPolar(gd, id, isSmith) {\n    return new Polar(gd, id, isSmith);\n};\n\nproto.plot = function(polarCalcData, fullLayout) {\n    var _this = this;\n    var polarLayout = fullLayout[_this.id];\n\n    var found = false;\n    for(var i = 0; i < polarCalcData.length; i++) {\n        var trace = polarCalcData[i][0].trace;\n        if(trace.cliponaxis === false) {\n            found = true;\n            break;\n        }\n    }\n    _this._hasClipOnAxisFalse = found;\n\n    _this.updateLayers(fullLayout, polarLayout);\n    _this.updateLayout(fullLayout, polarLayout);\n    Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n    _this.updateFx(fullLayout, polarLayout);\n\n    if(_this.isSmith) {\n        delete polarLayout.realaxis.range;\n        delete polarLayout.imaginaryaxis.range;\n    }\n};\n\nproto.updateLayers = function(fullLayout, polarLayout) {\n    var _this = this;\n    var isSmith = _this.isSmith;\n    var layers = _this.layers;\n    var radialLayout = _this.getRadial(polarLayout);\n    var angularLayout = _this.getAngular(polarLayout);\n    var layerNames = constants.layerNames;\n\n    var frontPlotIndex = layerNames.indexOf('frontplot');\n    var layerData = layerNames.slice(0, frontPlotIndex);\n    var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n    var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n\n    if(isAngularAxisBelowTraces) layerData.push('angular-line');\n    if(isRadialAxisBelowTraces) layerData.push('radial-line');\n    if(isAngularAxisBelowTraces) layerData.push('angular-axis');\n    if(isRadialAxisBelowTraces) layerData.push('radial-axis');\n\n    layerData.push('frontplot');\n\n    if(!isAngularAxisBelowTraces) layerData.push('angular-line');\n    if(!isRadialAxisBelowTraces) layerData.push('radial-line');\n    if(!isAngularAxisBelowTraces) layerData.push('angular-axis');\n    if(!isRadialAxisBelowTraces) layerData.push('radial-axis');\n\n    var subLayer = (isSmith ? 'smith' : 'polar') + 'sublayer';\n\n    var join = _this.framework.selectAll('.' + subLayer)\n        .data(layerData, String);\n\n    join.enter().append('g')\n        .attr('class', function(d) { return subLayer + ' ' + d;})\n        .each(function(d) {\n            var sel = layers[d] = d3.select(this);\n\n            switch(d) {\n                case 'frontplot':\n                    // TODO add option to place in 'backplot' layer??\n                    if(!isSmith) {\n                        sel.append('g').classed('barlayer', true);\n                    }\n                    sel.append('g').classed('scatterlayer', true);\n                    break;\n                case 'backplot':\n                    sel.append('g').classed('maplayer', true);\n                    break;\n                case 'plotbg':\n                    layers.bg = sel.append('path');\n                    break;\n                case 'radial-grid':\n                    sel.style('fill', 'none');\n                    break;\n                case 'angular-grid':\n                    sel.style('fill', 'none');\n                    break;\n                case 'radial-line':\n                    sel.append('line').style('fill', 'none');\n                    break;\n                case 'angular-line':\n                    sel.append('path').style('fill', 'none');\n                    break;\n            }\n        });\n\n    join.order();\n};\n\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - getRadial(polarLayout) (aka radialLayout in this file):\n * - getAngular(polarLayout) (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends getRadial(polarLayout), adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends getAngular(polarLayout), adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\nproto.updateLayout = function(fullLayout, polarLayout) {\n    var _this = this;\n    var layers = _this.layers;\n    var gs = fullLayout._size;\n\n    // axis attributes\n    var radialLayout = _this.getRadial(polarLayout);\n    var angularLayout = _this.getAngular(polarLayout);\n    // layout domains\n    var xDomain = polarLayout.domain.x;\n    var yDomain = polarLayout.domain.y;\n    // offsets from paper edge to layout domain box\n    _this.xOffset = gs.l + gs.w * xDomain[0];\n    _this.yOffset = gs.t + gs.h * (1 - yDomain[1]);\n    // lengths of the layout domain box\n    var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n    var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]);\n    // sector to plot\n    var sector = _this.getSector(polarLayout);\n    _this.sectorInRad = sector.map(deg2rad);\n    var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n    var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n    var dySectorBBox = sectorBBox[3] - sectorBBox[1];\n    // aspect ratios\n    var arDomain = yLength / xLength;\n    var arSector = Math.abs(dySectorBBox / dxSectorBBox);\n    // actual lengths and domains of subplot box\n    var xLength2, yLength2;\n    var xDomain2, yDomain2;\n    var gap;\n    if(arDomain > arSector) {\n        xLength2 = xLength;\n        yLength2 = xLength * arSector;\n        gap = (yLength - yLength2) / gs.h / 2;\n        xDomain2 = [xDomain[0], xDomain[1]];\n        yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n    } else {\n        xLength2 = yLength / arSector;\n        yLength2 = yLength;\n        gap = (xLength - xLength2) / gs.w / 2;\n        xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n        yDomain2 = [yDomain[0], yDomain[1]];\n    }\n    _this.xLength2 = xLength2;\n    _this.yLength2 = yLength2;\n    _this.xDomain2 = xDomain2;\n    _this.yDomain2 = yDomain2;\n    // actual offsets from paper edge to the subplot box top-left corner\n    var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n    var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]);\n    // circle radius in px\n    var radius = _this.radius = xLength2 / dxSectorBBox;\n    // 'inner' radius in px (when polar.hole is set)\n    var innerRadius = _this.innerRadius = _this.getHole(polarLayout) * radius;\n    // circle center position in px\n    var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n    var cy = _this.cy = yOffset2 + radius * sectorBBox[3];\n    // circle center in the coordinate system of plot area\n    var cxx = _this.cxx = cx - xOffset2;\n    var cyy = _this.cyy = cy - yOffset2;\n\n    var side = radialLayout.side;\n    var trueSide;\n    if(side === 'counterclockwise') {\n        trueSide = side;\n        side = 'top';\n    } else if(side === 'clockwise') {\n        trueSide = side;\n        side = 'bottom';\n    }\n\n    _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n        // make this an 'x' axis to make positioning (especially rotation) easier\n        _id: 'x',\n        // convert to 'x' axis equivalent\n        side: side,\n        // keep track of real side\n        _trueSide: trueSide,\n        // spans length 1 radius\n        domain: [innerRadius / gs.w, radius / gs.w]\n    });\n\n    _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n        side: 'right',\n        // to get auto nticks right\n        domain: [0, Math.PI],\n        // don't pass through autorange logic\n        autorange: false\n    });\n\n    _this.doAutoRange(fullLayout, polarLayout);\n    // N.B. this sets _this.vangles\n    _this.updateAngularAxis(fullLayout, polarLayout);\n    // N.B. this sets _this.radialAxisAngle\n    _this.updateRadialAxis(fullLayout, polarLayout);\n    _this.updateRadialAxisTitle(fullLayout, polarLayout);\n\n    _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n        _id: 'x',\n        domain: xDomain2\n    });\n\n    _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n        _id: 'y',\n        domain: yDomain2\n    });\n\n    var dPath = _this.pathSubplot();\n\n    _this.clipPaths.forTraces.select('path')\n        .attr('d', dPath)\n        .attr('transform', strTranslate(cxx, cyy));\n\n    layers.frontplot\n        .attr('transform', strTranslate(xOffset2, yOffset2))\n        .call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n\n    layers.bg\n        .attr('d', dPath)\n        .attr('transform', strTranslate(cx, cy))\n        .call(Color.fill, polarLayout.bgcolor);\n};\n\nproto.mockAxis = function(fullLayout, polarLayout, axLayout, opts) {\n    var ax = Lib.extendFlat({}, axLayout, opts);\n    setConvertPolar(ax, polarLayout, fullLayout);\n    return ax;\n};\n\nproto.mockCartesianAxis = function(fullLayout, polarLayout, opts) {\n    var _this = this;\n    var isSmith = _this.isSmith;\n    var axId = opts._id;\n\n    var ax = Lib.extendFlat({type: 'linear'}, opts);\n    setConvertCartesian(ax, fullLayout);\n\n    var bboxIndices = {\n        x: [0, 2],\n        y: [1, 3]\n    };\n\n    ax.setRange = function() {\n        var sectorBBox = _this.sectorBBox;\n        var ind = bboxIndices[axId];\n        var rl = _this.radialAxis._rl;\n        var drl = (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout));\n        ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n    };\n\n    ax.isPtWithinRange = axId === 'x' && !isSmith ?\n        function(d) { return _this.isPtInside(d); } :\n        function() { return true; };\n\n    ax.setRange();\n    ax.setScale();\n\n    return ax;\n};\n\nproto.doAutoRange = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var radialAxis = _this.radialAxis;\n    var radialLayout = _this.getRadial(polarLayout);\n\n    doAutoRange(gd, radialAxis);\n\n    var rng = radialAxis.range;\n    radialLayout.range = rng.slice();\n    radialLayout._input.range = rng.slice();\n\n    radialAxis._rl = [\n        radialAxis.r2l(rng[0], null, 'gregorian'),\n        radialAxis.r2l(rng[1], null, 'gregorian')\n    ];\n\n    if(radialAxis.minallowed !== undefined) {\n        var minallowed = radialAxis.r2l(radialAxis.minallowed);\n        if(radialAxis._rl[0] > radialAxis._rl[1]) {\n            radialAxis._rl[1] = Math.max(radialAxis._rl[1], minallowed);\n        } else {\n            radialAxis._rl[0] = Math.max(radialAxis._rl[0], minallowed);\n        }\n    }\n\n    if(radialAxis.maxallowed !== undefined) {\n        var maxallowed = radialAxis.r2l(radialAxis.maxallowed);\n        if(radialAxis._rl[0] < radialAxis._rl[1]) {\n            radialAxis._rl[1] = Math.min(radialAxis._rl[1], maxallowed);\n        } else {\n            radialAxis._rl[0] = Math.min(radialAxis._rl[0], maxallowed);\n        }\n    }\n};\n\nproto.updateRadialAxis = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialLayout = _this.getRadial(polarLayout);\n    var a0 = mod(_this.getSector(polarLayout)[0], 360);\n    var ax = _this.radialAxis;\n    var hasRoomForIt = innerRadius < radius;\n\n    var isSmith = _this.isSmith;\n    if(!isSmith) {\n        _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n        _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n\n        ax.setGeometry();\n    }\n\n    // rotate auto tick labels by 180 if in quadrant II and III to make them\n    // readable from left-to-right\n    //\n    // TODO try moving deeper in Axes.drawLabels for better results?\n    if(ax.tickangle === 'auto' && (a0 > 90 && a0 <= 270)) {\n        ax.tickangle = 180;\n    }\n\n    // easier to set rotate angle with custom translate function\n    var transFn = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([d.x, 0]));\n            return strTranslate(t[0] - cx, t[1] - cy);\n        } :\n        function(d) {\n            return strTranslate(ax.l2p(d.x) + innerRadius, 0);\n        };\n\n    // set special grid path function\n    var gridPathFn = isSmith ?\n        function(d) {\n            return resistanceArc(_this, d.x, -Infinity, Infinity);\n        } :\n        function(d) {\n            return _this.pathArc(ax.r2p(d.x) + innerRadius);\n        };\n\n    var newTickLayout = strTickLayout(radialLayout);\n    if(_this.radialTickLayout !== newTickLayout) {\n        layers['radial-axis'].selectAll('.xtick').remove();\n        _this.radialTickLayout = newTickLayout;\n    }\n\n    if(hasRoomForIt) {\n        ax.setScale();\n\n        var labelShift = 0;\n\n        var vals = isSmith ?\n            (ax.tickvals || []).filter(function(x) {\n                // filter negative\n                return x >= 0;\n            }).map(function(x) {\n                return Axes.tickText(ax, x, true, false);\n            }) : Axes.calcTicks(ax);\n\n        var valsClipped = isSmith ? vals : Axes.clipEnds(ax, vals);\n        var tickSign = Axes.getTickSigns(ax)[2];\n        if(isSmith) {\n            if(\n                (ax.ticks === 'top' && ax.side === 'bottom') ||\n                (ax.ticks === 'bottom' && ax.side === 'top')\n            ) {\n                // invert sign\n                tickSign = -tickSign;\n            }\n\n            if(ax.ticks === 'top' && ax.side === 'top') labelShift = -ax.ticklen;\n            if(ax.ticks === 'bottom' && ax.side === 'bottom') labelShift = ax.ticklen;\n        }\n\n        Axes.drawTicks(gd, ax, {\n            vals: vals,\n            layer: layers['radial-axis'],\n            path: Axes.makeTickPath(ax, 0, tickSign),\n            transFn: transFn,\n            crisp: false\n        });\n\n        Axes.drawGrid(gd, ax, {\n            vals: valsClipped,\n            layer: layers['radial-grid'],\n            path: gridPathFn,\n            transFn: Lib.noop,\n            crisp: false\n        });\n\n        Axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: layers['radial-axis'],\n            transFn: transFn,\n            labelFns: Axes.makeLabelFns(ax, labelShift)\n        });\n    }\n\n    // stash 'actual' radial axis angle for drag handlers (in degrees)\n    var angle = _this.radialAxisAngle = _this.vangles ?\n        rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) :\n        radialLayout.angle;\n\n    var tLayer = strTranslate(cx, cy);\n    var tLayer2 = tLayer + strRotate(-angle);\n\n    updateElement(\n        layers['radial-axis'],\n        hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks),\n        {transform: tLayer2}\n    );\n\n    updateElement(\n        layers['radial-grid'],\n        hasRoomForIt && radialLayout.showgrid,\n        {transform: isSmith ? '' : tLayer}\n    );\n\n    updateElement(\n        layers['radial-line'].select('line'),\n        hasRoomForIt && radialLayout.showline,\n        {\n            x1: isSmith ? -radius : innerRadius,\n            y1: 0,\n            x2: radius,\n            y2: 0,\n            transform: tLayer2\n        }\n    )\n    .attr('stroke-width', radialLayout.linewidth)\n    .call(Color.stroke, radialLayout.linecolor);\n};\n\nproto.updateRadialAxisTitle = function(fullLayout, polarLayout, _angle) {\n    if(this.isSmith) return;\n\n    var _this = this;\n    var gd = _this.gd;\n    var radius = _this.radius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialLayout = _this.getRadial(polarLayout);\n    var titleClass = _this.id + 'title';\n\n    var pad = 0;\n\n    // Hint: no need to check if there is in fact a title.text set\n    // because if plot is editable, pad needs to be calculated anyways\n    // to properly show placeholder text when title is empty.\n    if(radialLayout.title) {\n        var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n        var ts = radialLayout.title.font.size;\n        var side = radialLayout.side;\n        pad =\n            side === 'top' ? ts :\n            side === 'counterclockwise' ?\n                -(h + ts * 0.4) :\n                h + ts * 0.8;\n    }\n\n    var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n\n    var angleRad = deg2rad(angle);\n    var cosa = Math.cos(angleRad);\n    var sina = Math.sin(angleRad);\n\n    var x = cx + (radius / 2) * cosa + pad * sina;\n    var y = cy - (radius / 2) * sina + pad * cosa;\n\n    _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n        propContainer: radialLayout,\n        propName: _this.id + '.radialaxis.title',\n        placeholder: _(gd, 'Click to enter radial axis title'),\n        attributes: {\n            x: x,\n            y: y,\n            'text-anchor': 'middle'\n        },\n        transform: {rotate: -angle}\n    });\n};\n\nproto.updateAngularAxis = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var angularLayout = _this.getAngular(polarLayout);\n    var ax = _this.angularAxis;\n\n    var isSmith = _this.isSmith;\n    if(!isSmith) {\n        _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n\n        ax.setGeometry();\n        ax.setScale();\n    }\n\n    // 't'ick to 'g'eometric radians is used all over the place here\n    var t2g = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([0, d.x]));\n            return Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n        } :\n        function(d) { return ax.t2g(d.x); };\n\n    // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n    if(ax.type === 'linear' && ax.thetaunit === 'radians') {\n        ax.tick0 = rad2deg(ax.tick0);\n        ax.dtick = rad2deg(ax.dtick);\n    }\n\n    var _transFn = function(rad) {\n        return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n    };\n\n    var transFn = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([0, d.x]));\n            return strTranslate(t[0], t[1]);\n        } :\n        function(d) {\n            return _transFn(t2g(d));\n        };\n\n    var transFn2 = isSmith ?\n        function(d) {\n            var t = smithTransform(_this, smith([0, d.x]));\n            var rad = Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n            return strTranslate(t[0], t[1]) + strRotate(-rad2deg(rad));\n        } :\n        function(d) {\n            var rad = t2g(d);\n            return _transFn(rad) + strRotate(-rad2deg(rad));\n        };\n\n    var gridPathFn = isSmith ?\n        function(d) {\n            return reactanceArc(_this, d.x, 0, Infinity);\n        } :\n        function(d) {\n            var rad = t2g(d);\n            var cosRad = Math.cos(rad);\n            var sinRad = Math.sin(rad);\n            return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] +\n                'L' + [cx + radius * cosRad, cy - radius * sinRad];\n        };\n\n    var out = Axes.makeLabelFns(ax, 0);\n    var labelStandoff = out.labelStandoff;\n    var labelFns = {};\n\n    labelFns.xFn = function(d) {\n        var rad = t2g(d);\n        return Math.cos(rad) * labelStandoff;\n    };\n\n    labelFns.yFn = function(d) {\n        var rad = t2g(d);\n        var ff = Math.sin(rad) > 0 ? 0.2 : 1;\n        return -Math.sin(rad) * (labelStandoff + d.fontSize * ff) +\n            Math.abs(Math.cos(rad)) * (d.fontSize * MID_SHIFT);\n    };\n\n    labelFns.anchorFn = function(d) {\n        var rad = t2g(d);\n        var cos = Math.cos(rad);\n        return Math.abs(cos) < 0.1 ?\n            'middle' :\n            (cos > 0 ? 'start' : 'end');\n    };\n\n    labelFns.heightFn = function(d, a, h) {\n        var rad = t2g(d);\n        return -0.5 * (1 + Math.sin(rad)) * h;\n    };\n\n    var newTickLayout = strTickLayout(angularLayout);\n    if(_this.angularTickLayout !== newTickLayout) {\n        layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n        _this.angularTickLayout = newTickLayout;\n    }\n\n    var vals = isSmith ?\n        [Infinity].concat(ax.tickvals || []).map(function(x) {\n            return Axes.tickText(ax, x, true, false);\n        }) : Axes.calcTicks(ax);\n\n    if(isSmith) {\n        vals[0].text = '∞';\n        vals[0].fontSize *= 1.75;\n    }\n\n    // angle of polygon vertices in geometric radians (null means circles)\n    // TODO what to do when ax.period > ax._categories ??\n    var vangles;\n    if(polarLayout.gridshape === 'linear') {\n        vangles = vals.map(t2g);\n\n        // ax._vals should be always ordered, make them\n        // always turn counterclockwise for convenience here\n        if(Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n            vangles = vangles.slice().reverse();\n        }\n    } else {\n        vangles = null;\n    }\n    _this.vangles = vangles;\n\n    // Use tickval filter for category axes instead of tweaking\n    // the range w.r.t sector, so that sectors that cross 360 can\n    // show all their ticks.\n    if(ax.type === 'category') {\n        vals = vals.filter(function(d) {\n            return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n        });\n    }\n\n    if(ax.visible) {\n        var tickSign = ax.ticks === 'inside' ? -1 : 1;\n\n        var pad = (ax.linewidth || 1) / 2;\n\n        Axes.drawTicks(gd, ax, {\n            vals: vals,\n            layer: layers['angular-axis'],\n            path: 'M' + (tickSign * pad) + ',0h' + (tickSign * ax.ticklen),\n            transFn: transFn2,\n            crisp: false\n        });\n\n        Axes.drawGrid(gd, ax, {\n            vals: vals,\n            layer: layers['angular-grid'],\n            path: gridPathFn,\n            transFn: Lib.noop,\n            crisp: false\n        });\n\n        Axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: layers['angular-axis'],\n            repositionOnUpdate: true,\n            transFn: transFn,\n            labelFns: labelFns\n        });\n    }\n\n    // TODO maybe two arcs is better here?\n    // maybe split style attributes between inner and outer angular axes?\n\n    updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n        d: _this.pathSubplot(),\n        transform: strTranslate(cx, cy)\n    })\n    .attr('stroke-width', angularLayout.linewidth)\n    .call(Color.stroke, angularLayout.linecolor);\n};\n\nproto.updateFx = function(fullLayout, polarLayout) {\n    if(!this.gd._context.staticPlot) {\n        var hasDrag = !this.isSmith;\n        if(hasDrag) {\n            this.updateAngularDrag(fullLayout);\n            this.updateRadialDrag(fullLayout, polarLayout, 0);\n            this.updateRadialDrag(fullLayout, polarLayout, 1);\n        }\n        this.updateHoverAndMainDrag(fullLayout);\n    }\n};\n\nproto.updateHoverAndMainDrag = function(fullLayout) {\n    var _this = this;\n    var isSmith = _this.isSmith;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var zoomlayer = fullLayout._zoomlayer;\n    var MINZOOM = constants.MINZOOM;\n    var OFFEDGE = constants.OFFEDGE;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var cxx = _this.cxx;\n    var cyy = _this.cyy;\n    var sectorInRad = _this.sectorInRad;\n    var vangles = _this.vangles;\n    var radialAxis = _this.radialAxis;\n    var clampTiny = helpers.clampTiny;\n    var findXYatLength = helpers.findXYatLength;\n    var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n    var chw = constants.cornerHalfWidth;\n    var chl = constants.cornerLen / 2;\n\n    var scaleX;\n    var scaleY;\n\n    var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', fullLayout.dragmode === false ? 'none' : 'crosshair');\n\n    d3.select(mainDrag)\n        .attr('d', _this.pathSubplot())\n        .attr('transform', strTranslate(cx, cy));\n\n    mainDrag.onmousemove = function(evt) {\n        Fx.hover(gd, evt, _this.id);\n        gd._fullLayout._lasthover = mainDrag;\n        gd._fullLayout._hoversubplot = _this.id;\n    };\n\n    mainDrag.onmouseout = function(evt) {\n        if(gd._dragging) return;\n        dragElement.unhover(gd, evt);\n    };\n\n    var dragOpts = {\n        element: mainDrag,\n        gd: gd,\n        subplot: _this.id,\n        plotinfo: {\n            id: _this.id,\n            xaxis: _this.xaxis,\n            yaxis: _this.yaxis\n        },\n        xaxes: [_this.xaxis],\n        yaxes: [_this.yaxis]\n    };\n\n    // mouse px position at drag start (0), move (1)\n    var x0, y0;\n    // radial distance from circle center at drag start (0), move (1)\n    var r0, r1;\n    // zoombox persistent quantities\n    var path0, dimmed, lum;\n    // zoombox, corners elements\n    var zb, corners;\n\n    function norm(x, y) {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    function xy2r(x, y) {\n        return norm(x - cxx, y - cyy);\n    }\n\n    function xy2a(x, y) {\n        return Math.atan2(cyy - y, x - cxx);\n    }\n\n    function ra2xy(r, a) {\n        return [r * Math.cos(a), r * Math.sin(-a)];\n    }\n\n    function pathCorner(r, a) {\n        if(r === 0) return _this.pathSector(2 * chw);\n\n        var da = chl / r;\n        var am = a - da;\n        var ap = a + da;\n        var rb = Math.max(0, Math.min(r, radius));\n        var rm = rb - chw;\n        var rp = rb + chw;\n\n        return 'M' + ra2xy(rm, am) +\n            'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) +\n            'L' + ra2xy(rp, ap) +\n            'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) +\n            'Z';\n    }\n\n    // (x,y) is the pt at middle of the va0 <-> va1 edge\n    //\n    // ... we could eventually add another mode for cursor\n    // angles 'close to' enough to a particular vertex.\n    function pathCornerForPolygons(r, va0, va1) {\n        if(r === 0) return _this.pathSector(2 * chw);\n\n        var xy0 = ra2xy(r, va0);\n        var xy1 = ra2xy(r, va1);\n        var x = clampTiny((xy0[0] + xy1[0]) / 2);\n        var y = clampTiny((xy0[1] + xy1[1]) / 2);\n        var innerPts, outerPts;\n\n        if(x && y) {\n            var m = y / x;\n            var mperp = -1 / m;\n            var midPts = findXYatLength(chw, m, x, y);\n            innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n            outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n        } else {\n            var dx, dy;\n            if(y) {\n                // horizontal handles\n                dx = chl;\n                dy = chw;\n            } else {\n                // vertical handles\n                dx = chw;\n                dy = chl;\n            }\n            innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n            outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n        }\n\n        return 'M' + innerPts.join('L') +\n            'L' + outerPts.reverse().join('L') + 'Z';\n    }\n\n    function zoomPrep() {\n        r0 = null;\n        r1 = null;\n        path0 = _this.pathSubplot();\n        dimmed = false;\n\n        var polarLayoutNow = gd._fullLayout[_this.id];\n        lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n\n        zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n        zb.attr('fill-rule', 'evenodd');\n        corners = dragBox.makeCorners(zoomlayer, cx, cy);\n        clearOutline(gd);\n    }\n\n    // N.B. this sets scoped 'r0' and 'r1'\n    // return true if 'valid' zoom distance, false otherwise\n    function clampAndSetR0R1(rr0, rr1) {\n        rr1 = Math.max(Math.min(rr1, radius), innerRadius);\n\n        // starting or ending drag near center (outer edge),\n        // clamps radial distance at origin (at r=radius)\n        if(rr0 < OFFEDGE) rr0 = 0;\n        else if((radius - rr0) < OFFEDGE) rr0 = radius;\n        else if(rr1 < OFFEDGE) rr1 = 0;\n        else if((radius - rr1) < OFFEDGE) rr1 = radius;\n\n        // make sure r0 < r1,\n        // to get correct fill pattern in path1 below\n        if(Math.abs(rr1 - rr0) > MINZOOM) {\n            if(rr0 < rr1) {\n                r0 = rr0;\n                r1 = rr1;\n            } else {\n                r0 = rr1;\n                r1 = rr0;\n            }\n            return true;\n        } else {\n            r0 = null;\n            r1 = null;\n            return false;\n        }\n    }\n\n    function applyZoomMove(path1, cpath) {\n        path1 = path1 || path0;\n        cpath = cpath || 'M0,0Z';\n\n        zb.attr('d', path1);\n        corners.attr('d', cpath);\n        dragBox.transitionZoombox(zb, corners, dimmed, lum);\n        dimmed = true;\n\n        var updateObj = {};\n        computeZoomUpdates(updateObj);\n        gd.emit('plotly_relayouting', updateObj);\n    }\n\n    function zoomMove(dx, dy) {\n        dx = dx * scaleX;\n        dy = dy * scaleY;\n\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n\n        var rr0 = xy2r(x0, y0);\n        var rr1 = Math.min(xy2r(x1, y1), radius);\n        var a0 = xy2a(x0, y0);\n        var path1;\n        var cpath;\n\n        if(clampAndSetR0R1(rr0, rr1)) {\n            path1 = path0 + _this.pathSector(r1);\n            if(r0) path1 += _this.pathSector(r0);\n            // keep 'starting' angle\n            cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n        }\n        applyZoomMove(path1, cpath);\n    }\n\n    function findPolygonRadius(x, y, va0, va1) {\n        var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n        return norm(xy[0], xy[1]);\n    }\n\n    function zoomMoveForPolygons(dx, dy) {\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n        var a0 = xy2a(x0, y0);\n        var a1 = xy2a(x1, y1);\n        var vangles0 = findEnclosingVertexAngles(a0, vangles);\n        var vangles1 = findEnclosingVertexAngles(a1, vangles);\n        var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n        var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n        var path1;\n        var cpath;\n\n        if(clampAndSetR0R1(rr0, rr1)) {\n            path1 = path0 + _this.pathSector(r1);\n            if(r0) path1 += _this.pathSector(r0);\n            // keep 'starting' angle here too\n            cpath = [\n                pathCornerForPolygons(r0, vangles0[0], vangles0[1]),\n                pathCornerForPolygons(r1, vangles0[0], vangles0[1])\n            ].join(' ');\n        }\n        applyZoomMove(path1, cpath);\n    }\n\n    function zoomDone() {\n        dragBox.removeZoombox(gd);\n\n        if(r0 === null || r1 === null) return;\n        var updateObj = {};\n        computeZoomUpdates(updateObj);\n\n        dragBox.showDoubleClickNotifier(gd);\n\n        Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    function computeZoomUpdates(update) {\n        var rl = radialAxis._rl;\n        var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n        var newRng = [\n            rl[0] + (r0 - innerRadius) * m,\n            rl[0] + (r1 - innerRadius) * m\n        ];\n        update[_this.id + '.radialaxis.range'] = newRng;\n    }\n\n    function zoomClick(numClicks, evt) {\n        var clickMode = gd._fullLayout.clickmode;\n\n        dragBox.removeZoombox(gd);\n\n        // TODO double once vs twice logic (autorange vs fixed range)\n        if(numClicks === 2) {\n            var updateObj = {};\n            for(var k in _this.viewInitial) {\n                updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n            }\n\n            gd.emit('plotly_doubleclick', null);\n            Registry.call('_guiRelayout', gd, updateObj);\n        }\n\n        if(clickMode.indexOf('select') > -1 && numClicks === 1) {\n            selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n        }\n\n        if(clickMode.indexOf('event') > -1) {\n            Fx.click(gd, evt, _this.id);\n        }\n    }\n\n    dragOpts.prepFn = function(evt, startX, startY) {\n        var dragModeNow = gd._fullLayout.dragmode;\n\n        var bbox = mainDrag.getBoundingClientRect();\n        gd._fullLayout._calcInverseTransform(gd);\n        var inverse = gd._fullLayout._invTransform;\n        scaleX = gd._fullLayout._invScaleX;\n        scaleY = gd._fullLayout._invScaleY;\n        var transformedCoords = Lib.apply3DTransform(inverse)(startX - bbox.left, startY - bbox.top);\n        x0 = transformedCoords[0];\n        y0 = transformedCoords[1];\n\n        // need to offset x/y as bbox center does not\n        // match origin for asymmetric polygons\n        if(vangles) {\n            var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n            x0 += cxx + offset[0];\n            y0 += cyy + offset[1];\n        }\n\n        switch(dragModeNow) {\n            case 'zoom':\n                dragOpts.clickFn = zoomClick;\n\n                if(!isSmith) {\n                    if(vangles) {\n                        dragOpts.moveFn = zoomMoveForPolygons;\n                    } else {\n                        dragOpts.moveFn = zoomMove;\n                    }\n\n                    dragOpts.doneFn = zoomDone;\n                    zoomPrep(evt, startX, startY);\n                }\n                break;\n            case 'select':\n            case 'lasso':\n                prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n                break;\n        }\n    };\n\n    dragElement.init(dragOpts);\n};\n\nproto.updateRadialDrag = function(fullLayout, polarLayout, rngIndex) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialAxis = _this.radialAxis;\n    var bl = constants.radialDragBoxSize;\n    var bl2 = bl / 2;\n\n    if(!radialAxis.visible) return;\n\n    var angle0 = deg2rad(_this.radialAxisAngle);\n    var rl = radialAxis._rl;\n    var rl0 = rl[0];\n    var rl1 = rl[1];\n    var rbase = rl[rngIndex];\n    var m = 0.75 * (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout)) / radius;\n\n    var tx, ty, className;\n    if(rngIndex) {\n        tx = cx + (radius + bl2) * Math.cos(angle0);\n        ty = cy - (radius + bl2) * Math.sin(angle0);\n        className = 'radialdrag';\n    } else {\n        // the 'inner' box can get called:\n        // - when polar.hole>0\n        // - when polar.sector isn't a full circle\n        // otherwise it is hidden behind the main drag.\n        tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n        ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n        className = 'radialdrag-inner';\n    }\n\n    var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n    var dragOpts = {element: radialDrag, gd: gd};\n    if(fullLayout.dragmode === false) {\n        dragOpts.dragmode = false;\n    }\n\n    updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n        transform: strTranslate(tx, ty)\n    });\n\n    // move function (either rotate or re-range flavor)\n    var moveFn2;\n    // rotate angle on done\n    var angle1;\n    // re-range range[1] (or range[0]) on done\n    var rprime;\n\n    function moveFn(dx, dy) {\n        if(moveFn2) {\n            moveFn2(dx, dy);\n        } else {\n            var dvec = [dx, -dy];\n            var rvec = [Math.cos(angle0), Math.sin(angle0)];\n            var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec)));\n\n            // mostly perpendicular motions rotate,\n            // mostly parallel motions re-range\n            if(!isNaN(comp)) {\n                moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n            }\n        }\n\n        var update = {};\n        computeRadialAxisUpdates(update);\n        gd.emit('plotly_relayouting', update);\n    }\n\n    function computeRadialAxisUpdates(update) {\n        if(angle1 !== null) {\n            update[_this.id + '.radialaxis.angle'] = angle1;\n        } else if(rprime !== null) {\n            update[_this.id + '.radialaxis.range[' + rngIndex + ']'] = rprime;\n        }\n    }\n\n    function doneFn() {\n        if(angle1 !== null) {\n            Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n        } else if(rprime !== null) {\n            Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n        }\n    }\n\n    function rotateMove(dx, dy) {\n        // disable for inner drag boxes\n        if(rngIndex === 0) return;\n\n        var x1 = tx + dx;\n        var y1 = ty + dy;\n\n        angle1 = Math.atan2(cy - y1, x1 - cx);\n        if(_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n        angle1 = rad2deg(angle1);\n\n        var transform = strTranslate(cx, cy) + strRotate(-angle1);\n        layers['radial-axis'].attr('transform', transform);\n        layers['radial-line'].select('line').attr('transform', transform);\n\n        var fullLayoutNow = _this.gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n        _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n    }\n\n    function rerangeMove(dx, dy) {\n        // project (dx, dy) unto unit radial axis vector\n        var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n        rprime = rbase - m * dr;\n\n        // make sure rprime does not change the range[0] -> range[1] sign\n        if((m > 0) !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n            rprime = null;\n            return;\n        }\n\n        var fullLayoutNow = gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n\n        // update radial range -> update c2g -> update _m,_b\n        radialAxis.range[rngIndex] = rprime;\n        radialAxis._rl[rngIndex] = rprime;\n        _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n\n        _this.xaxis.setRange();\n        _this.xaxis.setScale();\n        _this.yaxis.setRange();\n        _this.yaxis.setScale();\n\n        var hasRegl = false;\n\n        for(var traceType in _this.traceHash) {\n            var moduleCalcData = _this.traceHash[traceType];\n            var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n            var _module = moduleCalcData[0][0].trace._module;\n            _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n            if(Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n        }\n\n        if(hasRegl) {\n            clearGlCanvases(gd);\n            redrawReglTraces(gd);\n        }\n    }\n\n    dragOpts.prepFn = function() {\n        moveFn2 = null;\n        angle1 = null;\n        rprime = null;\n\n        dragOpts.moveFn = moveFn;\n        dragOpts.doneFn = doneFn;\n\n        clearOutline(gd);\n    };\n\n    dragOpts.clampFn = function(dx, dy) {\n        if(Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n            dx = 0;\n            dy = 0;\n        }\n        return [dx, dy];\n    };\n\n    dragElement.init(dragOpts);\n};\n\nproto.updateAngularDrag = function(fullLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var angularAxis = _this.angularAxis;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var cxx = _this.cxx;\n    var cyy = _this.cyy;\n    var dbs = constants.angularDragBoxSize;\n\n    var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', fullLayout.dragmode === false ? 'none' : 'move');\n    var dragOpts = {element: angularDrag, gd: gd};\n\n    if(fullLayout.dragmode === false) {\n        dragOpts.dragmode = false;\n    } else {\n        d3.select(angularDrag)\n            .attr('d', _this.pathAnnulus(radius, radius + dbs))\n            .attr('transform', strTranslate(cx, cy))\n            .call(setCursor, 'move');\n    }\n\n    function xy2a(x, y) {\n        return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n    }\n\n    // scatter trace, points and textpoints selections\n    var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n    var scatterPoints = scatterTraces.selectAll('.point');\n    var scatterTextPoints = scatterTraces.selectAll('.textpoint');\n\n    // mouse px position at drag start (0), move (1)\n    var x0, y0;\n    // angular axis angle rotation at drag start (0), move (1)\n    var rot0, rot1;\n    // induced radial axis rotation (only used on polygon grids)\n    var rrot1;\n    // angle about circle center at drag start\n    var a0;\n\n    function moveFn(dx, dy) {\n        var fullLayoutNow = _this.gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n\n        var x1 = x0 + dx * fullLayout._invScaleX;\n        var y1 = y0 + dy * fullLayout._invScaleY;\n        var a1 = xy2a(x1, y1);\n        var da = rad2deg(a1 - a0);\n        rot1 = rot0 + da;\n\n        layers.frontplot.attr('transform',\n            strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy])\n        );\n\n        if(_this.vangles) {\n            rrot1 = _this.radialAxisAngle + da;\n\n            var trans = strTranslate(cx, cy) + strRotate(-da);\n            var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n\n            layers.bg.attr('transform', trans);\n            layers['radial-grid'].attr('transform', trans);\n            layers['radial-axis'].attr('transform', trans2);\n            layers['radial-line'].select('line').attr('transform', trans2);\n            _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n        } else {\n            _this.clipPaths.forTraces.select('path').attr('transform',\n                strTranslate(cxx, cyy) + strRotate(da)\n            );\n        }\n\n        // 'un-rotate' marker and text points\n        scatterPoints.each(function() {\n            var sel = d3.select(this);\n            var xy = Drawing.getTranslate(sel);\n            sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n        });\n        scatterTextPoints.each(function() {\n            var sel = d3.select(this);\n            var tx = sel.select('text');\n            var xy = Drawing.getTranslate(sel);\n            // N.B rotate -> translate ordering matters\n            sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n        });\n\n        // update rotation -> range -> _m,_b\n        angularAxis.rotation = Lib.modHalf(rot1, 360);\n        _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n\n        if(_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n            scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n        }\n\n        var hasRegl = false;\n\n        for(var traceType in _this.traceHash) {\n            if(Registry.traceIs(traceType, 'gl')) {\n                var moduleCalcData = _this.traceHash[traceType];\n                var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n                var _module = moduleCalcData[0][0].trace._module;\n                _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n                if(moduleCalcDataVisible.length) hasRegl = true;\n            }\n        }\n\n        if(hasRegl) {\n            clearGlCanvases(gd);\n            redrawReglTraces(gd);\n        }\n\n        var update = {};\n        computeRotationUpdates(update);\n        gd.emit('plotly_relayouting', update);\n    }\n\n    function computeRotationUpdates(updateObj) {\n        updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n\n        if(_this.vangles) {\n            updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n        }\n    }\n\n    function doneFn() {\n        scatterTextPoints.select('text').attr('transform', null);\n\n        var updateObj = {};\n        computeRotationUpdates(updateObj);\n        Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    dragOpts.prepFn = function(evt, startX, startY) {\n        var polarLayoutNow = fullLayout[_this.id];\n        rot0 = polarLayoutNow.angularaxis.rotation;\n\n        var bbox = angularDrag.getBoundingClientRect();\n        x0 = startX - bbox.left;\n        y0 = startY - bbox.top;\n\n        gd._fullLayout._calcInverseTransform(gd);\n        var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n        x0 = transformedCoords[0];\n        y0 = transformedCoords[1];\n\n        a0 = xy2a(x0, y0);\n\n        dragOpts.moveFn = moveFn;\n        dragOpts.doneFn = doneFn;\n\n        clearOutline(gd);\n    };\n\n    // I don't what we should do in this case, skip we now\n    if(_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n        dragOpts.prepFn = Lib.noop;\n        setCursor(d3.select(angularDrag), null);\n    }\n\n    dragElement.init(dragOpts);\n};\n\nproto.isPtInside = function(d) {\n    if(this.isSmith) return true;\n\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var thetag = this.angularAxis.c2g(d.theta);\n    var radialAxis = this.radialAxis;\n    var r = radialAxis.c2l(d.r);\n    var rl = radialAxis._rl;\n\n    var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n    return fn(r, thetag, rl, sectorInRad, vangles);\n};\n\nproto.pathArc = function(r) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n    return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSector = function(r) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n    return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathAnnulus = function(r0, r1) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n    return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSubplot = function() {\n    var r0 = this.innerRadius;\n    var r1 = this.radius;\n    return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\n\nproto.fillViewInitialKey = function(key, val) {\n    if(!(key in this.viewInitial)) {\n        this.viewInitial[key] = val;\n    }\n};\n\nfunction strTickLayout(axLayout) {\n    var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n    if('side' in axLayout) out += axLayout.side;\n    return out;\n}\n\n// Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\nfunction computeSectorBBox(sector) {\n    var s0 = sector[0];\n    var s1 = sector[1];\n    var arc = s1 - s0;\n    var a0 = mod(s0, 360);\n    var a1 = a0 + arc;\n\n    var ax0 = Math.cos(deg2rad(a0));\n    var ay0 = Math.sin(deg2rad(a0));\n    var ax1 = Math.cos(deg2rad(a1));\n    var ay1 = Math.sin(deg2rad(a1));\n\n    var x0, y0, x1, y1;\n\n    if((a0 <= 90 && a1 >= 90) || (a0 > 90 && a1 >= 450)) {\n        y1 = 1;\n    } else if(ay0 <= 0 && ay1 <= 0) {\n        y1 = 0;\n    } else {\n        y1 = Math.max(ay0, ay1);\n    }\n\n    if((a0 <= 180 && a1 >= 180) || (a0 > 180 && a1 >= 540)) {\n        x0 = -1;\n    } else if(ax0 >= 0 && ax1 >= 0) {\n        x0 = 0;\n    } else {\n        x0 = Math.min(ax0, ax1);\n    }\n\n    if((a0 <= 270 && a1 >= 270) || (a0 > 270 && a1 >= 630)) {\n        y0 = -1;\n    } else if(ay0 >= 0 && ay1 >= 0) {\n        y0 = 0;\n    } else {\n        y0 = Math.min(ay0, ay1);\n    }\n\n    if(a1 >= 360) {\n        x1 = 1;\n    } else if(ax0 <= 0 && ax1 <= 0) {\n        x1 = 0;\n    } else {\n        x1 = Math.max(ax0, ax1);\n    }\n\n    return [x0, y0, x1, y1];\n}\n\nfunction snapToVertexAngle(a, vangles) {\n    var fn = function(v) { return Lib.angleDist(a, v); };\n    var ind = Lib.findIndexOfMin(vangles, fn);\n    return vangles[ind];\n}\n\nfunction updateElement(sel, showAttr, attrs) {\n    if(showAttr) {\n        sel.attr('display', null);\n        sel.attr(attrs);\n    } else if(sel) {\n        sel.attr('display', 'none');\n    }\n    return sel;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}