{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Axes = require('../../plots/cartesian/axes');\nvar alignPeriod = require('../../plots/cartesian/align_period');\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar _ = Lib._;\nmodule.exports = function calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n  var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n  var cd = [];\n\n  // N.B. violin reuses same Box.calc\n  var numKey = trace.type === 'violin' ? '_numViolins' : '_numBoxes';\n  var i, j;\n  var valAxis, valLetter;\n  var posAxis, posLetter;\n  var hasPeriod;\n  if (trace.orientation === 'h') {\n    valAxis = xa;\n    valLetter = 'x';\n    posAxis = ya;\n    posLetter = 'y';\n    hasPeriod = !!trace.yperiodalignment;\n  } else {\n    valAxis = ya;\n    valLetter = 'y';\n    posAxis = xa;\n    posLetter = 'x';\n    hasPeriod = !!trace.xperiodalignment;\n  }\n  var allPosArrays = getPosArrays(trace, posLetter, posAxis, fullLayout[numKey]);\n  var posArray = allPosArrays[0];\n  var origPos = allPosArrays[1];\n  var dv = Lib.distinctVals(posArray, posAxis);\n  var posDistinct = dv.vals;\n  var dPos = dv.minDiff / 2;\n\n  // item in trace calcdata\n  var cdi;\n  // array of {v: v, i, i} sample pts\n  var pts;\n  // values of the `pts` array of objects\n  var boxVals;\n  // length of sample\n  var N;\n  // single sample point\n  var pt;\n  // single sample value\n  var v;\n\n  // filter function for outlier pts\n  // outlier definition based on http://www.physics.csbsju.edu/stats/box2.html\n  var ptFilterFn = (trace.boxpoints || trace.points) === 'all' ? Lib.identity : function (pt) {\n    return pt.v < cdi.lf || pt.v > cdi.uf;\n  };\n  if (trace._hasPreCompStats) {\n    var valArrayRaw = trace[valLetter];\n    var d2c = function (k) {\n      return valAxis.d2c((trace[k] || [])[i]);\n    };\n    var minVal = Infinity;\n    var maxVal = -Infinity;\n    for (i = 0; i < trace._length; i++) {\n      var posi = posArray[i];\n      if (!isNumeric(posi)) continue;\n      cdi = {};\n      cdi.pos = cdi[posLetter] = posi;\n      if (hasPeriod && origPos) {\n        cdi.orig_p = origPos[i]; // used by hover\n      }\n      cdi.q1 = d2c('q1');\n      cdi.med = d2c('median');\n      cdi.q3 = d2c('q3');\n      pts = [];\n      if (valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {\n        for (j = 0; j < valArrayRaw[i].length; j++) {\n          v = valAxis.d2c(valArrayRaw[i][j]);\n          if (v !== BADNUM) {\n            pt = {\n              v: v,\n              i: [i, j]\n            };\n            arraysToCalcdata(pt, trace, [i, j]);\n            pts.push(pt);\n          }\n        }\n      }\n      cdi.pts = pts.sort(sortByVal);\n      boxVals = cdi[valLetter] = pts.map(extractVal);\n      N = boxVals.length;\n      if (cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM && cdi.med >= cdi.q1 && cdi.q3 >= cdi.med) {\n        var lf = d2c('lowerfence');\n        cdi.lf = lf !== BADNUM && lf <= cdi.q1 ? lf : computeLowerFence(cdi, boxVals, N);\n        var uf = d2c('upperfence');\n        cdi.uf = uf !== BADNUM && uf >= cdi.q3 ? uf : computeUpperFence(cdi, boxVals, N);\n        var mean = d2c('mean');\n        cdi.mean = mean !== BADNUM ? mean : N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2;\n        var sd = d2c('sd');\n        cdi.sd = mean !== BADNUM && sd >= 0 ? sd : N ? Lib.stdev(boxVals, N, cdi.mean) : cdi.q3 - cdi.q1;\n        cdi.lo = computeLowerOutlierBound(cdi);\n        cdi.uo = computeUpperOutlierBound(cdi);\n        var ns = d2c('notchspan');\n        ns = ns !== BADNUM && ns > 0 ? ns : computeNotchSpan(cdi, N);\n        cdi.ln = cdi.med - ns;\n        cdi.un = cdi.med + ns;\n        var imin = cdi.lf;\n        var imax = cdi.uf;\n        if (trace.boxpoints && boxVals.length) {\n          imin = Math.min(imin, boxVals[0]);\n          imax = Math.max(imax, boxVals[N - 1]);\n        }\n        if (trace.notched) {\n          imin = Math.min(imin, cdi.ln);\n          imax = Math.max(imax, cdi.un);\n        }\n        cdi.min = imin;\n        cdi.max = imax;\n      } else {\n        Lib.warn(['Invalid input - make sure that q1 <= median <= q3', 'q1 = ' + cdi.q1, 'median = ' + cdi.med, 'q3 = ' + cdi.q3].join('\\n'));\n        var v0;\n        if (cdi.med !== BADNUM) {\n          v0 = cdi.med;\n        } else if (cdi.q1 !== BADNUM) {\n          if (cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;else v0 = cdi.q1;\n        } else if (cdi.q3 !== BADNUM) {\n          v0 = cdi.q3;\n        } else {\n          v0 = 0;\n        }\n\n        // draw box as line segment\n        cdi.med = v0;\n        cdi.q1 = cdi.q3 = v0;\n        cdi.lf = cdi.uf = v0;\n        cdi.mean = cdi.sd = v0;\n        cdi.ln = cdi.un = v0;\n        cdi.min = cdi.max = v0;\n      }\n      minVal = Math.min(minVal, cdi.min);\n      maxVal = Math.max(maxVal, cdi.max);\n      cdi.pts2 = pts.filter(ptFilterFn);\n      cd.push(cdi);\n    }\n    trace._extremes[valAxis._id] = Axes.findExtremes(valAxis, [minVal, maxVal], {\n      padded: true\n    });\n  } else {\n    var valArray = valAxis.makeCalcdata(trace, valLetter);\n    var posBins = makeBins(posDistinct, dPos);\n    var pLen = posDistinct.length;\n    var ptsPerBin = initNestedArray(pLen);\n\n    // bin pts info per position bins\n    for (i = 0; i < trace._length; i++) {\n      v = valArray[i];\n      if (!isNumeric(v)) continue;\n      var n = Lib.findBin(posArray[i], posBins);\n      if (n >= 0 && n < pLen) {\n        pt = {\n          v: v,\n          i: i\n        };\n        arraysToCalcdata(pt, trace, i);\n        ptsPerBin[n].push(pt);\n      }\n    }\n    var minLowerNotch = Infinity;\n    var maxUpperNotch = -Infinity;\n    var quartilemethod = trace.quartilemethod;\n    var usesExclusive = quartilemethod === 'exclusive';\n    var usesInclusive = quartilemethod === 'inclusive';\n\n    // build calcdata trace items, one item per distinct position\n    for (i = 0; i < pLen; i++) {\n      if (ptsPerBin[i].length > 0) {\n        cdi = {};\n        cdi.pos = cdi[posLetter] = posDistinct[i];\n        pts = cdi.pts = ptsPerBin[i].sort(sortByVal);\n        boxVals = cdi[valLetter] = pts.map(extractVal);\n        N = boxVals.length;\n        cdi.min = boxVals[0];\n        cdi.max = boxVals[N - 1];\n        cdi.mean = Lib.mean(boxVals, N);\n        cdi.sd = Lib.stdev(boxVals, N, cdi.mean) * trace.sdmultiple;\n        cdi.med = Lib.interp(boxVals, 0.5);\n        if (N % 2 && (usesExclusive || usesInclusive)) {\n          var lower;\n          var upper;\n          if (usesExclusive) {\n            // do NOT include the median in either half\n            lower = boxVals.slice(0, N / 2);\n            upper = boxVals.slice(N / 2 + 1);\n          } else if (usesInclusive) {\n            // include the median in either half\n            lower = boxVals.slice(0, N / 2 + 1);\n            upper = boxVals.slice(N / 2);\n          }\n          cdi.q1 = Lib.interp(lower, 0.5);\n          cdi.q3 = Lib.interp(upper, 0.5);\n        } else {\n          cdi.q1 = Lib.interp(boxVals, 0.25);\n          cdi.q3 = Lib.interp(boxVals, 0.75);\n        }\n\n        // lower and upper fences\n        cdi.lf = computeLowerFence(cdi, boxVals, N);\n        cdi.uf = computeUpperFence(cdi, boxVals, N);\n\n        // lower and upper outliers bounds\n        cdi.lo = computeLowerOutlierBound(cdi);\n        cdi.uo = computeUpperOutlierBound(cdi);\n\n        // lower and upper notches\n        var mci = computeNotchSpan(cdi, N);\n        cdi.ln = cdi.med - mci;\n        cdi.un = cdi.med + mci;\n        minLowerNotch = Math.min(minLowerNotch, cdi.ln);\n        maxUpperNotch = Math.max(maxUpperNotch, cdi.un);\n        cdi.pts2 = pts.filter(ptFilterFn);\n        cd.push(cdi);\n      }\n    }\n    if (trace.notched && Lib.isTypedArray(valArray)) valArray = Array.from(valArray);\n    trace._extremes[valAxis._id] = Axes.findExtremes(valAxis, trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray, {\n      padded: true\n    });\n  }\n  calcSelection(cd, trace);\n  if (cd.length > 0) {\n    cd[0].t = {\n      num: fullLayout[numKey],\n      dPos: dPos,\n      posLetter: posLetter,\n      valLetter: valLetter,\n      labels: {\n        med: _(gd, 'median:'),\n        min: _(gd, 'min:'),\n        q1: _(gd, 'q1:'),\n        q3: _(gd, 'q3:'),\n        max: _(gd, 'max:'),\n        mean: trace.boxmean === 'sd' || trace.sizemode === 'sd' ? _(gd, 'mean ± σ:').replace('σ', trace.sdmultiple === 1 ? 'σ' : trace.sdmultiple + 'σ') :\n        // displaying mean +- Nσ whilst supporting translations\n        _(gd, 'mean:'),\n        lf: _(gd, 'lower fence:'),\n        uf: _(gd, 'upper fence:')\n      }\n    };\n    fullLayout[numKey]++;\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n};\n\n// In vertical (horizontal) box plots:\n// if no x (y) data, use x0 (y0), or name\n// so if you want one box\n// per trace, set x0 (y0) to the x (y) value or category for this trace\n// (or set x (y) to a constant array matching y (x))\nfunction getPosArrays(trace, posLetter, posAxis, num) {\n  var hasPosArray = posLetter in trace;\n  var hasPos0 = posLetter + '0' in trace;\n  var hasPosStep = 'd' + posLetter in trace;\n  if (hasPosArray || hasPos0 && hasPosStep) {\n    var origPos = posAxis.makeCalcdata(trace, posLetter);\n    var pos = alignPeriod(trace, posAxis, posLetter, origPos).vals;\n    return [pos, origPos];\n  }\n  var pos0;\n  if (hasPos0) {\n    pos0 = trace[posLetter + '0'];\n  } else if ('name' in trace && (posAxis.type === 'category' || isNumeric(trace.name) && ['linear', 'log'].indexOf(posAxis.type) !== -1 || Lib.isDateTime(trace.name) && posAxis.type === 'date')) {\n    pos0 = trace.name;\n  } else {\n    pos0 = num;\n  }\n  var pos0c = posAxis.type === 'multicategory' ? posAxis.r2c_just_indices(pos0) : posAxis.d2c(pos0, 0, trace[posLetter + 'calendar']);\n  var len = trace._length;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) out[i] = pos0c;\n  return [out];\n}\nfunction makeBins(x, dx) {\n  var len = x.length;\n  var bins = new Array(len + 1);\n  for (var i = 0; i < len; i++) {\n    bins[i] = x[i] - dx;\n  }\n  bins[len] = x[len - 1] + dx;\n  return bins;\n}\nfunction initNestedArray(len) {\n  var arr = new Array(len);\n  for (var i = 0; i < len; i++) {\n    arr[i] = [];\n  }\n  return arr;\n}\nvar TRACE_TO_CALC = {\n  text: 'tx',\n  hovertext: 'htx'\n};\nfunction arraysToCalcdata(pt, trace, ptNumber) {\n  for (var k in TRACE_TO_CALC) {\n    if (Lib.isArrayOrTypedArray(trace[k])) {\n      if (Array.isArray(ptNumber)) {\n        if (Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {\n          pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];\n        }\n      } else {\n        pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];\n      }\n    }\n  }\n}\nfunction calcSelection(cd, trace) {\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    for (var i = 0; i < cd.length; i++) {\n      var pts = cd[i].pts || [];\n      var ptNumber2cdIndex = {};\n      for (var j = 0; j < pts.length; j++) {\n        ptNumber2cdIndex[pts[j].i] = j;\n      }\n      Lib.tagSelected(pts, trace, ptNumber2cdIndex);\n    }\n  }\n}\nfunction sortByVal(a, b) {\n  return a.v - b.v;\n}\nfunction extractVal(o) {\n  return o.v;\n}\n\n// last point below 1.5 * IQR\nfunction computeLowerFence(cdi, boxVals, N) {\n  if (N === 0) return cdi.q1;\n  return Math.min(cdi.q1, boxVals[Math.min(Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1, N - 1)]);\n}\n\n// last point above 1.5 * IQR\nfunction computeUpperFence(cdi, boxVals, N) {\n  if (N === 0) return cdi.q3;\n  return Math.max(cdi.q3, boxVals[Math.max(Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals), 0)]);\n}\n\n// 3 IQR below (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeLowerOutlierBound(cdi) {\n  return 4 * cdi.q1 - 3 * cdi.q3;\n}\n\n// 3 IQR above (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeUpperOutlierBound(cdi) {\n  return 4 * cdi.q3 - 3 * cdi.q1;\n}\n\n// 95% confidence intervals for median\nfunction computeNotchSpan(cdi, N) {\n  if (N === 0) return 0;\n  return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);\n}","map":{"version":3,"names":["isNumeric","require","Axes","alignPeriod","Lib","BADNUM","_","module","exports","calc","gd","trace","fullLayout","_fullLayout","xa","getFromId","xaxis","ya","yaxis","cd","numKey","type","i","j","valAxis","valLetter","posAxis","posLetter","hasPeriod","orientation","yperiodalignment","xperiodalignment","allPosArrays","getPosArrays","posArray","origPos","dv","distinctVals","posDistinct","vals","dPos","minDiff","cdi","pts","boxVals","N","pt","v","ptFilterFn","boxpoints","points","identity","lf","uf","_hasPreCompStats","valArrayRaw","d2c","k","minVal","Infinity","maxVal","_length","posi","pos","orig_p","q1","med","q3","isArrayOrTypedArray","length","arraysToCalcdata","push","sort","sortByVal","map","extractVal","computeLowerFence","computeUpperFence","mean","sd","stdev","lo","computeLowerOutlierBound","uo","computeUpperOutlierBound","ns","computeNotchSpan","ln","un","imin","imax","Math","min","max","notched","warn","join","v0","pts2","filter","_extremes","_id","findExtremes","padded","valArray","makeCalcdata","posBins","makeBins","pLen","ptsPerBin","initNestedArray","n","findBin","minLowerNotch","maxUpperNotch","quartilemethod","usesExclusive","usesInclusive","sdmultiple","interp","lower","upper","slice","mci","isTypedArray","Array","from","concat","calcSelection","t","num","labels","boxmean","sizemode","replace","empty","hasPosArray","hasPos0","hasPosStep","pos0","name","indexOf","isDateTime","pos0c","r2c_just_indices","len","out","x","dx","bins","arr","TRACE_TO_CALC","text","hovertext","ptNumber","isArray","selectedpoints","ptNumber2cdIndex","tagSelected","a","b","o","sqrt"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/box/calc.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Axes = require('../../plots/cartesian/axes');\nvar alignPeriod = require('../../plots/cartesian/align_period');\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar _ = Lib._;\n\nmodule.exports = function calc(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n    var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n    var cd = [];\n\n    // N.B. violin reuses same Box.calc\n    var numKey = trace.type === 'violin' ? '_numViolins' : '_numBoxes';\n\n    var i, j;\n    var valAxis, valLetter;\n    var posAxis, posLetter;\n\n    var hasPeriod;\n    if(trace.orientation === 'h') {\n        valAxis = xa;\n        valLetter = 'x';\n        posAxis = ya;\n        posLetter = 'y';\n        hasPeriod = !!trace.yperiodalignment;\n    } else {\n        valAxis = ya;\n        valLetter = 'y';\n        posAxis = xa;\n        posLetter = 'x';\n        hasPeriod = !!trace.xperiodalignment;\n    }\n\n    var allPosArrays = getPosArrays(trace, posLetter, posAxis, fullLayout[numKey]);\n    var posArray = allPosArrays[0];\n    var origPos = allPosArrays[1];\n    var dv = Lib.distinctVals(posArray, posAxis);\n    var posDistinct = dv.vals;\n    var dPos = dv.minDiff / 2;\n\n    // item in trace calcdata\n    var cdi;\n    // array of {v: v, i, i} sample pts\n    var pts;\n    // values of the `pts` array of objects\n    var boxVals;\n    // length of sample\n    var N;\n    // single sample point\n    var pt;\n    // single sample value\n    var v;\n\n    // filter function for outlier pts\n    // outlier definition based on http://www.physics.csbsju.edu/stats/box2.html\n    var ptFilterFn = (trace.boxpoints || trace.points) === 'all' ?\n        Lib.identity :\n        function(pt) { return (pt.v < cdi.lf || pt.v > cdi.uf); };\n\n    if(trace._hasPreCompStats) {\n        var valArrayRaw = trace[valLetter];\n        var d2c = function(k) { return valAxis.d2c((trace[k] || [])[i]); };\n        var minVal = Infinity;\n        var maxVal = -Infinity;\n\n        for(i = 0; i < trace._length; i++) {\n            var posi = posArray[i];\n            if(!isNumeric(posi)) continue;\n\n            cdi = {};\n            cdi.pos = cdi[posLetter] = posi;\n            if(hasPeriod && origPos) {\n                cdi.orig_p = origPos[i]; // used by hover\n            }\n\n            cdi.q1 = d2c('q1');\n            cdi.med = d2c('median');\n            cdi.q3 = d2c('q3');\n\n            pts = [];\n            if(valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {\n                for(j = 0; j < valArrayRaw[i].length; j++) {\n                    v = valAxis.d2c(valArrayRaw[i][j]);\n                    if(v !== BADNUM) {\n                        pt = {v: v, i: [i, j]};\n                        arraysToCalcdata(pt, trace, [i, j]);\n                        pts.push(pt);\n                    }\n                }\n            }\n            cdi.pts = pts.sort(sortByVal);\n            boxVals = cdi[valLetter] = pts.map(extractVal);\n            N = boxVals.length;\n\n            if(cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM &&\n                cdi.med >= cdi.q1 && cdi.q3 >= cdi.med\n            ) {\n                var lf = d2c('lowerfence');\n                cdi.lf = (lf !== BADNUM && lf <= cdi.q1) ?\n                    lf :\n                    computeLowerFence(cdi, boxVals, N);\n\n                var uf = d2c('upperfence');\n                cdi.uf = (uf !== BADNUM && uf >= cdi.q3) ?\n                    uf :\n                    computeUpperFence(cdi, boxVals, N);\n\n                var mean = d2c('mean');\n                cdi.mean = (mean !== BADNUM) ?\n                    mean :\n                    (N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2);\n\n                var sd = d2c('sd');\n                cdi.sd = (mean !== BADNUM && sd >= 0) ?\n                    sd :\n                    (N ? Lib.stdev(boxVals, N, cdi.mean) : (cdi.q3 - cdi.q1));\n\n                cdi.lo = computeLowerOutlierBound(cdi);\n                cdi.uo = computeUpperOutlierBound(cdi);\n\n                var ns = d2c('notchspan');\n                ns = (ns !== BADNUM && ns > 0) ? ns : computeNotchSpan(cdi, N);\n                cdi.ln = cdi.med - ns;\n                cdi.un = cdi.med + ns;\n\n                var imin = cdi.lf;\n                var imax = cdi.uf;\n                if(trace.boxpoints && boxVals.length) {\n                    imin = Math.min(imin, boxVals[0]);\n                    imax = Math.max(imax, boxVals[N - 1]);\n                }\n                if(trace.notched) {\n                    imin = Math.min(imin, cdi.ln);\n                    imax = Math.max(imax, cdi.un);\n                }\n                cdi.min = imin;\n                cdi.max = imax;\n            } else {\n                Lib.warn([\n                    'Invalid input - make sure that q1 <= median <= q3',\n                    'q1 = ' + cdi.q1,\n                    'median = ' + cdi.med,\n                    'q3 = ' + cdi.q3\n                ].join('\\n'));\n\n                var v0;\n                if(cdi.med !== BADNUM) {\n                    v0 = cdi.med;\n                } else if(cdi.q1 !== BADNUM) {\n                    if(cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;\n                    else v0 = cdi.q1;\n                } else if(cdi.q3 !== BADNUM) {\n                    v0 = cdi.q3;\n                } else {\n                    v0 = 0;\n                }\n\n                // draw box as line segment\n                cdi.med = v0;\n                cdi.q1 = cdi.q3 = v0;\n                cdi.lf = cdi.uf = v0;\n                cdi.mean = cdi.sd = v0;\n                cdi.ln = cdi.un = v0;\n                cdi.min = cdi.max = v0;\n            }\n\n            minVal = Math.min(minVal, cdi.min);\n            maxVal = Math.max(maxVal, cdi.max);\n\n            cdi.pts2 = pts.filter(ptFilterFn);\n\n            cd.push(cdi);\n        }\n\n        trace._extremes[valAxis._id] = Axes.findExtremes(valAxis,\n            [minVal, maxVal],\n            {padded: true}\n        );\n    } else {\n        var valArray = valAxis.makeCalcdata(trace, valLetter);\n        var posBins = makeBins(posDistinct, dPos);\n        var pLen = posDistinct.length;\n        var ptsPerBin = initNestedArray(pLen);\n\n        // bin pts info per position bins\n        for(i = 0; i < trace._length; i++) {\n            v = valArray[i];\n            if(!isNumeric(v)) continue;\n\n            var n = Lib.findBin(posArray[i], posBins);\n            if(n >= 0 && n < pLen) {\n                pt = {v: v, i: i};\n                arraysToCalcdata(pt, trace, i);\n                ptsPerBin[n].push(pt);\n            }\n        }\n\n        var minLowerNotch = Infinity;\n        var maxUpperNotch = -Infinity;\n\n        var quartilemethod = trace.quartilemethod;\n        var usesExclusive = quartilemethod === 'exclusive';\n        var usesInclusive = quartilemethod === 'inclusive';\n\n        // build calcdata trace items, one item per distinct position\n        for(i = 0; i < pLen; i++) {\n            if(ptsPerBin[i].length > 0) {\n                cdi = {};\n                cdi.pos = cdi[posLetter] = posDistinct[i];\n\n                pts = cdi.pts = ptsPerBin[i].sort(sortByVal);\n                boxVals = cdi[valLetter] = pts.map(extractVal);\n                N = boxVals.length;\n\n                cdi.min = boxVals[0];\n                cdi.max = boxVals[N - 1];\n                cdi.mean = Lib.mean(boxVals, N);\n                cdi.sd = Lib.stdev(boxVals, N, cdi.mean) * trace.sdmultiple;\n                cdi.med = Lib.interp(boxVals, 0.5);\n\n                if((N % 2) && (usesExclusive || usesInclusive)) {\n                    var lower;\n                    var upper;\n\n                    if(usesExclusive) {\n                        // do NOT include the median in either half\n                        lower = boxVals.slice(0, N / 2);\n                        upper = boxVals.slice(N / 2 + 1);\n                    } else if(usesInclusive) {\n                        // include the median in either half\n                        lower = boxVals.slice(0, N / 2 + 1);\n                        upper = boxVals.slice(N / 2);\n                    }\n\n                    cdi.q1 = Lib.interp(lower, 0.5);\n                    cdi.q3 = Lib.interp(upper, 0.5);\n                } else {\n                    cdi.q1 = Lib.interp(boxVals, 0.25);\n                    cdi.q3 = Lib.interp(boxVals, 0.75);\n                }\n\n                // lower and upper fences\n                cdi.lf = computeLowerFence(cdi, boxVals, N);\n                cdi.uf = computeUpperFence(cdi, boxVals, N);\n\n                // lower and upper outliers bounds\n                cdi.lo = computeLowerOutlierBound(cdi);\n                cdi.uo = computeUpperOutlierBound(cdi);\n\n                // lower and upper notches\n                var mci = computeNotchSpan(cdi, N);\n                cdi.ln = cdi.med - mci;\n                cdi.un = cdi.med + mci;\n                minLowerNotch = Math.min(minLowerNotch, cdi.ln);\n                maxUpperNotch = Math.max(maxUpperNotch, cdi.un);\n\n                cdi.pts2 = pts.filter(ptFilterFn);\n\n                cd.push(cdi);\n            }\n        }\n\n        if(trace.notched && Lib.isTypedArray(valArray)) valArray = Array.from(valArray);\n        trace._extremes[valAxis._id] = Axes.findExtremes(valAxis,\n            trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray,\n            {padded: true}\n        );\n    }\n\n    calcSelection(cd, trace);\n\n    if(cd.length > 0) {\n        cd[0].t = {\n            num: fullLayout[numKey],\n            dPos: dPos,\n            posLetter: posLetter,\n            valLetter: valLetter,\n            labels: {\n                med: _(gd, 'median:'),\n                min: _(gd, 'min:'),\n                q1: _(gd, 'q1:'),\n                q3: _(gd, 'q3:'),\n                max: _(gd, 'max:'),\n                mean: (trace.boxmean === 'sd') || (trace.sizemode === 'sd') ?\n                    _(gd, 'mean ± σ:').replace('σ', trace.sdmultiple === 1 ? 'σ' : (trace.sdmultiple + 'σ')) : // displaying mean +- Nσ whilst supporting translations\n                    _(gd, 'mean:'),\n                lf: _(gd, 'lower fence:'),\n                uf: _(gd, 'upper fence:')\n            }\n        };\n\n        fullLayout[numKey]++;\n        return cd;\n    } else {\n        return [{t: {empty: true}}];\n    }\n};\n\n// In vertical (horizontal) box plots:\n// if no x (y) data, use x0 (y0), or name\n// so if you want one box\n// per trace, set x0 (y0) to the x (y) value or category for this trace\n// (or set x (y) to a constant array matching y (x))\nfunction getPosArrays(trace, posLetter, posAxis, num) {\n    var hasPosArray = posLetter in trace;\n    var hasPos0 = posLetter + '0' in trace;\n    var hasPosStep = 'd' + posLetter in trace;\n\n    if(hasPosArray || (hasPos0 && hasPosStep)) {\n        var origPos = posAxis.makeCalcdata(trace, posLetter);\n        var pos = alignPeriod(trace, posAxis, posLetter, origPos).vals;\n        return [pos, origPos];\n    }\n\n    var pos0;\n    if(hasPos0) {\n        pos0 = trace[posLetter + '0'];\n    } else if('name' in trace && (\n        posAxis.type === 'category' || (\n            isNumeric(trace.name) &&\n            ['linear', 'log'].indexOf(posAxis.type) !== -1\n        ) || (\n            Lib.isDateTime(trace.name) &&\n            posAxis.type === 'date'\n        )\n    )) {\n        pos0 = trace.name;\n    } else {\n        pos0 = num;\n    }\n\n    var pos0c = posAxis.type === 'multicategory' ?\n        posAxis.r2c_just_indices(pos0) :\n        posAxis.d2c(pos0, 0, trace[posLetter + 'calendar']);\n\n    var len = trace._length;\n    var out = new Array(len);\n    for(var i = 0; i < len; i++) out[i] = pos0c;\n\n    return [out];\n}\n\nfunction makeBins(x, dx) {\n    var len = x.length;\n    var bins = new Array(len + 1);\n\n    for(var i = 0; i < len; i++) {\n        bins[i] = x[i] - dx;\n    }\n    bins[len] = x[len - 1] + dx;\n\n    return bins;\n}\n\nfunction initNestedArray(len) {\n    var arr = new Array(len);\n    for(var i = 0; i < len; i++) {\n        arr[i] = [];\n    }\n    return arr;\n}\n\nvar TRACE_TO_CALC = {\n    text: 'tx',\n    hovertext: 'htx'\n};\n\nfunction arraysToCalcdata(pt, trace, ptNumber) {\n    for(var k in TRACE_TO_CALC) {\n        if(Lib.isArrayOrTypedArray(trace[k])) {\n            if(Array.isArray(ptNumber)) {\n                if(Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {\n                    pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];\n                }\n            } else {\n                pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];\n            }\n        }\n    }\n}\n\nfunction calcSelection(cd, trace) {\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        for(var i = 0; i < cd.length; i++) {\n            var pts = cd[i].pts || [];\n            var ptNumber2cdIndex = {};\n\n            for(var j = 0; j < pts.length; j++) {\n                ptNumber2cdIndex[pts[j].i] = j;\n            }\n\n            Lib.tagSelected(pts, trace, ptNumber2cdIndex);\n        }\n    }\n}\n\nfunction sortByVal(a, b) { return a.v - b.v; }\n\nfunction extractVal(o) { return o.v; }\n\n// last point below 1.5 * IQR\nfunction computeLowerFence(cdi, boxVals, N) {\n    if(N === 0) return cdi.q1;\n    return Math.min(\n        cdi.q1,\n        boxVals[Math.min(\n            Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1,\n            N - 1\n        )]\n    );\n}\n\n// last point above 1.5 * IQR\nfunction computeUpperFence(cdi, boxVals, N) {\n    if(N === 0) return cdi.q3;\n    return Math.max(\n        cdi.q3,\n        boxVals[Math.max(\n            Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals),\n            0\n        )]\n    );\n}\n\n// 3 IQR below (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeLowerOutlierBound(cdi) {\n    return 4 * cdi.q1 - 3 * cdi.q3;\n}\n\n// 3 IQR above (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeUpperOutlierBound(cdi) {\n    return 4 * cdi.q3 - 3 * cdi.q1;\n}\n\n// 95% confidence intervals for median\nfunction computeNotchSpan(cdi, N) {\n    if(N === 0) return 0;\n    return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}