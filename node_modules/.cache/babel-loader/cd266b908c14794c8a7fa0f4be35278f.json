{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar hasHover = require('has-hover');\nvar Lib = require('../lib');\nvar nestedProperty = Lib.nestedProperty;\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\nvar Registry = require('../registry');\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar Axes = require('../plots/cartesian/axes');\nvar handleRangeDefaults = require('../plots/cartesian/range_defaults');\nvar cartesianLayoutAttributes = require('../plots/cartesian/layout_attributes');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar clearOutline = require('../components/selections').clearOutline;\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar editTypes = require('./edit_types');\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n\n/**\n * Internal plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction _doPlot(gd, data, layout, config) {\n  var frames;\n  gd = Lib.getGraphDiv(gd);\n\n  // Events.init is idempotent and bails early if gd has already been init'd\n  Events.init(gd);\n  if (Lib.isPlainObject(data)) {\n    var obj = data;\n    data = obj.data;\n    layout = obj.layout;\n    config = obj.config;\n    frames = obj.frames;\n  }\n  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n  if (okToPlot === false) return Promise.reject();\n\n  // if there's no data or layout, and this isn't yet a plotly plot\n  // container, log a warning to help plotly.js users debug\n  if (!data && !layout && !Lib.isPlotDiv(gd)) {\n    Lib.warn('Calling _doPlot as if redrawing ' + 'but this container doesn\\'t yet have a plot.', gd);\n  }\n  function addFrames() {\n    if (frames) {\n      return exports.addFrames(gd, frames);\n    }\n  }\n\n  // transfer configuration options to gd until we move over to\n  // a more OO like model\n  setPlotContext(gd, config);\n  if (!layout) layout = {};\n\n  // hook class for plots main container (in case of plotly.js\n  // this won't be #embedded-graph or .js-tab-contents)\n  d3.select(gd).classed('js-plotly-plot', true);\n\n  // off-screen getBoundingClientRect testing space,\n  // in #js-plotly-tester (and stored as Drawing.tester)\n  // so we can share cached text across tabs\n  Drawing.makeTester();\n\n  // collect promises for any async actions during plotting\n  // any part of the plotting code can push to gd._promises, then\n  // before we move to the next step, we check that they're all\n  // complete, and empty out the promise list again.\n  if (!Array.isArray(gd._promises)) gd._promises = [];\n  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data);\n\n  // if there is already data on the graph, append the new data\n  // if you only want to redraw, pass a non-array for data\n  if (Array.isArray(data)) {\n    helpers.cleanData(data);\n    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data);\n\n    // for routines outside graph_obj that want a clean tab\n    // (rather than appending to an existing one) gd.empty\n    // is used to determine whether to make a new tab\n    gd.empty = false;\n  }\n  if (!gd.layout || graphWasEmpty) {\n    gd.layout = helpers.cleanLayout(layout);\n  }\n  Plots.supplyDefaults(gd);\n  var fullLayout = gd._fullLayout;\n  var hasCartesian = fullLayout._has('cartesian');\n\n  // so we don't try to re-call _doPlot from inside\n  // legend and colorbar, if margins changed\n  fullLayout._replotting = true;\n\n  // make or remake the framework if we need to\n  if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {\n    makePlotFramework(gd);\n    if (fullLayout._shouldCreateBgLayer) {\n      delete fullLayout._shouldCreateBgLayer;\n    }\n  }\n\n  // clear gradient and pattern defs on each .plot call, because we know we'll loop through all traces\n  Drawing.initGradients(gd);\n  Drawing.initPatterns(gd);\n\n  // save initial show spikes once per graph\n  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd);\n\n  // prepare the data and find the autorange\n\n  // generate calcdata, if we need to\n  // to force redoing calcdata, just delete it before calling _doPlot\n  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n  if (recalc) Plots.doCalcdata(gd);\n\n  // in case it has changed, attach fullData traces to calcdata\n  for (var i = 0; i < gd.calcdata.length; i++) {\n    gd.calcdata[i][0].trace = gd._fullData[i];\n  }\n\n  // make the figure responsive\n  if (gd._context.responsive) {\n    if (!gd._responsiveChartHandler) {\n      // Keep a reference to the resize handler to purge it down the road\n      gd._responsiveChartHandler = function () {\n        if (!Lib.isHidden(gd)) Plots.resize(gd);\n      };\n\n      // Listen to window resize\n      window.addEventListener('resize', gd._responsiveChartHandler);\n    }\n  } else {\n    Lib.clearResponsive(gd);\n  }\n\n  /*\n   * start async-friendly code - now we're actually drawing things\n   */\n\n  var oldMargins = Lib.extendFlat({}, fullLayout._size);\n\n  // draw framework first so that margin-pushing\n  // components can position themselves correctly\n  var drawFrameworkCalls = 0;\n  function drawFramework() {\n    var basePlotModules = fullLayout._basePlotModules;\n    for (var i = 0; i < basePlotModules.length; i++) {\n      if (basePlotModules[i].drawFramework) {\n        basePlotModules[i].drawFramework(gd);\n      }\n    }\n    if (!fullLayout._glcanvas && fullLayout._has('gl')) {\n      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n        key: 'contextLayer',\n        context: true,\n        pick: false\n      }, {\n        key: 'focusLayer',\n        context: false,\n        pick: false\n      }, {\n        key: 'pickLayer',\n        context: false,\n        pick: true\n      }], function (d) {\n        return d.key;\n      });\n      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {\n        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n      }).style({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'visible',\n        'pointer-events': 'none'\n      });\n    }\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n    if (fullLayout._glcanvas) {\n      fullLayout._glcanvas.attr('width', fullLayout.width * plotGlPixelRatio).attr('height', fullLayout.height * plotGlPixelRatio).style('width', fullLayout.width + 'px').style('height', fullLayout.height + 'px');\n      var regl = fullLayout._glcanvas.data()[0].regl;\n      if (regl) {\n        // Unfortunately, this can happen when relayouting to large\n        // width/height on some browsers.\n        if (Math.floor(fullLayout.width * plotGlPixelRatio) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height * plotGlPixelRatio) !== regl._gl.drawingBufferHeight) {\n          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n          if (drawFrameworkCalls) {\n            Lib.error(msg);\n          } else {\n            Lib.log(msg + ' Clearing graph and plotting again.');\n            Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n            Plots.supplyDefaults(gd);\n            fullLayout = gd._fullLayout;\n            Plots.doCalcdata(gd);\n            drawFrameworkCalls++;\n            return drawFramework();\n          }\n        }\n      }\n    }\n    if (fullLayout.modebar.orientation === 'h') {\n      fullLayout._modebardiv.style('height', null).style('width', '100%');\n    } else {\n      fullLayout._modebardiv.style('width', null).style('height', fullLayout.height + 'px');\n    }\n    return Plots.previousPromises(gd);\n  }\n\n  // draw anything that can affect margins.\n  function marginPushers() {\n    // First reset the list of things that are allowed to change the margins\n    // So any deleted traces or components will be wiped out of the\n    // automargin calculation.\n    // This means *every* margin pusher must be listed here, even if it\n    // doesn't actually try to push the margins until later.\n    Plots.clearAutoMarginIds(gd);\n    subroutines.drawMarginPushers(gd);\n    Axes.allowAutoMargin(gd);\n    if (gd._fullLayout.title.text && gd._fullLayout.title.automargin) Plots.allowAutoMargin(gd, 'title.automargin');\n\n    // TODO can this be moved elsewhere?\n    if (fullLayout._has('pie')) {\n      var fullData = gd._fullData;\n      for (var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n        if (trace.type === 'pie' && trace.automargin) {\n          Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n        }\n      }\n    }\n    Plots.doAutoMargin(gd);\n    return Plots.previousPromises(gd);\n  }\n\n  // in case the margins changed, draw margin pushers again\n  function marginPushersAgain() {\n    if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);\n  }\n  function positionAndAutorange() {\n    if (!recalc) {\n      doAutoRangeAndConstraints();\n      return;\n    }\n\n    // TODO: autosize extra for text markers and images\n    // see https://github.com/plotly/plotly.js/issues/1111\n    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);\n  }\n  function doAutoRangeAndConstraints() {\n    if (gd._transitioning) return;\n    subroutines.doAutoRangeAndConstraints(gd);\n\n    // store initial ranges *after* enforcing constraints, otherwise\n    // we will never look like we're at the initial ranges\n    if (graphWasEmpty) Axes.saveRangeInitial(gd);\n\n    // this one is different from shapes/annotations calcAutorange\n    // the others incorporate those components into ax._extremes,\n    // this one actually sets the ranges in rangesliders.\n    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n  }\n\n  // draw ticks, titles, and calculate axis scaling (._b, ._m)\n  function drawAxes() {\n    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n  }\n  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];\n  if (hasCartesian) seq.push(positionAndAutorange);\n  seq.push(subroutines.layoutStyles);\n  if (hasCartesian) {\n    seq.push(drawAxes, function insideTickLabelsAutorange(gd) {\n      var insideTickLabelsUpdaterange = gd._fullLayout._insideTickLabelsUpdaterange;\n      if (insideTickLabelsUpdaterange) {\n        gd._fullLayout._insideTickLabelsUpdaterange = undefined;\n        return relayout(gd, insideTickLabelsUpdaterange).then(function () {\n          Axes.saveRangeInitial(gd, true);\n        });\n      }\n    });\n  }\n  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover, Plots.redrag, Plots.reselect,\n  // TODO: doAutoMargin is only needed here for axis automargin, which\n  // happens outside of marginPushers where all the other automargins are\n  // calculated. Would be much better to separate margin calculations from\n  // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n  Plots.doAutoMargin, Plots.previousPromises);\n\n  // even if everything we did was synchronous, return a promise\n  // so that the caller doesn't care which route we took\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    emitAfterPlot(gd);\n    return gd;\n  });\n}\nfunction emitAfterPlot(gd) {\n  var fullLayout = gd._fullLayout;\n  if (fullLayout._redrawFromAutoMarginCount) {\n    fullLayout._redrawFromAutoMarginCount--;\n  } else {\n    gd.emit('plotly_afterplot');\n  }\n}\nfunction setPlotConfig(obj) {\n  return Lib.extendFlat(dfltConfig, obj);\n}\nfunction setBackground(gd, bgColor) {\n  try {\n    gd._fullLayout._paper.style('background', bgColor);\n  } catch (e) {\n    Lib.error(e);\n  }\n}\nfunction opaqueSetBackground(gd, bgColor) {\n  var blend = Color.combine(bgColor, 'white');\n  setBackground(gd, blend);\n}\nfunction setPlotContext(gd, config) {\n  if (!gd._context) {\n    gd._context = Lib.extendDeep({}, dfltConfig);\n\n    // stash <base> href, used to make robust clipPath URLs\n    var base = d3.select('base');\n    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';\n  }\n  var context = gd._context;\n  var i, keys, key;\n  if (config) {\n    keys = Object.keys(config);\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      if (key === 'editable' || key === 'edits') continue;\n      if (key in context) {\n        if (key === 'setBackground' && config[key] === 'opaque') {\n          context[key] = opaqueSetBackground;\n        } else {\n          context[key] = config[key];\n        }\n      }\n    }\n\n    // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n      context.plotGlPixelRatio = context.plot3dPixelRatio;\n    }\n\n    // now deal with editable and edits - first editable overrides\n    // everything, then edits refines\n    var editable = config.editable;\n    if (editable !== undefined) {\n      // we're not going to *use* context.editable, we're only going to\n      // use context.edits... but keep it for the record\n      context.editable = editable;\n      keys = Object.keys(context.edits);\n      for (i = 0; i < keys.length; i++) {\n        context.edits[keys[i]] = editable;\n      }\n    }\n    if (config.edits) {\n      keys = Object.keys(config.edits);\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        if (key in context.edits) {\n          context.edits[key] = config.edits[key];\n        }\n      }\n    }\n\n    // not part of the user-facing config options\n    context._exportedPlot = config._exportedPlot;\n  }\n\n  // staticPlot forces a bunch of others:\n  if (context.staticPlot) {\n    context.editable = false;\n    context.edits = {};\n    context.autosizable = false;\n    context.scrollZoom = false;\n    context.doubleClick = false;\n    context.showTips = false;\n    context.showLink = false;\n    context.displayModeBar = false;\n  }\n\n  // make sure hover-only devices have mode bar visible\n  if (context.displayModeBar === 'hover' && !hasHover) {\n    context.displayModeBar = true;\n  }\n\n  // default and fallback for setBackground\n  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n    context.setBackground = setBackground;\n  }\n\n  // Check if gd has a specified widht/height to begin with\n  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\n\n  // fill context._scrollZoom helper to help manage scrollZoom flaglist\n  var szIn = context.scrollZoom;\n  var szOut = context._scrollZoom = {};\n  if (szIn === true) {\n    szOut.cartesian = 1;\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n    szOut.map = 1;\n  } else if (typeof szIn === 'string') {\n    var parts = szIn.split('+');\n    for (i = 0; i < parts.length; i++) {\n      szOut[parts[i]] = 1;\n    }\n  } else if (szIn !== false) {\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n    szOut.map = 1;\n  }\n}\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nfunction redraw(gd) {\n  gd = Lib.getGraphDiv(gd);\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n  helpers.cleanData(gd.data);\n  helpers.cleanLayout(gd.layout);\n  gd.calcdata = undefined;\n  return exports._doPlot(gd).then(function () {\n    gd.emit('plotly_redraw');\n    return gd;\n  });\n}\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nfunction newPlot(gd, data, layout, config) {\n  gd = Lib.getGraphDiv(gd);\n\n  // remove gl contexts\n  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n  Plots.purge(gd);\n  return exports._doPlot(gd, data, layout, config);\n}\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n  var parentLength = maxIndex + 1;\n  var positiveIndices = [];\n  var i;\n  var index;\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n    if (index < 0) {\n      positiveIndices.push(parentLength + index);\n    } else {\n      positiveIndices.push(index);\n    }\n  }\n  return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n  var i, index;\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n\n    // validate that indices are indeed integers\n    if (index !== parseInt(index, 10)) {\n      throw new Error('all values in ' + arrayName + ' must be integers');\n    }\n\n    // check that all indices are in bounds for given gd.data array length\n    if (index >= gd.data.length || index < -gd.data.length) {\n      throw new Error(arrayName + ' must be valid indices for gd.data.');\n    }\n\n    // check that indices aren't repeated\n    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n      throw new Error('each index in ' + arrayName + ' must be unique.');\n    }\n  }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  }\n\n  // validate currentIndices array\n  if (typeof currentIndices === 'undefined') {\n    throw new Error('currentIndices is a required argument.');\n  } else if (!Array.isArray(currentIndices)) {\n    currentIndices = [currentIndices];\n  }\n  assertIndexArray(gd, currentIndices, 'currentIndices');\n\n  // validate newIndices array if it exists\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n  if (typeof newIndices !== 'undefined') {\n    assertIndexArray(gd, newIndices, 'newIndices');\n  }\n\n  // check currentIndices and newIndices are the same length if newIdices exists\n  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n    throw new Error('current and new indices must be of equal length.');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n  var i, value;\n\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  }\n\n  // make sure traces exists\n  if (typeof traces === 'undefined') {\n    throw new Error('traces must be defined.');\n  }\n\n  // make sure traces is an array\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  }\n\n  // make sure each value in traces is an object\n  for (i = 0; i < traces.length; i++) {\n    value = traces[i];\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n      throw new Error('all values in traces array must be non-array objects');\n    }\n  }\n\n  // make sure we have an index for each trace\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n    throw new Error('if indices is specified, traces.length must equal indices.length');\n  }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array');\n  }\n  if (!Lib.isPlainObject(update)) {\n    throw new Error('update must be a key:value object');\n  }\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers');\n  }\n  assertIndexArray(gd, indices, 'indices');\n  for (var key in update) {\n    /*\n     * Verify that the attribute to be updated contains as many trace updates\n     * as indices. Failure must result in throw and no-op\n     */\n    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {\n      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n    }\n\n    /*\n     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n     */\n    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {\n      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');\n    }\n  }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  var updateProps = [];\n  var trace, target, prop, insert, maxp;\n\n  // allow scalar index to represent a single trace position\n  if (!Array.isArray(indices)) indices = [indices];\n\n  // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n  indices = positivifyIndices(indices, gd.data.length - 1);\n\n  // loop through all update keys and traces and harvest validated data.\n  for (var key in update) {\n    for (var j = 0; j < indices.length; j++) {\n      /*\n       * Choose the trace indexed by the indices map argument and get the prop setter-getter\n       * instance that references the key and value for this particular trace.\n       */\n      trace = gd.data[indices[j]];\n      prop = nestedProperty(trace, key);\n\n      /*\n       * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n       * Target must exist as an Array to allow the extend operation to be performed.\n       */\n      target = prop.get();\n      insert = update[key][j];\n      if (!Lib.isArrayOrTypedArray(insert)) {\n        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n      }\n      if (!Lib.isArrayOrTypedArray(target)) {\n        throw new Error('cannot extend missing or non-array attribute: ' + key);\n      }\n      if (target.constructor !== insert.constructor) {\n        throw new Error('cannot extend array with an array of a different type: ' + key);\n      }\n\n      /*\n       * maxPoints may be an object map or a scalar. If object select the key:value, else\n       * Use the scalar maxPoints for all key and trace combinations.\n       */\n      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n      // could have chosen null here, -1 just tells us to not take a window\n      if (!isNumeric(maxp)) maxp = -1;\n\n      /*\n       * Wrap the nestedProperty in an object containing required data\n       * for lengthening and windowing this particular trace - key combination.\n       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n       */\n      updateProps.push({\n        prop: prop,\n        target: target,\n        insert: insert,\n        maxp: Math.floor(maxp)\n      });\n    }\n  }\n\n  // all target and insertion data now validated\n  return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n  assertExtendTracesArgs(gd, update, indices, maxPoints);\n  var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n  var undoUpdate = {};\n  var undoPoints = {};\n  for (var i = 0; i < updateProps.length; i++) {\n    var prop = updateProps[i].prop;\n    var maxp = updateProps[i].maxp;\n\n    // return new array and remainder\n    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n    prop.set(out[0]);\n\n    // build the inverse update object for the undo operation\n    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n    undoUpdate[prop.astr].push(out[1]);\n\n    // build the matching maxPoints undo object containing original trace lengths\n    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n    undoPoints[prop.astr].push(updateProps[i].target.length);\n  }\n  return {\n    update: undoUpdate,\n    maxPoints: undoPoints\n  };\n}\nfunction concatTypedArray(arr0, arr1) {\n  var arr2 = new arr0.constructor(arr0.length + arr1.length);\n  arr2.set(arr0);\n  arr2.set(arr1, arr0.length);\n  return arr2;\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nfunction extendTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n    if (Lib.isTypedArray(target)) {\n      if (maxp < 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(target, insert);\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target);\n          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          var targetBegin = target.length - numberOfItemsFromTarget;\n          newArray.set(target.subarray(targetBegin));\n          newArray.set(insert, numberOfItemsFromTarget);\n          remainder.set(target.subarray(0, targetBegin));\n        }\n      }\n    } else {\n      newArray = target.concat(insert);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];\n    }\n    return [newArray, remainder];\n  }\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n  return promise;\n}\nfunction prependTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n    if (Lib.isTypedArray(target)) {\n      if (maxp <= 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(insert, target);\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n          remainder.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target, numberOfItemsFromInsert);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          newArray.set(insert);\n          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n          remainder.set(target.subarray(numberOfItemsFromTarget));\n        }\n      }\n    } else {\n      newArray = insert.concat(target);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];\n    }\n    return [newArray, remainder];\n  }\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n  return promise;\n}\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nfunction addTraces(gd, traces, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var currentIndices = [];\n  var undoFunc = exports.deleteTraces;\n  var redoFunc = addTraces;\n  var undoArgs = [gd, currentIndices];\n  var redoArgs = [gd, traces]; // no newIndices here\n  var i;\n  var promise;\n\n  // all validation is done elsewhere to remove clutter here\n  checkAddTracesArgs(gd, traces, newIndices);\n\n  // make sure traces is an array\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  }\n\n  // make sure traces do not repeat existing ones\n  traces = traces.map(function (trace) {\n    return Lib.extendFlat({}, trace);\n  });\n  helpers.cleanData(traces);\n\n  // add the traces to gd.data (no redrawing yet!)\n  for (i = 0; i < traces.length; i++) {\n    gd.data.push(traces[i]);\n  }\n\n  // to continue, we need to call moveTraces which requires currentIndices\n  for (i = 0; i < traces.length; i++) {\n    currentIndices.push(-traces.length + i);\n  }\n\n  // if the user didn't define newIndices, they just want the traces appended\n  // i.e., we can simply redraw and be done\n  if (typeof newIndices === 'undefined') {\n    promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    return promise;\n  }\n\n  // make sure indices is property defined\n  if (!Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n  try {\n    // this is redundant, but necessary to not catch later possible errors!\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n  } catch (error) {\n    // something went wrong, reset gd to be safe and rethrow error\n    gd.data.splice(gd.data.length - traces.length, traces.length);\n    throw error;\n  }\n\n  // if we're here, the user has defined specific places to place the new traces\n  // this requires some extra work that moveTraces will do\n  Queue.startSequence(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  promise = exports.moveTraces(gd, currentIndices, newIndices);\n  Queue.stopSequence(gd);\n  return promise;\n}\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nfunction deleteTraces(gd, indices) {\n  gd = Lib.getGraphDiv(gd);\n  var traces = [];\n  var undoFunc = exports.addTraces;\n  var redoFunc = deleteTraces;\n  var undoArgs = [gd, traces, indices];\n  var redoArgs = [gd, indices];\n  var i;\n  var deletedTrace;\n\n  // make sure indices are defined\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers.');\n  } else if (!Array.isArray(indices)) {\n    indices = [indices];\n  }\n  assertIndexArray(gd, indices, 'indices');\n\n  // convert negative indices to positive indices\n  indices = positivifyIndices(indices, gd.data.length - 1);\n\n  // we want descending here so that splicing later doesn't affect indexing\n  indices.sort(Lib.sorterDes);\n  for (i = 0; i < indices.length; i += 1) {\n    deletedTrace = gd.data.splice(indices[i], 1)[0];\n    traces.push(deletedTrace);\n  }\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nfunction moveTraces(gd, currentIndices, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var newData = [];\n  var movingTraceMap = [];\n  var undoFunc = moveTraces;\n  var redoFunc = moveTraces;\n  var undoArgs = [gd, newIndices, currentIndices];\n  var redoArgs = [gd, currentIndices, newIndices];\n  var i;\n\n  // to reduce complexity here, check args elsewhere\n  // this throws errors where appropriate\n  checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n  // make sure currentIndices is an array\n  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n  // if undefined, define newIndices to point to the end of gd.data array\n  if (typeof newIndices === 'undefined') {\n    newIndices = [];\n    for (i = 0; i < currentIndices.length; i++) {\n      newIndices.push(-currentIndices.length + i);\n    }\n  }\n\n  // make sure newIndices is an array if it's user-defined\n  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n  // convert negative indices to positive indices (they're the same length)\n  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n  newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n  // at this point, we've coerced the index arrays into predictable forms\n\n  // get the traces that aren't being moved around\n  for (i = 0; i < gd.data.length; i++) {\n    // if index isn't in currentIndices, include it in ignored!\n    if (currentIndices.indexOf(i) === -1) {\n      newData.push(gd.data[i]);\n    }\n  }\n\n  // get a mapping of indices to moving traces\n  for (i = 0; i < currentIndices.length; i++) {\n    movingTraceMap.push({\n      newIndex: newIndices[i],\n      trace: gd.data[currentIndices[i]]\n    });\n  }\n\n  // reorder this mapping by newIndex, ascending\n  movingTraceMap.sort(function (a, b) {\n    return a.newIndex - b.newIndex;\n  });\n\n  // now, add the moving traces back in, in order!\n  for (i = 0; i < movingTraceMap.length; i += 1) {\n    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n  }\n  gd.data = newData;\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nfunction restyle(gd, astr, val, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = Lib.extendFlat({}, astr);\n    if (_traces === undefined) _traces = val;\n  } else {\n    Lib.warn('Restyle fail.', astr, val, _traces);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n  var specs = _restyle(gd, aobj, traces);\n  var flags = specs.flags;\n\n  // clear calcdata and/or axis types if required so they get regenerated\n  if (flags.calc) gd.calcdata = undefined;\n  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\n\n  // fill in redraw sequence\n  var seq = [];\n  if (flags.fullReplot) {\n    seq.push(exports._doPlot);\n  } else {\n    seq.push(Plots.previousPromises);\n\n    // maybe only call Plots.supplyDataDefaults in the splom case,\n    // to skip over long and slow axes defaults\n    Plots.supplyDefaults(gd);\n    if (flags.markerSize) {\n      Plots.doCalcdata(gd);\n      addAxRangeSequence(seq);\n\n      // TODO\n      // if all axes have autorange:false, then\n      // proceed to subroutines.doTraceStyle(),\n      // otherwise we must go through addAxRangeSequence,\n      // which in general must redraws 'all' axes\n    }\n    if (flags.style) seq.push(subroutines.doTraceStyle);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n  seq.push(Plots.rehover, Plots.redrag, Plots.reselect);\n  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    gd.emit('plotly_restyle', specs.eventData);\n    return gd;\n  });\n}\n\n// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val) {\n  if (val === undefined) return null;\n  return val;\n}\n\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\nfunction makeNP(preGUI, guiEditFlag) {\n  if (!guiEditFlag) return nestedProperty;\n  return function (container, attr, prefix) {\n    var np = nestedProperty(container, attr);\n    var npSet = np.set;\n    np.set = function (val) {\n      var fullAttr = (prefix || '') + attr;\n      storeCurrent(fullAttr, np.get(), val, preGUI);\n      npSet(val);\n    };\n    return np;\n  };\n}\nfunction storeCurrent(attr, val, newVal, preGUI) {\n  if (Array.isArray(val) || Array.isArray(newVal)) {\n    var arrayVal = Array.isArray(val) ? val : [];\n    var arrayNew = Array.isArray(newVal) ? newVal : [];\n    var maxLen = Math.max(arrayVal.length, arrayNew.length);\n    for (var i = 0; i < maxLen; i++) {\n      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n    }\n  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n    var objVal = Lib.isPlainObject(val) ? val : {};\n    var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n    var objBoth = Lib.extendFlat({}, objVal, objNew);\n    for (var key in objBoth) {\n      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n    }\n  } else if (preGUI[attr] === undefined) {\n    preGUI[attr] = undefinedToNull(val);\n  }\n}\n\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n  for (var attr in edits) {\n    var np = nestedProperty(container, attr);\n    storeCurrent(attr, np.get(), edits[attr], preGUI);\n  }\n}\nfunction _restyle(gd, aobj, traces) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var data = gd.data;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var i;\n  cleanDeprecatedAttributeKeys(aobj);\n\n  // initialize flags\n  var flags = editTypes.traceFlags();\n\n  // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n  var redoit = {};\n  var undoit = {};\n  var axlist;\n\n  // make a new empty vals array for undoit\n  function a0() {\n    return traces.map(function () {\n      return undefined;\n    });\n  }\n\n  // for autoranging multiple axes\n  function addToAxlist(axid) {\n    var axName = Axes.id2name(axid);\n    if (axlist.indexOf(axName) === -1) axlist.push(axName);\n  }\n  function autorangeAttr(axName) {\n    return 'LAYOUT' + axName + '.autorange';\n  }\n  function rangeAttr(axName) {\n    return 'LAYOUT' + axName + '.range';\n  }\n  function getFullTrace(traceIndex) {\n    // usually fullData maps 1:1 onto data, but with groupby transforms\n    // the fullData index can be greater. Take the *first* matching trace.\n    for (var j = traceIndex; j < fullData.length; j++) {\n      if (fullData[j]._input === data[traceIndex]) return fullData[j];\n    }\n    // should never get here - and if we *do* it should cause an error\n    // later on undefined fullTrace is passed to nestedProperty.\n  }\n\n  // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // val=null will delete the attribute\n  // attr can be an array to set several at once (all to the same val)\n  function doextra(attr, val, i) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val, i);\n      });\n      return;\n    }\n    // quit if explicitly setting this elsewhere\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var extraparam;\n    if (attr.substr(0, 6) === 'LAYOUT') {\n      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n    } else {\n      var tracei = traces[i];\n      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n    }\n    if (!(attr in undoit)) {\n      undoit[attr] = a0();\n    }\n    if (undoit[attr][i] === undefined) {\n      undoit[attr][i] = undefinedToNull(extraparam.get());\n    }\n    if (val !== undefined) {\n      extraparam.set(val);\n    }\n  }\n  function allBins(binAttr) {\n    return function (j) {\n      return fullData[j][binAttr];\n    };\n  }\n  function arrayBins(binAttr) {\n    return function (vij, j) {\n      return vij === false ? fullData[traces[j]][binAttr] : null;\n    };\n  }\n\n  // now make the changes to gd.data (and occasionally gd.layout)\n  // and figure out what kind of graphics update we need to do\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n    var vi = aobj[ai];\n    var cont;\n    var contFull;\n    var param;\n    var oldVal;\n    var newVal;\n    var valObject;\n\n    // Backward compatibility shim for turning histogram autobin on,\n    // or freezing previous autobinned values.\n    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n    if (ai === 'autobinx' || ai === 'autobiny') {\n      ai = ai.charAt(ai.length - 1) + 'bins';\n      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;\n    }\n    redoit[ai] = vi;\n    if (ai.substr(0, 6) === 'LAYOUT') {\n      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n      undoit[ai] = [undefinedToNull(param.get())];\n      // since we're allowing val to be an array, allow it here too,\n      // even though that's meaningless\n      param.set(Array.isArray(vi) ? vi[0] : vi);\n      // ironically, the layout attrs in restyle only require replot,\n      // not relayout\n      flags.calc = true;\n      continue;\n    }\n\n    // set attribute in gd.data\n    undoit[ai] = a0();\n    for (i = 0; i < traces.length; i++) {\n      cont = data[traces[i]];\n      contFull = getFullTrace(traces[i]);\n      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n      param = makeNP(preGUI, guiEditFlag)(cont, ai);\n      oldVal = param.get();\n      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n      if (newVal === undefined) continue;\n      var finalPart = param.parts[param.parts.length - 1];\n      var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n      var prefixDot = prefix ? prefix + '.' : '';\n      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;\n      valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n      if (valObject && valObject.impliedEdits && newVal !== null) {\n        for (var impliedKey in valObject.impliedEdits) {\n          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n        }\n      } else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {\n        // changing colorbar size modes,\n        // make the resulting size not change\n        // note that colorbar fractional sizing is based on the\n        // original plot size, before anything (like a colorbar)\n        // increases the margins\n\n        var gs = fullLayout._size;\n        var orient = innerContFull.orient;\n        var topOrBottom = orient === 'top' || orient === 'bottom';\n        if (finalPart === 'thicknessmode') {\n          var thicknorm = topOrBottom ? gs.h : gs.w;\n          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n        } else {\n          var lennorm = topOrBottom ? gs.w : gs.h;\n          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n        }\n      } else if (ai === 'type' && (newVal === 'pie' !== (oldVal === 'pie') || newVal === 'funnelarea' !== (oldVal === 'funnelarea'))) {\n        var labelsTo = 'x';\n        var valuesTo = 'y';\n        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n          labelsTo = 'y';\n          valuesTo = 'x';\n        }\n        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n        if (oldVal === 'pie' || oldVal === 'funnelarea') {\n          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get());\n\n          // super kludgy - but if all pies are gone we won't remove them otherwise\n          fullLayout._pielayer.selectAll('g.trace').remove();\n        } else if (Registry.traceIs(cont, 'cartesian')) {\n          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());\n        }\n      }\n      undoit[ai][i] = undefinedToNull(oldVal);\n      // set the new value - if val is an array, it's one el per trace\n      // first check for attributes that get more complex alterations\n      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];\n      if (swapAttrs.indexOf(ai) !== -1) {\n        // setting an orientation: make sure it's changing\n        // before we swap everything else\n        if (ai === 'orientation') {\n          param.set(newVal);\n          // obnoxious that we need this level of coupling... but in order to\n          // properly handle setting orientation to `null` we need to mimic\n          // the logic inside Bars.supplyDefaults for default orientation\n          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';\n          if ((param.get() || defaultOrientation) === contFull.orientation) {\n            continue;\n          }\n        } else if (ai === 'orientationaxes') {\n          // orientationaxes has no value,\n          // it flips everything and the axes\n\n          cont.orientation = {\n            v: 'h',\n            h: 'v'\n          }[contFull.orientation];\n        }\n        helpers.swapXYData(cont);\n        flags.calc = flags.clearAxisTypes = true;\n      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n        // TODO: use manageArrays.applyContainerArrayChanges here too\n        helpers.manageArrayContainers(param, newVal, undoit);\n        flags.calc = true;\n      } else {\n        if (valObject) {\n          // must redo calcdata when restyling array values of arrayOk attributes\n          // ... but no need to this for regl-based traces\n          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {\n            flags.calc = true;\n          } else editTypes.update(flags, valObject);\n        } else {\n          /*\n           * if we couldn't find valObject,  assume a full recalc.\n           * This can happen if you're changing type and making\n           * some other edits too, so the modules we're\n           * looking at don't have these attributes in them.\n           */\n          flags.calc = true;\n        }\n\n        // all the other ones, just modify that one attribute\n        param.set(newVal);\n      }\n    }\n\n    // swap the data attributes of the relevant x and y axes?\n    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n      Axes.swap(gd, traces);\n    }\n\n    // swap hovermode if set to \"compare x/y data\"\n    if (ai === 'orientationaxes') {\n      var hovermode = nestedProperty(gd.layout, 'hovermode');\n      var h = hovermode.get();\n      if (h === 'x') {\n        hovermode.set('y');\n      } else if (h === 'y') {\n        hovermode.set('x');\n      } else if (h === 'x unified') {\n        hovermode.set('y unified');\n      } else if (h === 'y unified') {\n        hovermode.set('x unified');\n      }\n    }\n\n    // Major enough changes deserve autoscale and\n    // non-reversed axes so people don't get confused\n    //\n    // Note: autobin (or its new analog bin clearing) is not included here\n    // since we're not pushing bins back to gd.data, so if we have bin\n    // info it was explicitly provided by the user.\n    if (['orientation', 'type'].indexOf(ai) !== -1) {\n      axlist = [];\n      for (i = 0; i < traces.length; i++) {\n        var trace = data[traces[i]];\n        if (Registry.traceIs(trace, 'cartesian')) {\n          addToAxlist(trace.xaxis || 'x');\n          addToAxlist(trace.yaxis || 'y');\n        }\n      }\n      doextra(axlist.map(autorangeAttr), true, 0);\n      doextra(axlist.map(rangeAttr), [0, 1], 0);\n    }\n  }\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n  return {\n    flags: flags,\n    undoit: undoit,\n    redoit: redoit,\n    traces: traces,\n    eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n  };\n}\n\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\nfunction cleanDeprecatedAttributeKeys(aobj) {\n  var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n  var colorbarRegex = /colorbar\\.title$/;\n  var keys = Object.keys(aobj);\n  var i, key, value;\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    value = aobj[key];\n    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {\n      replace(key, key.replace('title', 'title.text'));\n    } else if (key.indexOf('titlefont') > -1 && key.indexOf('grouptitlefont') === -1) {\n      replace(key, key.replace('titlefont', 'title.font'));\n    } else if (key.indexOf('titleposition') > -1) {\n      replace(key, key.replace('titleposition', 'title.position'));\n    } else if (key.indexOf('titleside') > -1) {\n      replace(key, key.replace('titleside', 'title.side'));\n    } else if (key.indexOf('titleoffset') > -1) {\n      replace(key, key.replace('titleoffset', 'title.offset'));\n    }\n  }\n  function replace(oldAttrStr, newAttrStr) {\n    aobj[newAttrStr] = aobj[oldAttrStr];\n    delete aobj[oldAttrStr];\n  }\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nfunction relayout(gd, astr, val) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = Lib.extendFlat({}, astr);\n  } else {\n    Lib.warn('Relayout fail.', astr, val);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var specs = _relayout(gd, aobj);\n  var flags = specs.flags;\n\n  // clear calcdata if required\n  if (flags.calc) gd.calcdata = undefined;\n\n  // fill in redraw sequence\n\n  // even if we don't have anything left in aobj,\n  // something may have happened within relayout that we\n  // need to wait for\n  var seq = [Plots.previousPromises];\n  if (flags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else if (Object.keys(aobj).length) {\n    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n    if (flags.legend) seq.push(subroutines.doLegend);\n    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n    if (flags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (flags.modebar) seq.push(subroutines.doModeBar);\n    if (flags.camera) seq.push(subroutines.doCamera);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n  seq.push(Plots.rehover, Plots.redrag, Plots.reselect);\n  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_relayout', specs.eventData);\n    return gd;\n  });\n}\n\n// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n  var fullLayout = gd._fullLayout;\n  if (!flags.axrange) return false;\n  for (var k in flags) {\n    if (k !== 'axrange' && flags[k]) return false;\n  }\n  var axIn, axOut;\n  var coerce = function (attr, dflt) {\n    return Lib.coerce(axIn, axOut, cartesianLayoutAttributes, attr, dflt);\n  };\n  var options = {}; // passing empty options for now!\n\n  for (var axId in specs.rangesAltered) {\n    var axName = Axes.id2name(axId);\n    axIn = gd.layout[axName];\n    axOut = fullLayout[axName];\n    handleRangeDefaults(axIn, axOut, coerce, options);\n    if (axOut._matchGroup) {\n      for (var axId2 in axOut._matchGroup) {\n        if (axId2 !== axId) {\n          var ax2 = fullLayout[Axes.id2name(axId2)];\n          ax2.autorange = axOut.autorange;\n          ax2.range = axOut.range.slice();\n          ax2._input.range = axOut.range.slice();\n        }\n      }\n    }\n  }\n  return true;\n}\nfunction addAxRangeSequence(seq, rangesAltered) {\n  // N.B. leave as sequence of subroutines (for now) instead of\n  // subroutine of its own so that finalDraw always gets\n  // executed after drawData\n  var drawAxes = rangesAltered ? function (gd) {\n    var axIds = [];\n    var skipTitle = true;\n    for (var id in rangesAltered) {\n      var ax = Axes.getFromId(gd, id);\n      axIds.push(id);\n      if ((ax.ticklabelposition || '').indexOf('inside') !== -1) {\n        if (ax._anchorAxis) {\n          axIds.push(ax._anchorAxis._id);\n        }\n      }\n      if (ax._matchGroup) {\n        for (var id2 in ax._matchGroup) {\n          if (!rangesAltered[id2]) {\n            axIds.push(id2);\n          }\n        }\n      }\n    }\n    return Axes.draw(gd, axIds, {\n      skipTitle: skipTitle\n    });\n  } : function (gd) {\n    return Axes.draw(gd, 'redraw');\n  };\n  seq.push(clearOutline, subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);\n}\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\nfunction _relayout(gd, aobj) {\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var keys = Object.keys(aobj);\n  var axes = Axes.list(gd);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var arrayEdits = {};\n  var arrayStr, i, j;\n  cleanDeprecatedAttributeKeys(aobj);\n  keys = Object.keys(aobj);\n\n  // look for 'allaxes', split out into all axes\n  // in case of 3D the axis are nested within a scene which is held in _id\n  for (i = 0; i < keys.length; i++) {\n    if (keys[i].indexOf('allaxes') === 0) {\n      for (j = 0; j < axes.length; j++) {\n        var scene = axes[j]._id.substr(1);\n        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';\n        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n      }\n      delete aobj[keys[i]];\n    }\n  }\n\n  // initialize flags\n  var flags = editTypes.layoutFlags();\n\n  // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n  var redoit = {};\n  var undoit = {};\n\n  // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // attr can be an array to set several at once (all to the same val)\n  function doextra(attr, val) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val);\n      });\n      return;\n    }\n\n    // if we have another value for this attribute (explicitly or\n    // via a parent) do not override with this auto-generated extra\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var p = layoutNP(layout, attr);\n    if (!(attr in undoit)) {\n      undoit[attr] = undefinedToNull(p.get());\n    }\n    if (val !== undefined) p.set(val);\n  }\n\n  // for constraint enforcement: keep track of all axes (as {id: name})\n  // we're editing the (auto)range of, so we can tell the others constrained\n  // to scale with them that it's OK for them to shrink\n  var rangesAltered = {};\n  var ax;\n  function recordAlteredAxis(pleafPlus) {\n    var axId = Axes.name2id(pleafPlus.split('.')[0]);\n    rangesAltered[axId] = 1;\n    return axId;\n  }\n\n  // alter gd.layout\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n    var p = layoutNP(layout, ai);\n    var vi = aobj[ai];\n    var plen = p.parts.length;\n    // p.parts may end with an index integer if the property is an array\n    var pend = plen - 1;\n    while (pend > 0 && typeof p.parts[pend] !== 'string') pend--;\n    // last property in chain (leaf node)\n    var pleaf = p.parts[pend];\n    // leaf plus immediate parent\n    var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\n    // trunk nodes (everything except the leaf)\n    var ptrunk = p.parts.slice(0, pend).join('.');\n    var parentIn = nestedProperty(gd.layout, ptrunk).get();\n    var parentFull = nestedProperty(fullLayout, ptrunk).get();\n    var vOld = p.get();\n    if (vi === undefined) continue;\n    redoit[ai] = vi;\n\n    // axis reverse is special - it is its own inverse\n    // op and has no flag.\n    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);\n    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n    if (valObject && valObject.impliedEdits && vi !== null) {\n      for (var impliedKey in valObject.impliedEdits) {\n        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n      }\n    }\n\n    // Setting width or height to null must reset the graph's width / height\n    // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    //\n    // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // can't use impliedEdits for this because behavior depends on vi\n    if (['width', 'height'].indexOf(ai) !== -1) {\n      if (vi) {\n        doextra('autosize', null);\n        // currently we don't support autosize one dim only - so\n        // explicitly set the other one. Note that doextra will\n        // ignore this if the same relayout call also provides oppositeAttr\n        var oppositeAttr = ai === 'height' ? 'width' : 'height';\n        doextra(oppositeAttr, fullLayout[oppositeAttr]);\n      } else {\n        fullLayout[ai] = gd._initialAutoSize[ai];\n      }\n    } else if (ai === 'autosize') {\n      // depends on vi here too, so again can't use impliedEdits\n      doextra('width', vi ? null : fullLayout.width);\n      doextra('height', vi ? null : fullLayout.height);\n    } else if (pleafPlus.match(AX_RANGE_RE)) {\n      // check autorange vs range\n\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n      var axFull = nestedProperty(fullLayout, ptrunk).get();\n      if (axFull._inputDomain) {\n        // if we're autoranging and this axis has a constrained domain,\n        // reset it so we don't get locked into a shrunken size\n        axFull._input.domain = axFull._inputDomain.slice();\n      }\n    } else if (pleafPlus.match(AX_DOMAIN_RE)) {\n      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n    }\n\n    // toggling axis type between log and linear: we need to convert\n    // positions for components that are still using linearized values,\n    // not data values like newer components.\n    // previously we did this for log <-> not-log, but now only do it\n    // for log <-> linear\n    if (pleaf === 'type') {\n      ax = parentIn;\n      var toLog = parentFull.type === 'linear' && vi === 'log';\n      var fromLog = parentFull.type === 'log' && vi === 'linear';\n      if (toLog || fromLog) {\n        if (!ax || !ax.range) {\n          // 2D never gets here, but 3D does\n          // I don't think this is needed, but left here in case there\n          // are edge cases I'm not thinking of.\n          doextra(ptrunk + '.autorange', true);\n        } else if (!parentFull.autorange) {\n          // toggling log without autorange: need to also recalculate ranges\n          // because log axes use linearized values for range endpoints\n          var r0 = ax.range[0];\n          var r1 = ax.range[1];\n          if (toLog) {\n            // if both limits are negative, autorange\n            if (r0 <= 0 && r1 <= 0) {\n              doextra(ptrunk + '.autorange', true);\n            }\n            // if one is negative, set it 6 orders below the other.\n            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6;\n            // now set the range values as appropriate\n            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n          } else {\n            doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n            doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n          }\n        } else if (toLog) {\n          // just make sure the range is positive and in the right\n          // order, it'll get recalculated later\n          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];\n        }\n\n        // clear polar view initial stash for radial range so that\n        // value get recomputed in correct units\n        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {\n          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n        }\n\n        // Annotations and images also need to convert to/from linearized coords\n        // Shapes do not need this :)\n        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n      } else {\n        // any other type changes: the range from the previous type\n        // will not make sense, so autorange it.\n        doextra(ptrunk + '.autorange', true);\n        doextra(ptrunk + '.range', null);\n      }\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleaf.match(AX_NAME_PATTERN)) {\n      var fullProp = nestedProperty(fullLayout, ai).get();\n      var newType = (vi || {}).type;\n\n      // This can potentially cause strange behavior if the autotype is not\n      // numeric (linear, because we don't auto-log) but the previous type\n      // was log. That's a very strange edge case though\n      if (!newType || newType === '-') newType = 'linear';\n      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n    }\n\n    // alter gd.layout\n\n    // collect array component edits for execution all together\n    // so we can ensure consistent behavior adding/removing items\n    // and order-independence for add/remove/edit all together in\n    // one relayout call\n    var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n    if (containerArrayMatch) {\n      arrayStr = containerArrayMatch.array;\n      i = containerArrayMatch.index;\n      var propStr = containerArrayMatch.property;\n      var updateValObject = valObject || {\n        editType: 'calc'\n      };\n      if (i !== '' && propStr === '') {\n        // special handling of undoit if we're adding or removing an element\n        // ie 'annotations[2]' which can be {...} (add) or null,\n        // does not work when replacing the entire array\n        if (manageArrays.isAddVal(vi)) {\n          undoit[ai] = null;\n        } else if (manageArrays.isRemoveVal(vi)) {\n          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n        } else {\n          Lib.warn('unrecognized full object value', aobj);\n        }\n      }\n      editTypes.update(flags, updateValObject);\n\n      // prepare the edits object we'll send to applyContainerArrayChanges\n      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n      var objEdits = arrayEdits[arrayStr][i];\n      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n      objEdits[propStr] = vi;\n      delete aobj[ai];\n    } else if (pleaf === 'reverse') {\n      // handle axis reversal explicitly, as there's no 'reverse' attribute\n\n      if (parentIn.range) parentIn.range.reverse();else {\n        doextra(ptrunk + '.autorange', true);\n        parentIn.range = [1, 0];\n      }\n      if (parentFull.autorange) flags.calc = true;else flags.plot = true;\n    } else {\n      if (ai === 'dragmode' && (vi === false && vOld !== false || vi !== false && vOld === false)) {\n        flags.plot = true;\n      } else if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {\n        flags.plot = true;\n      } else if (fullLayout._has('gl2d')) {\n        flags.plot = true;\n      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;\n      p.set(vi);\n    }\n  }\n\n  // now we've collected component edits - execute them all together\n  for (arrayStr in arrayEdits) {\n    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n    if (!finished) flags.plot = true;\n  }\n\n  // figure out if we need to recalculate axis constraints\n  for (var axId in rangesAltered) {\n    ax = Axes.getFromId(gd, axId);\n    var group = ax && ax._constraintGroup;\n    if (group) {\n      // Always recalc if we're changing constrained ranges.\n      // Otherwise it's possible to violate the constraints by\n      // specifying arbitrary ranges for all axes in the group.\n      // this way some ranges may expand beyond what's specified,\n      // as they do at first draw, to satisfy the constraints.\n      flags.calc = true;\n      for (var groupAxId in group) {\n        if (!rangesAltered[groupAxId]) {\n          Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n        }\n      }\n    }\n  }\n\n  // If the autosize changed or height or width was explicitly specified,\n  // this triggers a redraw\n  // TODO: do we really need special aobj.height/width handling here?\n  // couldn't editType do this?\n  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n  // update shape legends\n  var shapes = fullLayout.shapes;\n  for (i = 0; i < shapes.length; i++) {\n    if (shapes[i].showlegend) {\n      flags.calc = true;\n      break;\n    }\n  }\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n\n  // now all attribute mods are done, as are\n  // redo and undo so we can save them\n\n  return {\n    flags: flags,\n    rangesAltered: rangesAltered,\n    undoit: undoit,\n    redoit: redoit,\n    eventData: eventData\n  };\n}\n\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\nfunction updateAutosize(gd) {\n  var fullLayout = gd._fullLayout;\n  var oldWidth = fullLayout.width;\n  var oldHeight = fullLayout.height;\n\n  // calculate autosizing\n  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n  if (Object.keys(traceUpdate).length) gd.changed = true;\n  if (Object.keys(layoutUpdate).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n  var restyleFlags = restyleSpecs.flags;\n  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n  var relayoutFlags = relayoutSpecs.flags;\n\n  // clear calcdata and/or axis types if required\n  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\n\n  // fill in redraw sequence\n  var seq = [];\n  if (relayoutFlags.layoutReplot) {\n    // N.B. works fine when both\n    // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n    seq.push(subroutines.layoutReplot);\n  } else if (restyleFlags.fullReplot) {\n    seq.push(exports._doPlot);\n  } else {\n    seq.push(Plots.previousPromises);\n    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n    if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n    if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n    if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n  seq.push(Plots.rehover, Plots.redrag, Plots.reselect);\n  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_update', {\n      data: restyleSpecs.eventData,\n      layout: relayoutSpecs.eventData\n    });\n    return gd;\n  });\n}\n\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\nfunction guiEdit(func) {\n  return function wrappedEdit(gd) {\n    gd._fullLayout._guiEditing = true;\n    var p = func.apply(null, arguments);\n    gd._fullLayout._guiEditing = false;\n    return p;\n  };\n}\n\n// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns = [{\n  pattern: /^hiddenlabels/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/\n},\n// showspikes and modes include those nested inside scenes\n{\n  pattern: /axis\\d*\\.showspikes$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /(hover|drag)mode$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /^(scene\\d*)\\.camera/\n}, {\n  pattern: /^(geo\\d*)\\.(projection|center|fitbounds)/\n}, {\n  pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/\n}, {\n  pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/\n}, {\n  pattern: /^(polar\\d*\\.angularaxis)\\.rotation/\n}, {\n  pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^(map\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^legend\\.(x|y)$/,\n  attr: 'editrevision'\n}, {\n  pattern: /^(shapes|annotations)/,\n  attr: 'editrevision'\n}, {\n  pattern: /^title\\.text$/,\n  attr: 'editrevision'\n}];\n\n// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns = [{\n  pattern: /^selectedpoints$/,\n  attr: 'selectionrevision'\n},\n// \"visible\" includes trace.transforms[i].styles[j].value.visible\n{\n  pattern: /(^|value\\.)visible$/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^dimensions\\[\\d+\\]\\.constraintrange/\n}, {\n  pattern: /^node\\.(x|y|groups)/\n},\n// for Sankey nodes\n{\n  pattern: /^level$/\n},\n// for Sunburst, Treemap and Icicle traces\n\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n\n// \"name\" also includes transform.styles\n{\n  pattern: /(^|value\\.)name$/\n},\n// including nested colorbar attributes (ie marker.colorbar)\n{\n  pattern: /colorbar\\.title\\.text$/\n}, {\n  pattern: /colorbar\\.(x|y)$/,\n  attr: 'editrevision'\n}];\nfunction findUIPattern(key, patternSpecs) {\n  for (var i = 0; i < patternSpecs.length; i++) {\n    var spec = patternSpecs[i];\n    var match = key.match(spec.pattern);\n    if (match) {\n      var head = match[1] || '';\n      return {\n        head: head,\n        tail: key.substr(head.length + 1),\n        attr: spec.attr\n      };\n    }\n  }\n}\n\n// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr, container) {\n  var newRev = nestedProperty(container, revAttr).get();\n  if (newRev !== undefined) return newRev;\n  var parts = revAttr.split('.');\n  parts.pop();\n  while (parts.length > 1) {\n    parts.pop();\n    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n    if (newRev !== undefined) return newRev;\n  }\n  return container.uirevision;\n}\nfunction getFullTraceIndexFromUid(uid, fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (fullData[i]._fullInput.uid === uid) return i;\n  }\n  return -1;\n}\nfunction getTraceIndexFromUid(uid, data, tracei) {\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].uid === uid) return i;\n  }\n  // fall back on trace order, but only if user didn't provide a uid for that trace\n  return !data[tracei] || data[tracei].uid ? -1 : tracei;\n}\nfunction valsMatch(v1, v2) {\n  var v1IsObj = Lib.isPlainObject(v1);\n  var v1IsArray = Array.isArray(v1);\n  if (v1IsObj || v1IsArray) {\n    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);\n  }\n  return v1 === v2;\n}\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n  var layoutPreGUI = oldFullLayout._preGUI;\n  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal, head, tail;\n  var bothInheritAutorange = [];\n  var newAutorangeIn = {};\n  var newRangeAccepted = {};\n  for (key in layoutPreGUI) {\n    match = findUIPattern(key, layoutUIControlPatterns);\n    if (match) {\n      head = match.head;\n      tail = match.tail;\n      revAttr = match.attr || head + '.uirevision';\n      oldRev = nestedProperty(oldFullLayout, revAttr).get();\n      newRev = oldRev && getNewRev(revAttr, layout);\n      if (newRev && newRev === oldRev) {\n        preGUIVal = layoutPreGUI[key];\n        if (preGUIVal === null) preGUIVal = undefined;\n        newNP = nestedProperty(layout, key);\n        newVal = newNP.get();\n        if (valsMatch(newVal, preGUIVal)) {\n          if (newVal === undefined && tail === 'autorange') {\n            bothInheritAutorange.push(head);\n          }\n          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n          continue;\n        } else if (tail === 'autorange' || tail.substr(0, 6) === 'range[') {\n          // Special case for (auto)range since we push it back into the layout\n          // so all null should be treated equivalently to autorange: true with any range\n          var pre0 = layoutPreGUI[head + '.range[0]'];\n          var pre1 = layoutPreGUI[head + '.range[1]'];\n          var preAuto = layoutPreGUI[head + '.autorange'];\n          if (preAuto || preAuto === null && pre0 === null && pre1 === null) {\n            // Only read the input layout once and stash the result,\n            // so we get it before we start modifying it\n            if (!(head in newAutorangeIn)) {\n              var newContainer = nestedProperty(layout, head).get();\n              newAutorangeIn[head] = newContainer && (newContainer.autorange || newContainer.autorange !== false && (!newContainer.range || newContainer.range.length !== 2));\n            }\n            if (newAutorangeIn[head]) {\n              newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n              continue;\n            }\n          }\n        }\n      }\n    } else {\n      Lib.warn('unrecognized GUI edit: ' + key);\n    }\n    // if we got this far, the new value was accepted as the new starting\n    // point (either because it changed or revision changed)\n    // so remove it from _preGUI for next time.\n    delete layoutPreGUI[key];\n    if (match && match.tail.substr(0, 6) === 'range[') {\n      newRangeAccepted[match.head] = 1;\n    }\n  }\n\n  // More special logic for `autorange`, since it interacts with `range`:\n  // If the new figure's matching `range` was kept, and `autorange`\n  // wasn't supplied explicitly in either the original or the new figure,\n  // we shouldn't alter that - but we may just have done that, so fix it.\n  for (var i = 0; i < bothInheritAutorange.length; i++) {\n    var axAttr = bothInheritAutorange[i];\n    if (newRangeAccepted[axAttr]) {\n      var newAx = nestedProperty(layout, axAttr).get();\n      if (newAx) delete newAx.autorange;\n    }\n  }\n\n  // Now traces - try to match them up by uid (in case we added/deleted in\n  // the middle), then fall back on index.\n  var allTracePreGUI = oldFullLayout._tracePreGUI;\n  for (var uid in allTracePreGUI) {\n    var tracePreGUI = allTracePreGUI[uid];\n    var newTrace = null;\n    var fullInput;\n    for (key in tracePreGUI) {\n      // wait until we know we have preGUI values to look for traces\n      // but if we don't find both, stop looking at this uid\n      if (!newTrace) {\n        var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n        if (fulli < 0) {\n          // Somehow we didn't even have this trace in oldFullData...\n          // I guess this could happen with `deleteTraces` or something\n          delete allTracePreGUI[uid];\n          break;\n        }\n        var fullTrace = oldFullData[fulli];\n        fullInput = fullTrace._fullInput;\n        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n        if (newTracei < 0) {\n          // No match in new data\n          delete allTracePreGUI[uid];\n          break;\n        }\n        newTrace = data[newTracei];\n      }\n      match = findUIPattern(key, traceUIControlPatterns);\n      if (match) {\n        if (match.attr) {\n          oldRev = nestedProperty(oldFullLayout, match.attr).get();\n          newRev = oldRev && getNewRev(match.attr, layout);\n        } else {\n          oldRev = fullInput.uirevision;\n          // inheritance for trace.uirevision is simple, just layout.uirevision\n          newRev = newTrace.uirevision;\n          if (newRev === undefined) newRev = layout.uirevision;\n        }\n        if (newRev && newRev === oldRev) {\n          preGUIVal = tracePreGUI[key];\n          if (preGUIVal === null) preGUIVal = undefined;\n          newNP = nestedProperty(newTrace, key);\n          newVal = newNP.get();\n          if (valsMatch(newVal, preGUIVal)) {\n            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n            continue;\n          }\n        }\n      } else {\n        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n      }\n      delete tracePreGUI[key];\n    }\n  }\n}\n\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction react(gd, data, layout, config) {\n  var frames, plotDone;\n  function addFrames() {\n    return exports.addFrames(gd, frames);\n  }\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var oldFullData = gd._fullData;\n  var oldFullLayout = gd._fullLayout;\n\n  // you can use this as the initial draw as well as to update\n  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n    plotDone = exports.newPlot(gd, data, layout, config);\n  } else {\n    if (Lib.isPlainObject(data)) {\n      var obj = data;\n      data = obj.data;\n      layout = obj.layout;\n      config = obj.config;\n      frames = obj.frames;\n    }\n    var configChanged = false;\n    // assume that if there's a config at all, we're reacting to it too,\n    // and completely replace the previous config\n    if (config) {\n      var oldConfig = Lib.extendDeep({}, gd._context);\n      gd._context = undefined;\n      setPlotContext(gd, config);\n      configChanged = diffConfig(oldConfig, gd._context);\n    }\n    gd.data = data || [];\n    helpers.cleanData(gd.data);\n    gd.layout = layout || {};\n    helpers.cleanLayout(gd.layout);\n    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\n\n    // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n    // which supplyDefaults usually does at the end, but we may need to NOT do\n    // if the diff (which we haven't determined yet) says we'll recalc\n    Plots.supplyDefaults(gd, {\n      skipUpdateCalc: true\n    });\n    var newFullData = gd._fullData;\n    var newFullLayout = gd._fullLayout;\n    var immutable = newFullLayout.datarevision === undefined;\n    var transition = newFullLayout.transition;\n    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n    var newDataRevision = relayoutFlags.newDataRevision;\n    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\n\n    // TODO: how to translate this part of relayout to Plotly.react?\n    // // Setting width or height to null must reset the graph's width / height\n    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    // //\n    // // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n    //     fullLayout[ai] = gd._initialAutoSize[ai];\n    // }\n\n    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true;\n\n    // clear calcdata and empty categories if required\n    if (restyleFlags.calc || relayoutFlags.calc) {\n      gd.calcdata = undefined;\n      var allNames = Object.getOwnPropertyNames(newFullLayout);\n      for (var q = 0; q < allNames.length; q++) {\n        var name = allNames[q];\n        var start = name.substring(0, 5);\n        if (start === 'xaxis' || start === 'yaxis') {\n          var emptyCategories = newFullLayout[name]._emptyCategories;\n          if (emptyCategories) emptyCategories();\n        }\n      }\n      // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n    } else {\n      Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n    }\n\n    // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n    // must be handled by the user when using Plotly.react.\n\n    // fill in redraw sequence\n    var seq = [];\n    if (frames) {\n      gd._transitionData = {};\n      Plots.createTransitionData(gd);\n      seq.push(addFrames);\n    }\n\n    // Transition pathway,\n    // only used when 'transition' is set by user and\n    // when at least one animatable attribute has changed,\n    // N.B. config changed aren't animatable\n    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      Plots.doCalcdata(gd);\n      subroutines.doAutoRangeAndConstraints(gd);\n      seq.push(function () {\n        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n      });\n    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n      gd._fullLayout._skipDefaults = true;\n      seq.push(exports._doPlot);\n    } else {\n      for (var componentType in relayoutFlags.arrays) {\n        var indices = relayoutFlags.arrays[componentType];\n        if (indices.length) {\n          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n          if (drawOne !== Lib.noop) {\n            for (var i = 0; i < indices.length; i++) {\n              drawOne(gd, indices[i]);\n            }\n          } else {\n            var draw = Registry.getComponentMethod(componentType, 'draw');\n            if (draw === Lib.noop) {\n              throw new Error('cannot draw components: ' + componentType);\n            }\n            draw(gd);\n          }\n        }\n      }\n      seq.push(Plots.previousPromises);\n      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n      if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n      if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n      if (relayoutFlags.axrange) addAxRangeSequence(seq);\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n      if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n      seq.push(emitAfterPlot);\n    }\n    seq.push(Plots.rehover, Plots.redrag, Plots.reselect);\n    plotDone = Lib.syncOrAsync(seq, gd);\n    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  }\n  return plotDone.then(function () {\n    gd.emit('plotly_react', {\n      data: data,\n      layout: layout\n    });\n    return gd;\n  });\n}\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n  var sameTraceLength = oldFullData.length === newFullData.length;\n  if (!transition && !sameTraceLength) {\n    return {\n      fullReplot: true,\n      calc: true\n    };\n  }\n  var flags = editTypes.traceFlags();\n  flags.arrays = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  var i, trace;\n  function getTraceValObject(parts) {\n    var out = PlotSchema.getTraceValObject(trace, parts);\n    if (!trace._module.animatable && out.anim) {\n      out.anim = false;\n    }\n    return out;\n  }\n  var diffOpts = {\n    getValObject: getTraceValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    newDataRevision: newDataRevision,\n    gd: gd\n  };\n  var seenUIDs = {};\n  for (i = 0; i < oldFullData.length; i++) {\n    if (newFullData[i]) {\n      trace = newFullData[i]._fullInput;\n      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n      if (seenUIDs[trace.uid]) continue;\n      seenUIDs[trace.uid] = 1;\n      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n    }\n  }\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';\n  }\n  return flags;\n}\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n  var flags = editTypes.layoutFlags();\n  flags.arrays = {};\n  flags.rangesAltered = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  function getLayoutValObject(parts) {\n    return PlotSchema.getLayoutValObject(newFullLayout, parts);\n  }\n  var diffOpts = {\n    getValObject: getLayoutValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    gd: gd\n  };\n  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n  }\n  return flags;\n}\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n  var valObject, key, astr;\n  var getValObject = opts.getValObject;\n  var flags = opts.flags;\n  var immutable = opts.immutable;\n  var inArray = opts.inArray;\n  var arrayIndex = opts.arrayIndex;\n  function changed() {\n    var editType = valObject.editType;\n    if (inArray && editType.indexOf('arraydraw') !== -1) {\n      Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n      return;\n    }\n    editTypes.update(flags, valObject);\n    if (editType !== 'none') {\n      flags.nChanges++;\n    }\n\n    // track animatable changes\n    if (opts.transition && valObject.anim) {\n      flags.nChangesAnim++;\n    }\n\n    // track cartesian axes with altered ranges\n    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n      flags.rangesAltered[outerparts[0]] = 1;\n    }\n\n    // clear _inputDomain on cartesian axes with altered domains\n    if (AX_DOMAIN_RE.test(astr)) {\n      nestedProperty(newContainer, '_inputDomain').set(null);\n    }\n\n    // track datarevision changes\n    if (key === 'datarevision') {\n      flags.newDataRevision = 1;\n    }\n  }\n  function valObjectCanBeDataArray(valObject) {\n    return valObject.valType === 'data_array' || valObject.arrayOk;\n  }\n  for (key in oldContainer) {\n    // short-circuit based on previous calls or previous keys that already maximized the pathway\n    if (flags.calc && !opts.transition) return;\n    var oldVal = oldContainer[key];\n    var newVal = newContainer[key];\n    var parts = outerparts.concat(key);\n    astr = parts.join('.');\n    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\n\n    // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n    // and unlike other auto values they don't make it back into the input,\n    // so newContainer won't have them.\n    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n      var tickMode = newContainer.tickmode;\n      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n    }\n    // FIXME: Similarly for axis ranges for 3D\n    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n    if (key === 'range' && newContainer.autorange) continue;\n    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n    valObject = getValObject(parts);\n\n    // in case type changed, we may not even *have* a valObject.\n    if (!valObject) continue;\n    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n    var valType = valObject.valType;\n    var i;\n    var canBeDataArray = valObjectCanBeDataArray(valObject);\n    var wasArray = Array.isArray(oldVal);\n    var nowArray = Array.isArray(newVal);\n\n    // hack for traces that modify the data in supplyDefaults, like\n    // converting 1D to 2D arrays, which will always create new objects\n    if (wasArray && nowArray) {\n      var inputKey = '_input_' + key;\n      var oldValIn = oldContainer[inputKey];\n      var newValIn = newContainer[inputKey];\n      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n    }\n    if (newVal === undefined) {\n      if (canBeDataArray && wasArray) flags.calc = true;else changed();\n    } else if (valObject._isLinkedToArray) {\n      var arrayEditIndices = [];\n      var extraIndices = false;\n      if (!inArray) flags.arrays[key] = arrayEditIndices;\n      var minLen = Math.min(oldVal.length, newVal.length);\n      var maxLen = Math.max(oldVal.length, newVal.length);\n      if (minLen !== maxLen) {\n        if (valObject.editType === 'arraydraw') {\n          extraIndices = true;\n        } else {\n          changed();\n          continue;\n        }\n      }\n      for (i = 0; i < minLen; i++) {\n        getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\n        // add array indices, but not if we're already in an array\n        Lib.extendFlat({\n          inArray: key,\n          arrayIndex: i\n        }, opts));\n      }\n\n      // put this at the end so that we know our collected array indices are sorted\n      // but the check for length changes happens up front so we can short-circuit\n      // diffing if appropriate\n      if (extraIndices) {\n        for (i = minLen; i < maxLen; i++) {\n          arrayEditIndices.push(i);\n        }\n      }\n    } else if (!valType && Lib.isPlainObject(oldVal)) {\n      getDiffFlags(oldVal, newVal, parts, opts);\n    } else if (canBeDataArray) {\n      if (wasArray && nowArray) {\n        // don't try to diff two data arrays. If immutable we know the data changed,\n        // if not, assume it didn't and let `layout.datarevision` tell us if it did\n        if (immutable) {\n          flags.calc = true;\n        }\n\n        // look for animatable attributes when the data changed\n        if (immutable || opts.newDataRevision) {\n          changed();\n        }\n      } else if (wasArray !== nowArray) {\n        flags.calc = true;\n      } else changed();\n    } else if (wasArray && nowArray) {\n      // info array, colorscale, 'any' - these are short, just stringify.\n      // I don't *think* that covers up any real differences post-validation, does it?\n      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n      // all elements.\n      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n        changed();\n      }\n    } else {\n      changed();\n    }\n  }\n  for (key in newContainer) {\n    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n      valObject = getValObject(outerparts.concat(key));\n      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n        flags.calc = true;\n        return;\n      } else changed();\n    }\n  }\n}\n\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\nfunction diffConfig(oldConfig, newConfig) {\n  var key;\n  for (key in oldConfig) {\n    if (key.charAt(0) === '_') continue;\n    var oldVal = oldConfig[key];\n    var newVal = newConfig[key];\n    if (oldVal !== newVal) {\n      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n        if (diffConfig(oldVal, newVal)) {\n          return true;\n        }\n      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {\n        if (oldVal.length !== newVal.length) {\n          return true;\n        }\n        for (var i = 0; i < oldVal.length; i++) {\n          if (oldVal[i] !== newVal[i]) {\n            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n              if (diffConfig(oldVal[i], newVal[i])) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n}\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n  gd = Lib.getGraphDiv(gd);\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plotly.com/javascript/animations/');\n  }\n  var trans = gd._transitionData;\n\n  // This is the queue of frames that will be animated as soon as possible. They\n  // are popped immediately upon the *start* of a transition:\n  if (!trans._frameQueue) {\n    trans._frameQueue = [];\n  }\n  animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n  var transitionOpts = animationOpts.transition;\n  var frameOpts = animationOpts.frame;\n\n  // Since frames are popped immediately, an empty queue only means all frames have\n  // *started* to transition, not that the animation is complete. To solve that,\n  // track a separate counter that increments at the same time as frames are added\n  // to the queue, but decrements only when the transition is complete.\n  if (trans._frameWaitingCnt === undefined) {\n    trans._frameWaitingCnt = 0;\n  }\n  function getTransitionOpts(i) {\n    if (Array.isArray(transitionOpts)) {\n      if (i >= transitionOpts.length) {\n        return transitionOpts[0];\n      } else {\n        return transitionOpts[i];\n      }\n    } else {\n      return transitionOpts;\n    }\n  }\n  function getFrameOpts(i) {\n    if (Array.isArray(frameOpts)) {\n      if (i >= frameOpts.length) {\n        return frameOpts[0];\n      } else {\n        return frameOpts[i];\n      }\n    } else {\n      return frameOpts;\n    }\n  }\n\n  // Execute a callback after the wrapper function has been called n times.\n  // This is used to defer the resolution until a transition has resolved *and*\n  // the frame has completed. If it's not done this way, then we get a race\n  // condition in which the animation might resolve before a transition is complete\n  // or vice versa.\n  function callbackOnNthTime(cb, n) {\n    var cnt = 0;\n    return function () {\n      if (cb && ++cnt === n) {\n        return cb();\n      }\n    };\n  }\n  return new Promise(function (resolve, reject) {\n    function discardExistingFrames() {\n      if (trans._frameQueue.length === 0) {\n        return;\n      }\n      while (trans._frameQueue.length) {\n        var next = trans._frameQueue.pop();\n        if (next.onInterrupt) {\n          next.onInterrupt();\n        }\n      }\n      gd.emit('plotly_animationinterrupted', []);\n    }\n    function queueFrames(frameList) {\n      if (frameList.length === 0) return;\n      for (var i = 0; i < frameList.length; i++) {\n        var computedFrame;\n        if (frameList[i].type === 'byname') {\n          // If it's a named frame, compute it:\n          computedFrame = Plots.computeFrame(gd, frameList[i].name);\n        } else {\n          // Otherwise we must have been given a simple object, so treat\n          // the input itself as the computed frame.\n          computedFrame = frameList[i].data;\n        }\n        var frameOpts = getFrameOpts(i);\n        var transitionOpts = getTransitionOpts(i);\n\n        // It doesn't make much sense for the transition duration to be greater than\n        // the frame duration, so limit it:\n        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n        var nextFrame = {\n          frame: computedFrame,\n          name: frameList[i].name,\n          frameOpts: frameOpts,\n          transitionOpts: transitionOpts\n        };\n        if (i === frameList.length - 1) {\n          // The last frame in this .animate call stores the promise resolve\n          // and reject callbacks. This is how we ensure that the animation\n          // loop (which may exist as a result of a *different* .animate call)\n          // still resolves or rejecdts this .animate call's promise. once it's\n          // complete.\n          nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n          nextFrame.onInterrupt = reject;\n        }\n        trans._frameQueue.push(nextFrame);\n      }\n\n      // Set it as never having transitioned to a frame. This will cause the animation\n      // loop to immediately transition to the next frame (which, for immediate mode,\n      // is the first frame in the list since all others would have been discarded\n      // below)\n      if (animationOpts.mode === 'immediate') {\n        trans._lastFrameAt = -Infinity;\n      }\n\n      // Only it's not already running, start a RAF loop. This could be avoided in the\n      // case that there's only one frame, but it significantly complicated the logic\n      // and only sped things up by about 5% or so for a lorenz attractor simulation.\n      // It would be a fine thing to implement, but the benefit of that optimization\n      // doesn't seem worth the extra complexity.\n      if (!trans._animationRaf) {\n        beginAnimationLoop();\n      }\n    }\n    function stopAnimationLoop() {\n      gd.emit('plotly_animated');\n\n      // Be sure to unset also since it's how we know whether a loop is already running:\n      window.cancelAnimationFrame(trans._animationRaf);\n      trans._animationRaf = null;\n    }\n    function nextFrame() {\n      if (trans._currentFrame && trans._currentFrame.onComplete) {\n        // Execute the callback and unset it to ensure it doesn't\n        // accidentally get called twice\n        trans._currentFrame.onComplete();\n      }\n      var newFrame = trans._currentFrame = trans._frameQueue.shift();\n      if (newFrame) {\n        // Since it's sometimes necessary to do deep digging into frame data,\n        // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n        // so check when casting the name, just to be absolutely certain:\n        var stringName = newFrame.name ? newFrame.name.toString() : null;\n        gd._fullLayout._currentFrame = stringName;\n        trans._lastFrameAt = Date.now();\n        trans._timeToNext = newFrame.frameOpts.duration;\n\n        // This is simply called and it's left to .transition to decide how to manage\n        // interrupting current transitions. That means we don't need to worry about\n        // how it resolves or what happens after this:\n        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {\n          if (newFrame.onComplete) {\n            newFrame.onComplete();\n          }\n        });\n        gd.emit('plotly_animatingframe', {\n          name: stringName,\n          frame: newFrame.frame,\n          animation: {\n            frame: newFrame.frameOpts,\n            transition: newFrame.transitionOpts\n          }\n        });\n      } else {\n        // If there are no more frames, then stop the RAF loop:\n        stopAnimationLoop();\n      }\n    }\n    function beginAnimationLoop() {\n      gd.emit('plotly_animating');\n\n      // If no timer is running, then set last frame = long ago so that the next\n      // frame is immediately transitioned:\n      trans._lastFrameAt = -Infinity;\n      trans._timeToNext = 0;\n      trans._runningTransitions = 0;\n      trans._currentFrame = null;\n      var doFrame = function () {\n        // This *must* be requested before nextFrame since nextFrame may decide\n        // to cancel it if there's nothing more to animated:\n        trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n        // Check if we're ready for a new frame:\n        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {\n          nextFrame();\n        }\n      };\n      doFrame();\n    }\n\n    // This is an animate-local counter that helps match up option input list\n    // items with the particular frame.\n    var configCounter = 0;\n    function setTransitionConfig(frame) {\n      if (Array.isArray(transitionOpts)) {\n        if (configCounter >= transitionOpts.length) {\n          frame.transitionOpts = transitionOpts[configCounter];\n        } else {\n          frame.transitionOpts = transitionOpts[0];\n        }\n      } else {\n        frame.transitionOpts = transitionOpts;\n      }\n      configCounter++;\n      return frame;\n    }\n\n    // Disambiguate what's sort of frames have been received\n    var i, frame;\n    var frameList = [];\n    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n    if (isSingleFrame) {\n      // In this case, a simple object has been passed to animate.\n      frameList.push({\n        type: 'object',\n        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n      });\n    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n      // In this case, null or undefined has been passed so that we want to\n      // animate *all* currently defined frames\n      for (i = 0; i < trans._frames.length; i++) {\n        frame = trans._frames[i];\n        if (!frame) continue;\n        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n          frameList.push({\n            type: 'byname',\n            name: String(frame.name),\n            data: setTransitionConfig({\n              name: frame.name\n            })\n          });\n        }\n      }\n    } else if (isFrameArray) {\n      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n        var frameOrName = frameOrGroupNameOrFrameList[i];\n        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n          frameOrName = String(frameOrName);\n          // In this case, there's an array and this frame is a string name:\n          frameList.push({\n            type: 'byname',\n            name: frameOrName,\n            data: setTransitionConfig({\n              name: frameOrName\n            })\n          });\n        } else if (Lib.isPlainObject(frameOrName)) {\n          frameList.push({\n            type: 'object',\n            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n          });\n        }\n      }\n    }\n\n    // Verify that all of these frames actually exist; return and reject if not:\n    for (i = 0; i < frameList.length; i++) {\n      frame = frameList[i];\n      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n        Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n        reject();\n        return;\n      }\n    }\n\n    // If the mode is either next or immediate, then all currently queued frames must\n    // be dumped and the corresponding .animate promises rejected.\n    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n      discardExistingFrames();\n    }\n    if (animationOpts.direction === 'reverse') {\n      frameList.reverse();\n    }\n    var currentFrame = gd._fullLayout._currentFrame;\n    if (currentFrame && animationOpts.fromcurrent) {\n      var idx = -1;\n      for (i = 0; i < frameList.length; i++) {\n        frame = frameList[i];\n        if (frame.type === 'byname' && frame.name === currentFrame) {\n          idx = i;\n          break;\n        }\n      }\n      if (idx > 0 && idx < frameList.length - 1) {\n        var filteredFrameList = [];\n        for (i = 0; i < frameList.length; i++) {\n          frame = frameList[i];\n          if (frameList[i].type !== 'byname' || i > idx) {\n            filteredFrameList.push(frame);\n          }\n        }\n        frameList = filteredFrameList;\n      }\n    }\n    if (frameList.length > 0) {\n      queueFrames(frameList);\n    } else {\n      // This is the case where there were simply no frames. It's a little strange\n      // since there's not much to do:\n      gd.emit('plotly_animated');\n      resolve();\n    }\n  });\n}\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nfunction addFrames(gd, frameList, indices) {\n  gd = Lib.getGraphDiv(gd);\n  if (frameList === null || frameList === undefined) {\n    return Promise.resolve();\n  }\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plotly.com/javascript/animations/');\n  }\n  var i, frame, j, idx;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n  if (!Array.isArray(frameList)) {\n    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n  }\n\n  // Create a sorted list of insertions since we run into lots of problems if these\n  // aren't in ascending order of index:\n  //\n  // Strictly for sorting. Make sure this is guaranteed to never collide with any\n  // already-exisisting indices:\n  var bigIndex = _frames.length + frameList.length * 2;\n  var insertions = [];\n  var _frameHashLocal = {};\n  for (i = frameList.length - 1; i >= 0; i--) {\n    if (!Lib.isPlainObject(frameList[i])) continue;\n\n    // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n    // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n    var lookupName = frameList[i].name;\n    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n    var newName = frameList[i].name;\n    var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n      numericNameWarningCount++;\n      Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name + '\" with a frame whose name of type \"number\" also equates to \"' + name + '\". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');\n      if (numericNameWarningCount === numericNameWarningCountLimit) {\n        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');\n      }\n    }\n    _frameHashLocal[lookupName] = {\n      name: lookupName\n    };\n    insertions.push({\n      frame: Plots.supplyFrameDefaults(frameList[i]),\n      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i\n    });\n  }\n\n  // Sort this, taking note that undefined insertions end up at the end:\n  insertions.sort(function (a, b) {\n    if (a.index > b.index) return -1;\n    if (a.index < b.index) return 1;\n    return 0;\n  });\n  var ops = [];\n  var revops = [];\n  var frameCount = _frames.length;\n  for (i = insertions.length - 1; i >= 0; i--) {\n    frame = insertions[i].frame;\n    if (typeof frame.name === 'number') {\n      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');\n    }\n    if (!frame.name) {\n      // Repeatedly assign a default name, incrementing the counter each time until\n      // we get a name that's not in the hashed lookup table:\n      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]);\n    }\n    if (_frameHash[frame.name]) {\n      // If frame is present, overwrite its definition:\n      for (j = 0; j < _frames.length; j++) {\n        if ((_frames[j] || {}).name === frame.name) break;\n      }\n      ops.push({\n        type: 'replace',\n        index: j,\n        value: frame\n      });\n      revops.unshift({\n        type: 'replace',\n        index: j,\n        value: _frames[j]\n      });\n    } else {\n      // Otherwise insert it at the end of the list:\n      idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n      ops.push({\n        type: 'insert',\n        index: idx,\n        value: frame\n      });\n      revops.unshift({\n        type: 'delete',\n        index: idx\n      });\n      frameCount++;\n    }\n  }\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nfunction deleteFrames(gd, frameList) {\n  gd = Lib.getGraphDiv(gd);\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n  var i, idx;\n  var _frames = gd._transitionData._frames;\n  var ops = [];\n  var revops = [];\n  if (!frameList) {\n    frameList = [];\n    for (i = 0; i < _frames.length; i++) {\n      frameList.push(i);\n    }\n  }\n  frameList = frameList.slice();\n  frameList.sort();\n  for (i = frameList.length - 1; i >= 0; i--) {\n    idx = frameList[i];\n    ops.push({\n      type: 'delete',\n      index: idx\n    });\n    revops.unshift({\n      type: 'insert',\n      index: idx,\n      value: _frames[idx]\n    });\n  }\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Purge a graph container div back to its initial pre-_doPlot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nfunction purge(gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n  var fullData = gd._fullData || [];\n\n  // remove gl contexts\n  Plots.cleanPlot([], {}, fullData, fullLayout);\n\n  // purge properties\n  Plots.purge(gd);\n\n  // purge event emitter methods\n  Events.purge(gd);\n\n  // remove plot container\n  if (fullLayout._container) fullLayout._container.remove();\n\n  // in contrast to _doPlots.purge which does NOT clear _context!\n  delete gd._context;\n  return gd;\n}\n\n// determines if the graph div requires a recalculation of its inverse matrix transforms by comparing old + new bounding boxes.\nfunction calcInverseTransform(gd) {\n  var fullLayout = gd._fullLayout;\n  var newBBox = gd.getBoundingClientRect();\n  if (Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;\n  var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));\n  fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);\n  fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);\n  fullLayout._lastBBox = newBBox;\n}\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n  var gd3 = d3.select(gd);\n  var fullLayout = gd._fullLayout;\n  fullLayout._calcInverseTransform = calcInverseTransform;\n  fullLayout._calcInverseTransform(gd);\n\n  // Plot container\n  fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true)\n  // The plot container should always take the full with the height of its\n  // parent (the graph div). This ensures that for responsive plots\n  // without a height or width set, the paper div will take up the full\n  // height & width of the graph div. \n  // So, for responsive plots without a height or width set, if the plot\n  // container's height is left to 'auto', its height will be dictated by\n  // its childrens' height. (The plot container's only child is the paper\n  // div.) \n  // In this scenario, the paper div's height will be set to 100%,\n  // which will be 100% of the plot container's auto height. That is\n  // meaninglesss, so the browser will use the paper div's children to set\n  // the height of the plot container instead. However, the paper div's\n  // children do not have any height, because they are all positioned\n  // absolutely, and therefore take up no space.\n  .style({\n    width: \"100%\",\n    height: \"100%\"\n  });\n\n  // Make the svg container\n  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n  fullLayout._paperdiv.enter().append('div').classed('user-select-none', true).classed('svg-container', true).style('position', 'relative');\n\n  // Make the graph containers\n  // start fresh each time we get here, so we know the order comes out\n  // right, rather than enter/exit which can muck up the order\n  // TODO: sort out all the ordering so we don't have to\n  // explicitly delete anything\n  // FIXME: parcoords reuses this object, not the best pattern\n  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);\n  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);\n  fullLayout._paperdiv.selectAll('.main-svg').remove();\n  fullLayout._paperdiv.select('.modebar-container').remove();\n  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);\n  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n  delete fullLayout._modeBar;\n  fullLayout._hoverpaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  if (!fullLayout._uid) {\n    var otherUids = {};\n    d3.selectAll('defs').each(function () {\n      if (this.id) otherUids[this.id.split('-')[1]] = 1;\n    });\n    fullLayout._uid = Lib.randstr(otherUids);\n  }\n  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);\n  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);\n  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);\n  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);\n  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);\n  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);\n  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true);\n\n  // lower shape/image layer - note that this is behind\n  // all subplots data/grids but above the backgrounds\n  // except inset subplots, whose backgrounds are drawn\n  // inside their own group so that they appear above\n  // the data for the main subplot\n  // lower shapes and images which are fully referenced to\n  // a subplot still get drawn within the subplot's group\n  // so they will work correctly on insets\n  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);\n  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);\n  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true);\n\n  // single cartesian layer for the whole plot\n  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n  // single polar layer for the whole plot\n  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\n\n  // single smith layer for the whole plot\n  fullLayout._smithlayer = fullLayout._paper.append('g').classed('smithlayer', true);\n\n  // single ternary layer for the whole plot\n  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n  // single geo layer for the whole plot\n  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n  // single funnelarea layer for the whole plot\n  fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true);\n\n  // single pie layer for the whole plot\n  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n  // single treemap layer for the whole plot\n  fullLayout._iciclelayer = fullLayout._paper.append('g').classed('iciclelayer', true);\n\n  // single treemap layer for the whole plot\n  fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true);\n\n  // single sunburst layer for the whole plot\n  fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true);\n\n  // single indicator layer for the whole plot\n  fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true);\n\n  // fill in image server scrape-svg\n  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n  // lastly upper shapes, info (legend, annotations) and hover layers go on top\n  // these are in a different svg element normally, but get collapsed into a single\n  // svg when exporting (after inserting 3D)\n  // upper shapes/images are only those drawn above the whole plot, including subplots\n  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);\n  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);\n  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);\n  fullLayout._selectionLayer = fullLayout._toppaper.append('g').classed('selectionlayer', true);\n  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n  fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true);\n\n  // Make the modebar container\n  fullLayout._modebardiv.classed('modebar-container', true).style('position', 'absolute').style('top', '0px').style('right', '0px');\n  gd.emit('plotly_framework');\n}\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\nexports.newPlot = newPlot;\nexports._doPlot = _doPlot;\nexports.purge = purge;\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\nexports.setPlotConfig = setPlotConfig;\nexports.update = update;\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;","map":{"version":3,"names":["d3","require","isNumeric","hasHover","Lib","nestedProperty","Events","Queue","Registry","PlotSchema","Plots","Axes","handleRangeDefaults","cartesianLayoutAttributes","Drawing","Color","initInteractions","xmlnsNamespaces","clearOutline","dfltConfig","manageArrays","helpers","subroutines","editTypes","AX_NAME_PATTERN","numericNameWarningCount","numericNameWarningCountLimit","_doPlot","gd","data","layout","config","frames","getGraphDiv","init","isPlainObject","obj","okToPlot","triggerHandler","Promise","reject","isPlotDiv","warn","addFrames","exports","setPlotContext","select","classed","makeTester","Array","isArray","_promises","graphWasEmpty","length","cleanData","push","apply","empty","cleanLayout","supplyDefaults","fullLayout","_fullLayout","hasCartesian","_has","_replotting","_shouldCreateBgLayer","makePlotFramework","initGradients","initPatterns","saveShowSpikeInitial","recalc","calcdata","_fullData","doCalcdata","i","trace","_context","responsive","_responsiveChartHandler","isHidden","resize","window","addEventListener","clearResponsive","oldMargins","extendFlat","_size","drawFrameworkCalls","drawFramework","basePlotModules","_basePlotModules","_glcanvas","_glcontainer","selectAll","key","context","pick","d","enter","append","attr","replace","style","position","top","left","overflow","plotGlPixelRatio","width","height","regl","Math","floor","_gl","drawingBufferWidth","drawingBufferHeight","msg","error","log","cleanPlot","modebar","orientation","_modebardiv","previousPromises","marginPushers","clearAutoMarginIds","drawMarginPushers","allowAutoMargin","title","text","automargin","fullData","type","uid","doAutoMargin","marginPushersAgain","didMarginChange","syncOrAsync","layoutStyles","positionAndAutorange","doAutoRangeAndConstraints","getComponentMethod","_transitioning","saveRangeInitial","drawAxes","draw","seq","insideTickLabelsAutorange","insideTickLabelsUpdaterange","_insideTickLabelsUpdaterange","undefined","relayout","then","drawData","finalDraw","addLinks","rehover","redrag","reselect","plotDone","resolve","emitAfterPlot","_redrawFromAutoMarginCount","emit","setPlotConfig","setBackground","bgColor","_paper","e","opaqueSetBackground","blend","combine","extendDeep","base","_baseUrl","size","location","href","split","keys","Object","plot3dPixelRatio","editable","edits","_exportedPlot","staticPlot","autosizable","scrollZoom","doubleClick","showTips","showLink","displayModeBar","_hasZeroHeight","clientHeight","_hasZeroWidth","clientWidth","szIn","szOut","_scrollZoom","cartesian","gl3d","geo","mapbox","map","parts","redraw","Error","newPlot","purge","positivifyIndices","indices","maxIndex","parentLength","positiveIndices","index","assertIndexArray","arrayName","parseInt","indexOf","checkMoveTracesArgs","currentIndices","newIndices","checkAddTracesArgs","traces","value","assertExtendTracesArgs","update","maxPoints","maxPointsIsObject","getExtendProperties","updateProps","target","prop","insert","maxp","j","get","isArrayOrTypedArray","constructor","spliceTraces","updateArray","undoUpdate","undoPoints","out","set","astr","concatTypedArray","arr0","arr1","arr2","extendTraces","newArray","remainder","isTypedArray","none","both","numberOfItemsFromInsert","subarray","numberOfItemsFromTarget","targetBegin","concat","splice","undo","promise","undoArgs","add","prependTraces","arguments","addTraces","undoFunc","deleteTraces","redoFunc","redoArgs","startSequence","moveTraces","stopSequence","deletedTrace","sort","sorterDes","newData","movingTraceMap","newIndex","a","b","restyle","val","_traces","clearPromiseQueue","aobj","changed","coerceTraceIndices","specs","_restyle","flags","calc","clearAxisTypes","fullReplot","markerSize","addAxRangeSequence","doTraceStyle","colorbars","doColorBars","undoit","redoit","eventData","undefinedToNull","makeNP","preGUI","guiEditFlag","container","prefix","np","npSet","fullAttr","storeCurrent","newVal","arrayVal","arrayNew","maxLen","max","objVal","objNew","objBoth","_storeDirectGUIEdit","_guiEditing","layoutNP","_preGUI","extendDeepAll","cleanDeprecatedAttributeKeys","traceFlags","axlist","a0","addToAxlist","axid","axName","id2name","autorangeAttr","rangeAttr","getFullTrace","traceIndex","_input","doextra","forEach","hasParent","extraparam","substr","tracei","_tracePreGUI","_fullInput","allBins","binAttr","arrayBins","vij","ai","vi","cont","contFull","param","oldVal","valObject","charAt","finalPart","prefixDot","innerContFull","getTraceValObject","impliedEdits","impliedKey","relativeAttr","gs","orient","topOrBottom","thicknorm","h","w","thickness","lennorm","len","labelsTo","valuesTo","swapAttrs","_pielayer","remove","traceIs","defaultOrientation","x","y","v","swapXYData","dataArrayContainers","manageArrayContainers","arrayOk","swap","hovermode","xaxis","yaxis","plot","extendDeepNoArrays","oldAxisTitleRegex","counterRegex","colorbarRegex","test","oldAttrStr","newAttrStr","_relayout","layoutReplot","axRangeSupplyDefaultsByPass","legend","doLegend","layoutstyle","axrange","rangesAltered","ticks","doTicksRelayout","doModeBar","camera","doCamera","k","axIn","axOut","coerce","dflt","options","axId","_matchGroup","axId2","ax2","autorange","range","slice","axIds","skipTitle","id","ax","getFromId","ticklabelposition","_anchorAxis","_id","id2","AX_RANGE_RE","AX_AUTORANGE_RE","AX_DOMAIN_RE","axes","list","arrayEdits","arrayStr","scene","axisAttr","newkey","_name","layoutFlags","p","recordAlteredAxis","pleafPlus","name2id","plen","pend","pleaf","ptrunk","join","parentIn","parentFull","vOld","getLayoutValObject","oppositeAttr","_initialAutoSize","match","axFull","_inputDomain","domain","toLog","fromLog","r0","r1","LN10","pow","_subplots","polar","_subplot","viewInitial","fullProp","newType","containerArrayMatch","array","propStr","property","updateValObject","editType","isAddVal","isRemoveVal","objEdits","reverse","finished","applyContainerArrayChanges","group","_constraintGroup","groupAxId","_constraintShrinkable","updateAutosize","shapes","showlegend","oldWidth","oldHeight","autosize","plotAutoSize","traceUpdate","layoutUpdate","restyleSpecs","restyleFlags","relayoutSpecs","relayoutFlags","guiEdit","func","wrappedEdit","layoutUIControlPatterns","pattern","traceUIControlPatterns","findUIPattern","patternSpecs","spec","head","tail","getNewRev","revAttr","newRev","pop","uirevision","getFullTraceIndexFromUid","getTraceIndexFromUid","valsMatch","v1","v2","v1IsObj","v1IsArray","JSON","stringify","applyUIRevisions","oldFullData","oldFullLayout","layoutPreGUI","oldRev","preGUIVal","newNP","bothInheritAutorange","newAutorangeIn","newRangeAccepted","pre0","pre1","preAuto","newContainer","axAttr","newAx","allTracePreGUI","tracePreGUI","newTrace","fullInput","fulli","fullTrace","newTracei","react","configChanged","oldConfig","diffConfig","skipUpdateCalc","newFullData","newFullLayout","immutable","datarevision","transition","diffLayout","newDataRevision","diffData","allNames","getOwnPropertyNames","q","name","start","substring","emptyCategories","_emptyCategories","supplyDefaultsUpdateCalc","_transitionData","createTransitionData","anim","transitionFromReact","_skipDefaults","componentType","arrays","drawOne","noop","sameTraceLength","nChanges","nChangesAnim","_module","animatable","diffOpts","getValObject","seenUIDs","hasMakesDataTransform","getDiffFlags","oldContainer","outerparts","opts","inArray","arrayIndex","pushUnique","valObjectCanBeDataArray","valType","tickMode","tickmode","_compareAsJSON","canBeDataArray","wasArray","nowArray","inputKey","oldValIn","newValIn","_isLinkedToArray","arrayEditIndices","extraIndices","minLen","min","String","newConfig","animate","frameOrGroupNameOrFrameList","animationOpts","trans","_frameQueue","supplyAnimationDefaults","transitionOpts","frameOpts","frame","_frameWaitingCnt","getTransitionOpts","getFrameOpts","callbackOnNthTime","cb","n","cnt","discardExistingFrames","next","onInterrupt","queueFrames","frameList","computedFrame","computeFrame","duration","nextFrame","onComplete","mode","_lastFrameAt","Infinity","_animationRaf","beginAnimationLoop","stopAnimationLoop","cancelAnimationFrame","_currentFrame","newFrame","shift","stringName","toString","Date","now","_timeToNext","animation","_runningTransitions","doFrame","requestAnimationFrame","configCounter","setTransitionConfig","allFrames","isFrameArray","isSingleFrame","_frames","frameOrName","_frameHash","direction","currentFrame","fromcurrent","idx","filteredFrameList","bigIndex","insertions","_frameHashLocal","lookupName","newName","collisionPresent","supplyFrameDefaults","ops","revops","frameCount","_counter","unshift","modifyFrames","deleteFrames","_container","calcInverseTransform","newBBox","getBoundingClientRect","equalDomRects","_lastBBox","m","_invTransform","inverseTransformMatrix","getFullTransformMatrix","_invScaleX","sqrt","_invScaleY","gd3","_calcInverseTransform","_paperdiv","_toppaper","_modeBar","_hoverpaper","_uid","otherUids","each","randstr","svgAttrs","_defs","_clips","_topdefs","_topclips","_bgLayer","_draggers","layerBelow","_imageLowerLayer","_shapeLowerLayer","_cartesianlayer","_polarlayer","_smithlayer","_ternarylayer","_geolayer","_funnelarealayer","_iciclelayer","_treemaplayer","_sunburstlayer","_indicatorlayer","_glimages","layerAbove","_imageUpperLayer","_shapeUpperLayer","_selectionLayer","_infolayer","_menulayer","_zoomlayer","_hoverlayer","_guiRelayout","_guiRestyle","_guiUpdate"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plot_api/plot_api.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\n\nvar Axes = require('../plots/cartesian/axes');\nvar handleRangeDefaults = require('../plots/cartesian/range_defaults');\n\nvar cartesianLayoutAttributes = require('../plots/cartesian/layout_attributes');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar clearOutline = require('../components/selections').clearOutline;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n\n/**\n * Internal plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction _doPlot(gd, data, layout, config) {\n    var frames;\n\n    gd = Lib.getGraphDiv(gd);\n\n    // Events.init is idempotent and bails early if gd has already been init'd\n    Events.init(gd);\n\n    if(Lib.isPlainObject(data)) {\n        var obj = data;\n        data = obj.data;\n        layout = obj.layout;\n        config = obj.config;\n        frames = obj.frames;\n    }\n\n    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n    if(okToPlot === false) return Promise.reject();\n\n    // if there's no data or layout, and this isn't yet a plotly plot\n    // container, log a warning to help plotly.js users debug\n    if(!data && !layout && !Lib.isPlotDiv(gd)) {\n        Lib.warn('Calling _doPlot as if redrawing ' +\n            'but this container doesn\\'t yet have a plot.', gd);\n    }\n\n    function addFrames() {\n        if(frames) {\n            return exports.addFrames(gd, frames);\n        }\n    }\n\n    // transfer configuration options to gd until we move over to\n    // a more OO like model\n    setPlotContext(gd, config);\n\n    if(!layout) layout = {};\n\n    // hook class for plots main container (in case of plotly.js\n    // this won't be #embedded-graph or .js-tab-contents)\n    d3.select(gd).classed('js-plotly-plot', true);\n\n    // off-screen getBoundingClientRect testing space,\n    // in #js-plotly-tester (and stored as Drawing.tester)\n    // so we can share cached text across tabs\n    Drawing.makeTester();\n\n    // collect promises for any async actions during plotting\n    // any part of the plotting code can push to gd._promises, then\n    // before we move to the next step, we check that they're all\n    // complete, and empty out the promise list again.\n    if(!Array.isArray(gd._promises)) gd._promises = [];\n\n    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));\n\n    // if there is already data on the graph, append the new data\n    // if you only want to redraw, pass a non-array for data\n    if(Array.isArray(data)) {\n        helpers.cleanData(data);\n\n        if(graphWasEmpty) gd.data = data;\n        else gd.data.push.apply(gd.data, data);\n\n        // for routines outside graph_obj that want a clean tab\n        // (rather than appending to an existing one) gd.empty\n        // is used to determine whether to make a new tab\n        gd.empty = false;\n    }\n\n    if(!gd.layout || graphWasEmpty) {\n        gd.layout = helpers.cleanLayout(layout);\n    }\n\n    Plots.supplyDefaults(gd);\n\n    var fullLayout = gd._fullLayout;\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // so we don't try to re-call _doPlot from inside\n    // legend and colorbar, if margins changed\n    fullLayout._replotting = true;\n\n    // make or remake the framework if we need to\n    if(graphWasEmpty || fullLayout._shouldCreateBgLayer) {\n        makePlotFramework(gd);\n\n        if(fullLayout._shouldCreateBgLayer) {\n            delete fullLayout._shouldCreateBgLayer;\n        }\n    }\n\n    // clear gradient and pattern defs on each .plot call, because we know we'll loop through all traces\n    Drawing.initGradients(gd);\n    Drawing.initPatterns(gd);\n\n    // save initial show spikes once per graph\n    if(graphWasEmpty) Axes.saveShowSpikeInitial(gd);\n\n    // prepare the data and find the autorange\n\n    // generate calcdata, if we need to\n    // to force redoing calcdata, just delete it before calling _doPlot\n    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n    if(recalc) Plots.doCalcdata(gd);\n\n    // in case it has changed, attach fullData traces to calcdata\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        gd.calcdata[i][0].trace = gd._fullData[i];\n    }\n\n    // make the figure responsive\n    if(gd._context.responsive) {\n        if(!gd._responsiveChartHandler) {\n            // Keep a reference to the resize handler to purge it down the road\n            gd._responsiveChartHandler = function() { if(!Lib.isHidden(gd)) Plots.resize(gd); };\n\n            // Listen to window resize\n            window.addEventListener('resize', gd._responsiveChartHandler);\n        }\n    } else {\n        Lib.clearResponsive(gd);\n    }\n\n    /*\n     * start async-friendly code - now we're actually drawing things\n     */\n\n    var oldMargins = Lib.extendFlat({}, fullLayout._size);\n\n    // draw framework first so that margin-pushing\n    // components can position themselves correctly\n    var drawFrameworkCalls = 0;\n    function drawFramework() {\n        var basePlotModules = fullLayout._basePlotModules;\n\n        for(var i = 0; i < basePlotModules.length; i++) {\n            if(basePlotModules[i].drawFramework) {\n                basePlotModules[i].drawFramework(gd);\n            }\n        }\n\n        if(!fullLayout._glcanvas && fullLayout._has('gl')) {\n            fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n                key: 'contextLayer',\n                context: true,\n                pick: false\n            }, {\n                key: 'focusLayer',\n                context: false,\n                pick: false\n            }, {\n                key: 'pickLayer',\n                context: false,\n                pick: true\n            }], function(d) { return d.key; });\n\n            fullLayout._glcanvas.enter().append('canvas')\n                .attr('class', function(d) {\n                    return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n                })\n                .style({\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    overflow: 'visible',\n                    'pointer-events': 'none'\n                });\n        }\n\n        var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n        if(fullLayout._glcanvas) {\n            fullLayout._glcanvas\n                .attr('width', fullLayout.width * plotGlPixelRatio)\n                .attr('height', fullLayout.height * plotGlPixelRatio)\n                .style('width', fullLayout.width + 'px')\n                .style('height', fullLayout.height + 'px');\n\n            var regl = fullLayout._glcanvas.data()[0].regl;\n            if(regl) {\n                // Unfortunately, this can happen when relayouting to large\n                // width/height on some browsers.\n                if(Math.floor(fullLayout.width * plotGlPixelRatio) !== regl._gl.drawingBufferWidth ||\n                    Math.floor(fullLayout.height * plotGlPixelRatio) !== regl._gl.drawingBufferHeight\n                 ) {\n                    var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n                    if(drawFrameworkCalls) {\n                        Lib.error(msg);\n                    } else {\n                        Lib.log(msg + ' Clearing graph and plotting again.');\n                        Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n                        Plots.supplyDefaults(gd);\n                        fullLayout = gd._fullLayout;\n                        Plots.doCalcdata(gd);\n                        drawFrameworkCalls++;\n                        return drawFramework();\n                    }\n                }\n            }\n        }\n\n        if(fullLayout.modebar.orientation === 'h') {\n            fullLayout._modebardiv\n              .style('height', null)\n              .style('width', '100%');\n        } else {\n            fullLayout._modebardiv\n              .style('width', null)\n              .style('height', fullLayout.height + 'px');\n        }\n\n        return Plots.previousPromises(gd);\n    }\n\n    // draw anything that can affect margins.\n    function marginPushers() {\n        // First reset the list of things that are allowed to change the margins\n        // So any deleted traces or components will be wiped out of the\n        // automargin calculation.\n        // This means *every* margin pusher must be listed here, even if it\n        // doesn't actually try to push the margins until later.\n        Plots.clearAutoMarginIds(gd);\n\n        subroutines.drawMarginPushers(gd);\n        Axes.allowAutoMargin(gd);\n        if(gd._fullLayout.title.text && gd._fullLayout.title.automargin) Plots.allowAutoMargin(gd, 'title.automargin');\n\n        // TODO can this be moved elsewhere?\n        if(fullLayout._has('pie')) {\n            var fullData = gd._fullData;\n            for(var i = 0; i < fullData.length; i++) {\n                var trace = fullData[i];\n                if(trace.type === 'pie' && trace.automargin) {\n                    Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n                }\n            }\n        }\n\n        Plots.doAutoMargin(gd);\n        return Plots.previousPromises(gd);\n    }\n\n    // in case the margins changed, draw margin pushers again\n    function marginPushersAgain() {\n        if(!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n\n        return Lib.syncOrAsync([\n            marginPushers,\n            subroutines.layoutStyles\n        ], gd);\n    }\n\n    function positionAndAutorange() {\n        if(!recalc) {\n            doAutoRangeAndConstraints();\n            return;\n        }\n\n        // TODO: autosize extra for text markers and images\n        // see https://github.com/plotly/plotly.js/issues/1111\n        return Lib.syncOrAsync([\n            Registry.getComponentMethod('shapes', 'calcAutorange'),\n            Registry.getComponentMethod('annotations', 'calcAutorange'),\n            doAutoRangeAndConstraints\n        ], gd);\n    }\n\n    function doAutoRangeAndConstraints() {\n        if(gd._transitioning) return;\n\n        subroutines.doAutoRangeAndConstraints(gd);\n\n        // store initial ranges *after* enforcing constraints, otherwise\n        // we will never look like we're at the initial ranges\n        if(graphWasEmpty) Axes.saveRangeInitial(gd);\n\n        // this one is different from shapes/annotations calcAutorange\n        // the others incorporate those components into ax._extremes,\n        // this one actually sets the ranges in rangesliders.\n        Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n    }\n\n    // draw ticks, titles, and calculate axis scaling (._b, ._m)\n    function drawAxes() {\n        return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n    }\n\n    var seq = [\n        Plots.previousPromises,\n        addFrames,\n        drawFramework,\n        marginPushers,\n        marginPushersAgain\n    ];\n\n    if(hasCartesian) seq.push(positionAndAutorange);\n\n    seq.push(subroutines.layoutStyles);\n    if(hasCartesian) {\n        seq.push(\n            drawAxes,\n            function insideTickLabelsAutorange(gd) {\n                var insideTickLabelsUpdaterange = gd._fullLayout._insideTickLabelsUpdaterange;\n                if(insideTickLabelsUpdaterange) {\n                    gd._fullLayout._insideTickLabelsUpdaterange = undefined;\n\n                    return relayout(gd, insideTickLabelsUpdaterange).then(function() {\n                        Axes.saveRangeInitial(gd, true);\n                    });\n                }\n            }\n        );\n    }\n\n    seq.push(\n        subroutines.drawData,\n        subroutines.finalDraw,\n        initInteractions,\n        Plots.addLinks,\n        Plots.rehover,\n        Plots.redrag,\n        Plots.reselect,\n        // TODO: doAutoMargin is only needed here for axis automargin, which\n        // happens outside of marginPushers where all the other automargins are\n        // calculated. Would be much better to separate margin calculations from\n        // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n        Plots.doAutoMargin,\n        Plots.previousPromises\n    );\n\n    // even if everything we did was synchronous, return a promise\n    // so that the caller doesn't care which route we took\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        emitAfterPlot(gd);\n        return gd;\n    });\n}\n\nfunction emitAfterPlot(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(fullLayout._redrawFromAutoMarginCount) {\n        fullLayout._redrawFromAutoMarginCount--;\n    } else {\n        gd.emit('plotly_afterplot');\n    }\n}\n\nfunction setPlotConfig(obj) {\n    return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n    try {\n        gd._fullLayout._paper.style('background', bgColor);\n    } catch(e) {\n        Lib.error(e);\n    }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n    var blend = Color.combine(bgColor, 'white');\n    setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n    if(!gd._context) {\n        gd._context = Lib.extendDeep({}, dfltConfig);\n\n        // stash <base> href, used to make robust clipPath URLs\n        var base = d3.select('base');\n        gd._context._baseUrl = base.size() && base.attr('href') ?\n            window.location.href.split('#')[0] :\n            '';\n    }\n\n    var context = gd._context;\n\n    var i, keys, key;\n\n    if(config) {\n        keys = Object.keys(config);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            if(key === 'editable' || key === 'edits') continue;\n            if(key in context) {\n                if(key === 'setBackground' && config[key] === 'opaque') {\n                    context[key] = opaqueSetBackground;\n                } else {\n                    context[key] = config[key];\n                }\n            }\n        }\n\n        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n            context.plotGlPixelRatio = context.plot3dPixelRatio;\n        }\n\n        // now deal with editable and edits - first editable overrides\n        // everything, then edits refines\n        var editable = config.editable;\n        if(editable !== undefined) {\n            // we're not going to *use* context.editable, we're only going to\n            // use context.edits... but keep it for the record\n            context.editable = editable;\n\n            keys = Object.keys(context.edits);\n            for(i = 0; i < keys.length; i++) {\n                context.edits[keys[i]] = editable;\n            }\n        }\n        if(config.edits) {\n            keys = Object.keys(config.edits);\n            for(i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if(key in context.edits) {\n                    context.edits[key] = config.edits[key];\n                }\n            }\n        }\n\n        // not part of the user-facing config options\n        context._exportedPlot = config._exportedPlot;\n    }\n\n    // staticPlot forces a bunch of others:\n    if(context.staticPlot) {\n        context.editable = false;\n        context.edits = {};\n        context.autosizable = false;\n        context.scrollZoom = false;\n        context.doubleClick = false;\n        context.showTips = false;\n        context.showLink = false;\n        context.displayModeBar = false;\n    }\n\n    // make sure hover-only devices have mode bar visible\n    if(context.displayModeBar === 'hover' && !hasHover) {\n        context.displayModeBar = true;\n    }\n\n    // default and fallback for setBackground\n    if(context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n        context.setBackground = setBackground;\n    }\n\n    // Check if gd has a specified widht/height to begin with\n    context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n    context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\n\n    // fill context._scrollZoom helper to help manage scrollZoom flaglist\n    var szIn = context.scrollZoom;\n    var szOut = context._scrollZoom = {};\n    if(szIn === true) {\n        szOut.cartesian = 1;\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n        szOut.map = 1;\n    } else if(typeof szIn === 'string') {\n        var parts = szIn.split('+');\n        for(i = 0; i < parts.length; i++) {\n            szOut[parts[i]] = 1;\n        }\n    } else if(szIn !== false) {\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n        szOut.map = 1;\n    }\n}\n\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nfunction redraw(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    helpers.cleanData(gd.data);\n    helpers.cleanLayout(gd.layout);\n\n    gd.calcdata = undefined;\n    return exports._doPlot(gd).then(function() {\n        gd.emit('plotly_redraw');\n        return gd;\n    });\n}\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nfunction newPlot(gd, data, layout, config) {\n    gd = Lib.getGraphDiv(gd);\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n\n    Plots.purge(gd);\n    return exports._doPlot(gd, data, layout, config);\n}\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n    var parentLength = maxIndex + 1;\n    var positiveIndices = [];\n    var i;\n    var index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n        if(index < 0) {\n            positiveIndices.push(parentLength + index);\n        } else {\n            positiveIndices.push(index);\n        }\n    }\n    return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n    var i,\n        index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n\n        // validate that indices are indeed integers\n        if(index !== parseInt(index, 10)) {\n            throw new Error('all values in ' + arrayName + ' must be integers');\n        }\n\n        // check that all indices are in bounds for given gd.data array length\n        if(index >= gd.data.length || index < -gd.data.length) {\n            throw new Error(arrayName + ' must be valid indices for gd.data.');\n        }\n\n        // check that indices aren't repeated\n        if(indices.indexOf(index, i + 1) > -1 ||\n                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||\n                index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n            throw new Error('each index in ' + arrayName + ' must be unique.');\n        }\n    }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // validate currentIndices array\n    if(typeof currentIndices === 'undefined') {\n        throw new Error('currentIndices is a required argument.');\n    } else if(!Array.isArray(currentIndices)) {\n        currentIndices = [currentIndices];\n    }\n    assertIndexArray(gd, currentIndices, 'currentIndices');\n\n    // validate newIndices array if it exists\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined') {\n        assertIndexArray(gd, newIndices, 'newIndices');\n    }\n\n    // check currentIndices and newIndices are the same length if newIdices exists\n    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n        throw new Error('current and new indices must be of equal length.');\n    }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n    var i, value;\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // make sure traces exists\n    if(typeof traces === 'undefined') {\n        throw new Error('traces must be defined.');\n    }\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure each value in traces is an object\n    for(i = 0; i < traces.length; i++) {\n        value = traces[i];\n        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {\n            throw new Error('all values in traces array must be non-array objects');\n        }\n    }\n\n    // make sure we have an index for each trace\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n        throw new Error(\n            'if indices is specified, traces.length must equal indices.length'\n        );\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array');\n    }\n    if(!Lib.isPlainObject(update)) {\n        throw new Error('update must be a key:value object');\n    }\n\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers');\n    }\n\n    assertIndexArray(gd, indices, 'indices');\n\n    for(var key in update) {\n        /*\n         * Verify that the attribute to be updated contains as many trace updates\n         * as indices. Failure must result in throw and no-op\n         */\n        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {\n            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n        }\n\n        /*\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n         */\n        if(maxPointsIsObject &&\n            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||\n            maxPoints[key].length !== update[key].length)) {\n            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +\n                            'corrispondence with the keys and number of traces in the update object');\n        }\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n    var updateProps = [];\n    var trace, target, prop, insert, maxp;\n\n    // allow scalar index to represent a single trace position\n    if(!Array.isArray(indices)) indices = [indices];\n\n    // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // loop through all update keys and traces and harvest validated data.\n    for(var key in update) {\n        for(var j = 0; j < indices.length; j++) {\n            /*\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\n             * instance that references the key and value for this particular trace.\n             */\n            trace = gd.data[indices[j]];\n            prop = nestedProperty(trace, key);\n\n            /*\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n             * Target must exist as an Array to allow the extend operation to be performed.\n             */\n            target = prop.get();\n            insert = update[key][j];\n\n            if(!Lib.isArrayOrTypedArray(insert)) {\n                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n            }\n            if(!Lib.isArrayOrTypedArray(target)) {\n                throw new Error('cannot extend missing or non-array attribute: ' + key);\n            }\n            if(target.constructor !== insert.constructor) {\n                throw new Error('cannot extend array with an array of a different type: ' + key);\n            }\n\n            /*\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\n             * Use the scalar maxPoints for all key and trace combinations.\n             */\n            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n            // could have chosen null here, -1 just tells us to not take a window\n            if(!isNumeric(maxp)) maxp = -1;\n\n            /*\n             * Wrap the nestedProperty in an object containing required data\n             * for lengthening and windowing this particular trace - key combination.\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n             */\n            updateProps.push({\n                prop: prop,\n                target: target,\n                insert: insert,\n                maxp: Math.floor(maxp)\n            });\n        }\n    }\n\n    // all target and insertion data now validated\n    return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n    assertExtendTracesArgs(gd, update, indices, maxPoints);\n\n    var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n    var undoUpdate = {};\n    var undoPoints = {};\n\n    for(var i = 0; i < updateProps.length; i++) {\n        var prop = updateProps[i].prop;\n        var maxp = updateProps[i].maxp;\n\n        // return new array and remainder\n        var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n        prop.set(out[0]);\n\n        // build the inverse update object for the undo operation\n        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n        undoUpdate[prop.astr].push(out[1]);\n\n         // build the matching maxPoints undo object containing original trace lengths\n        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n        undoPoints[prop.astr].push(updateProps[i].target.length);\n    }\n\n    return {update: undoUpdate, maxPoints: undoPoints};\n}\n\nfunction concatTypedArray(arr0, arr1) {\n    var arr2 = new arr0.constructor(arr0.length + arr1.length);\n    arr2.set(arr0);\n    arr2.set(arr1, arr0.length);\n    return arr2;\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nfunction extendTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp < 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(target, insert);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target);\n                    remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n                    var targetBegin = target.length - numberOfItemsFromTarget;\n\n                    newArray.set(target.subarray(targetBegin));\n                    newArray.set(insert, numberOfItemsFromTarget);\n                    remainder.set(target.subarray(0, targetBegin));\n                }\n            }\n        } else {\n            newArray = target.concat(insert);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(0, newArray.length - maxp) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n\n    return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp <= 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(insert, target);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n                    remainder.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target, numberOfItemsFromInsert);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n\n                    newArray.set(insert);\n                    newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n                    remainder.set(target.subarray(numberOfItemsFromTarget));\n                }\n            }\n        } else {\n            newArray = insert.concat(target);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(maxp, newArray.length) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n\n    return promise;\n}\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nfunction addTraces(gd, traces, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var currentIndices = [];\n    var undoFunc = exports.deleteTraces;\n    var redoFunc = addTraces;\n    var undoArgs = [gd, currentIndices];\n    var redoArgs = [gd, traces];  // no newIndices here\n    var i;\n    var promise;\n\n    // all validation is done elsewhere to remove clutter here\n    checkAddTracesArgs(gd, traces, newIndices);\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure traces do not repeat existing ones\n    traces = traces.map(function(trace) {\n        return Lib.extendFlat({}, trace);\n    });\n\n    helpers.cleanData(traces);\n\n    // add the traces to gd.data (no redrawing yet!)\n    for(i = 0; i < traces.length; i++) {\n        gd.data.push(traces[i]);\n    }\n\n    // to continue, we need to call moveTraces which requires currentIndices\n    for(i = 0; i < traces.length; i++) {\n        currentIndices.push(-traces.length + i);\n    }\n\n    // if the user didn't define newIndices, they just want the traces appended\n    // i.e., we can simply redraw and be done\n    if(typeof newIndices === 'undefined') {\n        promise = exports.redraw(gd);\n        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n        return promise;\n    }\n\n    // make sure indices is property defined\n    if(!Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n\n    try {\n        // this is redundant, but necessary to not catch later possible errors!\n        checkMoveTracesArgs(gd, currentIndices, newIndices);\n    } catch(error) {\n        // something went wrong, reset gd to be safe and rethrow error\n        gd.data.splice(gd.data.length - traces.length, traces.length);\n        throw error;\n    }\n\n    // if we're here, the user has defined specific places to place the new traces\n    // this requires some extra work that moveTraces will do\n    Queue.startSequence(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    promise = exports.moveTraces(gd, currentIndices, newIndices);\n    Queue.stopSequence(gd);\n    return promise;\n}\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nfunction deleteTraces(gd, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var traces = [];\n    var undoFunc = exports.addTraces;\n    var redoFunc = deleteTraces;\n    var undoArgs = [gd, traces, indices];\n    var redoArgs = [gd, indices];\n    var i;\n    var deletedTrace;\n\n    // make sure indices are defined\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers.');\n    } else if(!Array.isArray(indices)) {\n        indices = [indices];\n    }\n    assertIndexArray(gd, indices, 'indices');\n\n    // convert negative indices to positive indices\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // we want descending here so that splicing later doesn't affect indexing\n    indices.sort(Lib.sorterDes);\n    for(i = 0; i < indices.length; i += 1) {\n        deletedTrace = gd.data.splice(indices[i], 1)[0];\n        traces.push(deletedTrace);\n    }\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n}\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nfunction moveTraces(gd, currentIndices, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var newData = [];\n    var movingTraceMap = [];\n    var undoFunc = moveTraces;\n    var redoFunc = moveTraces;\n    var undoArgs = [gd, newIndices, currentIndices];\n    var redoArgs = [gd, currentIndices, newIndices];\n    var i;\n\n    // to reduce complexity here, check args elsewhere\n    // this throws errors where appropriate\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n    // make sure currentIndices is an array\n    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n    // if undefined, define newIndices to point to the end of gd.data array\n    if(typeof newIndices === 'undefined') {\n        newIndices = [];\n        for(i = 0; i < currentIndices.length; i++) {\n            newIndices.push(-currentIndices.length + i);\n        }\n    }\n\n    // make sure newIndices is an array if it's user-defined\n    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n    // convert negative indices to positive indices (they're the same length)\n    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n    newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n    // at this point, we've coerced the index arrays into predictable forms\n\n    // get the traces that aren't being moved around\n    for(i = 0; i < gd.data.length; i++) {\n        // if index isn't in currentIndices, include it in ignored!\n        if(currentIndices.indexOf(i) === -1) {\n            newData.push(gd.data[i]);\n        }\n    }\n\n    // get a mapping of indices to moving traces\n    for(i = 0; i < currentIndices.length; i++) {\n        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});\n    }\n\n    // reorder this mapping by newIndex, ascending\n    movingTraceMap.sort(function(a, b) {\n        return a.newIndex - b.newIndex;\n    });\n\n    // now, add the moving traces back in, in order!\n    for(i = 0; i < movingTraceMap.length; i += 1) {\n        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n    }\n\n    gd.data = newData;\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n}\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nfunction restyle(gd, astr, val, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var aobj = {};\n    if(typeof astr === 'string') aobj[astr] = val;\n    else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = Lib.extendFlat({}, astr);\n        if(_traces === undefined) _traces = val;\n    } else {\n        Lib.warn('Restyle fail.', astr, val, _traces);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var specs = _restyle(gd, aobj, traces);\n    var flags = specs.flags;\n\n    // clear calcdata and/or axis types if required so they get regenerated\n    if(flags.calc) gd.calcdata = undefined;\n    if(flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(flags.fullReplot) {\n        seq.push(exports._doPlot);\n    } else {\n        seq.push(Plots.previousPromises);\n\n        // maybe only call Plots.supplyDataDefaults in the splom case,\n        // to skip over long and slow axes defaults\n        Plots.supplyDefaults(gd);\n\n        if(flags.markerSize) {\n            Plots.doCalcdata(gd);\n            addAxRangeSequence(seq);\n\n            // TODO\n            // if all axes have autorange:false, then\n            // proceed to subroutines.doTraceStyle(),\n            // otherwise we must go through addAxRangeSequence,\n            // which in general must redraws 'all' axes\n        }\n\n        if(flags.style) seq.push(subroutines.doTraceStyle);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(\n        Plots.rehover,\n        Plots.redrag,\n        Plots.reselect\n    );\n\n    Queue.add(gd,\n        restyle, [gd, specs.undoit, specs.traces],\n        restyle, [gd, specs.redoit, specs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        gd.emit('plotly_restyle', specs.eventData);\n        return gd;\n    });\n}\n\n// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val) {\n    if(val === undefined) return null;\n    return val;\n}\n\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\nfunction makeNP(preGUI, guiEditFlag) {\n    if(!guiEditFlag) return nestedProperty;\n\n    return function(container, attr, prefix) {\n        var np = nestedProperty(container, attr);\n        var npSet = np.set;\n        np.set = function(val) {\n            var fullAttr = (prefix || '') + attr;\n            storeCurrent(fullAttr, np.get(), val, preGUI);\n            npSet(val);\n        };\n        return np;\n    };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n    if(Array.isArray(val) || Array.isArray(newVal)) {\n        var arrayVal = Array.isArray(val) ? val : [];\n        var arrayNew = Array.isArray(newVal) ? newVal : [];\n        var maxLen = Math.max(arrayVal.length, arrayNew.length);\n        for(var i = 0; i < maxLen; i++) {\n            storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n        }\n    } else if(Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n        var objVal = Lib.isPlainObject(val) ? val : {};\n        var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n        var objBoth = Lib.extendFlat({}, objVal, objNew);\n        for(var key in objBoth) {\n            storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n        }\n    } else if(preGUI[attr] === undefined) {\n        preGUI[attr] = undefinedToNull(val);\n    }\n}\n\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n    for(var attr in edits) {\n        var np = nestedProperty(container, attr);\n        storeCurrent(attr, np.get(), edits[attr], preGUI);\n    }\n}\n\nfunction _restyle(gd, aobj, traces) {\n    var fullLayout = gd._fullLayout;\n    var fullData = gd._fullData;\n    var data = gd.data;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var i;\n\n    cleanDeprecatedAttributeKeys(aobj);\n\n    // initialize flags\n    var flags = editTypes.traceFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n    var axlist;\n\n    // make a new empty vals array for undoit\n    function a0() { return traces.map(function() { return undefined; }); }\n\n    // for autoranging multiple axes\n    function addToAxlist(axid) {\n        var axName = Axes.id2name(axid);\n        if(axlist.indexOf(axName) === -1) axlist.push(axName);\n    }\n\n    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }\n\n    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }\n\n    function getFullTrace(traceIndex) {\n        // usually fullData maps 1:1 onto data, but with groupby transforms\n        // the fullData index can be greater. Take the *first* matching trace.\n        for(var j = traceIndex; j < fullData.length; j++) {\n            if(fullData[j]._input === data[traceIndex]) return fullData[j];\n        }\n        // should never get here - and if we *do* it should cause an error\n        // later on undefined fullTrace is passed to nestedProperty.\n    }\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // val=null will delete the attribute\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val, i) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val, i); });\n            return;\n        }\n        // quit if explicitly setting this elsewhere\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var extraparam;\n        if(attr.substr(0, 6) === 'LAYOUT') {\n            extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n        } else {\n            var tracei = traces[i];\n            var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n            extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n        }\n\n        if(!(attr in undoit)) {\n            undoit[attr] = a0();\n        }\n        if(undoit[attr][i] === undefined) {\n            undoit[attr][i] = undefinedToNull(extraparam.get());\n        }\n        if(val !== undefined) {\n            extraparam.set(val);\n        }\n    }\n\n    function allBins(binAttr) {\n        return function(j) {\n            return fullData[j][binAttr];\n        };\n    }\n\n    function arrayBins(binAttr) {\n        return function(vij, j) {\n            return vij === false ? fullData[traces[j]][binAttr] : null;\n        };\n    }\n\n    // now make the changes to gd.data (and occasionally gd.layout)\n    // and figure out what kind of graphics update we need to do\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n        }\n\n        var vi = aobj[ai];\n        var cont;\n        var contFull;\n        var param;\n        var oldVal;\n        var newVal;\n        var valObject;\n\n        // Backward compatibility shim for turning histogram autobin on,\n        // or freezing previous autobinned values.\n        // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n        // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n        if(ai === 'autobinx' || ai === 'autobiny') {\n            ai = ai.charAt(ai.length - 1) + 'bins';\n            if(Array.isArray(vi)) vi = vi.map(arrayBins(ai));\n            else if(vi === false) vi = traces.map(allBins(ai));\n            else vi = null;\n        }\n\n        redoit[ai] = vi;\n\n        if(ai.substr(0, 6) === 'LAYOUT') {\n            param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n            undoit[ai] = [undefinedToNull(param.get())];\n            // since we're allowing val to be an array, allow it here too,\n            // even though that's meaningless\n            param.set(Array.isArray(vi) ? vi[0] : vi);\n            // ironically, the layout attrs in restyle only require replot,\n            // not relayout\n            flags.calc = true;\n            continue;\n        }\n\n        // set attribute in gd.data\n        undoit[ai] = a0();\n        for(i = 0; i < traces.length; i++) {\n            cont = data[traces[i]];\n            contFull = getFullTrace(traces[i]);\n            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n            param = makeNP(preGUI, guiEditFlag)(cont, ai);\n            oldVal = param.get();\n            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n\n            if(newVal === undefined) continue;\n\n            var finalPart = param.parts[param.parts.length - 1];\n            var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n            var prefixDot = prefix ? prefix + '.' : '';\n            var innerContFull = prefix ?\n                nestedProperty(contFull, prefix).get() : contFull;\n\n            valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n            if(valObject && valObject.impliedEdits && newVal !== null) {\n                for(var impliedKey in valObject.impliedEdits) {\n                    doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n                }\n            } else if((finalPart === 'thicknessmode' || finalPart === 'lenmode') &&\n                    oldVal !== newVal &&\n                    (newVal === 'fraction' || newVal === 'pixels') &&\n                    innerContFull\n            ) {\n                // changing colorbar size modes,\n                // make the resulting size not change\n                // note that colorbar fractional sizing is based on the\n                // original plot size, before anything (like a colorbar)\n                // increases the margins\n\n                var gs = fullLayout._size;\n                var orient = innerContFull.orient;\n                var topOrBottom = (orient === 'top') || (orient === 'bottom');\n                if(finalPart === 'thicknessmode') {\n                    var thicknorm = topOrBottom ? gs.h : gs.w;\n                    doextra(prefixDot + 'thickness', innerContFull.thickness *\n                        (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n                } else {\n                    var lennorm = topOrBottom ? gs.w : gs.h;\n                    doextra(prefixDot + 'len', innerContFull.len *\n                        (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n                }\n            } else if(ai === 'type' && (\n                (newVal === 'pie') !== (oldVal === 'pie') ||\n                (newVal === 'funnelarea') !== (oldVal === 'funnelarea')\n            )) {\n                var labelsTo = 'x';\n                var valuesTo = 'y';\n                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n                    labelsTo = 'y';\n                    valuesTo = 'x';\n                }\n                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n                if(oldVal === 'pie' || oldVal === 'funnelarea') {\n                    nestedProperty(cont, 'marker.color')\n                        .set(nestedProperty(cont, 'marker.colors').get());\n\n                    // super kludgy - but if all pies are gone we won't remove them otherwise\n                    fullLayout._pielayer.selectAll('g.trace').remove();\n                } else if(Registry.traceIs(cont, 'cartesian')) {\n                    nestedProperty(cont, 'marker.colors')\n                        .set(nestedProperty(cont, 'marker.color').get());\n                }\n            }\n\n            undoit[ai][i] = undefinedToNull(oldVal);\n            // set the new value - if val is an array, it's one el per trace\n            // first check for attributes that get more complex alterations\n            var swapAttrs = [\n                'swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'\n            ];\n            if(swapAttrs.indexOf(ai) !== -1) {\n                // setting an orientation: make sure it's changing\n                // before we swap everything else\n                if(ai === 'orientation') {\n                    param.set(newVal);\n                    // obnoxious that we need this level of coupling... but in order to\n                    // properly handle setting orientation to `null` we need to mimic\n                    // the logic inside Bars.supplyDefaults for default orientation\n                    var defaultOrientation = (cont.x && !cont.y) ? 'h' : 'v';\n                    if((param.get() || defaultOrientation) === contFull.orientation) {\n                        continue;\n                    }\n                } else if(ai === 'orientationaxes') {\n                    // orientationaxes has no value,\n                    // it flips everything and the axes\n\n                    cont.orientation =\n                        {v: 'h', h: 'v'}[contFull.orientation];\n                }\n                helpers.swapXYData(cont);\n                flags.calc = flags.clearAxisTypes = true;\n            } else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n                // TODO: use manageArrays.applyContainerArrayChanges here too\n                helpers.manageArrayContainers(param, newVal, undoit);\n                flags.calc = true;\n            } else {\n                if(valObject) {\n                    // must redo calcdata when restyling array values of arrayOk attributes\n                    // ... but no need to this for regl-based traces\n                    if(valObject.arrayOk &&\n                        !Registry.traceIs(contFull, 'regl') &&\n                        (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))\n                    ) {\n                        flags.calc = true;\n                    } else editTypes.update(flags, valObject);\n                } else {\n                    /*\n                     * if we couldn't find valObject,  assume a full recalc.\n                     * This can happen if you're changing type and making\n                     * some other edits too, so the modules we're\n                     * looking at don't have these attributes in them.\n                     */\n                    flags.calc = true;\n                }\n\n                // all the other ones, just modify that one attribute\n                param.set(newVal);\n            }\n        }\n\n        // swap the data attributes of the relevant x and y axes?\n        if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n            Axes.swap(gd, traces);\n        }\n\n        // swap hovermode if set to \"compare x/y data\"\n        if(ai === 'orientationaxes') {\n            var hovermode = nestedProperty(gd.layout, 'hovermode');\n            var h = hovermode.get();\n            if(h === 'x') {\n                hovermode.set('y');\n            } else if(h === 'y') {\n                hovermode.set('x');\n            } else if(h === 'x unified') {\n                hovermode.set('y unified');\n            } else if(h === 'y unified') {\n                hovermode.set('x unified');\n            }\n        }\n\n        // Major enough changes deserve autoscale and\n        // non-reversed axes so people don't get confused\n        //\n        // Note: autobin (or its new analog bin clearing) is not included here\n        // since we're not pushing bins back to gd.data, so if we have bin\n        // info it was explicitly provided by the user.\n        if(['orientation', 'type'].indexOf(ai) !== -1) {\n            axlist = [];\n            for(i = 0; i < traces.length; i++) {\n                var trace = data[traces[i]];\n\n                if(Registry.traceIs(trace, 'cartesian')) {\n                    addToAxlist(trace.xaxis || 'x');\n                    addToAxlist(trace.yaxis || 'y');\n                }\n            }\n\n            doextra(axlist.map(autorangeAttr), true, 0);\n            doextra(axlist.map(rangeAttr), [0, 1], 0);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    return {\n        flags: flags,\n        undoit: undoit,\n        redoit: redoit,\n        traces: traces,\n        eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n    };\n}\n\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\nfunction cleanDeprecatedAttributeKeys(aobj) {\n    var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n    var colorbarRegex = /colorbar\\.title$/;\n    var keys = Object.keys(aobj);\n    var i, key, value;\n\n    for(i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = aobj[key];\n\n        if((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) &&\n          (typeof value === 'string' || typeof value === 'number')) {\n            replace(key, key.replace('title', 'title.text'));\n        } else if(key.indexOf('titlefont') > -1 && key.indexOf('grouptitlefont') === -1) {\n            replace(key, key.replace('titlefont', 'title.font'));\n        } else if(key.indexOf('titleposition') > -1) {\n            replace(key, key.replace('titleposition', 'title.position'));\n        } else if(key.indexOf('titleside') > -1) {\n            replace(key, key.replace('titleside', 'title.side'));\n        } else if(key.indexOf('titleoffset') > -1) {\n            replace(key, key.replace('titleoffset', 'title.offset'));\n        }\n    }\n\n    function replace(oldAttrStr, newAttrStr) {\n        aobj[newAttrStr] = aobj[oldAttrStr];\n        delete aobj[oldAttrStr];\n    }\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nfunction relayout(gd, astr, val) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = Lib.extendFlat({}, astr);\n    } else {\n        Lib.warn('Relayout fail.', astr, val);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var specs = _relayout(gd, aobj);\n    var flags = specs.flags;\n\n    // clear calcdata if required\n    if(flags.calc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n\n    // even if we don't have anything left in aobj,\n    // something may have happened within relayout that we\n    // need to wait for\n    var seq = [Plots.previousPromises];\n    if(flags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    } else if(Object.keys(aobj).length) {\n        axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n\n        if(flags.legend) seq.push(subroutines.doLegend);\n        if(flags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n        if(flags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(flags.modebar) seq.push(subroutines.doModeBar);\n        if(flags.camera) seq.push(subroutines.doCamera);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(\n        Plots.rehover,\n        Plots.redrag,\n        Plots.reselect\n    );\n\n    Queue.add(gd,\n        relayout, [gd, specs.undoit],\n        relayout, [gd, specs.redoit]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_relayout', specs.eventData);\n        return gd;\n    });\n}\n\n// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n    var fullLayout = gd._fullLayout;\n\n    if(!flags.axrange) return false;\n\n    for(var k in flags) {\n        if(k !== 'axrange' && flags[k]) return false;\n    }\n\n    var axIn, axOut;\n    var coerce = function(attr, dflt) {\n        return Lib.coerce(axIn, axOut, cartesianLayoutAttributes, attr, dflt);\n    };\n\n    var options = {}; // passing empty options for now!\n\n    for(var axId in specs.rangesAltered) {\n        var axName = Axes.id2name(axId);\n        axIn = gd.layout[axName];\n        axOut = fullLayout[axName];\n\n        handleRangeDefaults(axIn, axOut, coerce, options);\n\n        if(axOut._matchGroup) {\n            for(var axId2 in axOut._matchGroup) {\n                if(axId2 !== axId) {\n                    var ax2 = fullLayout[Axes.id2name(axId2)];\n                    ax2.autorange = axOut.autorange;\n                    ax2.range = axOut.range.slice();\n                    ax2._input.range = axOut.range.slice();\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n    // N.B. leave as sequence of subroutines (for now) instead of\n    // subroutine of its own so that finalDraw always gets\n    // executed after drawData\n    var drawAxes = rangesAltered ?\n        function(gd) {\n            var axIds = [];\n            var skipTitle = true;\n\n            for(var id in rangesAltered) {\n                var ax = Axes.getFromId(gd, id);\n                axIds.push(id);\n\n                if((ax.ticklabelposition || '').indexOf('inside') !== -1) {\n                    if(ax._anchorAxis) {\n                        axIds.push(ax._anchorAxis._id);\n                    }\n                }\n\n                if(ax._matchGroup) {\n                    for(var id2 in ax._matchGroup) {\n                        if(!rangesAltered[id2]) {\n                            axIds.push(id2);\n                        }\n                    }\n                }\n            }\n\n            return Axes.draw(gd, axIds, {skipTitle: skipTitle});\n        } :\n        function(gd) {\n            return Axes.draw(gd, 'redraw');\n        };\n\n    seq.push(\n        clearOutline,\n        subroutines.doAutoRangeAndConstraints,\n        drawAxes,\n        subroutines.drawData,\n        subroutines.finalDraw\n    );\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n    var layout = gd.layout;\n    var fullLayout = gd._fullLayout;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var keys = Object.keys(aobj);\n    var axes = Axes.list(gd);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var arrayEdits = {};\n\n    var arrayStr, i, j;\n\n    cleanDeprecatedAttributeKeys(aobj);\n    keys = Object.keys(aobj);\n\n    // look for 'allaxes', split out into all axes\n    // in case of 3D the axis are nested within a scene which is held in _id\n    for(i = 0; i < keys.length; i++) {\n        if(keys[i].indexOf('allaxes') === 0) {\n            for(j = 0; j < axes.length; j++) {\n                var scene = axes[j]._id.substr(1);\n                var axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '';\n                var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n\n                if(!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n            }\n\n            delete aobj[keys[i]];\n        }\n    }\n\n    // initialize flags\n    var flags = editTypes.layoutFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val); });\n            return;\n        }\n\n        // if we have another value for this attribute (explicitly or\n        // via a parent) do not override with this auto-generated extra\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var p = layoutNP(layout, attr);\n        if(!(attr in undoit)) {\n            undoit[attr] = undefinedToNull(p.get());\n        }\n        if(val !== undefined) p.set(val);\n    }\n\n    // for constraint enforcement: keep track of all axes (as {id: name})\n    // we're editing the (auto)range of, so we can tell the others constrained\n    // to scale with them that it's OK for them to shrink\n    var rangesAltered = {};\n    var ax;\n\n    function recordAlteredAxis(pleafPlus) {\n        var axId = Axes.name2id(pleafPlus.split('.')[0]);\n        rangesAltered[axId] = 1;\n        return axId;\n    }\n\n    // alter gd.layout\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n        }\n\n        var p = layoutNP(layout, ai);\n        var vi = aobj[ai];\n        var plen = p.parts.length;\n        // p.parts may end with an index integer if the property is an array\n        var pend = plen - 1;\n        while(pend > 0 && typeof p.parts[pend] !== 'string') pend--;\n        // last property in chain (leaf node)\n        var pleaf = p.parts[pend];\n        // leaf plus immediate parent\n        var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\n        // trunk nodes (everything except the leaf)\n        var ptrunk = p.parts.slice(0, pend).join('.');\n        var parentIn = nestedProperty(gd.layout, ptrunk).get();\n        var parentFull = nestedProperty(fullLayout, ptrunk).get();\n        var vOld = p.get();\n\n        if(vi === undefined) continue;\n\n        redoit[ai] = vi;\n\n        // axis reverse is special - it is its own inverse\n        // op and has no flag.\n        undoit[ai] = (pleaf === 'reverse') ? vi : undefinedToNull(vOld);\n\n        var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n        if(valObject && valObject.impliedEdits && vi !== null) {\n            for(var impliedKey in valObject.impliedEdits) {\n                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n            }\n        }\n\n        // Setting width or height to null must reset the graph's width / height\n        // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        //\n        // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // can't use impliedEdits for this because behavior depends on vi\n        if(['width', 'height'].indexOf(ai) !== -1) {\n            if(vi) {\n                doextra('autosize', null);\n                // currently we don't support autosize one dim only - so\n                // explicitly set the other one. Note that doextra will\n                // ignore this if the same relayout call also provides oppositeAttr\n                var oppositeAttr = ai === 'height' ? 'width' : 'height';\n                doextra(oppositeAttr, fullLayout[oppositeAttr]);\n            } else {\n                fullLayout[ai] = gd._initialAutoSize[ai];\n            }\n        } else if(ai === 'autosize') {\n            // depends on vi here too, so again can't use impliedEdits\n            doextra('width', vi ? null : fullLayout.width);\n            doextra('height', vi ? null : fullLayout.height);\n        } else if(pleafPlus.match(AX_RANGE_RE)) {\n            // check autorange vs range\n\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        } else if(pleafPlus.match(AX_AUTORANGE_RE)) {\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n            var axFull = nestedProperty(fullLayout, ptrunk).get();\n            if(axFull._inputDomain) {\n                // if we're autoranging and this axis has a constrained domain,\n                // reset it so we don't get locked into a shrunken size\n                axFull._input.domain = axFull._inputDomain.slice();\n            }\n        } else if(pleafPlus.match(AX_DOMAIN_RE)) {\n            nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n        }\n\n        // toggling axis type between log and linear: we need to convert\n        // positions for components that are still using linearized values,\n        // not data values like newer components.\n        // previously we did this for log <-> not-log, but now only do it\n        // for log <-> linear\n        if(pleaf === 'type') {\n            ax = parentIn;\n            var toLog = parentFull.type === 'linear' && vi === 'log';\n            var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n            if(toLog || fromLog) {\n                if(!ax || !ax.range) {\n                    // 2D never gets here, but 3D does\n                    // I don't think this is needed, but left here in case there\n                    // are edge cases I'm not thinking of.\n                    doextra(ptrunk + '.autorange', true);\n                } else if(!parentFull.autorange) {\n                    // toggling log without autorange: need to also recalculate ranges\n                    // because log axes use linearized values for range endpoints\n                    var r0 = ax.range[0];\n                    var r1 = ax.range[1];\n                    if(toLog) {\n                        // if both limits are negative, autorange\n                        if(r0 <= 0 && r1 <= 0) {\n                            doextra(ptrunk + '.autorange', true);\n                        }\n                        // if one is negative, set it 6 orders below the other.\n                        if(r0 <= 0) r0 = r1 / 1e6;\n                        else if(r1 <= 0) r1 = r0 / 1e6;\n                        // now set the range values as appropriate\n                        doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n                        doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n                    } else {\n                        doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n                        doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n                    }\n                } else if(toLog) {\n                    // just make sure the range is positive and in the right\n                    // order, it'll get recalculated later\n                    ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];\n                }\n\n                // clear polar view initial stash for radial range so that\n                // value get recomputed in correct units\n                if(Array.isArray(fullLayout._subplots.polar) &&\n                    fullLayout._subplots.polar.length &&\n                    fullLayout[p.parts[0]] &&\n                    p.parts[1] === 'radialaxis'\n                ) {\n                    delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n                }\n\n                // Annotations and images also need to convert to/from linearized coords\n                // Shapes do not need this :)\n                Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n                Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n            } else {\n                // any other type changes: the range from the previous type\n                // will not make sense, so autorange it.\n                doextra(ptrunk + '.autorange', true);\n                doextra(ptrunk + '.range', null);\n            }\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        } else if(pleaf.match(AX_NAME_PATTERN)) {\n            var fullProp = nestedProperty(fullLayout, ai).get();\n            var newType = (vi || {}).type;\n\n            // This can potentially cause strange behavior if the autotype is not\n            // numeric (linear, because we don't auto-log) but the previous type\n            // was log. That's a very strange edge case though\n            if(!newType || newType === '-') newType = 'linear';\n            Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n            Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n        }\n\n        // alter gd.layout\n\n        // collect array component edits for execution all together\n        // so we can ensure consistent behavior adding/removing items\n        // and order-independence for add/remove/edit all together in\n        // one relayout call\n        var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n        if(containerArrayMatch) {\n            arrayStr = containerArrayMatch.array;\n            i = containerArrayMatch.index;\n            var propStr = containerArrayMatch.property;\n            var updateValObject = valObject || {editType: 'calc'};\n\n            if(i !== '' && propStr === '') {\n                // special handling of undoit if we're adding or removing an element\n                // ie 'annotations[2]' which can be {...} (add) or null,\n                // does not work when replacing the entire array\n                if(manageArrays.isAddVal(vi)) {\n                    undoit[ai] = null;\n                } else if(manageArrays.isRemoveVal(vi)) {\n                    undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n                } else {\n                    Lib.warn('unrecognized full object value', aobj);\n                }\n            }\n            editTypes.update(flags, updateValObject);\n\n            // prepare the edits object we'll send to applyContainerArrayChanges\n            if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n            var objEdits = arrayEdits[arrayStr][i];\n            if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n            objEdits[propStr] = vi;\n\n            delete aobj[ai];\n        } else if(pleaf === 'reverse') {\n            // handle axis reversal explicitly, as there's no 'reverse' attribute\n\n            if(parentIn.range) parentIn.range.reverse();\n            else {\n                doextra(ptrunk + '.autorange', true);\n                parentIn.range = [1, 0];\n            }\n\n            if(parentFull.autorange) flags.calc = true;\n            else flags.plot = true;\n        } else {\n            if(ai === 'dragmode' && ((vi === false && vOld !== false) || (vi !== false && vOld === false))) {\n                flags.plot = true;\n            } else if((fullLayout._has('scatter-like') && fullLayout._has('regl')) &&\n                (ai === 'dragmode' &&\n                (vi === 'lasso' || vi === 'select') &&\n                !(vOld === 'lasso' || vOld === 'select'))\n            ) {\n                flags.plot = true;\n            } else if(fullLayout._has('gl2d')) {\n                flags.plot = true;\n            } else if(valObject) editTypes.update(flags, valObject);\n            else flags.calc = true;\n\n            p.set(vi);\n        }\n    }\n\n    // now we've collected component edits - execute them all together\n    for(arrayStr in arrayEdits) {\n        var finished = manageArrays.applyContainerArrayChanges(gd,\n            layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n        if(!finished) flags.plot = true;\n    }\n\n    // figure out if we need to recalculate axis constraints\n    for(var axId in rangesAltered) {\n        ax = Axes.getFromId(gd, axId);\n        var group = ax && ax._constraintGroup;\n        if(group) {\n            // Always recalc if we're changing constrained ranges.\n            // Otherwise it's possible to violate the constraints by\n            // specifying arbitrary ranges for all axes in the group.\n            // this way some ranges may expand beyond what's specified,\n            // as they do at first draw, to satisfy the constraints.\n            flags.calc = true;\n            for(var groupAxId in group) {\n                if(!rangesAltered[groupAxId]) {\n                    Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n                }\n            }\n        }\n    }\n\n    // If the autosize changed or height or width was explicitly specified,\n    // this triggers a redraw\n    // TODO: do we really need special aobj.height/width handling here?\n    // couldn't editType do this?\n    if(updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n    // update shape legends\n    var shapes = fullLayout.shapes;\n    for(i = 0; i < shapes.length; i++) {\n        if(shapes[i].showlegend) {\n            flags.calc = true;\n            break;\n        }\n    }\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    // now all attribute mods are done, as are\n    // redo and undo so we can save them\n\n    return {\n        flags: flags,\n        rangesAltered: rangesAltered,\n        undoit: undoit,\n        redoit: redoit,\n        eventData: eventData\n    };\n}\n\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\nfunction updateAutosize(gd) {\n    var fullLayout = gd._fullLayout;\n    var oldWidth = fullLayout.width;\n    var oldHeight = fullLayout.height;\n\n    // calculate autosizing\n    if(gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n\n    return (fullLayout.width !== oldWidth) || (fullLayout.height !== oldHeight);\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n\n    if(Object.keys(traceUpdate).length) gd.changed = true;\n    if(Object.keys(layoutUpdate).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n    var restyleFlags = restyleSpecs.flags;\n\n    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n    var relayoutFlags = relayoutSpecs.flags;\n\n    // clear calcdata and/or axis types if required\n    if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n    if(restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(relayoutFlags.layoutReplot) {\n        // N.B. works fine when both\n        // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n        seq.push(subroutines.layoutReplot);\n    } else if(restyleFlags.fullReplot) {\n        seq.push(exports._doPlot);\n    } else {\n        seq.push(Plots.previousPromises);\n        axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n\n        if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n        if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n        if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n        if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n        if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n        if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(\n        Plots.rehover,\n        Plots.redrag,\n        Plots.reselect\n    );\n\n    Queue.add(gd,\n        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],\n        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_update', {\n            data: restyleSpecs.eventData,\n            layout: relayoutSpecs.eventData\n        });\n\n        return gd;\n    });\n}\n\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\nfunction guiEdit(func) {\n    return function wrappedEdit(gd) {\n        gd._fullLayout._guiEditing = true;\n        var p = func.apply(null, arguments);\n        gd._fullLayout._guiEditing = false;\n        return p;\n    };\n}\n\n// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns = [\n    {pattern: /^hiddenlabels/, attr: 'legend.uirevision'},\n    {pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/},\n\n    // showspikes and modes include those nested inside scenes\n    {pattern: /axis\\d*\\.showspikes$/, attr: 'modebar.uirevision'},\n    {pattern: /(hover|drag)mode$/, attr: 'modebar.uirevision'},\n\n    {pattern: /^(scene\\d*)\\.camera/},\n    {pattern: /^(geo\\d*)\\.(projection|center|fitbounds)/},\n    {pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/},\n    {pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/},\n    {pattern: /^(polar\\d*\\.angularaxis)\\.rotation/},\n    {pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/},\n    {pattern: /^(map\\d*)\\.(center|zoom|bearing|pitch)/},\n\n    {pattern: /^legend\\.(x|y)$/, attr: 'editrevision'},\n    {pattern: /^(shapes|annotations)/, attr: 'editrevision'},\n    {pattern: /^title\\.text$/, attr: 'editrevision'}\n];\n\n// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns = [\n    {pattern: /^selectedpoints$/, attr: 'selectionrevision'},\n    // \"visible\" includes trace.transforms[i].styles[j].value.visible\n    {pattern: /(^|value\\.)visible$/, attr: 'legend.uirevision'},\n    {pattern: /^dimensions\\[\\d+\\]\\.constraintrange/},\n    {pattern: /^node\\.(x|y|groups)/}, // for Sankey nodes\n    {pattern: /^level$/}, // for Sunburst, Treemap and Icicle traces\n\n    // below this you must be in editable: true mode\n    // TODO: I still put name and title with `trace.uirevision`\n    // reasonable or should these be `editrevision`?\n    // Also applies to axis titles up in the layout section\n\n    // \"name\" also includes transform.styles\n    {pattern: /(^|value\\.)name$/},\n    // including nested colorbar attributes (ie marker.colorbar)\n    {pattern: /colorbar\\.title\\.text$/},\n    {pattern: /colorbar\\.(x|y)$/, attr: 'editrevision'}\n];\n\nfunction findUIPattern(key, patternSpecs) {\n    for(var i = 0; i < patternSpecs.length; i++) {\n        var spec = patternSpecs[i];\n        var match = key.match(spec.pattern);\n        if(match) {\n            var head = match[1] || '';\n            return {head: head, tail: key.substr(head.length + 1), attr: spec.attr};\n        }\n    }\n}\n\n// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr, container) {\n    var newRev = nestedProperty(container, revAttr).get();\n    if(newRev !== undefined) return newRev;\n\n    var parts = revAttr.split('.');\n    parts.pop();\n    while(parts.length > 1) {\n        parts.pop();\n        newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n        if(newRev !== undefined) return newRev;\n    }\n\n    return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n    for(var i = 0; i < fullData.length; i++) {\n        if(fullData[i]._fullInput.uid === uid) return i;\n    }\n    return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n    for(var i = 0; i < data.length; i++) {\n        if(data[i].uid === uid) return i;\n    }\n    // fall back on trace order, but only if user didn't provide a uid for that trace\n    return (!data[tracei] || data[tracei].uid) ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n    var v1IsObj = Lib.isPlainObject(v1);\n    var v1IsArray = Array.isArray(v1);\n    if(v1IsObj || v1IsArray) {\n        return (\n            (v1IsObj && Lib.isPlainObject(v2)) ||\n            (v1IsArray && Array.isArray(v2))\n        ) && JSON.stringify(v1) === JSON.stringify(v2);\n    }\n    return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n    var layoutPreGUI = oldFullLayout._preGUI;\n    var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal, head, tail;\n    var bothInheritAutorange = [];\n    var newAutorangeIn = {};\n    var newRangeAccepted = {};\n    for(key in layoutPreGUI) {\n        match = findUIPattern(key, layoutUIControlPatterns);\n        if(match) {\n            head = match.head;\n            tail = match.tail;\n            revAttr = match.attr || (head + '.uirevision');\n            oldRev = nestedProperty(oldFullLayout, revAttr).get();\n            newRev = oldRev && getNewRev(revAttr, layout);\n\n            if(newRev && (newRev === oldRev)) {\n                preGUIVal = layoutPreGUI[key];\n                if(preGUIVal === null) preGUIVal = undefined;\n                newNP = nestedProperty(layout, key);\n                newVal = newNP.get();\n\n                if(valsMatch(newVal, preGUIVal)) {\n                    if(newVal === undefined && tail === 'autorange') {\n                        bothInheritAutorange.push(head);\n                    }\n                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n                    continue;\n                } else if(tail === 'autorange' || tail.substr(0, 6) === 'range[') {\n                    // Special case for (auto)range since we push it back into the layout\n                    // so all null should be treated equivalently to autorange: true with any range\n                    var pre0 = layoutPreGUI[head + '.range[0]'];\n                    var pre1 = layoutPreGUI[head + '.range[1]'];\n                    var preAuto = layoutPreGUI[head + '.autorange'];\n                    if(preAuto || (preAuto === null && pre0 === null && pre1 === null)) {\n                        // Only read the input layout once and stash the result,\n                        // so we get it before we start modifying it\n                        if(!(head in newAutorangeIn)) {\n                            var newContainer = nestedProperty(layout, head).get();\n                            newAutorangeIn[head] = newContainer && (\n                                newContainer.autorange ||\n                                (newContainer.autorange !== false && (\n                                    !newContainer.range || newContainer.range.length !== 2)\n                                )\n                            );\n                        }\n                        if(newAutorangeIn[head]) {\n                            newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n                            continue;\n                        }\n                    }\n                }\n            }\n        } else {\n            Lib.warn('unrecognized GUI edit: ' + key);\n        }\n        // if we got this far, the new value was accepted as the new starting\n        // point (either because it changed or revision changed)\n        // so remove it from _preGUI for next time.\n        delete layoutPreGUI[key];\n\n        if(match && match.tail.substr(0, 6) === 'range[') {\n            newRangeAccepted[match.head] = 1;\n        }\n    }\n\n    // More special logic for `autorange`, since it interacts with `range`:\n    // If the new figure's matching `range` was kept, and `autorange`\n    // wasn't supplied explicitly in either the original or the new figure,\n    // we shouldn't alter that - but we may just have done that, so fix it.\n    for(var i = 0; i < bothInheritAutorange.length; i++) {\n        var axAttr = bothInheritAutorange[i];\n        if(newRangeAccepted[axAttr]) {\n            var newAx = nestedProperty(layout, axAttr).get();\n            if(newAx) delete newAx.autorange;\n        }\n    }\n\n    // Now traces - try to match them up by uid (in case we added/deleted in\n    // the middle), then fall back on index.\n    var allTracePreGUI = oldFullLayout._tracePreGUI;\n    for(var uid in allTracePreGUI) {\n        var tracePreGUI = allTracePreGUI[uid];\n        var newTrace = null;\n        var fullInput;\n        for(key in tracePreGUI) {\n            // wait until we know we have preGUI values to look for traces\n            // but if we don't find both, stop looking at this uid\n            if(!newTrace) {\n                var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n                if(fulli < 0) {\n                    // Somehow we didn't even have this trace in oldFullData...\n                    // I guess this could happen with `deleteTraces` or something\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                var fullTrace = oldFullData[fulli];\n                fullInput = fullTrace._fullInput;\n\n                var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n                if(newTracei < 0) {\n                    // No match in new data\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                newTrace = data[newTracei];\n            }\n\n            match = findUIPattern(key, traceUIControlPatterns);\n            if(match) {\n                if(match.attr) {\n                    oldRev = nestedProperty(oldFullLayout, match.attr).get();\n                    newRev = oldRev && getNewRev(match.attr, layout);\n                } else {\n                    oldRev = fullInput.uirevision;\n                    // inheritance for trace.uirevision is simple, just layout.uirevision\n                    newRev = newTrace.uirevision;\n                    if(newRev === undefined) newRev = layout.uirevision;\n                }\n\n                if(newRev && newRev === oldRev) {\n                    preGUIVal = tracePreGUI[key];\n                    if(preGUIVal === null) preGUIVal = undefined;\n                    newNP = nestedProperty(newTrace, key);\n                    newVal = newNP.get();\n                    if(valsMatch(newVal, preGUIVal)) {\n                        newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n                        continue;\n                    }\n                }\n            } else {\n                Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n            }\n            delete tracePreGUI[key];\n        }\n    }\n}\n\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nfunction react(gd, data, layout, config) {\n    var frames, plotDone;\n\n    function addFrames() { return exports.addFrames(gd, frames); }\n\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var oldFullData = gd._fullData;\n    var oldFullLayout = gd._fullLayout;\n\n    // you can use this as the initial draw as well as to update\n    if(!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n        plotDone = exports.newPlot(gd, data, layout, config);\n    } else {\n        if(Lib.isPlainObject(data)) {\n            var obj = data;\n            data = obj.data;\n            layout = obj.layout;\n            config = obj.config;\n            frames = obj.frames;\n        }\n\n        var configChanged = false;\n        // assume that if there's a config at all, we're reacting to it too,\n        // and completely replace the previous config\n        if(config) {\n            var oldConfig = Lib.extendDeep({}, gd._context);\n            gd._context = undefined;\n            setPlotContext(gd, config);\n            configChanged = diffConfig(oldConfig, gd._context);\n        }\n\n        gd.data = data || [];\n        helpers.cleanData(gd.data);\n        gd.layout = layout || {};\n        helpers.cleanLayout(gd.layout);\n\n        applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\n\n        // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n        // which supplyDefaults usually does at the end, but we may need to NOT do\n        // if the diff (which we haven't determined yet) says we'll recalc\n        Plots.supplyDefaults(gd, {skipUpdateCalc: true});\n\n        var newFullData = gd._fullData;\n        var newFullLayout = gd._fullLayout;\n        var immutable = newFullLayout.datarevision === undefined;\n        var transition = newFullLayout.transition;\n\n        var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n        var newDataRevision = relayoutFlags.newDataRevision;\n        var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\n\n        // TODO: how to translate this part of relayout to Plotly.react?\n        // // Setting width or height to null must reset the graph's width / height\n        // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        // //\n        // // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n        //     fullLayout[ai] = gd._initialAutoSize[ai];\n        // }\n\n        if(updateAutosize(gd)) relayoutFlags.layoutReplot = true;\n\n        // clear calcdata and empty categories if required\n        if(restyleFlags.calc || relayoutFlags.calc) {\n            gd.calcdata = undefined;\n            var allNames = Object.getOwnPropertyNames(newFullLayout);\n            for(var q = 0; q < allNames.length; q++) {\n                var name = allNames[q];\n                var start = name.substring(0, 5);\n                if(start === 'xaxis' || start === 'yaxis') {\n                    var emptyCategories = newFullLayout[name]._emptyCategories;\n                    if(emptyCategories) emptyCategories();\n                }\n            }\n        // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n        } else {\n            Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n        }\n\n        // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n        // must be handled by the user when using Plotly.react.\n\n        // fill in redraw sequence\n        var seq = [];\n\n        if(frames) {\n            gd._transitionData = {};\n            Plots.createTransitionData(gd);\n            seq.push(addFrames);\n        }\n\n        // Transition pathway,\n        // only used when 'transition' is set by user and\n        // when at least one animatable attribute has changed,\n        // N.B. config changed aren't animatable\n        if(newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n\n            Plots.doCalcdata(gd);\n            subroutines.doAutoRangeAndConstraints(gd);\n\n            seq.push(function() {\n                return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n            });\n        } else if(restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n            gd._fullLayout._skipDefaults = true;\n            seq.push(exports._doPlot);\n        } else {\n            for(var componentType in relayoutFlags.arrays) {\n                var indices = relayoutFlags.arrays[componentType];\n                if(indices.length) {\n                    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n                    if(drawOne !== Lib.noop) {\n                        for(var i = 0; i < indices.length; i++) {\n                            drawOne(gd, indices[i]);\n                        }\n                    } else {\n                        var draw = Registry.getComponentMethod(componentType, 'draw');\n                        if(draw === Lib.noop) {\n                            throw new Error('cannot draw components: ' + componentType);\n                        }\n                        draw(gd);\n                    }\n                }\n            }\n\n            seq.push(Plots.previousPromises);\n            if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n            if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n            if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n            if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n            if(relayoutFlags.axrange) addAxRangeSequence(seq);\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n            if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n            if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n            seq.push(emitAfterPlot);\n        }\n\n        seq.push(\n            Plots.rehover,\n            Plots.redrag,\n            Plots.reselect\n        );\n\n        plotDone = Lib.syncOrAsync(seq, gd);\n        if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n    }\n\n    return plotDone.then(function() {\n        gd.emit('plotly_react', {\n            data: data,\n            layout: layout\n        });\n\n        return gd;\n    });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n    var sameTraceLength = oldFullData.length === newFullData.length;\n\n    if(!transition && !sameTraceLength) {\n        return {\n            fullReplot: true,\n            calc: true\n        };\n    }\n\n    var flags = editTypes.traceFlags();\n    flags.arrays = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    var i, trace;\n\n    function getTraceValObject(parts) {\n        var out = PlotSchema.getTraceValObject(trace, parts);\n        if(!trace._module.animatable && out.anim) {\n            out.anim = false;\n        }\n        return out;\n    }\n\n    var diffOpts = {\n        getValObject: getTraceValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        newDataRevision: newDataRevision,\n        gd: gd\n    };\n\n    var seenUIDs = {};\n\n    for(i = 0; i < oldFullData.length; i++) {\n        if(newFullData[i]) {\n            trace = newFullData[i]._fullInput;\n            if(Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n            if(seenUIDs[trace.uid]) continue;\n            seenUIDs[trace.uid] = 1;\n\n            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = (flags.nChanges === flags.nChangesAnim) && sameTraceLength ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n    var flags = editTypes.layoutFlags();\n    flags.arrays = {};\n    flags.rangesAltered = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    function getLayoutValObject(parts) {\n        return PlotSchema.getLayoutValObject(newFullLayout, parts);\n    }\n\n    var diffOpts = {\n        getValObject: getLayoutValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        gd: gd\n    };\n\n    getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n    var valObject, key, astr;\n\n    var getValObject = opts.getValObject;\n    var flags = opts.flags;\n    var immutable = opts.immutable;\n    var inArray = opts.inArray;\n    var arrayIndex = opts.arrayIndex;\n\n    function changed() {\n        var editType = valObject.editType;\n        if(inArray && editType.indexOf('arraydraw') !== -1) {\n            Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n            return;\n        }\n        editTypes.update(flags, valObject);\n\n        if(editType !== 'none') {\n            flags.nChanges++;\n        }\n\n        // track animatable changes\n        if(opts.transition && valObject.anim) {\n            flags.nChangesAnim++;\n        }\n\n        // track cartesian axes with altered ranges\n        if(AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n            flags.rangesAltered[outerparts[0]] = 1;\n        }\n\n        // clear _inputDomain on cartesian axes with altered domains\n        if(AX_DOMAIN_RE.test(astr)) {\n            nestedProperty(newContainer, '_inputDomain').set(null);\n        }\n\n        // track datarevision changes\n        if(key === 'datarevision') {\n            flags.newDataRevision = 1;\n        }\n    }\n\n    function valObjectCanBeDataArray(valObject) {\n        return valObject.valType === 'data_array' || valObject.arrayOk;\n    }\n\n    for(key in oldContainer) {\n        // short-circuit based on previous calls or previous keys that already maximized the pathway\n        if(flags.calc && !opts.transition) return;\n\n        var oldVal = oldContainer[key];\n        var newVal = newContainer[key];\n        var parts = outerparts.concat(key);\n        astr = parts.join('.');\n\n        if(key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\n\n        // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n        // and unlike other auto values they don't make it back into the input,\n        // so newContainer won't have them.\n        if((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n            var tickMode = newContainer.tickmode;\n            if(tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n        }\n        // FIXME: Similarly for axis ranges for 3D\n        // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n        if(key === 'range' && newContainer.autorange) continue;\n        if((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n\n        valObject = getValObject(parts);\n\n        // in case type changed, we may not even *have* a valObject.\n        if(!valObject) continue;\n\n        if(valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n\n        var valType = valObject.valType;\n        var i;\n\n        var canBeDataArray = valObjectCanBeDataArray(valObject);\n        var wasArray = Array.isArray(oldVal);\n        var nowArray = Array.isArray(newVal);\n\n        // hack for traces that modify the data in supplyDefaults, like\n        // converting 1D to 2D arrays, which will always create new objects\n        if(wasArray && nowArray) {\n            var inputKey = '_input_' + key;\n            var oldValIn = oldContainer[inputKey];\n            var newValIn = newContainer[inputKey];\n            if(Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n        }\n\n        if(newVal === undefined) {\n            if(canBeDataArray && wasArray) flags.calc = true;\n            else changed();\n        } else if(valObject._isLinkedToArray) {\n            var arrayEditIndices = [];\n            var extraIndices = false;\n            if(!inArray) flags.arrays[key] = arrayEditIndices;\n\n            var minLen = Math.min(oldVal.length, newVal.length);\n            var maxLen = Math.max(oldVal.length, newVal.length);\n            if(minLen !== maxLen) {\n                if(valObject.editType === 'arraydraw') {\n                    extraIndices = true;\n                } else {\n                    changed();\n                    continue;\n                }\n            }\n\n            for(i = 0; i < minLen; i++) {\n                getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\n                    // add array indices, but not if we're already in an array\n                    Lib.extendFlat({inArray: key, arrayIndex: i}, opts));\n            }\n\n            // put this at the end so that we know our collected array indices are sorted\n            // but the check for length changes happens up front so we can short-circuit\n            // diffing if appropriate\n            if(extraIndices) {\n                for(i = minLen; i < maxLen; i++) {\n                    arrayEditIndices.push(i);\n                }\n            }\n        } else if(!valType && Lib.isPlainObject(oldVal)) {\n            getDiffFlags(oldVal, newVal, parts, opts);\n        } else if(canBeDataArray) {\n            if(wasArray && nowArray) {\n                // don't try to diff two data arrays. If immutable we know the data changed,\n                // if not, assume it didn't and let `layout.datarevision` tell us if it did\n                if(immutable) {\n                    flags.calc = true;\n                }\n\n                // look for animatable attributes when the data changed\n                if(immutable || opts.newDataRevision) {\n                    changed();\n                }\n            } else if(wasArray !== nowArray) {\n                flags.calc = true;\n            } else changed();\n        } else if(wasArray && nowArray) {\n            // info array, colorscale, 'any' - these are short, just stringify.\n            // I don't *think* that covers up any real differences post-validation, does it?\n            // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n            // all elements.\n            if(oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n                changed();\n            }\n        } else {\n            changed();\n        }\n    }\n\n    for(key in newContainer) {\n        if(!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n            valObject = getValObject(outerparts.concat(key));\n\n            if(valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n                flags.calc = true;\n                return;\n            } else changed();\n        }\n    }\n}\n\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\nfunction diffConfig(oldConfig, newConfig) {\n    var key;\n\n    for(key in oldConfig) {\n        if(key.charAt(0) === '_') continue;\n        var oldVal = oldConfig[key];\n        var newVal = newConfig[key];\n        if(oldVal !== newVal) {\n            if(Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n                if(diffConfig(oldVal, newVal)) {\n                    return true;\n                }\n            } else if(Array.isArray(oldVal) && Array.isArray(newVal)) {\n                if(oldVal.length !== newVal.length) {\n                    return true;\n                }\n                for(var i = 0; i < oldVal.length; i++) {\n                    if(oldVal[i] !== newVal[i]) {\n                        if(Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n                            if(diffConfig(oldVal[i], newVal[i])) {\n                                return true;\n                            }\n                        } else {\n                            return true;\n                        }\n                    }\n                }\n            } else {\n                return true;\n            }\n        }\n    }\n}\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before animating it. For more details, see ' +\n            'https://plotly.com/javascript/animations/'\n        );\n    }\n\n    var trans = gd._transitionData;\n\n    // This is the queue of frames that will be animated as soon as possible. They\n    // are popped immediately upon the *start* of a transition:\n    if(!trans._frameQueue) {\n        trans._frameQueue = [];\n    }\n\n    animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n    var transitionOpts = animationOpts.transition;\n    var frameOpts = animationOpts.frame;\n\n    // Since frames are popped immediately, an empty queue only means all frames have\n    // *started* to transition, not that the animation is complete. To solve that,\n    // track a separate counter that increments at the same time as frames are added\n    // to the queue, but decrements only when the transition is complete.\n    if(trans._frameWaitingCnt === undefined) {\n        trans._frameWaitingCnt = 0;\n    }\n\n    function getTransitionOpts(i) {\n        if(Array.isArray(transitionOpts)) {\n            if(i >= transitionOpts.length) {\n                return transitionOpts[0];\n            } else {\n                return transitionOpts[i];\n            }\n        } else {\n            return transitionOpts;\n        }\n    }\n\n    function getFrameOpts(i) {\n        if(Array.isArray(frameOpts)) {\n            if(i >= frameOpts.length) {\n                return frameOpts[0];\n            } else {\n                return frameOpts[i];\n            }\n        } else {\n            return frameOpts;\n        }\n    }\n\n    // Execute a callback after the wrapper function has been called n times.\n    // This is used to defer the resolution until a transition has resolved *and*\n    // the frame has completed. If it's not done this way, then we get a race\n    // condition in which the animation might resolve before a transition is complete\n    // or vice versa.\n    function callbackOnNthTime(cb, n) {\n        var cnt = 0;\n        return function() {\n            if(cb && ++cnt === n) {\n                return cb();\n            }\n        };\n    }\n\n    return new Promise(function(resolve, reject) {\n        function discardExistingFrames() {\n            if(trans._frameQueue.length === 0) {\n                return;\n            }\n\n            while(trans._frameQueue.length) {\n                var next = trans._frameQueue.pop();\n                if(next.onInterrupt) {\n                    next.onInterrupt();\n                }\n            }\n\n            gd.emit('plotly_animationinterrupted', []);\n        }\n\n        function queueFrames(frameList) {\n            if(frameList.length === 0) return;\n\n            for(var i = 0; i < frameList.length; i++) {\n                var computedFrame;\n\n                if(frameList[i].type === 'byname') {\n                    // If it's a named frame, compute it:\n                    computedFrame = Plots.computeFrame(gd, frameList[i].name);\n                } else {\n                    // Otherwise we must have been given a simple object, so treat\n                    // the input itself as the computed frame.\n                    computedFrame = frameList[i].data;\n                }\n\n                var frameOpts = getFrameOpts(i);\n                var transitionOpts = getTransitionOpts(i);\n\n                // It doesn't make much sense for the transition duration to be greater than\n                // the frame duration, so limit it:\n                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n\n                var nextFrame = {\n                    frame: computedFrame,\n                    name: frameList[i].name,\n                    frameOpts: frameOpts,\n                    transitionOpts: transitionOpts,\n                };\n                if(i === frameList.length - 1) {\n                    // The last frame in this .animate call stores the promise resolve\n                    // and reject callbacks. This is how we ensure that the animation\n                    // loop (which may exist as a result of a *different* .animate call)\n                    // still resolves or rejecdts this .animate call's promise. once it's\n                    // complete.\n                    nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n                    nextFrame.onInterrupt = reject;\n                }\n\n                trans._frameQueue.push(nextFrame);\n            }\n\n            // Set it as never having transitioned to a frame. This will cause the animation\n            // loop to immediately transition to the next frame (which, for immediate mode,\n            // is the first frame in the list since all others would have been discarded\n            // below)\n            if(animationOpts.mode === 'immediate') {\n                trans._lastFrameAt = -Infinity;\n            }\n\n            // Only it's not already running, start a RAF loop. This could be avoided in the\n            // case that there's only one frame, but it significantly complicated the logic\n            // and only sped things up by about 5% or so for a lorenz attractor simulation.\n            // It would be a fine thing to implement, but the benefit of that optimization\n            // doesn't seem worth the extra complexity.\n            if(!trans._animationRaf) {\n                beginAnimationLoop();\n            }\n        }\n\n        function stopAnimationLoop() {\n            gd.emit('plotly_animated');\n\n            // Be sure to unset also since it's how we know whether a loop is already running:\n            window.cancelAnimationFrame(trans._animationRaf);\n            trans._animationRaf = null;\n        }\n\n        function nextFrame() {\n            if(trans._currentFrame && trans._currentFrame.onComplete) {\n                // Execute the callback and unset it to ensure it doesn't\n                // accidentally get called twice\n                trans._currentFrame.onComplete();\n            }\n\n            var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n            if(newFrame) {\n                // Since it's sometimes necessary to do deep digging into frame data,\n                // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n                // so check when casting the name, just to be absolutely certain:\n                var stringName = newFrame.name ? newFrame.name.toString() : null;\n                gd._fullLayout._currentFrame = stringName;\n\n                trans._lastFrameAt = Date.now();\n                trans._timeToNext = newFrame.frameOpts.duration;\n\n                // This is simply called and it's left to .transition to decide how to manage\n                // interrupting current transitions. That means we don't need to worry about\n                // how it resolves or what happens after this:\n                Plots.transition(gd,\n                    newFrame.frame.data,\n                    newFrame.frame.layout,\n                    helpers.coerceTraceIndices(gd, newFrame.frame.traces),\n                    newFrame.frameOpts,\n                    newFrame.transitionOpts\n                ).then(function() {\n                    if(newFrame.onComplete) {\n                        newFrame.onComplete();\n                    }\n                });\n\n                gd.emit('plotly_animatingframe', {\n                    name: stringName,\n                    frame: newFrame.frame,\n                    animation: {\n                        frame: newFrame.frameOpts,\n                        transition: newFrame.transitionOpts,\n                    }\n                });\n            } else {\n                // If there are no more frames, then stop the RAF loop:\n                stopAnimationLoop();\n            }\n        }\n\n        function beginAnimationLoop() {\n            gd.emit('plotly_animating');\n\n            // If no timer is running, then set last frame = long ago so that the next\n            // frame is immediately transitioned:\n            trans._lastFrameAt = -Infinity;\n            trans._timeToNext = 0;\n            trans._runningTransitions = 0;\n            trans._currentFrame = null;\n\n            var doFrame = function() {\n                // This *must* be requested before nextFrame since nextFrame may decide\n                // to cancel it if there's nothing more to animated:\n                trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n                // Check if we're ready for a new frame:\n                if(Date.now() - trans._lastFrameAt > trans._timeToNext) {\n                    nextFrame();\n                }\n            };\n\n            doFrame();\n        }\n\n        // This is an animate-local counter that helps match up option input list\n        // items with the particular frame.\n        var configCounter = 0;\n        function setTransitionConfig(frame) {\n            if(Array.isArray(transitionOpts)) {\n                if(configCounter >= transitionOpts.length) {\n                    frame.transitionOpts = transitionOpts[configCounter];\n                } else {\n                    frame.transitionOpts = transitionOpts[0];\n                }\n            } else {\n                frame.transitionOpts = transitionOpts;\n            }\n            configCounter++;\n            return frame;\n        }\n\n        // Disambiguate what's sort of frames have been received\n        var i, frame;\n        var frameList = [];\n        var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n        var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n        var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n        if(isSingleFrame) {\n            // In this case, a simple object has been passed to animate.\n            frameList.push({\n                type: 'object',\n                data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n            });\n        } else if(allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n            // In this case, null or undefined has been passed so that we want to\n            // animate *all* currently defined frames\n            for(i = 0; i < trans._frames.length; i++) {\n                frame = trans._frames[i];\n\n                if(!frame) continue;\n\n                if(allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n                    frameList.push({\n                        type: 'byname',\n                        name: String(frame.name),\n                        data: setTransitionConfig({name: frame.name})\n                    });\n                }\n            }\n        } else if(isFrameArray) {\n            for(i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n                var frameOrName = frameOrGroupNameOrFrameList[i];\n                if(['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n                    frameOrName = String(frameOrName);\n                    // In this case, there's an array and this frame is a string name:\n                    frameList.push({\n                        type: 'byname',\n                        name: frameOrName,\n                        data: setTransitionConfig({name: frameOrName})\n                    });\n                } else if(Lib.isPlainObject(frameOrName)) {\n                    frameList.push({\n                        type: 'object',\n                        data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n                    });\n                }\n            }\n        }\n\n        // Verify that all of these frames actually exist; return and reject if not:\n        for(i = 0; i < frameList.length; i++) {\n            frame = frameList[i];\n            if(frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n                Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n                reject();\n                return;\n            }\n        }\n\n        // If the mode is either next or immediate, then all currently queued frames must\n        // be dumped and the corresponding .animate promises rejected.\n        if(['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n            discardExistingFrames();\n        }\n\n        if(animationOpts.direction === 'reverse') {\n            frameList.reverse();\n        }\n\n        var currentFrame = gd._fullLayout._currentFrame;\n        if(currentFrame && animationOpts.fromcurrent) {\n            var idx = -1;\n            for(i = 0; i < frameList.length; i++) {\n                frame = frameList[i];\n                if(frame.type === 'byname' && frame.name === currentFrame) {\n                    idx = i;\n                    break;\n                }\n            }\n\n            if(idx > 0 && idx < frameList.length - 1) {\n                var filteredFrameList = [];\n                for(i = 0; i < frameList.length; i++) {\n                    frame = frameList[i];\n                    if(frameList[i].type !== 'byname' || i > idx) {\n                        filteredFrameList.push(frame);\n                    }\n                }\n                frameList = filteredFrameList;\n            }\n        }\n\n        if(frameList.length > 0) {\n            queueFrames(frameList);\n        } else {\n            // This is the case where there were simply no frames. It's a little strange\n            // since there's not much to do:\n            gd.emit('plotly_animated');\n            resolve();\n        }\n    });\n}\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nfunction addFrames(gd, frameList, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(frameList === null || frameList === undefined) {\n        return Promise.resolve();\n    }\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before adding frames. For more details, see ' +\n            'https://plotly.com/javascript/animations/'\n        );\n    }\n\n    var i, frame, j, idx;\n    var _frames = gd._transitionData._frames;\n    var _frameHash = gd._transitionData._frameHash;\n\n\n    if(!Array.isArray(frameList)) {\n        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n    }\n\n    // Create a sorted list of insertions since we run into lots of problems if these\n    // aren't in ascending order of index:\n    //\n    // Strictly for sorting. Make sure this is guaranteed to never collide with any\n    // already-exisisting indices:\n    var bigIndex = _frames.length + frameList.length * 2;\n\n    var insertions = [];\n    var _frameHashLocal = {};\n    for(i = frameList.length - 1; i >= 0; i--) {\n        if(!Lib.isPlainObject(frameList[i])) continue;\n\n        // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n        // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n        var lookupName = frameList[i].name;\n        var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n        var newName = frameList[i].name;\n        var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n        if(name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n            numericNameWarningCount++;\n\n            Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name +\n                '\" with a frame whose name of type \"number\" also equates to \"' +\n                name + '\". This is valid but may potentially lead to unexpected ' +\n                'behavior since all plotly.js frame names are stored internally ' +\n                'as strings.');\n\n            if(numericNameWarningCount === numericNameWarningCountLimit) {\n                Lib.warn('addFrames: This API call has yielded too many of these warnings. ' +\n                    'For the rest of this call, further warnings about numeric frame ' +\n                    'names will be suppressed.');\n            }\n        }\n\n        _frameHashLocal[lookupName] = {name: lookupName};\n\n        insertions.push({\n            frame: Plots.supplyFrameDefaults(frameList[i]),\n            index: (indices && indices[i] !== undefined && indices[i] !== null) ? indices[i] : bigIndex + i\n        });\n    }\n\n    // Sort this, taking note that undefined insertions end up at the end:\n    insertions.sort(function(a, b) {\n        if(a.index > b.index) return -1;\n        if(a.index < b.index) return 1;\n        return 0;\n    });\n\n    var ops = [];\n    var revops = [];\n    var frameCount = _frames.length;\n\n    for(i = insertions.length - 1; i >= 0; i--) {\n        frame = insertions[i].frame;\n\n        if(typeof frame.name === 'number') {\n            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +\n                'implicitly cast to strings');\n        }\n\n        if(!frame.name) {\n            // Repeatedly assign a default name, incrementing the counter each time until\n            // we get a name that's not in the hashed lookup table:\n            while(_frameHash[(frame.name = 'frame ' + gd._transitionData._counter++)]);\n        }\n\n        if(_frameHash[frame.name]) {\n            // If frame is present, overwrite its definition:\n            for(j = 0; j < _frames.length; j++) {\n                if((_frames[j] || {}).name === frame.name) break;\n            }\n            ops.push({type: 'replace', index: j, value: frame});\n            revops.unshift({type: 'replace', index: j, value: _frames[j]});\n        } else {\n            // Otherwise insert it at the end of the list:\n            idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n\n            ops.push({type: 'insert', index: idx, value: frame});\n            revops.unshift({type: 'delete', index: idx});\n            frameCount++;\n        }\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nfunction deleteFrames(gd, frameList) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    var i, idx;\n    var _frames = gd._transitionData._frames;\n    var ops = [];\n    var revops = [];\n\n    if(!frameList) {\n        frameList = [];\n        for(i = 0; i < _frames.length; i++) {\n            frameList.push(i);\n        }\n    }\n\n    frameList = frameList.slice();\n    frameList.sort();\n\n    for(i = frameList.length - 1; i >= 0; i--) {\n        idx = frameList[i];\n        ops.push({type: 'delete', index: idx});\n        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n}\n\n/**\n * Purge a graph container div back to its initial pre-_doPlot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nfunction purge(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    var fullLayout = gd._fullLayout || {};\n    var fullData = gd._fullData || [];\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, fullData, fullLayout);\n\n    // purge properties\n    Plots.purge(gd);\n\n    // purge event emitter methods\n    Events.purge(gd);\n\n    // remove plot container\n    if(fullLayout._container) fullLayout._container.remove();\n\n    // in contrast to _doPlots.purge which does NOT clear _context!\n    delete gd._context;\n\n    return gd;\n}\n\n// determines if the graph div requires a recalculation of its inverse matrix transforms by comparing old + new bounding boxes.\nfunction calcInverseTransform(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var newBBox = gd.getBoundingClientRect();\n    if(Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;\n\n    var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));\n    fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);\n    fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);\n    fullLayout._lastBBox = newBBox;\n}\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n    var gd3 = d3.select(gd);\n    var fullLayout = gd._fullLayout;\n\n    fullLayout._calcInverseTransform = calcInverseTransform;\n    fullLayout._calcInverseTransform(gd);\n\n    // Plot container\n    fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n    fullLayout._container.enter()\n        .insert('div', ':first-child')\n        .classed('plot-container', true)\n        .classed('plotly', true)\n        // The plot container should always take the full with the height of its\n        // parent (the graph div). This ensures that for responsive plots\n        // without a height or width set, the paper div will take up the full\n        // height & width of the graph div. \n        // So, for responsive plots without a height or width set, if the plot\n        // container's height is left to 'auto', its height will be dictated by\n        // its childrens' height. (The plot container's only child is the paper\n        // div.) \n        // In this scenario, the paper div's height will be set to 100%,\n        // which will be 100% of the plot container's auto height. That is\n        // meaninglesss, so the browser will use the paper div's children to set\n        // the height of the plot container instead. However, the paper div's\n        // children do not have any height, because they are all positioned\n        // absolutely, and therefore take up no space.\n        .style({\n            width: \"100%\",\n            height: \"100%\"\n        });\n\n    // Make the svg container\n    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n    fullLayout._paperdiv.enter().append('div')\n        .classed('user-select-none', true)\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // Make the graph containers\n    // start fresh each time we get here, so we know the order comes out\n    // right, rather than enter/exit which can muck up the order\n    // TODO: sort out all the ordering so we don't have to\n    // explicitly delete anything\n    // FIXME: parcoords reuses this object, not the best pattern\n    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')\n        .data([{}]);\n\n    fullLayout._glcontainer.enter().append('div')\n        .classed('gl-container', true);\n\n    fullLayout._paperdiv.selectAll('.main-svg').remove();\n    fullLayout._paperdiv.select('.modebar-container').remove();\n\n    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')\n        .classed('main-svg', true);\n\n    fullLayout._toppaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n    delete fullLayout._modeBar;\n\n    fullLayout._hoverpaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    if(!fullLayout._uid) {\n        var otherUids = {};\n        d3.selectAll('defs').each(function() {\n            if(this.id) otherUids[this.id.split('-')[1]] = 1;\n        });\n        fullLayout._uid = Lib.randstr(otherUids);\n    }\n\n    fullLayout._paperdiv.selectAll('.main-svg')\n        .attr(xmlnsNamespaces.svgAttrs);\n\n    fullLayout._defs = fullLayout._paper.append('defs')\n        .attr('id', 'defs-' + fullLayout._uid);\n\n    fullLayout._clips = fullLayout._defs.append('g')\n        .classed('clips', true);\n\n    fullLayout._topdefs = fullLayout._toppaper.append('defs')\n        .attr('id', 'topdefs-' + fullLayout._uid);\n\n    fullLayout._topclips = fullLayout._topdefs.append('g')\n        .classed('clips', true);\n\n    fullLayout._bgLayer = fullLayout._paper.append('g')\n        .classed('bglayer', true);\n\n    fullLayout._draggers = fullLayout._paper.append('g')\n        .classed('draglayer', true);\n\n    // lower shape/image layer - note that this is behind\n    // all subplots data/grids but above the backgrounds\n    // except inset subplots, whose backgrounds are drawn\n    // inside their own group so that they appear above\n    // the data for the main subplot\n    // lower shapes and images which are fully referenced to\n    // a subplot still get drawn within the subplot's group\n    // so they will work correctly on insets\n    var layerBelow = fullLayout._paper.append('g')\n        .classed('layer-below', true);\n    fullLayout._imageLowerLayer = layerBelow.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeLowerLayer = layerBelow.append('g')\n        .classed('shapelayer', true);\n\n    // single cartesian layer for the whole plot\n    fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n    // single polar layer for the whole plot\n    fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\n\n    // single smith layer for the whole plot\n    fullLayout._smithlayer = fullLayout._paper.append('g').classed('smithlayer', true);\n\n    // single ternary layer for the whole plot\n    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n    // single geo layer for the whole plot\n    fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n    // single funnelarea layer for the whole plot\n    fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true);\n\n    // single pie layer for the whole plot\n    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n    // single treemap layer for the whole plot\n    fullLayout._iciclelayer = fullLayout._paper.append('g').classed('iciclelayer', true);\n\n    // single treemap layer for the whole plot\n    fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true);\n\n    // single sunburst layer for the whole plot\n    fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true);\n\n    // single indicator layer for the whole plot\n    fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true);\n\n    // fill in image server scrape-svg\n    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n    // lastly upper shapes, info (legend, annotations) and hover layers go on top\n    // these are in a different svg element normally, but get collapsed into a single\n    // svg when exporting (after inserting 3D)\n    // upper shapes/images are only those drawn above the whole plot, including subplots\n    var layerAbove = fullLayout._toppaper.append('g')\n        .classed('layer-above', true);\n    fullLayout._imageUpperLayer = layerAbove.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeUpperLayer = layerAbove.append('g')\n        .classed('shapelayer', true);\n\n    fullLayout._selectionLayer = fullLayout._toppaper.append('g').classed('selectionlayer', true);\n    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n    fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n    fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true);\n\n    // Make the modebar container\n    fullLayout._modebardiv\n        .classed('modebar-container', true)\n        .style('position', 'absolute')\n        .style('top', '0px')\n        .style('right', '0px');\n\n    gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\n\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\n\nexports.newPlot = newPlot;\nexports._doPlot = _doPlot;\nexports.purge = purge;\n\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\n\nexports.setPlotConfig = setPlotConfig;\n\nexports.update = update;\n\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\n\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,YAAY,CAAC;AAC9B,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACzC,IAAIE,QAAQ,GAAGF,OAAO,CAAC,WAAW,CAAC;AAEnC,IAAIG,GAAG,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAC3B,IAAII,cAAc,GAAGD,GAAG,CAACC,cAAc;AAEvC,IAAIC,MAAM,GAAGL,OAAO,CAAC,eAAe,CAAC;AACrC,IAAIM,KAAK,GAAGN,OAAO,CAAC,cAAc,CAAC;AAEnC,IAAIO,QAAQ,GAAGP,OAAO,CAAC,aAAa,CAAC;AACrC,IAAIQ,UAAU,GAAGR,OAAO,CAAC,eAAe,CAAC;AACzC,IAAIS,KAAK,GAAGT,OAAO,CAAC,gBAAgB,CAAC;AAErC,IAAIU,IAAI,GAAGV,OAAO,CAAC,yBAAyB,CAAC;AAC7C,IAAIW,mBAAmB,GAAGX,OAAO,CAAC,mCAAmC,CAAC;AAEtE,IAAIY,yBAAyB,GAAGZ,OAAO,CAAC,sCAAsC,CAAC;AAC/E,IAAIa,OAAO,GAAGb,OAAO,CAAC,uBAAuB,CAAC;AAC9C,IAAIc,KAAK,GAAGd,OAAO,CAAC,qBAAqB,CAAC;AAC1C,IAAIe,gBAAgB,GAAGf,OAAO,CAAC,mCAAmC,CAAC,CAACe,gBAAgB;AACpF,IAAIC,eAAe,GAAGhB,OAAO,CAAC,+BAA+B,CAAC;AAC9D,IAAIiB,YAAY,GAAGjB,OAAO,CAAC,0BAA0B,CAAC,CAACiB,YAAY;AAEnE,IAAIC,UAAU,GAAGlB,OAAO,CAAC,eAAe,CAAC,CAACkB,UAAU;AACpD,IAAIC,YAAY,GAAGnB,OAAO,CAAC,iBAAiB,CAAC;AAC7C,IAAIoB,OAAO,GAAGpB,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIqB,WAAW,GAAGrB,OAAO,CAAC,eAAe,CAAC;AAC1C,IAAIsB,SAAS,GAAGtB,OAAO,CAAC,cAAc,CAAC;AAEvC,IAAIuB,eAAe,GAAGvB,OAAO,CAAC,8BAA8B,CAAC,CAACuB,eAAe;AAE7E,IAAIC,uBAAuB,GAAG,CAAC;AAC/B,IAAIC,4BAA4B,GAAG,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAE;EACvC,IAAIC,MAAM;EAEVJ,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;;EAExB;EACAtB,MAAM,CAAC4B,IAAI,CAACN,EAAE,CAAC;EAEf,IAAGxB,GAAG,CAAC+B,aAAa,CAACN,IAAI,CAAC,EAAE;IACxB,IAAIO,GAAG,GAAGP,IAAI;IACdA,IAAI,GAAGO,GAAG,CAACP,IAAI;IACfC,MAAM,GAAGM,GAAG,CAACN,MAAM;IACnBC,MAAM,GAAGK,GAAG,CAACL,MAAM;IACnBC,MAAM,GAAGI,GAAG,CAACJ,MAAM;EACvB;EAEA,IAAIK,QAAQ,GAAG/B,MAAM,CAACgC,cAAc,CAACV,EAAE,EAAE,mBAAmB,EAAE,CAACC,IAAI,EAAEC,MAAM,EAAEC,MAAM,CAAC,CAAC;EACrF,IAAGM,QAAQ,KAAK,KAAK,EAAE,OAAOE,OAAO,CAACC,MAAM,CAAC,CAAC;;EAE9C;EACA;EACA,IAAG,CAACX,IAAI,IAAI,CAACC,MAAM,IAAI,CAAC1B,GAAG,CAACqC,SAAS,CAACb,EAAE,CAAC,EAAE;IACvCxB,GAAG,CAACsC,IAAI,CAAC,kCAAkC,GACvC,8CAA8C,EAAEd,EAAE,CAAC;EAC3D;EAEA,SAASe,SAASA,CAAA,EAAG;IACjB,IAAGX,MAAM,EAAE;MACP,OAAOY,OAAO,CAACD,SAAS,CAACf,EAAE,EAAEI,MAAM,CAAC;IACxC;EACJ;;EAEA;EACA;EACAa,cAAc,CAACjB,EAAE,EAAEG,MAAM,CAAC;EAE1B,IAAG,CAACD,MAAM,EAAEA,MAAM,GAAG,CAAC,CAAC;;EAEvB;EACA;EACA9B,EAAE,CAAC8C,MAAM,CAAClB,EAAE,CAAC,CAACmB,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;;EAE7C;EACA;EACA;EACAjC,OAAO,CAACkC,UAAU,CAAC,CAAC;;EAEpB;EACA;EACA;EACA;EACA,IAAG,CAACC,KAAK,CAACC,OAAO,CAACtB,EAAE,CAACuB,SAAS,CAAC,EAAEvB,EAAE,CAACuB,SAAS,GAAG,EAAE;EAElD,IAAIC,aAAa,GAAI,CAACxB,EAAE,CAACC,IAAI,IAAI,EAAE,EAAEwB,MAAM,KAAK,CAAC,IAAIJ,KAAK,CAACC,OAAO,CAACrB,IAAI,CAAE;;EAEzE;EACA;EACA,IAAGoB,KAAK,CAACC,OAAO,CAACrB,IAAI,CAAC,EAAE;IACpBR,OAAO,CAACiC,SAAS,CAACzB,IAAI,CAAC;IAEvB,IAAGuB,aAAa,EAAExB,EAAE,CAACC,IAAI,GAAGA,IAAI,CAAC,KAC5BD,EAAE,CAACC,IAAI,CAAC0B,IAAI,CAACC,KAAK,CAAC5B,EAAE,CAACC,IAAI,EAAEA,IAAI,CAAC;;IAEtC;IACA;IACA;IACAD,EAAE,CAAC6B,KAAK,GAAG,KAAK;EACpB;EAEA,IAAG,CAAC7B,EAAE,CAACE,MAAM,IAAIsB,aAAa,EAAE;IAC5BxB,EAAE,CAACE,MAAM,GAAGT,OAAO,CAACqC,WAAW,CAAC5B,MAAM,CAAC;EAC3C;EAEApB,KAAK,CAACiD,cAAc,CAAC/B,EAAE,CAAC;EAExB,IAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAC/B,IAAIC,YAAY,GAAGF,UAAU,CAACG,IAAI,CAAC,WAAW,CAAC;;EAE/C;EACA;EACAH,UAAU,CAACI,WAAW,GAAG,IAAI;;EAE7B;EACA,IAAGZ,aAAa,IAAIQ,UAAU,CAACK,oBAAoB,EAAE;IACjDC,iBAAiB,CAACtC,EAAE,CAAC;IAErB,IAAGgC,UAAU,CAACK,oBAAoB,EAAE;MAChC,OAAOL,UAAU,CAACK,oBAAoB;IAC1C;EACJ;;EAEA;EACAnD,OAAO,CAACqD,aAAa,CAACvC,EAAE,CAAC;EACzBd,OAAO,CAACsD,YAAY,CAACxC,EAAE,CAAC;;EAExB;EACA,IAAGwB,aAAa,EAAEzC,IAAI,CAAC0D,oBAAoB,CAACzC,EAAE,CAAC;;EAE/C;;EAEA;EACA;EACA,IAAI0C,MAAM,GAAG,CAAC1C,EAAE,CAAC2C,QAAQ,IAAI3C,EAAE,CAAC2C,QAAQ,CAAClB,MAAM,KAAK,CAACzB,EAAE,CAAC4C,SAAS,IAAI,EAAE,EAAEnB,MAAM;EAC/E,IAAGiB,MAAM,EAAE5D,KAAK,CAAC+D,UAAU,CAAC7C,EAAE,CAAC;;EAE/B;EACA,KAAI,IAAI8C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9C,EAAE,CAAC2C,QAAQ,CAAClB,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACxC9C,EAAE,CAAC2C,QAAQ,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,KAAK,GAAG/C,EAAE,CAAC4C,SAAS,CAACE,CAAC,CAAC;EAC7C;;EAEA;EACA,IAAG9C,EAAE,CAACgD,QAAQ,CAACC,UAAU,EAAE;IACvB,IAAG,CAACjD,EAAE,CAACkD,uBAAuB,EAAE;MAC5B;MACAlD,EAAE,CAACkD,uBAAuB,GAAG,YAAW;QAAE,IAAG,CAAC1E,GAAG,CAAC2E,QAAQ,CAACnD,EAAE,CAAC,EAAElB,KAAK,CAACsE,MAAM,CAACpD,EAAE,CAAC;MAAE,CAAC;;MAEnF;MACAqD,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAEtD,EAAE,CAACkD,uBAAuB,CAAC;IACjE;EACJ,CAAC,MAAM;IACH1E,GAAG,CAAC+E,eAAe,CAACvD,EAAE,CAAC;EAC3B;;EAEA;AACJ;AACA;;EAEI,IAAIwD,UAAU,GAAGhF,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAEzB,UAAU,CAAC0B,KAAK,CAAC;;EAErD;EACA;EACA,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,SAASC,aAAaA,CAAA,EAAG;IACrB,IAAIC,eAAe,GAAG7B,UAAU,CAAC8B,gBAAgB;IAEjD,KAAI,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,eAAe,CAACpC,MAAM,EAAEqB,CAAC,EAAE,EAAE;MAC5C,IAAGe,eAAe,CAACf,CAAC,CAAC,CAACc,aAAa,EAAE;QACjCC,eAAe,CAACf,CAAC,CAAC,CAACc,aAAa,CAAC5D,EAAE,CAAC;MACxC;IACJ;IAEA,IAAG,CAACgC,UAAU,CAAC+B,SAAS,IAAI/B,UAAU,CAACG,IAAI,CAAC,IAAI,CAAC,EAAE;MAC/CH,UAAU,CAAC+B,SAAS,GAAG/B,UAAU,CAACgC,YAAY,CAACC,SAAS,CAAC,YAAY,CAAC,CAAChE,IAAI,CAAC,CAAC;QACzEiE,GAAG,EAAE,cAAc;QACnBC,OAAO,EAAE,IAAI;QACbC,IAAI,EAAE;MACV,CAAC,EAAE;QACCF,GAAG,EAAE,YAAY;QACjBC,OAAO,EAAE,KAAK;QACdC,IAAI,EAAE;MACV,CAAC,EAAE;QACCF,GAAG,EAAE,WAAW;QAChBC,OAAO,EAAE,KAAK;QACdC,IAAI,EAAE;MACV,CAAC,CAAC,EAAE,UAASC,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACH,GAAG;MAAE,CAAC,CAAC;MAElClC,UAAU,CAAC+B,SAAS,CAACO,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,QAAQ,CAAC,CACxCC,IAAI,CAAC,OAAO,EAAE,UAASH,CAAC,EAAE;QACvB,OAAO,sBAAsB,GAAGA,CAAC,CAACH,GAAG,CAACO,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;MAC9D,CAAC,CAAC,CACDC,KAAK,CAAC;QACHC,QAAQ,EAAE,UAAU;QACpBC,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACPC,QAAQ,EAAE,SAAS;QACnB,gBAAgB,EAAE;MACtB,CAAC,CAAC;IACV;IAEA,IAAIC,gBAAgB,GAAG/E,EAAE,CAACgD,QAAQ,CAAC+B,gBAAgB;IACnD,IAAG/C,UAAU,CAAC+B,SAAS,EAAE;MACrB/B,UAAU,CAAC+B,SAAS,CACfS,IAAI,CAAC,OAAO,EAAExC,UAAU,CAACgD,KAAK,GAAGD,gBAAgB,CAAC,CAClDP,IAAI,CAAC,QAAQ,EAAExC,UAAU,CAACiD,MAAM,GAAGF,gBAAgB,CAAC,CACpDL,KAAK,CAAC,OAAO,EAAE1C,UAAU,CAACgD,KAAK,GAAG,IAAI,CAAC,CACvCN,KAAK,CAAC,QAAQ,EAAE1C,UAAU,CAACiD,MAAM,GAAG,IAAI,CAAC;MAE9C,IAAIC,IAAI,GAAGlD,UAAU,CAAC+B,SAAS,CAAC9D,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAACiF,IAAI;MAC9C,IAAGA,IAAI,EAAE;QACL;QACA;QACA,IAAGC,IAAI,CAACC,KAAK,CAACpD,UAAU,CAACgD,KAAK,GAAGD,gBAAgB,CAAC,KAAKG,IAAI,CAACG,GAAG,CAACC,kBAAkB,IAC9EH,IAAI,CAACC,KAAK,CAACpD,UAAU,CAACiD,MAAM,GAAGF,gBAAgB,CAAC,KAAKG,IAAI,CAACG,GAAG,CAACE,mBAAmB,EAClF;UACC,IAAIC,GAAG,GAAG,mFAAmF;UAC7F,IAAG7B,kBAAkB,EAAE;YACnBnF,GAAG,CAACiH,KAAK,CAACD,GAAG,CAAC;UAClB,CAAC,MAAM;YACHhH,GAAG,CAACkH,GAAG,CAACF,GAAG,GAAG,qCAAqC,CAAC;YACpD1G,KAAK,CAAC6G,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE3F,EAAE,CAAC4C,SAAS,EAAEZ,UAAU,CAAC;YACjDlD,KAAK,CAACiD,cAAc,CAAC/B,EAAE,CAAC;YACxBgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW;YAC3BnD,KAAK,CAAC+D,UAAU,CAAC7C,EAAE,CAAC;YACpB2D,kBAAkB,EAAE;YACpB,OAAOC,aAAa,CAAC,CAAC;UAC1B;QACJ;MACJ;IACJ;IAEA,IAAG5B,UAAU,CAAC4D,OAAO,CAACC,WAAW,KAAK,GAAG,EAAE;MACvC7D,UAAU,CAAC8D,WAAW,CACnBpB,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CACrBA,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC;IAC7B,CAAC,MAAM;MACH1C,UAAU,CAAC8D,WAAW,CACnBpB,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CACpBA,KAAK,CAAC,QAAQ,EAAE1C,UAAU,CAACiD,MAAM,GAAG,IAAI,CAAC;IAChD;IAEA,OAAOnG,KAAK,CAACiH,gBAAgB,CAAC/F,EAAE,CAAC;EACrC;;EAEA;EACA,SAASgG,aAAaA,CAAA,EAAG;IACrB;IACA;IACA;IACA;IACA;IACAlH,KAAK,CAACmH,kBAAkB,CAACjG,EAAE,CAAC;IAE5BN,WAAW,CAACwG,iBAAiB,CAAClG,EAAE,CAAC;IACjCjB,IAAI,CAACoH,eAAe,CAACnG,EAAE,CAAC;IACxB,IAAGA,EAAE,CAACiC,WAAW,CAACmE,KAAK,CAACC,IAAI,IAAIrG,EAAE,CAACiC,WAAW,CAACmE,KAAK,CAACE,UAAU,EAAExH,KAAK,CAACqH,eAAe,CAACnG,EAAE,EAAE,kBAAkB,CAAC;;IAE9G;IACA,IAAGgC,UAAU,CAACG,IAAI,CAAC,KAAK,CAAC,EAAE;MACvB,IAAIoE,QAAQ,GAAGvG,EAAE,CAAC4C,SAAS;MAC3B,KAAI,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,QAAQ,CAAC9E,MAAM,EAAEqB,CAAC,EAAE,EAAE;QACrC,IAAIC,KAAK,GAAGwD,QAAQ,CAACzD,CAAC,CAAC;QACvB,IAAGC,KAAK,CAACyD,IAAI,KAAK,KAAK,IAAIzD,KAAK,CAACuD,UAAU,EAAE;UACzCxH,KAAK,CAACqH,eAAe,CAACnG,EAAE,EAAE,MAAM,GAAG+C,KAAK,CAAC0D,GAAG,GAAG,aAAa,CAAC;QACjE;MACJ;IACJ;IAEA3H,KAAK,CAAC4H,YAAY,CAAC1G,EAAE,CAAC;IACtB,OAAOlB,KAAK,CAACiH,gBAAgB,CAAC/F,EAAE,CAAC;EACrC;;EAEA;EACA,SAAS2G,kBAAkBA,CAAA,EAAG;IAC1B,IAAG,CAAC7H,KAAK,CAAC8H,eAAe,CAACpD,UAAU,EAAExB,UAAU,CAAC0B,KAAK,CAAC,EAAE;IAEzD,OAAOlF,GAAG,CAACqI,WAAW,CAAC,CACnBb,aAAa,EACbtG,WAAW,CAACoH,YAAY,CAC3B,EAAE9G,EAAE,CAAC;EACV;EAEA,SAAS+G,oBAAoBA,CAAA,EAAG;IAC5B,IAAG,CAACrE,MAAM,EAAE;MACRsE,yBAAyB,CAAC,CAAC;MAC3B;IACJ;;IAEA;IACA;IACA,OAAOxI,GAAG,CAACqI,WAAW,CAAC,CACnBjI,QAAQ,CAACqI,kBAAkB,CAAC,QAAQ,EAAE,eAAe,CAAC,EACtDrI,QAAQ,CAACqI,kBAAkB,CAAC,aAAa,EAAE,eAAe,CAAC,EAC3DD,yBAAyB,CAC5B,EAAEhH,EAAE,CAAC;EACV;EAEA,SAASgH,yBAAyBA,CAAA,EAAG;IACjC,IAAGhH,EAAE,CAACkH,cAAc,EAAE;IAEtBxH,WAAW,CAACsH,yBAAyB,CAAChH,EAAE,CAAC;;IAEzC;IACA;IACA,IAAGwB,aAAa,EAAEzC,IAAI,CAACoI,gBAAgB,CAACnH,EAAE,CAAC;;IAE3C;IACA;IACA;IACApB,QAAQ,CAACqI,kBAAkB,CAAC,aAAa,EAAE,eAAe,CAAC,CAACjH,EAAE,CAAC;EACnE;;EAEA;EACA,SAASoH,QAAQA,CAAA,EAAG;IAChB,OAAOrI,IAAI,CAACsI,IAAI,CAACrH,EAAE,EAAEwB,aAAa,GAAG,EAAE,GAAG,QAAQ,CAAC;EACvD;EAEA,IAAI8F,GAAG,GAAG,CACNxI,KAAK,CAACiH,gBAAgB,EACtBhF,SAAS,EACT6C,aAAa,EACboC,aAAa,EACbW,kBAAkB,CACrB;EAED,IAAGzE,YAAY,EAAEoF,GAAG,CAAC3F,IAAI,CAACoF,oBAAoB,CAAC;EAE/CO,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACoH,YAAY,CAAC;EAClC,IAAG5E,YAAY,EAAE;IACboF,GAAG,CAAC3F,IAAI,CACJyF,QAAQ,EACR,SAASG,yBAAyBA,CAACvH,EAAE,EAAE;MACnC,IAAIwH,2BAA2B,GAAGxH,EAAE,CAACiC,WAAW,CAACwF,4BAA4B;MAC7E,IAAGD,2BAA2B,EAAE;QAC5BxH,EAAE,CAACiC,WAAW,CAACwF,4BAA4B,GAAGC,SAAS;QAEvD,OAAOC,QAAQ,CAAC3H,EAAE,EAAEwH,2BAA2B,CAAC,CAACI,IAAI,CAAC,YAAW;UAC7D7I,IAAI,CAACoI,gBAAgB,CAACnH,EAAE,EAAE,IAAI,CAAC;QACnC,CAAC,CAAC;MACN;IACJ,CACJ,CAAC;EACL;EAEAsH,GAAG,CAAC3F,IAAI,CACJjC,WAAW,CAACmI,QAAQ,EACpBnI,WAAW,CAACoI,SAAS,EACrB1I,gBAAgB,EAChBN,KAAK,CAACiJ,QAAQ,EACdjJ,KAAK,CAACkJ,OAAO,EACblJ,KAAK,CAACmJ,MAAM,EACZnJ,KAAK,CAACoJ,QAAQ;EACd;EACA;EACA;EACA;EACApJ,KAAK,CAAC4H,YAAY,EAClB5H,KAAK,CAACiH,gBACV,CAAC;;EAED;EACA;EACA,IAAIoC,QAAQ,GAAG3J,GAAG,CAACqI,WAAW,CAACS,GAAG,EAAEtH,EAAE,CAAC;EACvC,IAAG,CAACmI,QAAQ,IAAI,CAACA,QAAQ,CAACP,IAAI,EAAEO,QAAQ,GAAGxH,OAAO,CAACyH,OAAO,CAAC,CAAC;EAE5D,OAAOD,QAAQ,CAACP,IAAI,CAAC,YAAW;IAC5BS,aAAa,CAACrI,EAAE,CAAC;IACjB,OAAOA,EAAE;EACb,CAAC,CAAC;AACN;AAEA,SAASqI,aAAaA,CAACrI,EAAE,EAAE;EACvB,IAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAE/B,IAAGD,UAAU,CAACsG,0BAA0B,EAAE;IACtCtG,UAAU,CAACsG,0BAA0B,EAAE;EAC3C,CAAC,MAAM;IACHtI,EAAE,CAACuI,IAAI,CAAC,kBAAkB,CAAC;EAC/B;AACJ;AAEA,SAASC,aAAaA,CAAChI,GAAG,EAAE;EACxB,OAAOhC,GAAG,CAACiF,UAAU,CAAClE,UAAU,EAAEiB,GAAG,CAAC;AAC1C;AAEA,SAASiI,aAAaA,CAACzI,EAAE,EAAE0I,OAAO,EAAE;EAChC,IAAI;IACA1I,EAAE,CAACiC,WAAW,CAAC0G,MAAM,CAACjE,KAAK,CAAC,YAAY,EAAEgE,OAAO,CAAC;EACtD,CAAC,CAAC,OAAME,CAAC,EAAE;IACPpK,GAAG,CAACiH,KAAK,CAACmD,CAAC,CAAC;EAChB;AACJ;AAEA,SAASC,mBAAmBA,CAAC7I,EAAE,EAAE0I,OAAO,EAAE;EACtC,IAAII,KAAK,GAAG3J,KAAK,CAAC4J,OAAO,CAACL,OAAO,EAAE,OAAO,CAAC;EAC3CD,aAAa,CAACzI,EAAE,EAAE8I,KAAK,CAAC;AAC5B;AAEA,SAAS7H,cAAcA,CAACjB,EAAE,EAAEG,MAAM,EAAE;EAChC,IAAG,CAACH,EAAE,CAACgD,QAAQ,EAAE;IACbhD,EAAE,CAACgD,QAAQ,GAAGxE,GAAG,CAACwK,UAAU,CAAC,CAAC,CAAC,EAAEzJ,UAAU,CAAC;;IAE5C;IACA,IAAI0J,IAAI,GAAG7K,EAAE,CAAC8C,MAAM,CAAC,MAAM,CAAC;IAC5BlB,EAAE,CAACgD,QAAQ,CAACkG,QAAQ,GAAGD,IAAI,CAACE,IAAI,CAAC,CAAC,IAAIF,IAAI,CAACzE,IAAI,CAAC,MAAM,CAAC,GACnDnB,MAAM,CAAC+F,QAAQ,CAACC,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAClC,EAAE;EACV;EAEA,IAAInF,OAAO,GAAGnE,EAAE,CAACgD,QAAQ;EAEzB,IAAIF,CAAC,EAAEyG,IAAI,EAAErF,GAAG;EAEhB,IAAG/D,MAAM,EAAE;IACPoJ,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACpJ,MAAM,CAAC;IAC1B,KAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyG,IAAI,CAAC9H,MAAM,EAAEqB,CAAC,EAAE,EAAE;MAC7BoB,GAAG,GAAGqF,IAAI,CAACzG,CAAC,CAAC;MACb,IAAGoB,GAAG,KAAK,UAAU,IAAIA,GAAG,KAAK,OAAO,EAAE;MAC1C,IAAGA,GAAG,IAAIC,OAAO,EAAE;QACf,IAAGD,GAAG,KAAK,eAAe,IAAI/D,MAAM,CAAC+D,GAAG,CAAC,KAAK,QAAQ,EAAE;UACpDC,OAAO,CAACD,GAAG,CAAC,GAAG2E,mBAAmB;QACtC,CAAC,MAAM;UACH1E,OAAO,CAACD,GAAG,CAAC,GAAG/D,MAAM,CAAC+D,GAAG,CAAC;QAC9B;MACJ;IACJ;;IAEA;IACA,IAAG/D,MAAM,CAACsJ,gBAAgB,IAAI,CAACtF,OAAO,CAACY,gBAAgB,EAAE;MACrDZ,OAAO,CAACY,gBAAgB,GAAGZ,OAAO,CAACsF,gBAAgB;IACvD;;IAEA;IACA;IACA,IAAIC,QAAQ,GAAGvJ,MAAM,CAACuJ,QAAQ;IAC9B,IAAGA,QAAQ,KAAKhC,SAAS,EAAE;MACvB;MACA;MACAvD,OAAO,CAACuF,QAAQ,GAAGA,QAAQ;MAE3BH,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACpF,OAAO,CAACwF,KAAK,CAAC;MACjC,KAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyG,IAAI,CAAC9H,MAAM,EAAEqB,CAAC,EAAE,EAAE;QAC7BqB,OAAO,CAACwF,KAAK,CAACJ,IAAI,CAACzG,CAAC,CAAC,CAAC,GAAG4G,QAAQ;MACrC;IACJ;IACA,IAAGvJ,MAAM,CAACwJ,KAAK,EAAE;MACbJ,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACpJ,MAAM,CAACwJ,KAAK,CAAC;MAChC,KAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyG,IAAI,CAAC9H,MAAM,EAAEqB,CAAC,EAAE,EAAE;QAC7BoB,GAAG,GAAGqF,IAAI,CAACzG,CAAC,CAAC;QACb,IAAGoB,GAAG,IAAIC,OAAO,CAACwF,KAAK,EAAE;UACrBxF,OAAO,CAACwF,KAAK,CAACzF,GAAG,CAAC,GAAG/D,MAAM,CAACwJ,KAAK,CAACzF,GAAG,CAAC;QAC1C;MACJ;IACJ;;IAEA;IACAC,OAAO,CAACyF,aAAa,GAAGzJ,MAAM,CAACyJ,aAAa;EAChD;;EAEA;EACA,IAAGzF,OAAO,CAAC0F,UAAU,EAAE;IACnB1F,OAAO,CAACuF,QAAQ,GAAG,KAAK;IACxBvF,OAAO,CAACwF,KAAK,GAAG,CAAC,CAAC;IAClBxF,OAAO,CAAC2F,WAAW,GAAG,KAAK;IAC3B3F,OAAO,CAAC4F,UAAU,GAAG,KAAK;IAC1B5F,OAAO,CAAC6F,WAAW,GAAG,KAAK;IAC3B7F,OAAO,CAAC8F,QAAQ,GAAG,KAAK;IACxB9F,OAAO,CAAC+F,QAAQ,GAAG,KAAK;IACxB/F,OAAO,CAACgG,cAAc,GAAG,KAAK;EAClC;;EAEA;EACA,IAAGhG,OAAO,CAACgG,cAAc,KAAK,OAAO,IAAI,CAAC5L,QAAQ,EAAE;IAChD4F,OAAO,CAACgG,cAAc,GAAG,IAAI;EACjC;;EAEA;EACA,IAAGhG,OAAO,CAACsE,aAAa,KAAK,aAAa,IAAI,OAAOtE,OAAO,CAACsE,aAAa,KAAK,UAAU,EAAE;IACvFtE,OAAO,CAACsE,aAAa,GAAGA,aAAa;EACzC;;EAEA;EACAtE,OAAO,CAACiG,cAAc,GAAGjG,OAAO,CAACiG,cAAc,IAAIpK,EAAE,CAACqK,YAAY,KAAK,CAAC;EACxElG,OAAO,CAACmG,aAAa,GAAGnG,OAAO,CAACmG,aAAa,IAAItK,EAAE,CAACuK,WAAW,KAAK,CAAC;;EAErE;EACA,IAAIC,IAAI,GAAGrG,OAAO,CAAC4F,UAAU;EAC7B,IAAIU,KAAK,GAAGtG,OAAO,CAACuG,WAAW,GAAG,CAAC,CAAC;EACpC,IAAGF,IAAI,KAAK,IAAI,EAAE;IACdC,KAAK,CAACE,SAAS,GAAG,CAAC;IACnBF,KAAK,CAACG,IAAI,GAAG,CAAC;IACdH,KAAK,CAACI,GAAG,GAAG,CAAC;IACbJ,KAAK,CAACK,MAAM,GAAG,CAAC;IAChBL,KAAK,CAACM,GAAG,GAAG,CAAC;EACjB,CAAC,MAAM,IAAG,OAAOP,IAAI,KAAK,QAAQ,EAAE;IAChC,IAAIQ,KAAK,GAAGR,IAAI,CAAClB,KAAK,CAAC,GAAG,CAAC;IAC3B,KAAIxG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkI,KAAK,CAACvJ,MAAM,EAAEqB,CAAC,EAAE,EAAE;MAC9B2H,KAAK,CAACO,KAAK,CAAClI,CAAC,CAAC,CAAC,GAAG,CAAC;IACvB;EACJ,CAAC,MAAM,IAAG0H,IAAI,KAAK,KAAK,EAAE;IACtBC,KAAK,CAACG,IAAI,GAAG,CAAC;IACdH,KAAK,CAACI,GAAG,GAAG,CAAC;IACbJ,KAAK,CAACK,MAAM,GAAG,CAAC;IAChBL,KAAK,CAACM,GAAG,GAAG,CAAC;EACjB;AACJ;;AAGA;AACA,SAASE,MAAMA,CAACjL,EAAE,EAAE;EAChBA,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAG,CAACxB,GAAG,CAACqC,SAAS,CAACb,EAAE,CAAC,EAAE;IACnB,MAAM,IAAIkL,KAAK,CAAC,qCAAqC,GAAGlL,EAAE,CAAC;EAC/D;EAEAP,OAAO,CAACiC,SAAS,CAAC1B,EAAE,CAACC,IAAI,CAAC;EAC1BR,OAAO,CAACqC,WAAW,CAAC9B,EAAE,CAACE,MAAM,CAAC;EAE9BF,EAAE,CAAC2C,QAAQ,GAAG+E,SAAS;EACvB,OAAO1G,OAAO,CAACjB,OAAO,CAACC,EAAE,CAAC,CAAC4H,IAAI,CAAC,YAAW;IACvC5H,EAAE,CAACuI,IAAI,CAAC,eAAe,CAAC;IACxB,OAAOvI,EAAE;EACb,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmL,OAAOA,CAACnL,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAE;EACvCH,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;;EAExB;EACAlB,KAAK,CAAC6G,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE3F,EAAE,CAAC4C,SAAS,IAAI,EAAE,EAAE5C,EAAE,CAACiC,WAAW,IAAI,CAAC,CAAC,CAAC;EAEjEnD,KAAK,CAACsM,KAAK,CAACpL,EAAE,CAAC;EACf,OAAOgB,OAAO,CAACjB,OAAO,CAACC,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,CAAC;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkL,iBAAiBA,CAACC,OAAO,EAAEC,QAAQ,EAAE;EAC1C,IAAIC,YAAY,GAAGD,QAAQ,GAAG,CAAC;EAC/B,IAAIE,eAAe,GAAG,EAAE;EACxB,IAAI3I,CAAC;EACL,IAAI4I,KAAK;EAET,KAAI5I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwI,OAAO,CAAC7J,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAChC4I,KAAK,GAAGJ,OAAO,CAACxI,CAAC,CAAC;IAClB,IAAG4I,KAAK,GAAG,CAAC,EAAE;MACVD,eAAe,CAAC9J,IAAI,CAAC6J,YAAY,GAAGE,KAAK,CAAC;IAC9C,CAAC,MAAM;MACHD,eAAe,CAAC9J,IAAI,CAAC+J,KAAK,CAAC;IAC/B;EACJ;EACA,OAAOD,eAAe;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,gBAAgBA,CAAC3L,EAAE,EAAEsL,OAAO,EAAEM,SAAS,EAAE;EAC9C,IAAI9I,CAAC,EACD4I,KAAK;EAET,KAAI5I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwI,OAAO,CAAC7J,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAChC4I,KAAK,GAAGJ,OAAO,CAACxI,CAAC,CAAC;;IAElB;IACA,IAAG4I,KAAK,KAAKG,QAAQ,CAACH,KAAK,EAAE,EAAE,CAAC,EAAE;MAC9B,MAAM,IAAIR,KAAK,CAAC,gBAAgB,GAAGU,SAAS,GAAG,mBAAmB,CAAC;IACvE;;IAEA;IACA,IAAGF,KAAK,IAAI1L,EAAE,CAACC,IAAI,CAACwB,MAAM,IAAIiK,KAAK,GAAG,CAAC1L,EAAE,CAACC,IAAI,CAACwB,MAAM,EAAE;MACnD,MAAM,IAAIyJ,KAAK,CAACU,SAAS,GAAG,qCAAqC,CAAC;IACtE;;IAEA;IACA,IAAGN,OAAO,CAACQ,OAAO,CAACJ,KAAK,EAAE5I,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAC7B4I,KAAK,IAAI,CAAC,IAAIJ,OAAO,CAACQ,OAAO,CAAC,CAAC9L,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAGiK,KAAK,CAAC,GAAG,CAAC,CAAC,IAC3DA,KAAK,GAAG,CAAC,IAAIJ,OAAO,CAACQ,OAAO,CAAC9L,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAGiK,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;MAC/D,MAAM,IAAIR,KAAK,CAAC,gBAAgB,GAAGU,SAAS,GAAG,kBAAkB,CAAC;IACtE;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,mBAAmBA,CAAC/L,EAAE,EAAEgM,cAAc,EAAEC,UAAU,EAAE;EACzD;EACA,IAAG,CAAC5K,KAAK,CAACC,OAAO,CAACtB,EAAE,CAACC,IAAI,CAAC,EAAE;IACxB,MAAM,IAAIiL,KAAK,CAAC,2BAA2B,CAAC;EAChD;;EAEA;EACA,IAAG,OAAOc,cAAc,KAAK,WAAW,EAAE;IACtC,MAAM,IAAId,KAAK,CAAC,wCAAwC,CAAC;EAC7D,CAAC,MAAM,IAAG,CAAC7J,KAAK,CAACC,OAAO,CAAC0K,cAAc,CAAC,EAAE;IACtCA,cAAc,GAAG,CAACA,cAAc,CAAC;EACrC;EACAL,gBAAgB,CAAC3L,EAAE,EAAEgM,cAAc,EAAE,gBAAgB,CAAC;;EAEtD;EACA,IAAG,OAAOC,UAAU,KAAK,WAAW,IAAI,CAAC5K,KAAK,CAACC,OAAO,CAAC2K,UAAU,CAAC,EAAE;IAChEA,UAAU,GAAG,CAACA,UAAU,CAAC;EAC7B;EACA,IAAG,OAAOA,UAAU,KAAK,WAAW,EAAE;IAClCN,gBAAgB,CAAC3L,EAAE,EAAEiM,UAAU,EAAE,YAAY,CAAC;EAClD;;EAEA;EACA,IAAG,OAAOA,UAAU,KAAK,WAAW,IAAID,cAAc,CAACvK,MAAM,KAAKwK,UAAU,CAACxK,MAAM,EAAE;IACjF,MAAM,IAAIyJ,KAAK,CAAC,kDAAkD,CAAC;EACvE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,kBAAkBA,CAAClM,EAAE,EAAEmM,MAAM,EAAEF,UAAU,EAAE;EAChD,IAAInJ,CAAC,EAAEsJ,KAAK;;EAEZ;EACA,IAAG,CAAC/K,KAAK,CAACC,OAAO,CAACtB,EAAE,CAACC,IAAI,CAAC,EAAE;IACxB,MAAM,IAAIiL,KAAK,CAAC,2BAA2B,CAAC;EAChD;;EAEA;EACA,IAAG,OAAOiB,MAAM,KAAK,WAAW,EAAE;IAC9B,MAAM,IAAIjB,KAAK,CAAC,yBAAyB,CAAC;EAC9C;;EAEA;EACA,IAAG,CAAC7J,KAAK,CAACC,OAAO,CAAC6K,MAAM,CAAC,EAAE;IACvBA,MAAM,GAAG,CAACA,MAAM,CAAC;EACrB;;EAEA;EACA,KAAIrJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,MAAM,CAAC1K,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAC/BsJ,KAAK,GAAGD,MAAM,CAACrJ,CAAC,CAAC;IACjB,IAAG,OAAOsJ,KAAK,KAAK,QAAQ,IAAK/K,KAAK,CAACC,OAAO,CAAC8K,KAAK,CAAC,IAAIA,KAAK,KAAK,IAAK,EAAE;MACtE,MAAM,IAAIlB,KAAK,CAAC,sDAAsD,CAAC;IAC3E;EACJ;;EAEA;EACA,IAAG,OAAOe,UAAU,KAAK,WAAW,IAAI,CAAC5K,KAAK,CAACC,OAAO,CAAC2K,UAAU,CAAC,EAAE;IAChEA,UAAU,GAAG,CAACA,UAAU,CAAC;EAC7B;EACA,IAAG,OAAOA,UAAU,KAAK,WAAW,IAAIA,UAAU,CAACxK,MAAM,KAAK0K,MAAM,CAAC1K,MAAM,EAAE;IACzE,MAAM,IAAIyJ,KAAK,CACX,kEACJ,CAAC;EACL;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,sBAAsBA,CAACrM,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAE;EAC5D,IAAIC,iBAAiB,GAAGhO,GAAG,CAAC+B,aAAa,CAACgM,SAAS,CAAC;EAEpD,IAAG,CAAClL,KAAK,CAACC,OAAO,CAACtB,EAAE,CAACC,IAAI,CAAC,EAAE;IACxB,MAAM,IAAIiL,KAAK,CAAC,0BAA0B,CAAC;EAC/C;EACA,IAAG,CAAC1M,GAAG,CAAC+B,aAAa,CAAC+L,MAAM,CAAC,EAAE;IAC3B,MAAM,IAAIpB,KAAK,CAAC,mCAAmC,CAAC;EACxD;EAEA,IAAG,OAAOI,OAAO,KAAK,WAAW,EAAE;IAC/B,MAAM,IAAIJ,KAAK,CAAC,iDAAiD,CAAC;EACtE;EAEAS,gBAAgB,CAAC3L,EAAE,EAAEsL,OAAO,EAAE,SAAS,CAAC;EAExC,KAAI,IAAIpH,GAAG,IAAIoI,MAAM,EAAE;IACnB;AACR;AACA;AACA;IACQ,IAAG,CAACjL,KAAK,CAACC,OAAO,CAACgL,MAAM,CAACpI,GAAG,CAAC,CAAC,IAAIoI,MAAM,CAACpI,GAAG,CAAC,CAACzC,MAAM,KAAK6J,OAAO,CAAC7J,MAAM,EAAE;MACrE,MAAM,IAAIyJ,KAAK,CAAC,YAAY,GAAGhH,GAAG,GAAG,2DAA2D,CAAC;IACrG;;IAEA;AACR;AACA;IACQ,IAAGsI,iBAAiB,KACf,EAAEtI,GAAG,IAAIqI,SAAS,CAAC,IAAI,CAAClL,KAAK,CAACC,OAAO,CAACiL,SAAS,CAACrI,GAAG,CAAC,CAAC,IACtDqI,SAAS,CAACrI,GAAG,CAAC,CAACzC,MAAM,KAAK6K,MAAM,CAACpI,GAAG,CAAC,CAACzC,MAAM,CAAC,EAAE;MAC/C,MAAM,IAAIyJ,KAAK,CAAC,oEAAoE,GACpE,wEAAwE,CAAC;IAC7F;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuB,mBAAmBA,CAACzM,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAE;EACzD,IAAIC,iBAAiB,GAAGhO,GAAG,CAAC+B,aAAa,CAACgM,SAAS,CAAC;EACpD,IAAIG,WAAW,GAAG,EAAE;EACpB,IAAI3J,KAAK,EAAE4J,MAAM,EAAEC,IAAI,EAAEC,MAAM,EAAEC,IAAI;;EAErC;EACA,IAAG,CAACzL,KAAK,CAACC,OAAO,CAACgK,OAAO,CAAC,EAAEA,OAAO,GAAG,CAACA,OAAO,CAAC;;EAE/C;EACAA,OAAO,GAAGD,iBAAiB,CAACC,OAAO,EAAEtL,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC;;EAExD;EACA,KAAI,IAAIyC,GAAG,IAAIoI,MAAM,EAAE;IACnB,KAAI,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,OAAO,CAAC7J,MAAM,EAAEsL,CAAC,EAAE,EAAE;MACpC;AACZ;AACA;AACA;MACYhK,KAAK,GAAG/C,EAAE,CAACC,IAAI,CAACqL,OAAO,CAACyB,CAAC,CAAC,CAAC;MAC3BH,IAAI,GAAGnO,cAAc,CAACsE,KAAK,EAAEmB,GAAG,CAAC;;MAEjC;AACZ;AACA;AACA;MACYyI,MAAM,GAAGC,IAAI,CAACI,GAAG,CAAC,CAAC;MACnBH,MAAM,GAAGP,MAAM,CAACpI,GAAG,CAAC,CAAC6I,CAAC,CAAC;MAEvB,IAAG,CAACvO,GAAG,CAACyO,mBAAmB,CAACJ,MAAM,CAAC,EAAE;QACjC,MAAM,IAAI3B,KAAK,CAAC,aAAa,GAAGhH,GAAG,GAAG,UAAU,GAAG6I,CAAC,GAAG,mBAAmB,CAAC;MAC/E;MACA,IAAG,CAACvO,GAAG,CAACyO,mBAAmB,CAACN,MAAM,CAAC,EAAE;QACjC,MAAM,IAAIzB,KAAK,CAAC,gDAAgD,GAAGhH,GAAG,CAAC;MAC3E;MACA,IAAGyI,MAAM,CAACO,WAAW,KAAKL,MAAM,CAACK,WAAW,EAAE;QAC1C,MAAM,IAAIhC,KAAK,CAAC,yDAAyD,GAAGhH,GAAG,CAAC;MACpF;;MAEA;AACZ;AACA;AACA;MACY4I,IAAI,GAAGN,iBAAiB,GAAGD,SAAS,CAACrI,GAAG,CAAC,CAAC6I,CAAC,CAAC,GAAGR,SAAS;;MAExD;MACA,IAAG,CAACjO,SAAS,CAACwO,IAAI,CAAC,EAAEA,IAAI,GAAG,CAAC,CAAC;;MAE9B;AACZ;AACA;AACA;AACA;MACYJ,WAAW,CAAC/K,IAAI,CAAC;QACbiL,IAAI,EAAEA,IAAI;QACVD,MAAM,EAAEA,MAAM;QACdE,MAAM,EAAEA,MAAM;QACdC,IAAI,EAAE3H,IAAI,CAACC,KAAK,CAAC0H,IAAI;MACzB,CAAC,CAAC;IACN;EACJ;;EAEA;EACA,OAAOJ,WAAW;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,YAAYA,CAACnN,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAEa,WAAW,EAAE;EAC/Df,sBAAsB,CAACrM,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,CAAC;EAEtD,IAAIG,WAAW,GAAGD,mBAAmB,CAACzM,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,CAAC;EACrE,IAAIc,UAAU,GAAG,CAAC,CAAC;EACnB,IAAIC,UAAU,GAAG,CAAC,CAAC;EAEnB,KAAI,IAAIxK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4J,WAAW,CAACjL,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACxC,IAAI8J,IAAI,GAAGF,WAAW,CAAC5J,CAAC,CAAC,CAAC8J,IAAI;IAC9B,IAAIE,IAAI,GAAGJ,WAAW,CAAC5J,CAAC,CAAC,CAACgK,IAAI;;IAE9B;IACA,IAAIS,GAAG,GAAGH,WAAW,CAACV,WAAW,CAAC5J,CAAC,CAAC,CAAC6J,MAAM,EAAED,WAAW,CAAC5J,CAAC,CAAC,CAAC+J,MAAM,EAAEC,IAAI,CAAC;IACzEF,IAAI,CAACY,GAAG,CAACD,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEhB;IACA,IAAG,CAAClM,KAAK,CAACC,OAAO,CAAC+L,UAAU,CAACT,IAAI,CAACa,IAAI,CAAC,CAAC,EAAEJ,UAAU,CAACT,IAAI,CAACa,IAAI,CAAC,GAAG,EAAE;IACpEJ,UAAU,CAACT,IAAI,CAACa,IAAI,CAAC,CAAC9L,IAAI,CAAC4L,GAAG,CAAC,CAAC,CAAC,CAAC;;IAEjC;IACD,IAAG,CAAClM,KAAK,CAACC,OAAO,CAACgM,UAAU,CAACV,IAAI,CAACa,IAAI,CAAC,CAAC,EAAEH,UAAU,CAACV,IAAI,CAACa,IAAI,CAAC,GAAG,EAAE;IACpEH,UAAU,CAACV,IAAI,CAACa,IAAI,CAAC,CAAC9L,IAAI,CAAC+K,WAAW,CAAC5J,CAAC,CAAC,CAAC6J,MAAM,CAAClL,MAAM,CAAC;EAC5D;EAEA,OAAO;IAAC6K,MAAM,EAAEe,UAAU;IAAEd,SAAS,EAAEe;EAAU,CAAC;AACtD;AAEA,SAASI,gBAAgBA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAClC,IAAIC,IAAI,GAAG,IAAIF,IAAI,CAACT,WAAW,CAACS,IAAI,CAAClM,MAAM,GAAGmM,IAAI,CAACnM,MAAM,CAAC;EAC1DoM,IAAI,CAACL,GAAG,CAACG,IAAI,CAAC;EACdE,IAAI,CAACL,GAAG,CAACI,IAAI,EAAED,IAAI,CAAClM,MAAM,CAAC;EAC3B,OAAOoM,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAAC9N,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAE;EAClDvM,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,SAASoN,WAAWA,CAACT,MAAM,EAAEE,MAAM,EAAEC,IAAI,EAAE;IACvC,IAAIiB,QAAQ,EAAEC,SAAS;IAEvB,IAAGxP,GAAG,CAACyP,YAAY,CAACtB,MAAM,CAAC,EAAE;MACzB,IAAGG,IAAI,GAAG,CAAC,EAAE;QACT,IAAIoB,IAAI,GAAG,IAAIvB,MAAM,CAACO,WAAW,CAAC,CAAC,CAAC;QACpC,IAAIiB,IAAI,GAAGT,gBAAgB,CAACf,MAAM,EAAEE,MAAM,CAAC;QAE3C,IAAGC,IAAI,GAAG,CAAC,EAAE;UACTiB,QAAQ,GAAGI,IAAI;UACfH,SAAS,GAAGE,IAAI;QACpB,CAAC,MAAM;UACHH,QAAQ,GAAGG,IAAI;UACfF,SAAS,GAAGG,IAAI;QACpB;MACJ,CAAC,MAAM;QACHJ,QAAQ,GAAG,IAAIpB,MAAM,CAACO,WAAW,CAACJ,IAAI,CAAC;QACvCkB,SAAS,GAAG,IAAIrB,MAAM,CAACO,WAAW,CAACP,MAAM,CAAClL,MAAM,GAAGoL,MAAM,CAACpL,MAAM,GAAGqL,IAAI,CAAC;QAExE,IAAGA,IAAI,KAAKD,MAAM,CAACpL,MAAM,EAAE;UACvBsM,QAAQ,CAACP,GAAG,CAACX,MAAM,CAAC;UACpBmB,SAAS,CAACR,GAAG,CAACb,MAAM,CAAC;QACzB,CAAC,MAAM,IAAGG,IAAI,GAAGD,MAAM,CAACpL,MAAM,EAAE;UAC5B,IAAI2M,uBAAuB,GAAGvB,MAAM,CAACpL,MAAM,GAAGqL,IAAI;UAElDiB,QAAQ,CAACP,GAAG,CAACX,MAAM,CAACwB,QAAQ,CAACD,uBAAuB,CAAC,CAAC;UACtDJ,SAAS,CAACR,GAAG,CAACb,MAAM,CAAC;UACrBqB,SAAS,CAACR,GAAG,CAACX,MAAM,CAACwB,QAAQ,CAAC,CAAC,EAAED,uBAAuB,CAAC,EAAEzB,MAAM,CAAClL,MAAM,CAAC;QAC7E,CAAC,MAAM;UACH,IAAI6M,uBAAuB,GAAGxB,IAAI,GAAGD,MAAM,CAACpL,MAAM;UAClD,IAAI8M,WAAW,GAAG5B,MAAM,CAAClL,MAAM,GAAG6M,uBAAuB;UAEzDP,QAAQ,CAACP,GAAG,CAACb,MAAM,CAAC0B,QAAQ,CAACE,WAAW,CAAC,CAAC;UAC1CR,QAAQ,CAACP,GAAG,CAACX,MAAM,EAAEyB,uBAAuB,CAAC;UAC7CN,SAAS,CAACR,GAAG,CAACb,MAAM,CAAC0B,QAAQ,CAAC,CAAC,EAAEE,WAAW,CAAC,CAAC;QAClD;MACJ;IACJ,CAAC,MAAM;MACHR,QAAQ,GAAGpB,MAAM,CAAC6B,MAAM,CAAC3B,MAAM,CAAC;MAChCmB,SAAS,GAAIlB,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAGiB,QAAQ,CAACtM,MAAM,GAC5CsM,QAAQ,CAACU,MAAM,CAAC,CAAC,EAAEV,QAAQ,CAACtM,MAAM,GAAGqL,IAAI,CAAC,GAC1C,EAAE;IACV;IAEA,OAAO,CAACiB,QAAQ,EAAEC,SAAS,CAAC;EAChC;EAEA,IAAIU,IAAI,GAAGvB,YAAY,CAACnN,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAEa,WAAW,CAAC;EACpE,IAAIuB,OAAO,GAAG3N,OAAO,CAACiK,MAAM,CAACjL,EAAE,CAAC;EAChC,IAAI4O,QAAQ,GAAG,CAAC5O,EAAE,EAAE0O,IAAI,CAACpC,MAAM,EAAEhB,OAAO,EAAEoD,IAAI,CAACnC,SAAS,CAAC;EACzD5N,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEgB,OAAO,CAAC8N,aAAa,EAAEF,QAAQ,EAAEd,YAAY,EAAEiB,SAAS,CAAC;EAEvE,OAAOJ,OAAO;AAClB;AAEA,SAASG,aAAaA,CAAC9O,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAE;EACnDvM,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,SAASoN,WAAWA,CAACT,MAAM,EAAEE,MAAM,EAAEC,IAAI,EAAE;IACvC,IAAIiB,QAAQ,EAAEC,SAAS;IAEvB,IAAGxP,GAAG,CAACyP,YAAY,CAACtB,MAAM,CAAC,EAAE;MACzB,IAAGG,IAAI,IAAI,CAAC,EAAE;QACV,IAAIoB,IAAI,GAAG,IAAIvB,MAAM,CAACO,WAAW,CAAC,CAAC,CAAC;QACpC,IAAIiB,IAAI,GAAGT,gBAAgB,CAACb,MAAM,EAAEF,MAAM,CAAC;QAE3C,IAAGG,IAAI,GAAG,CAAC,EAAE;UACTiB,QAAQ,GAAGI,IAAI;UACfH,SAAS,GAAGE,IAAI;QACpB,CAAC,MAAM;UACHH,QAAQ,GAAGG,IAAI;UACfF,SAAS,GAAGG,IAAI;QACpB;MACJ,CAAC,MAAM;QACHJ,QAAQ,GAAG,IAAIpB,MAAM,CAACO,WAAW,CAACJ,IAAI,CAAC;QACvCkB,SAAS,GAAG,IAAIrB,MAAM,CAACO,WAAW,CAACP,MAAM,CAAClL,MAAM,GAAGoL,MAAM,CAACpL,MAAM,GAAGqL,IAAI,CAAC;QAExE,IAAGA,IAAI,KAAKD,MAAM,CAACpL,MAAM,EAAE;UACvBsM,QAAQ,CAACP,GAAG,CAACX,MAAM,CAAC;UACpBmB,SAAS,CAACR,GAAG,CAACb,MAAM,CAAC;QACzB,CAAC,MAAM,IAAGG,IAAI,GAAGD,MAAM,CAACpL,MAAM,EAAE;UAC5B,IAAI2M,uBAAuB,GAAGvB,MAAM,CAACpL,MAAM,GAAGqL,IAAI;UAElDiB,QAAQ,CAACP,GAAG,CAACX,MAAM,CAACwB,QAAQ,CAAC,CAAC,EAAED,uBAAuB,CAAC,CAAC;UACzDJ,SAAS,CAACR,GAAG,CAACX,MAAM,CAACwB,QAAQ,CAACD,uBAAuB,CAAC,CAAC;UACvDJ,SAAS,CAACR,GAAG,CAACb,MAAM,EAAEyB,uBAAuB,CAAC;QAClD,CAAC,MAAM;UACH,IAAIE,uBAAuB,GAAGxB,IAAI,GAAGD,MAAM,CAACpL,MAAM;UAElDsM,QAAQ,CAACP,GAAG,CAACX,MAAM,CAAC;UACpBkB,QAAQ,CAACP,GAAG,CAACb,MAAM,CAAC0B,QAAQ,CAAC,CAAC,EAAEC,uBAAuB,CAAC,EAAEzB,MAAM,CAACpL,MAAM,CAAC;UACxEuM,SAAS,CAACR,GAAG,CAACb,MAAM,CAAC0B,QAAQ,CAACC,uBAAuB,CAAC,CAAC;QAC3D;MACJ;IACJ,CAAC,MAAM;MACHP,QAAQ,GAAGlB,MAAM,CAAC2B,MAAM,CAAC7B,MAAM,CAAC;MAChCqB,SAAS,GAAIlB,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAGiB,QAAQ,CAACtM,MAAM,GAC5CsM,QAAQ,CAACU,MAAM,CAAC3B,IAAI,EAAEiB,QAAQ,CAACtM,MAAM,CAAC,GACtC,EAAE;IACV;IAEA,OAAO,CAACsM,QAAQ,EAAEC,SAAS,CAAC;EAChC;EAEA,IAAIU,IAAI,GAAGvB,YAAY,CAACnN,EAAE,EAAEsM,MAAM,EAAEhB,OAAO,EAAEiB,SAAS,EAAEa,WAAW,CAAC;EACpE,IAAIuB,OAAO,GAAG3N,OAAO,CAACiK,MAAM,CAACjL,EAAE,CAAC;EAChC,IAAI4O,QAAQ,GAAG,CAAC5O,EAAE,EAAE0O,IAAI,CAACpC,MAAM,EAAEhB,OAAO,EAAEoD,IAAI,CAACnC,SAAS,CAAC;EACzD5N,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEgB,OAAO,CAAC8M,YAAY,EAAEc,QAAQ,EAAEE,aAAa,EAAEC,SAAS,CAAC;EAEvE,OAAOJ,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,SAASA,CAAChP,EAAE,EAAEmM,MAAM,EAAEF,UAAU,EAAE;EACvCjM,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAIgM,cAAc,GAAG,EAAE;EACvB,IAAIiD,QAAQ,GAAGjO,OAAO,CAACkO,YAAY;EACnC,IAAIC,QAAQ,GAAGH,SAAS;EACxB,IAAIJ,QAAQ,GAAG,CAAC5O,EAAE,EAAEgM,cAAc,CAAC;EACnC,IAAIoD,QAAQ,GAAG,CAACpP,EAAE,EAAEmM,MAAM,CAAC,CAAC,CAAE;EAC9B,IAAIrJ,CAAC;EACL,IAAI6L,OAAO;;EAEX;EACAzC,kBAAkB,CAAClM,EAAE,EAAEmM,MAAM,EAAEF,UAAU,CAAC;;EAE1C;EACA,IAAG,CAAC5K,KAAK,CAACC,OAAO,CAAC6K,MAAM,CAAC,EAAE;IACvBA,MAAM,GAAG,CAACA,MAAM,CAAC;EACrB;;EAEA;EACAA,MAAM,GAAGA,MAAM,CAACpB,GAAG,CAAC,UAAShI,KAAK,EAAE;IAChC,OAAOvE,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAEV,KAAK,CAAC;EACpC,CAAC,CAAC;EAEFtD,OAAO,CAACiC,SAAS,CAACyK,MAAM,CAAC;;EAEzB;EACA,KAAIrJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,MAAM,CAAC1K,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAC/B9C,EAAE,CAACC,IAAI,CAAC0B,IAAI,CAACwK,MAAM,CAACrJ,CAAC,CAAC,CAAC;EAC3B;;EAEA;EACA,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,MAAM,CAAC1K,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAC/BkJ,cAAc,CAACrK,IAAI,CAAC,CAACwK,MAAM,CAAC1K,MAAM,GAAGqB,CAAC,CAAC;EAC3C;;EAEA;EACA;EACA,IAAG,OAAOmJ,UAAU,KAAK,WAAW,EAAE;IAClC0C,OAAO,GAAG3N,OAAO,CAACiK,MAAM,CAACjL,EAAE,CAAC;IAC5BrB,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEiP,QAAQ,EAAEL,QAAQ,EAAEO,QAAQ,EAAEC,QAAQ,CAAC;IACrD,OAAOT,OAAO;EAClB;;EAEA;EACA,IAAG,CAACtN,KAAK,CAACC,OAAO,CAAC2K,UAAU,CAAC,EAAE;IAC3BA,UAAU,GAAG,CAACA,UAAU,CAAC;EAC7B;EAEA,IAAI;IACA;IACAF,mBAAmB,CAAC/L,EAAE,EAAEgM,cAAc,EAAEC,UAAU,CAAC;EACvD,CAAC,CAAC,OAAMxG,KAAK,EAAE;IACX;IACAzF,EAAE,CAACC,IAAI,CAACwO,MAAM,CAACzO,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAG0K,MAAM,CAAC1K,MAAM,EAAE0K,MAAM,CAAC1K,MAAM,CAAC;IAC7D,MAAMgE,KAAK;EACf;;EAEA;EACA;EACA9G,KAAK,CAAC0Q,aAAa,CAACrP,EAAE,CAAC;EACvBrB,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEiP,QAAQ,EAAEL,QAAQ,EAAEO,QAAQ,EAAEC,QAAQ,CAAC;EACrDT,OAAO,GAAG3N,OAAO,CAACsO,UAAU,CAACtP,EAAE,EAAEgM,cAAc,EAAEC,UAAU,CAAC;EAC5DtN,KAAK,CAAC4Q,YAAY,CAACvP,EAAE,CAAC;EACtB,OAAO2O,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,YAAYA,CAAClP,EAAE,EAAEsL,OAAO,EAAE;EAC/BtL,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAImM,MAAM,GAAG,EAAE;EACf,IAAI8C,QAAQ,GAAGjO,OAAO,CAACgO,SAAS;EAChC,IAAIG,QAAQ,GAAGD,YAAY;EAC3B,IAAIN,QAAQ,GAAG,CAAC5O,EAAE,EAAEmM,MAAM,EAAEb,OAAO,CAAC;EACpC,IAAI8D,QAAQ,GAAG,CAACpP,EAAE,EAAEsL,OAAO,CAAC;EAC5B,IAAIxI,CAAC;EACL,IAAI0M,YAAY;;EAEhB;EACA,IAAG,OAAOlE,OAAO,KAAK,WAAW,EAAE;IAC/B,MAAM,IAAIJ,KAAK,CAAC,kDAAkD,CAAC;EACvE,CAAC,MAAM,IAAG,CAAC7J,KAAK,CAACC,OAAO,CAACgK,OAAO,CAAC,EAAE;IAC/BA,OAAO,GAAG,CAACA,OAAO,CAAC;EACvB;EACAK,gBAAgB,CAAC3L,EAAE,EAAEsL,OAAO,EAAE,SAAS,CAAC;;EAExC;EACAA,OAAO,GAAGD,iBAAiB,CAACC,OAAO,EAAEtL,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC;;EAExD;EACA6J,OAAO,CAACmE,IAAI,CAACjR,GAAG,CAACkR,SAAS,CAAC;EAC3B,KAAI5M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwI,OAAO,CAAC7J,MAAM,EAAEqB,CAAC,IAAI,CAAC,EAAE;IACnC0M,YAAY,GAAGxP,EAAE,CAACC,IAAI,CAACwO,MAAM,CAACnD,OAAO,CAACxI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/CqJ,MAAM,CAACxK,IAAI,CAAC6N,YAAY,CAAC;EAC7B;EAEA,IAAIb,OAAO,GAAG3N,OAAO,CAACiK,MAAM,CAACjL,EAAE,CAAC;EAChCrB,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEiP,QAAQ,EAAEL,QAAQ,EAAEO,QAAQ,EAAEC,QAAQ,CAAC;EAErD,OAAOT,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,UAAUA,CAACtP,EAAE,EAAEgM,cAAc,EAAEC,UAAU,EAAE;EAChDjM,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAI2P,OAAO,GAAG,EAAE;EAChB,IAAIC,cAAc,GAAG,EAAE;EACvB,IAAIX,QAAQ,GAAGK,UAAU;EACzB,IAAIH,QAAQ,GAAGG,UAAU;EACzB,IAAIV,QAAQ,GAAG,CAAC5O,EAAE,EAAEiM,UAAU,EAAED,cAAc,CAAC;EAC/C,IAAIoD,QAAQ,GAAG,CAACpP,EAAE,EAAEgM,cAAc,EAAEC,UAAU,CAAC;EAC/C,IAAInJ,CAAC;;EAEL;EACA;EACAiJ,mBAAmB,CAAC/L,EAAE,EAAEgM,cAAc,EAAEC,UAAU,CAAC;;EAEnD;EACAD,cAAc,GAAG3K,KAAK,CAACC,OAAO,CAAC0K,cAAc,CAAC,GAAGA,cAAc,GAAG,CAACA,cAAc,CAAC;;EAElF;EACA,IAAG,OAAOC,UAAU,KAAK,WAAW,EAAE;IAClCA,UAAU,GAAG,EAAE;IACf,KAAInJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkJ,cAAc,CAACvK,MAAM,EAAEqB,CAAC,EAAE,EAAE;MACvCmJ,UAAU,CAACtK,IAAI,CAAC,CAACqK,cAAc,CAACvK,MAAM,GAAGqB,CAAC,CAAC;IAC/C;EACJ;;EAEA;EACAmJ,UAAU,GAAG5K,KAAK,CAACC,OAAO,CAAC2K,UAAU,CAAC,GAAGA,UAAU,GAAG,CAACA,UAAU,CAAC;;EAElE;EACAD,cAAc,GAAGX,iBAAiB,CAACW,cAAc,EAAEhM,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC;EACtEwK,UAAU,GAAGZ,iBAAiB,CAACY,UAAU,EAAEjM,EAAE,CAACC,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC;;EAE9D;;EAEA;EACA,KAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9C,EAAE,CAACC,IAAI,CAACwB,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAChC;IACA,IAAGkJ,cAAc,CAACF,OAAO,CAAChJ,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;MACjC6M,OAAO,CAAChO,IAAI,CAAC3B,EAAE,CAACC,IAAI,CAAC6C,CAAC,CAAC,CAAC;IAC5B;EACJ;;EAEA;EACA,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkJ,cAAc,CAACvK,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACvC8M,cAAc,CAACjO,IAAI,CAAC;MAACkO,QAAQ,EAAE5D,UAAU,CAACnJ,CAAC,CAAC;MAAEC,KAAK,EAAE/C,EAAE,CAACC,IAAI,CAAC+L,cAAc,CAAClJ,CAAC,CAAC;IAAC,CAAC,CAAC;EACrF;;EAEA;EACA8M,cAAc,CAACH,IAAI,CAAC,UAASK,CAAC,EAAEC,CAAC,EAAE;IAC/B,OAAOD,CAAC,CAACD,QAAQ,GAAGE,CAAC,CAACF,QAAQ;EAClC,CAAC,CAAC;;EAEF;EACA,KAAI/M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8M,cAAc,CAACnO,MAAM,EAAEqB,CAAC,IAAI,CAAC,EAAE;IAC1C6M,OAAO,CAAClB,MAAM,CAACmB,cAAc,CAAC9M,CAAC,CAAC,CAAC+M,QAAQ,EAAE,CAAC,EAAED,cAAc,CAAC9M,CAAC,CAAC,CAACC,KAAK,CAAC;EAC1E;EAEA/C,EAAE,CAACC,IAAI,GAAG0P,OAAO;EAEjB,IAAIhB,OAAO,GAAG3N,OAAO,CAACiK,MAAM,CAACjL,EAAE,CAAC;EAChCrB,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEiP,QAAQ,EAAEL,QAAQ,EAAEO,QAAQ,EAAEC,QAAQ,CAAC;EAErD,OAAOT,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqB,OAAOA,CAAChQ,EAAE,EAAEyN,IAAI,EAAEwC,GAAG,EAAEC,OAAO,EAAE;EACrClQ,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EACxBP,OAAO,CAAC0Q,iBAAiB,CAACnQ,EAAE,CAAC;EAE7B,IAAIoQ,IAAI,GAAG,CAAC,CAAC;EACb,IAAG,OAAO3C,IAAI,KAAK,QAAQ,EAAE2C,IAAI,CAAC3C,IAAI,CAAC,GAAGwC,GAAG,CAAC,KACzC,IAAGzR,GAAG,CAAC+B,aAAa,CAACkN,IAAI,CAAC,EAAE;IAC7B;IACA2C,IAAI,GAAG5R,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAEgK,IAAI,CAAC;IAC/B,IAAGyC,OAAO,KAAKxI,SAAS,EAAEwI,OAAO,GAAGD,GAAG;EAC3C,CAAC,MAAM;IACHzR,GAAG,CAACsC,IAAI,CAAC,eAAe,EAAE2M,IAAI,EAAEwC,GAAG,EAAEC,OAAO,CAAC;IAC7C,OAAOvP,OAAO,CAACC,MAAM,CAAC,CAAC;EAC3B;EAEA,IAAG4I,MAAM,CAACD,IAAI,CAAC6G,IAAI,CAAC,CAAC3O,MAAM,EAAEzB,EAAE,CAACqQ,OAAO,GAAG,IAAI;EAE9C,IAAIlE,MAAM,GAAG1M,OAAO,CAAC6Q,kBAAkB,CAACtQ,EAAE,EAAEkQ,OAAO,CAAC;EAEpD,IAAIK,KAAK,GAAGC,QAAQ,CAACxQ,EAAE,EAAEoQ,IAAI,EAAEjE,MAAM,CAAC;EACtC,IAAIsE,KAAK,GAAGF,KAAK,CAACE,KAAK;;EAEvB;EACA,IAAGA,KAAK,CAACC,IAAI,EAAE1Q,EAAE,CAAC2C,QAAQ,GAAG+E,SAAS;EACtC,IAAG+I,KAAK,CAACE,cAAc,EAAElR,OAAO,CAACkR,cAAc,CAAC3Q,EAAE,EAAEmM,MAAM,EAAE,CAAC,CAAC,CAAC;;EAE/D;EACA,IAAI7E,GAAG,GAAG,EAAE;EAEZ,IAAGmJ,KAAK,CAACG,UAAU,EAAE;IACjBtJ,GAAG,CAAC3F,IAAI,CAACX,OAAO,CAACjB,OAAO,CAAC;EAC7B,CAAC,MAAM;IACHuH,GAAG,CAAC3F,IAAI,CAAC7C,KAAK,CAACiH,gBAAgB,CAAC;;IAEhC;IACA;IACAjH,KAAK,CAACiD,cAAc,CAAC/B,EAAE,CAAC;IAExB,IAAGyQ,KAAK,CAACI,UAAU,EAAE;MACjB/R,KAAK,CAAC+D,UAAU,CAAC7C,EAAE,CAAC;MACpB8Q,kBAAkB,CAACxJ,GAAG,CAAC;;MAEvB;MACA;MACA;MACA;MACA;IACJ;IAEA,IAAGmJ,KAAK,CAAC/L,KAAK,EAAE4C,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACqR,YAAY,CAAC;IAClD,IAAGN,KAAK,CAACO,SAAS,EAAE1J,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuR,WAAW,CAAC;IAErD3J,GAAG,CAAC3F,IAAI,CAAC0G,aAAa,CAAC;EAC3B;EAEAf,GAAG,CAAC3F,IAAI,CACJ7C,KAAK,CAACkJ,OAAO,EACblJ,KAAK,CAACmJ,MAAM,EACZnJ,KAAK,CAACoJ,QACV,CAAC;EAEDvJ,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EACRgQ,OAAO,EAAE,CAAChQ,EAAE,EAAEuQ,KAAK,CAACW,MAAM,EAAEX,KAAK,CAACpE,MAAM,CAAC,EACzC6D,OAAO,EAAE,CAAChQ,EAAE,EAAEuQ,KAAK,CAACY,MAAM,EAAEZ,KAAK,CAACpE,MAAM,CAC5C,CAAC;EAED,IAAIhE,QAAQ,GAAG3J,GAAG,CAACqI,WAAW,CAACS,GAAG,EAAEtH,EAAE,CAAC;EACvC,IAAG,CAACmI,QAAQ,IAAI,CAACA,QAAQ,CAACP,IAAI,EAAEO,QAAQ,GAAGxH,OAAO,CAACyH,OAAO,CAAC,CAAC;EAE5D,OAAOD,QAAQ,CAACP,IAAI,CAAC,YAAW;IAC5B5H,EAAE,CAACuI,IAAI,CAAC,gBAAgB,EAAEgI,KAAK,CAACa,SAAS,CAAC;IAC1C,OAAOpR,EAAE;EACb,CAAC,CAAC;AACN;;AAEA;AACA;AACA,SAASqR,eAAeA,CAACpB,GAAG,EAAE;EAC1B,IAAGA,GAAG,KAAKvI,SAAS,EAAE,OAAO,IAAI;EACjC,OAAOuI,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASqB,MAAMA,CAACC,MAAM,EAAEC,WAAW,EAAE;EACjC,IAAG,CAACA,WAAW,EAAE,OAAO/S,cAAc;EAEtC,OAAO,UAASgT,SAAS,EAAEjN,IAAI,EAAEkN,MAAM,EAAE;IACrC,IAAIC,EAAE,GAAGlT,cAAc,CAACgT,SAAS,EAAEjN,IAAI,CAAC;IACxC,IAAIoN,KAAK,GAAGD,EAAE,CAACnE,GAAG;IAClBmE,EAAE,CAACnE,GAAG,GAAG,UAASyC,GAAG,EAAE;MACnB,IAAI4B,QAAQ,GAAG,CAACH,MAAM,IAAI,EAAE,IAAIlN,IAAI;MACpCsN,YAAY,CAACD,QAAQ,EAAEF,EAAE,CAAC3E,GAAG,CAAC,CAAC,EAAEiD,GAAG,EAAEsB,MAAM,CAAC;MAC7CK,KAAK,CAAC3B,GAAG,CAAC;IACd,CAAC;IACD,OAAO0B,EAAE;EACb,CAAC;AACL;AAEA,SAASG,YAAYA,CAACtN,IAAI,EAAEyL,GAAG,EAAE8B,MAAM,EAAER,MAAM,EAAE;EAC7C,IAAGlQ,KAAK,CAACC,OAAO,CAAC2O,GAAG,CAAC,IAAI5O,KAAK,CAACC,OAAO,CAACyQ,MAAM,CAAC,EAAE;IAC5C,IAAIC,QAAQ,GAAG3Q,KAAK,CAACC,OAAO,CAAC2O,GAAG,CAAC,GAAGA,GAAG,GAAG,EAAE;IAC5C,IAAIgC,QAAQ,GAAG5Q,KAAK,CAACC,OAAO,CAACyQ,MAAM,CAAC,GAAGA,MAAM,GAAG,EAAE;IAClD,IAAIG,MAAM,GAAG/M,IAAI,CAACgN,GAAG,CAACH,QAAQ,CAACvQ,MAAM,EAAEwQ,QAAQ,CAACxQ,MAAM,CAAC;IACvD,KAAI,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoP,MAAM,EAAEpP,CAAC,EAAE,EAAE;MAC5BgP,YAAY,CAACtN,IAAI,GAAG,GAAG,GAAG1B,CAAC,GAAG,GAAG,EAAEkP,QAAQ,CAAClP,CAAC,CAAC,EAAEmP,QAAQ,CAACnP,CAAC,CAAC,EAAEyO,MAAM,CAAC;IACxE;EACJ,CAAC,MAAM,IAAG/S,GAAG,CAAC+B,aAAa,CAAC0P,GAAG,CAAC,IAAIzR,GAAG,CAAC+B,aAAa,CAACwR,MAAM,CAAC,EAAE;IAC3D,IAAIK,MAAM,GAAG5T,GAAG,CAAC+B,aAAa,CAAC0P,GAAG,CAAC,GAAGA,GAAG,GAAG,CAAC,CAAC;IAC9C,IAAIoC,MAAM,GAAG7T,GAAG,CAAC+B,aAAa,CAACwR,MAAM,CAAC,GAAGA,MAAM,GAAG,CAAC,CAAC;IACpD,IAAIO,OAAO,GAAG9T,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAE2O,MAAM,EAAEC,MAAM,CAAC;IAChD,KAAI,IAAInO,GAAG,IAAIoO,OAAO,EAAE;MACpBR,YAAY,CAACtN,IAAI,GAAG,GAAG,GAAGN,GAAG,EAAEkO,MAAM,CAAClO,GAAG,CAAC,EAAEmO,MAAM,CAACnO,GAAG,CAAC,EAAEqN,MAAM,CAAC;IACpE;EACJ,CAAC,MAAM,IAAGA,MAAM,CAAC/M,IAAI,CAAC,KAAKkD,SAAS,EAAE;IAClC6J,MAAM,CAAC/M,IAAI,CAAC,GAAG6M,eAAe,CAACpB,GAAG,CAAC;EACvC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsC,mBAAmBA,CAACd,SAAS,EAAEF,MAAM,EAAE5H,KAAK,EAAE;EACnD,KAAI,IAAInF,IAAI,IAAImF,KAAK,EAAE;IACnB,IAAIgI,EAAE,GAAGlT,cAAc,CAACgT,SAAS,EAAEjN,IAAI,CAAC;IACxCsN,YAAY,CAACtN,IAAI,EAAEmN,EAAE,CAAC3E,GAAG,CAAC,CAAC,EAAErD,KAAK,CAACnF,IAAI,CAAC,EAAE+M,MAAM,CAAC;EACrD;AACJ;AAEA,SAASf,QAAQA,CAACxQ,EAAE,EAAEoQ,IAAI,EAAEjE,MAAM,EAAE;EAChC,IAAInK,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAC/B,IAAIsE,QAAQ,GAAGvG,EAAE,CAAC4C,SAAS;EAC3B,IAAI3C,IAAI,GAAGD,EAAE,CAACC,IAAI;EAClB,IAAIuR,WAAW,GAAGxP,UAAU,CAACwQ,WAAW;EACxC,IAAIC,QAAQ,GAAGnB,MAAM,CAACtP,UAAU,CAAC0Q,OAAO,EAAElB,WAAW,CAAC;EACtD,IAAIJ,SAAS,GAAG5S,GAAG,CAACmU,aAAa,CAAC,CAAC,CAAC,EAAEvC,IAAI,CAAC;EAC3C,IAAItN,CAAC;EAEL8P,4BAA4B,CAACxC,IAAI,CAAC;;EAElC;EACA,IAAIK,KAAK,GAAG9Q,SAAS,CAACkT,UAAU,CAAC,CAAC;;EAElC;EACA;EACA,IAAI1B,MAAM,GAAG,CAAC,CAAC;EACf,IAAID,MAAM,GAAG,CAAC,CAAC;EACf,IAAI4B,MAAM;;EAEV;EACA,SAASC,EAAEA,CAAA,EAAG;IAAE,OAAO5G,MAAM,CAACpB,GAAG,CAAC,YAAW;MAAE,OAAOrD,SAAS;IAAE,CAAC,CAAC;EAAE;;EAErE;EACA,SAASsL,WAAWA,CAACC,IAAI,EAAE;IACvB,IAAIC,MAAM,GAAGnU,IAAI,CAACoU,OAAO,CAACF,IAAI,CAAC;IAC/B,IAAGH,MAAM,CAAChH,OAAO,CAACoH,MAAM,CAAC,KAAK,CAAC,CAAC,EAAEJ,MAAM,CAACnR,IAAI,CAACuR,MAAM,CAAC;EACzD;EAEA,SAASE,aAAaA,CAACF,MAAM,EAAE;IAAE,OAAO,QAAQ,GAAGA,MAAM,GAAG,YAAY;EAAE;EAE1E,SAASG,SAASA,CAACH,MAAM,EAAE;IAAE,OAAO,QAAQ,GAAGA,MAAM,GAAG,QAAQ;EAAE;EAElE,SAASI,YAAYA,CAACC,UAAU,EAAE;IAC9B;IACA;IACA,KAAI,IAAIxG,CAAC,GAAGwG,UAAU,EAAExG,CAAC,GAAGxG,QAAQ,CAAC9E,MAAM,EAAEsL,CAAC,EAAE,EAAE;MAC9C,IAAGxG,QAAQ,CAACwG,CAAC,CAAC,CAACyG,MAAM,KAAKvT,IAAI,CAACsT,UAAU,CAAC,EAAE,OAAOhN,QAAQ,CAACwG,CAAC,CAAC;IAClE;IACA;IACA;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA,SAAS0G,OAAOA,CAACjP,IAAI,EAAEyL,GAAG,EAAEnN,CAAC,EAAE;IAC3B,IAAGzB,KAAK,CAACC,OAAO,CAACkD,IAAI,CAAC,EAAE;MACpBA,IAAI,CAACkP,OAAO,CAAC,UAAS5D,CAAC,EAAE;QAAE2D,OAAO,CAAC3D,CAAC,EAAEG,GAAG,EAAEnN,CAAC,CAAC;MAAE,CAAC,CAAC;MACjD;IACJ;IACA;IACA,IAAG0B,IAAI,IAAI4L,IAAI,IAAI3Q,OAAO,CAACkU,SAAS,CAACvD,IAAI,EAAE5L,IAAI,CAAC,EAAE;IAElD,IAAIoP,UAAU;IACd,IAAGpP,IAAI,CAACqP,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC/BD,UAAU,GAAGnB,QAAQ,CAACzS,EAAE,CAACE,MAAM,EAAEsE,IAAI,CAACC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;IAChE,CAAC,MAAM;MACH,IAAIqP,MAAM,GAAG3H,MAAM,CAACrJ,CAAC,CAAC;MACtB,IAAIyO,MAAM,GAAGvP,UAAU,CAAC+R,YAAY,CAACT,YAAY,CAACQ,MAAM,CAAC,CAACE,UAAU,CAACvN,GAAG,CAAC;MACzEmN,UAAU,GAAGtC,MAAM,CAACC,MAAM,EAAEC,WAAW,CAAC,CAACvR,IAAI,CAAC6T,MAAM,CAAC,EAAEtP,IAAI,CAAC;IAChE;IAEA,IAAG,EAAEA,IAAI,IAAI0M,MAAM,CAAC,EAAE;MAClBA,MAAM,CAAC1M,IAAI,CAAC,GAAGuO,EAAE,CAAC,CAAC;IACvB;IACA,IAAG7B,MAAM,CAAC1M,IAAI,CAAC,CAAC1B,CAAC,CAAC,KAAK4E,SAAS,EAAE;MAC9BwJ,MAAM,CAAC1M,IAAI,CAAC,CAAC1B,CAAC,CAAC,GAAGuO,eAAe,CAACuC,UAAU,CAAC5G,GAAG,CAAC,CAAC,CAAC;IACvD;IACA,IAAGiD,GAAG,KAAKvI,SAAS,EAAE;MAClBkM,UAAU,CAACpG,GAAG,CAACyC,GAAG,CAAC;IACvB;EACJ;EAEA,SAASgE,OAAOA,CAACC,OAAO,EAAE;IACtB,OAAO,UAASnH,CAAC,EAAE;MACf,OAAOxG,QAAQ,CAACwG,CAAC,CAAC,CAACmH,OAAO,CAAC;IAC/B,CAAC;EACL;EAEA,SAASC,SAASA,CAACD,OAAO,EAAE;IACxB,OAAO,UAASE,GAAG,EAAErH,CAAC,EAAE;MACpB,OAAOqH,GAAG,KAAK,KAAK,GAAG7N,QAAQ,CAAC4F,MAAM,CAACY,CAAC,CAAC,CAAC,CAACmH,OAAO,CAAC,GAAG,IAAI;IAC9D,CAAC;EACL;;EAEA;EACA;EACA,KAAI,IAAIG,EAAE,IAAIjE,IAAI,EAAE;IAChB,IAAG3Q,OAAO,CAACkU,SAAS,CAACvD,IAAI,EAAEiE,EAAE,CAAC,EAAE;MAC5B,MAAM,IAAInJ,KAAK,CAAC,aAAa,GAAGmJ,EAAE,GAAG,wCAAwC,CAAC;IAClF;IAEA,IAAIC,EAAE,GAAGlE,IAAI,CAACiE,EAAE,CAAC;IACjB,IAAIE,IAAI;IACR,IAAIC,QAAQ;IACZ,IAAIC,KAAK;IACT,IAAIC,MAAM;IACV,IAAI3C,MAAM;IACV,IAAI4C,SAAS;;IAEb;IACA;IACA;IACA;IACA,IAAGN,EAAE,KAAK,UAAU,IAAIA,EAAE,KAAK,UAAU,EAAE;MACvCA,EAAE,GAAGA,EAAE,CAACO,MAAM,CAACP,EAAE,CAAC5S,MAAM,GAAG,CAAC,CAAC,GAAG,MAAM;MACtC,IAAGJ,KAAK,CAACC,OAAO,CAACgT,EAAE,CAAC,EAAEA,EAAE,GAAGA,EAAE,CAACvJ,GAAG,CAACoJ,SAAS,CAACE,EAAE,CAAC,CAAC,CAAC,KAC5C,IAAGC,EAAE,KAAK,KAAK,EAAEA,EAAE,GAAGnI,MAAM,CAACpB,GAAG,CAACkJ,OAAO,CAACI,EAAE,CAAC,CAAC,CAAC,KAC9CC,EAAE,GAAG,IAAI;IAClB;IAEAnD,MAAM,CAACkD,EAAE,CAAC,GAAGC,EAAE;IAEf,IAAGD,EAAE,CAACR,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC7BY,KAAK,GAAGhC,QAAQ,CAACzS,EAAE,CAACE,MAAM,EAAEmU,EAAE,CAAC5P,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;MACrDyM,MAAM,CAACmD,EAAE,CAAC,GAAG,CAAChD,eAAe,CAACoD,KAAK,CAACzH,GAAG,CAAC,CAAC,CAAC,CAAC;MAC3C;MACA;MACAyH,KAAK,CAACjH,GAAG,CAACnM,KAAK,CAACC,OAAO,CAACgT,EAAE,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,GAAGA,EAAE,CAAC;MACzC;MACA;MACA7D,KAAK,CAACC,IAAI,GAAG,IAAI;MACjB;IACJ;;IAEA;IACAQ,MAAM,CAACmD,EAAE,CAAC,GAAGtB,EAAE,CAAC,CAAC;IACjB,KAAIjQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,MAAM,CAAC1K,MAAM,EAAEqB,CAAC,EAAE,EAAE;MAC/ByR,IAAI,GAAGtU,IAAI,CAACkM,MAAM,CAACrJ,CAAC,CAAC,CAAC;MACtB0R,QAAQ,GAAGlB,YAAY,CAACnH,MAAM,CAACrJ,CAAC,CAAC,CAAC;MAClC,IAAIyO,MAAM,GAAGvP,UAAU,CAAC+R,YAAY,CAACS,QAAQ,CAACR,UAAU,CAACvN,GAAG,CAAC;MAC7DgO,KAAK,GAAGnD,MAAM,CAACC,MAAM,EAAEC,WAAW,CAAC,CAAC+C,IAAI,EAAEF,EAAE,CAAC;MAC7CK,MAAM,GAAGD,KAAK,CAACzH,GAAG,CAAC,CAAC;MACpB+E,MAAM,GAAG1Q,KAAK,CAACC,OAAO,CAACgT,EAAE,CAAC,GAAGA,EAAE,CAACxR,CAAC,GAAGwR,EAAE,CAAC7S,MAAM,CAAC,GAAG6S,EAAE;MAEnD,IAAGvC,MAAM,KAAKrK,SAAS,EAAE;MAEzB,IAAImN,SAAS,GAAGJ,KAAK,CAACzJ,KAAK,CAACyJ,KAAK,CAACzJ,KAAK,CAACvJ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAIiQ,MAAM,GAAG2C,EAAE,CAACR,MAAM,CAAC,CAAC,EAAEQ,EAAE,CAAC5S,MAAM,GAAGoT,SAAS,CAACpT,MAAM,GAAG,CAAC,CAAC;MAC3D,IAAIqT,SAAS,GAAGpD,MAAM,GAAGA,MAAM,GAAG,GAAG,GAAG,EAAE;MAC1C,IAAIqD,aAAa,GAAGrD,MAAM,GACtBjT,cAAc,CAAC+V,QAAQ,EAAE9C,MAAM,CAAC,CAAC1E,GAAG,CAAC,CAAC,GAAGwH,QAAQ;MAErDG,SAAS,GAAG9V,UAAU,CAACmW,iBAAiB,CAACR,QAAQ,EAAEC,KAAK,CAACzJ,KAAK,CAAC;MAE/D,IAAG2J,SAAS,IAAIA,SAAS,CAACM,YAAY,IAAIlD,MAAM,KAAK,IAAI,EAAE;QACvD,KAAI,IAAImD,UAAU,IAAIP,SAAS,CAACM,YAAY,EAAE;UAC1CxB,OAAO,CAACjV,GAAG,CAAC2W,YAAY,CAACd,EAAE,EAAEa,UAAU,CAAC,EAAEP,SAAS,CAACM,YAAY,CAACC,UAAU,CAAC,EAAEpS,CAAC,CAAC;QACpF;MACJ,CAAC,MAAM,IAAG,CAAC+R,SAAS,KAAK,eAAe,IAAIA,SAAS,KAAK,SAAS,KAC3DH,MAAM,KAAK3C,MAAM,KAChBA,MAAM,KAAK,UAAU,IAAIA,MAAM,KAAK,QAAQ,CAAC,IAC9CgD,aAAa,EACnB;QACE;QACA;QACA;QACA;QACA;;QAEA,IAAIK,EAAE,GAAGpT,UAAU,CAAC0B,KAAK;QACzB,IAAI2R,MAAM,GAAGN,aAAa,CAACM,MAAM;QACjC,IAAIC,WAAW,GAAID,MAAM,KAAK,KAAK,IAAMA,MAAM,KAAK,QAAS;QAC7D,IAAGR,SAAS,KAAK,eAAe,EAAE;UAC9B,IAAIU,SAAS,GAAGD,WAAW,GAAGF,EAAE,CAACI,CAAC,GAAGJ,EAAE,CAACK,CAAC;UACzChC,OAAO,CAACqB,SAAS,GAAG,WAAW,EAAEC,aAAa,CAACW,SAAS,IACnD3D,MAAM,KAAK,UAAU,GAAG,CAAC,GAAGwD,SAAS,GAAGA,SAAS,CAAC,EAAEzS,CAAC,CAAC;QAC/D,CAAC,MAAM;UACH,IAAI6S,OAAO,GAAGL,WAAW,GAAGF,EAAE,CAACK,CAAC,GAAGL,EAAE,CAACI,CAAC;UACvC/B,OAAO,CAACqB,SAAS,GAAG,KAAK,EAAEC,aAAa,CAACa,GAAG,IACvC7D,MAAM,KAAK,UAAU,GAAG,CAAC,GAAG4D,OAAO,GAAGA,OAAO,CAAC,EAAE7S,CAAC,CAAC;QAC3D;MACJ,CAAC,MAAM,IAAGuR,EAAE,KAAK,MAAM,KAClBtC,MAAM,KAAK,KAAK,MAAO2C,MAAM,KAAK,KAAK,CAAC,IACxC3C,MAAM,KAAK,YAAY,MAAO2C,MAAM,KAAK,YAAY,CAAC,CAC1D,EAAE;QACC,IAAImB,QAAQ,GAAG,GAAG;QAClB,IAAIC,QAAQ,GAAG,GAAG;QAClB,IAAG,CAAC/D,MAAM,KAAK,KAAK,IAAI2C,MAAM,KAAK,KAAK,KAAKH,IAAI,CAAC1O,WAAW,KAAK,GAAG,EAAE;UACnEgQ,QAAQ,GAAG,GAAG;UACdC,QAAQ,GAAG,GAAG;QAClB;QACAtX,GAAG,CAACuX,SAAS,CAACxB,IAAI,EAAE,CAAC,GAAG,EAAE,MAAM,CAAC,EAAE,QAAQ,EAAEsB,QAAQ,CAAC;QACtDrX,GAAG,CAACuX,SAAS,CAACxB,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,OAAO,EAAEsB,QAAQ,CAAC;QACpDrX,GAAG,CAACuX,SAAS,CAACxB,IAAI,EAAE,CAAC,GAAG,EAAE,MAAM,CAAC,EAAE,QAAQ,EAAEuB,QAAQ,CAAC;QAEtD,IAAGpB,MAAM,KAAK,KAAK,IAAIA,MAAM,KAAK,YAAY,EAAE;UAC5CjW,cAAc,CAAC8V,IAAI,EAAE,cAAc,CAAC,CAC/B/G,GAAG,CAAC/O,cAAc,CAAC8V,IAAI,EAAE,eAAe,CAAC,CAACvH,GAAG,CAAC,CAAC,CAAC;;UAErD;UACAhL,UAAU,CAACgU,SAAS,CAAC/R,SAAS,CAAC,SAAS,CAAC,CAACgS,MAAM,CAAC,CAAC;QACtD,CAAC,MAAM,IAAGrX,QAAQ,CAACsX,OAAO,CAAC3B,IAAI,EAAE,WAAW,CAAC,EAAE;UAC3C9V,cAAc,CAAC8V,IAAI,EAAE,eAAe,CAAC,CAChC/G,GAAG,CAAC/O,cAAc,CAAC8V,IAAI,EAAE,cAAc,CAAC,CAACvH,GAAG,CAAC,CAAC,CAAC;QACxD;MACJ;MAEAkE,MAAM,CAACmD,EAAE,CAAC,CAACvR,CAAC,CAAC,GAAGuO,eAAe,CAACqD,MAAM,CAAC;MACvC;MACA;MACA,IAAIqB,SAAS,GAAG,CACZ,QAAQ,EAAE,YAAY,EAAE,aAAa,EAAE,iBAAiB,CAC3D;MACD,IAAGA,SAAS,CAACjK,OAAO,CAACuI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;QAC7B;QACA;QACA,IAAGA,EAAE,KAAK,aAAa,EAAE;UACrBI,KAAK,CAACjH,GAAG,CAACuE,MAAM,CAAC;UACjB;UACA;UACA;UACA,IAAIoE,kBAAkB,GAAI5B,IAAI,CAAC6B,CAAC,IAAI,CAAC7B,IAAI,CAAC8B,CAAC,GAAI,GAAG,GAAG,GAAG;UACxD,IAAG,CAAC5B,KAAK,CAACzH,GAAG,CAAC,CAAC,IAAImJ,kBAAkB,MAAM3B,QAAQ,CAAC3O,WAAW,EAAE;YAC7D;UACJ;QACJ,CAAC,MAAM,IAAGwO,EAAE,KAAK,iBAAiB,EAAE;UAChC;UACA;;UAEAE,IAAI,CAAC1O,WAAW,GACZ;YAACyQ,CAAC,EAAE,GAAG;YAAEd,CAAC,EAAE;UAAG,CAAC,CAAChB,QAAQ,CAAC3O,WAAW,CAAC;QAC9C;QACApG,OAAO,CAAC8W,UAAU,CAAChC,IAAI,CAAC;QACxB9D,KAAK,CAACC,IAAI,GAAGD,KAAK,CAACE,cAAc,GAAG,IAAI;MAC5C,CAAC,MAAM,IAAG7R,KAAK,CAAC0X,mBAAmB,CAAC1K,OAAO,CAAC2I,KAAK,CAACzJ,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;QAChE;QACAvL,OAAO,CAACgX,qBAAqB,CAAChC,KAAK,EAAE1C,MAAM,EAAEb,MAAM,CAAC;QACpDT,KAAK,CAACC,IAAI,GAAG,IAAI;MACrB,CAAC,MAAM;QACH,IAAGiE,SAAS,EAAE;UACV;UACA;UACA,IAAGA,SAAS,CAAC+B,OAAO,IAChB,CAAC9X,QAAQ,CAACsX,OAAO,CAAC1B,QAAQ,EAAE,MAAM,CAAC,KAClChW,GAAG,CAACyO,mBAAmB,CAAC8E,MAAM,CAAC,IAAIvT,GAAG,CAACyO,mBAAmB,CAACyH,MAAM,CAAC,CAAC,EACtE;YACEjE,KAAK,CAACC,IAAI,GAAG,IAAI;UACrB,CAAC,MAAM/Q,SAAS,CAAC2M,MAAM,CAACmE,KAAK,EAAEkE,SAAS,CAAC;QAC7C,CAAC,MAAM;UACH;AACpB;AACA;AACA;AACA;AACA;UACoBlE,KAAK,CAACC,IAAI,GAAG,IAAI;QACrB;;QAEA;QACA+D,KAAK,CAACjH,GAAG,CAACuE,MAAM,CAAC;MACrB;IACJ;;IAEA;IACA,IAAG,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAACjG,OAAO,CAACuI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;MACrDtV,IAAI,CAAC4X,IAAI,CAAC3W,EAAE,EAAEmM,MAAM,CAAC;IACzB;;IAEA;IACA,IAAGkI,EAAE,KAAK,iBAAiB,EAAE;MACzB,IAAIuC,SAAS,GAAGnY,cAAc,CAACuB,EAAE,CAACE,MAAM,EAAE,WAAW,CAAC;MACtD,IAAIsV,CAAC,GAAGoB,SAAS,CAAC5J,GAAG,CAAC,CAAC;MACvB,IAAGwI,CAAC,KAAK,GAAG,EAAE;QACVoB,SAAS,CAACpJ,GAAG,CAAC,GAAG,CAAC;MACtB,CAAC,MAAM,IAAGgI,CAAC,KAAK,GAAG,EAAE;QACjBoB,SAAS,CAACpJ,GAAG,CAAC,GAAG,CAAC;MACtB,CAAC,MAAM,IAAGgI,CAAC,KAAK,WAAW,EAAE;QACzBoB,SAAS,CAACpJ,GAAG,CAAC,WAAW,CAAC;MAC9B,CAAC,MAAM,IAAGgI,CAAC,KAAK,WAAW,EAAE;QACzBoB,SAAS,CAACpJ,GAAG,CAAC,WAAW,CAAC;MAC9B;IACJ;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA,IAAG,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC1B,OAAO,CAACuI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;MAC3CvB,MAAM,GAAG,EAAE;MACX,KAAIhQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,MAAM,CAAC1K,MAAM,EAAEqB,CAAC,EAAE,EAAE;QAC/B,IAAIC,KAAK,GAAG9C,IAAI,CAACkM,MAAM,CAACrJ,CAAC,CAAC,CAAC;QAE3B,IAAGlE,QAAQ,CAACsX,OAAO,CAACnT,KAAK,EAAE,WAAW,CAAC,EAAE;UACrCiQ,WAAW,CAACjQ,KAAK,CAAC8T,KAAK,IAAI,GAAG,CAAC;UAC/B7D,WAAW,CAACjQ,KAAK,CAAC+T,KAAK,IAAI,GAAG,CAAC;QACnC;MACJ;MAEArD,OAAO,CAACX,MAAM,CAAC/H,GAAG,CAACqI,aAAa,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;MAC3CK,OAAO,CAACX,MAAM,CAAC/H,GAAG,CAACsI,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAC7C;EACJ;EAEA,IAAG5C,KAAK,CAACC,IAAI,IAAID,KAAK,CAACsG,IAAI,EAAE;IACzBtG,KAAK,CAACG,UAAU,GAAG,IAAI;EAC3B;EAEA,OAAO;IACHH,KAAK,EAAEA,KAAK;IACZS,MAAM,EAAEA,MAAM;IACdC,MAAM,EAAEA,MAAM;IACdhF,MAAM,EAAEA,MAAM;IACdiF,SAAS,EAAE5S,GAAG,CAACwY,kBAAkB,CAAC,EAAE,EAAE,CAAC5F,SAAS,EAAEjF,MAAM,CAAC;EAC7D,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyG,4BAA4BA,CAACxC,IAAI,EAAE;EACxC,IAAI6G,iBAAiB,GAAGzY,GAAG,CAAC0Y,YAAY,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC;EACzE,IAAIC,aAAa,GAAG,kBAAkB;EACtC,IAAI5N,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAC6G,IAAI,CAAC;EAC5B,IAAItN,CAAC,EAAEoB,GAAG,EAAEkI,KAAK;EAEjB,KAAItJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyG,IAAI,CAAC9H,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAC7BoB,GAAG,GAAGqF,IAAI,CAACzG,CAAC,CAAC;IACbsJ,KAAK,GAAGgE,IAAI,CAAClM,GAAG,CAAC;IAEjB,IAAG,CAACA,GAAG,KAAK,OAAO,IAAI+S,iBAAiB,CAACG,IAAI,CAAClT,GAAG,CAAC,IAAIiT,aAAa,CAACC,IAAI,CAAClT,GAAG,CAAC,MAC1E,OAAOkI,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,CAAC,EAAE;MACxD3H,OAAO,CAACP,GAAG,EAAEA,GAAG,CAACO,OAAO,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;IACpD,CAAC,MAAM,IAAGP,GAAG,CAAC4H,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI5H,GAAG,CAAC4H,OAAO,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,EAAE;MAC7ErH,OAAO,CAACP,GAAG,EAAEA,GAAG,CAACO,OAAO,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;IACxD,CAAC,MAAM,IAAGP,GAAG,CAAC4H,OAAO,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE;MACzCrH,OAAO,CAACP,GAAG,EAAEA,GAAG,CAACO,OAAO,CAAC,eAAe,EAAE,gBAAgB,CAAC,CAAC;IAChE,CAAC,MAAM,IAAGP,GAAG,CAAC4H,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE;MACrCrH,OAAO,CAACP,GAAG,EAAEA,GAAG,CAACO,OAAO,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;IACxD,CAAC,MAAM,IAAGP,GAAG,CAAC4H,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE;MACvCrH,OAAO,CAACP,GAAG,EAAEA,GAAG,CAACO,OAAO,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;IAC5D;EACJ;EAEA,SAASA,OAAOA,CAAC4S,UAAU,EAAEC,UAAU,EAAE;IACrClH,IAAI,CAACkH,UAAU,CAAC,GAAGlH,IAAI,CAACiH,UAAU,CAAC;IACnC,OAAOjH,IAAI,CAACiH,UAAU,CAAC;EAC3B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1P,QAAQA,CAAC3H,EAAE,EAAEyN,IAAI,EAAEwC,GAAG,EAAE;EAC7BjQ,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EACxBP,OAAO,CAAC0Q,iBAAiB,CAACnQ,EAAE,CAAC;EAE7B,IAAIoQ,IAAI,GAAG,CAAC,CAAC;EACb,IAAG,OAAO3C,IAAI,KAAK,QAAQ,EAAE;IACzB2C,IAAI,CAAC3C,IAAI,CAAC,GAAGwC,GAAG;EACpB,CAAC,MAAM,IAAGzR,GAAG,CAAC+B,aAAa,CAACkN,IAAI,CAAC,EAAE;IAC/B2C,IAAI,GAAG5R,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAEgK,IAAI,CAAC;EACnC,CAAC,MAAM;IACHjP,GAAG,CAACsC,IAAI,CAAC,gBAAgB,EAAE2M,IAAI,EAAEwC,GAAG,CAAC;IACrC,OAAOtP,OAAO,CAACC,MAAM,CAAC,CAAC;EAC3B;EAEA,IAAG4I,MAAM,CAACD,IAAI,CAAC6G,IAAI,CAAC,CAAC3O,MAAM,EAAEzB,EAAE,CAACqQ,OAAO,GAAG,IAAI;EAE9C,IAAIE,KAAK,GAAGgH,SAAS,CAACvX,EAAE,EAAEoQ,IAAI,CAAC;EAC/B,IAAIK,KAAK,GAAGF,KAAK,CAACE,KAAK;;EAEvB;EACA,IAAGA,KAAK,CAACC,IAAI,EAAE1Q,EAAE,CAAC2C,QAAQ,GAAG+E,SAAS;;EAEtC;;EAEA;EACA;EACA;EACA,IAAIJ,GAAG,GAAG,CAACxI,KAAK,CAACiH,gBAAgB,CAAC;EAClC,IAAG0K,KAAK,CAAC+G,YAAY,EAAE;IACnBlQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAAC8X,YAAY,CAAC;EACtC,CAAC,MAAM,IAAGhO,MAAM,CAACD,IAAI,CAAC6G,IAAI,CAAC,CAAC3O,MAAM,EAAE;IAChCgW,2BAA2B,CAACzX,EAAE,EAAEyQ,KAAK,EAAEF,KAAK,CAAC,IAAIzR,KAAK,CAACiD,cAAc,CAAC/B,EAAE,CAAC;IAEzE,IAAGyQ,KAAK,CAACiH,MAAM,EAAEpQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACiY,QAAQ,CAAC;IAC/C,IAAGlH,KAAK,CAACmH,WAAW,EAAEtQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACoH,YAAY,CAAC;IACxD,IAAG2J,KAAK,CAACoH,OAAO,EAAE/G,kBAAkB,CAACxJ,GAAG,EAAEiJ,KAAK,CAACuH,aAAa,CAAC;IAC9D,IAAGrH,KAAK,CAACsH,KAAK,EAAEzQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACsY,eAAe,CAAC;IACrD,IAAGvH,KAAK,CAAC7K,OAAO,EAAE0B,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuY,SAAS,CAAC;IACjD,IAAGxH,KAAK,CAACyH,MAAM,EAAE5Q,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACyY,QAAQ,CAAC;IAC/C,IAAG1H,KAAK,CAACO,SAAS,EAAE1J,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuR,WAAW,CAAC;IAErD3J,GAAG,CAAC3F,IAAI,CAAC0G,aAAa,CAAC;EAC3B;EAEAf,GAAG,CAAC3F,IAAI,CACJ7C,KAAK,CAACkJ,OAAO,EACblJ,KAAK,CAACmJ,MAAM,EACZnJ,KAAK,CAACoJ,QACV,CAAC;EAEDvJ,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EACR2H,QAAQ,EAAE,CAAC3H,EAAE,EAAEuQ,KAAK,CAACW,MAAM,CAAC,EAC5BvJ,QAAQ,EAAE,CAAC3H,EAAE,EAAEuQ,KAAK,CAACY,MAAM,CAC/B,CAAC;EAED,IAAIhJ,QAAQ,GAAG3J,GAAG,CAACqI,WAAW,CAACS,GAAG,EAAEtH,EAAE,CAAC;EACvC,IAAG,CAACmI,QAAQ,IAAI,CAACA,QAAQ,CAACP,IAAI,EAAEO,QAAQ,GAAGxH,OAAO,CAACyH,OAAO,CAACpI,EAAE,CAAC;EAE9D,OAAOmI,QAAQ,CAACP,IAAI,CAAC,YAAW;IAC5B5H,EAAE,CAACuI,IAAI,CAAC,iBAAiB,EAAEgI,KAAK,CAACa,SAAS,CAAC;IAC3C,OAAOpR,EAAE;EACb,CAAC,CAAC;AACN;;AAEA;AACA;AACA,SAASyX,2BAA2BA,CAACzX,EAAE,EAAEyQ,KAAK,EAAEF,KAAK,EAAE;EACnD,IAAIvO,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAE/B,IAAG,CAACwO,KAAK,CAACoH,OAAO,EAAE,OAAO,KAAK;EAE/B,KAAI,IAAIO,CAAC,IAAI3H,KAAK,EAAE;IAChB,IAAG2H,CAAC,KAAK,SAAS,IAAI3H,KAAK,CAAC2H,CAAC,CAAC,EAAE,OAAO,KAAK;EAChD;EAEA,IAAIC,IAAI,EAAEC,KAAK;EACf,IAAIC,MAAM,GAAG,SAAAA,CAAS/T,IAAI,EAAEgU,IAAI,EAAE;IAC9B,OAAOha,GAAG,CAAC+Z,MAAM,CAACF,IAAI,EAAEC,KAAK,EAAErZ,yBAAyB,EAAEuF,IAAI,EAAEgU,IAAI,CAAC;EACzE,CAAC;EAED,IAAIC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;;EAElB,KAAI,IAAIC,IAAI,IAAInI,KAAK,CAACuH,aAAa,EAAE;IACjC,IAAI5E,MAAM,GAAGnU,IAAI,CAACoU,OAAO,CAACuF,IAAI,CAAC;IAC/BL,IAAI,GAAGrY,EAAE,CAACE,MAAM,CAACgT,MAAM,CAAC;IACxBoF,KAAK,GAAGtW,UAAU,CAACkR,MAAM,CAAC;IAE1BlU,mBAAmB,CAACqZ,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEE,OAAO,CAAC;IAEjD,IAAGH,KAAK,CAACK,WAAW,EAAE;MAClB,KAAI,IAAIC,KAAK,IAAIN,KAAK,CAACK,WAAW,EAAE;QAChC,IAAGC,KAAK,KAAKF,IAAI,EAAE;UACf,IAAIG,GAAG,GAAG7W,UAAU,CAACjD,IAAI,CAACoU,OAAO,CAACyF,KAAK,CAAC,CAAC;UACzCC,GAAG,CAACC,SAAS,GAAGR,KAAK,CAACQ,SAAS;UAC/BD,GAAG,CAACE,KAAK,GAAGT,KAAK,CAACS,KAAK,CAACC,KAAK,CAAC,CAAC;UAC/BH,GAAG,CAACrF,MAAM,CAACuF,KAAK,GAAGT,KAAK,CAACS,KAAK,CAACC,KAAK,CAAC,CAAC;QAC1C;MACJ;IACJ;EACJ;EAEA,OAAO,IAAI;AACf;AAEA,SAASlI,kBAAkBA,CAACxJ,GAAG,EAAEwQ,aAAa,EAAE;EAC5C;EACA;EACA;EACA,IAAI1Q,QAAQ,GAAG0Q,aAAa,GACxB,UAAS9X,EAAE,EAAE;IACT,IAAIiZ,KAAK,GAAG,EAAE;IACd,IAAIC,SAAS,GAAG,IAAI;IAEpB,KAAI,IAAIC,EAAE,IAAIrB,aAAa,EAAE;MACzB,IAAIsB,EAAE,GAAGra,IAAI,CAACsa,SAAS,CAACrZ,EAAE,EAAEmZ,EAAE,CAAC;MAC/BF,KAAK,CAACtX,IAAI,CAACwX,EAAE,CAAC;MAEd,IAAG,CAACC,EAAE,CAACE,iBAAiB,IAAI,EAAE,EAAExN,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;QACtD,IAAGsN,EAAE,CAACG,WAAW,EAAE;UACfN,KAAK,CAACtX,IAAI,CAACyX,EAAE,CAACG,WAAW,CAACC,GAAG,CAAC;QAClC;MACJ;MAEA,IAAGJ,EAAE,CAACT,WAAW,EAAE;QACf,KAAI,IAAIc,GAAG,IAAIL,EAAE,CAACT,WAAW,EAAE;UAC3B,IAAG,CAACb,aAAa,CAAC2B,GAAG,CAAC,EAAE;YACpBR,KAAK,CAACtX,IAAI,CAAC8X,GAAG,CAAC;UACnB;QACJ;MACJ;IACJ;IAEA,OAAO1a,IAAI,CAACsI,IAAI,CAACrH,EAAE,EAAEiZ,KAAK,EAAE;MAACC,SAAS,EAAEA;IAAS,CAAC,CAAC;EACvD,CAAC,GACD,UAASlZ,EAAE,EAAE;IACT,OAAOjB,IAAI,CAACsI,IAAI,CAACrH,EAAE,EAAE,QAAQ,CAAC;EAClC,CAAC;EAELsH,GAAG,CAAC3F,IAAI,CACJrC,YAAY,EACZI,WAAW,CAACsH,yBAAyB,EACrCI,QAAQ,EACR1H,WAAW,CAACmI,QAAQ,EACpBnI,WAAW,CAACoI,SAChB,CAAC;AACL;AAEA,IAAI4R,WAAW,GAAG,sCAAsC;AACxD,IAAIC,eAAe,GAAG,8BAA8B;AACpD,IAAIC,YAAY,GAAG,uCAAuC;AAE1D,SAASrC,SAASA,CAACvX,EAAE,EAAEoQ,IAAI,EAAE;EACzB,IAAIlQ,MAAM,GAAGF,EAAE,CAACE,MAAM;EACtB,IAAI8B,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAC/B,IAAIuP,WAAW,GAAGxP,UAAU,CAACwQ,WAAW;EACxC,IAAIC,QAAQ,GAAGnB,MAAM,CAACtP,UAAU,CAAC0Q,OAAO,EAAElB,WAAW,CAAC;EACtD,IAAIjI,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAC6G,IAAI,CAAC;EAC5B,IAAIyJ,IAAI,GAAG9a,IAAI,CAAC+a,IAAI,CAAC9Z,EAAE,CAAC;EACxB,IAAIoR,SAAS,GAAG5S,GAAG,CAACmU,aAAa,CAAC,CAAC,CAAC,EAAEvC,IAAI,CAAC;EAC3C,IAAI2J,UAAU,GAAG,CAAC,CAAC;EAEnB,IAAIC,QAAQ,EAAElX,CAAC,EAAEiK,CAAC;EAElB6F,4BAA4B,CAACxC,IAAI,CAAC;EAClC7G,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAC6G,IAAI,CAAC;;EAExB;EACA;EACA,KAAItN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyG,IAAI,CAAC9H,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAC7B,IAAGyG,IAAI,CAACzG,CAAC,CAAC,CAACgJ,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;MACjC,KAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8M,IAAI,CAACpY,MAAM,EAAEsL,CAAC,EAAE,EAAE;QAC7B,IAAIkN,KAAK,GAAGJ,IAAI,CAAC9M,CAAC,CAAC,CAACyM,GAAG,CAAC3F,MAAM,CAAC,CAAC,CAAC;QACjC,IAAIqG,QAAQ,GAAID,KAAK,CAACnO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAKmO,KAAK,GAAG,GAAG,GAAI,EAAE;QACnE,IAAIE,MAAM,GAAG5Q,IAAI,CAACzG,CAAC,CAAC,CAAC2B,OAAO,CAAC,SAAS,EAAEyV,QAAQ,GAAGL,IAAI,CAAC9M,CAAC,CAAC,CAACqN,KAAK,CAAC;QAEjE,IAAG,CAAChK,IAAI,CAAC+J,MAAM,CAAC,EAAE/J,IAAI,CAAC+J,MAAM,CAAC,GAAG/J,IAAI,CAAC7G,IAAI,CAACzG,CAAC,CAAC,CAAC;MAClD;MAEA,OAAOsN,IAAI,CAAC7G,IAAI,CAACzG,CAAC,CAAC,CAAC;IACxB;EACJ;;EAEA;EACA,IAAI2N,KAAK,GAAG9Q,SAAS,CAAC0a,WAAW,CAAC,CAAC;;EAEnC;EACA;EACA,IAAIlJ,MAAM,GAAG,CAAC,CAAC;EACf,IAAID,MAAM,GAAG,CAAC,CAAC;;EAEf;EACA;EACA;EACA;EACA,SAASuC,OAAOA,CAACjP,IAAI,EAAEyL,GAAG,EAAE;IACxB,IAAG5O,KAAK,CAACC,OAAO,CAACkD,IAAI,CAAC,EAAE;MACpBA,IAAI,CAACkP,OAAO,CAAC,UAAS5D,CAAC,EAAE;QAAE2D,OAAO,CAAC3D,CAAC,EAAEG,GAAG,CAAC;MAAE,CAAC,CAAC;MAC9C;IACJ;;IAEA;IACA;IACA,IAAGzL,IAAI,IAAI4L,IAAI,IAAI3Q,OAAO,CAACkU,SAAS,CAACvD,IAAI,EAAE5L,IAAI,CAAC,EAAE;IAElD,IAAI8V,CAAC,GAAG7H,QAAQ,CAACvS,MAAM,EAAEsE,IAAI,CAAC;IAC9B,IAAG,EAAEA,IAAI,IAAI0M,MAAM,CAAC,EAAE;MAClBA,MAAM,CAAC1M,IAAI,CAAC,GAAG6M,eAAe,CAACiJ,CAAC,CAACtN,GAAG,CAAC,CAAC,CAAC;IAC3C;IACA,IAAGiD,GAAG,KAAKvI,SAAS,EAAE4S,CAAC,CAAC9M,GAAG,CAACyC,GAAG,CAAC;EACpC;;EAEA;EACA;EACA;EACA,IAAI6H,aAAa,GAAG,CAAC,CAAC;EACtB,IAAIsB,EAAE;EAEN,SAASmB,iBAAiBA,CAACC,SAAS,EAAE;IAClC,IAAI9B,IAAI,GAAG3Z,IAAI,CAAC0b,OAAO,CAACD,SAAS,CAAClR,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAChDwO,aAAa,CAACY,IAAI,CAAC,GAAG,CAAC;IACvB,OAAOA,IAAI;EACf;;EAEA;EACA,KAAI,IAAIrE,EAAE,IAAIjE,IAAI,EAAE;IAChB,IAAG3Q,OAAO,CAACkU,SAAS,CAACvD,IAAI,EAAEiE,EAAE,CAAC,EAAE;MAC5B,MAAM,IAAInJ,KAAK,CAAC,aAAa,GAAGmJ,EAAE,GAAG,wCAAwC,CAAC;IAClF;IAEA,IAAIiG,CAAC,GAAG7H,QAAQ,CAACvS,MAAM,EAAEmU,EAAE,CAAC;IAC5B,IAAIC,EAAE,GAAGlE,IAAI,CAACiE,EAAE,CAAC;IACjB,IAAIqG,IAAI,GAAGJ,CAAC,CAACtP,KAAK,CAACvJ,MAAM;IACzB;IACA,IAAIkZ,IAAI,GAAGD,IAAI,GAAG,CAAC;IACnB,OAAMC,IAAI,GAAG,CAAC,IAAI,OAAOL,CAAC,CAACtP,KAAK,CAAC2P,IAAI,CAAC,KAAK,QAAQ,EAAEA,IAAI,EAAE;IAC3D;IACA,IAAIC,KAAK,GAAGN,CAAC,CAACtP,KAAK,CAAC2P,IAAI,CAAC;IACzB;IACA,IAAIH,SAAS,GAAGF,CAAC,CAACtP,KAAK,CAAC2P,IAAI,GAAG,CAAC,CAAC,GAAG,GAAG,GAAGC,KAAK;IAC/C;IACA,IAAIC,MAAM,GAAGP,CAAC,CAACtP,KAAK,CAACgO,KAAK,CAAC,CAAC,EAAE2B,IAAI,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC;IAC7C,IAAIC,QAAQ,GAAGtc,cAAc,CAACuB,EAAE,CAACE,MAAM,EAAE2a,MAAM,CAAC,CAAC7N,GAAG,CAAC,CAAC;IACtD,IAAIgO,UAAU,GAAGvc,cAAc,CAACuD,UAAU,EAAE6Y,MAAM,CAAC,CAAC7N,GAAG,CAAC,CAAC;IACzD,IAAIiO,IAAI,GAAGX,CAAC,CAACtN,GAAG,CAAC,CAAC;IAElB,IAAGsH,EAAE,KAAK5M,SAAS,EAAE;IAErByJ,MAAM,CAACkD,EAAE,CAAC,GAAGC,EAAE;;IAEf;IACA;IACApD,MAAM,CAACmD,EAAE,CAAC,GAAIuG,KAAK,KAAK,SAAS,GAAItG,EAAE,GAAGjD,eAAe,CAAC4J,IAAI,CAAC;IAE/D,IAAItG,SAAS,GAAG9V,UAAU,CAACqc,kBAAkB,CAAClZ,UAAU,EAAEsY,CAAC,CAACtP,KAAK,CAAC;IAElE,IAAG2J,SAAS,IAAIA,SAAS,CAACM,YAAY,IAAIX,EAAE,KAAK,IAAI,EAAE;MACnD,KAAI,IAAIY,UAAU,IAAIP,SAAS,CAACM,YAAY,EAAE;QAC1CxB,OAAO,CAACjV,GAAG,CAAC2W,YAAY,CAACd,EAAE,EAAEa,UAAU,CAAC,EAAEP,SAAS,CAACM,YAAY,CAACC,UAAU,CAAC,CAAC;MACjF;IACJ;;IAEA;IACA;IACA;IACA;IACA;IACA,IAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAACpJ,OAAO,CAACuI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;MACvC,IAAGC,EAAE,EAAE;QACHb,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;QACzB;QACA;QACA;QACA,IAAI0H,YAAY,GAAG9G,EAAE,KAAK,QAAQ,GAAG,OAAO,GAAG,QAAQ;QACvDZ,OAAO,CAAC0H,YAAY,EAAEnZ,UAAU,CAACmZ,YAAY,CAAC,CAAC;MACnD,CAAC,MAAM;QACHnZ,UAAU,CAACqS,EAAE,CAAC,GAAGrU,EAAE,CAACob,gBAAgB,CAAC/G,EAAE,CAAC;MAC5C;IACJ,CAAC,MAAM,IAAGA,EAAE,KAAK,UAAU,EAAE;MACzB;MACAZ,OAAO,CAAC,OAAO,EAAEa,EAAE,GAAG,IAAI,GAAGtS,UAAU,CAACgD,KAAK,CAAC;MAC9CyO,OAAO,CAAC,QAAQ,EAAEa,EAAE,GAAG,IAAI,GAAGtS,UAAU,CAACiD,MAAM,CAAC;IACpD,CAAC,MAAM,IAAGuV,SAAS,CAACa,KAAK,CAAC3B,WAAW,CAAC,EAAE;MACpC;;MAEAa,iBAAiB,CAACC,SAAS,CAAC;MAC5B/b,cAAc,CAACuD,UAAU,EAAE6Y,MAAM,GAAG,cAAc,CAAC,CAACrN,GAAG,CAAC,IAAI,CAAC;IACjE,CAAC,MAAM,IAAGgN,SAAS,CAACa,KAAK,CAAC1B,eAAe,CAAC,EAAE;MACxCY,iBAAiB,CAACC,SAAS,CAAC;MAC5B/b,cAAc,CAACuD,UAAU,EAAE6Y,MAAM,GAAG,cAAc,CAAC,CAACrN,GAAG,CAAC,IAAI,CAAC;MAC7D,IAAI8N,MAAM,GAAG7c,cAAc,CAACuD,UAAU,EAAE6Y,MAAM,CAAC,CAAC7N,GAAG,CAAC,CAAC;MACrD,IAAGsO,MAAM,CAACC,YAAY,EAAE;QACpB;QACA;QACAD,MAAM,CAAC9H,MAAM,CAACgI,MAAM,GAAGF,MAAM,CAACC,YAAY,CAACvC,KAAK,CAAC,CAAC;MACtD;IACJ,CAAC,MAAM,IAAGwB,SAAS,CAACa,KAAK,CAACzB,YAAY,CAAC,EAAE;MACrCnb,cAAc,CAACuD,UAAU,EAAE6Y,MAAM,GAAG,eAAe,CAAC,CAACrN,GAAG,CAAC,IAAI,CAAC;IAClE;;IAEA;IACA;IACA;IACA;IACA;IACA,IAAGoN,KAAK,KAAK,MAAM,EAAE;MACjBxB,EAAE,GAAG2B,QAAQ;MACb,IAAIU,KAAK,GAAGT,UAAU,CAACxU,IAAI,KAAK,QAAQ,IAAI8N,EAAE,KAAK,KAAK;MACxD,IAAIoH,OAAO,GAAGV,UAAU,CAACxU,IAAI,KAAK,KAAK,IAAI8N,EAAE,KAAK,QAAQ;MAE1D,IAAGmH,KAAK,IAAIC,OAAO,EAAE;QACjB,IAAG,CAACtC,EAAE,IAAI,CAACA,EAAE,CAACL,KAAK,EAAE;UACjB;UACA;UACA;UACAtF,OAAO,CAACoH,MAAM,GAAG,YAAY,EAAE,IAAI,CAAC;QACxC,CAAC,MAAM,IAAG,CAACG,UAAU,CAAClC,SAAS,EAAE;UAC7B;UACA;UACA,IAAI6C,EAAE,GAAGvC,EAAE,CAACL,KAAK,CAAC,CAAC,CAAC;UACpB,IAAI6C,EAAE,GAAGxC,EAAE,CAACL,KAAK,CAAC,CAAC,CAAC;UACpB,IAAG0C,KAAK,EAAE;YACN;YACA,IAAGE,EAAE,IAAI,CAAC,IAAIC,EAAE,IAAI,CAAC,EAAE;cACnBnI,OAAO,CAACoH,MAAM,GAAG,YAAY,EAAE,IAAI,CAAC;YACxC;YACA;YACA,IAAGc,EAAE,IAAI,CAAC,EAAEA,EAAE,GAAGC,EAAE,GAAG,GAAG,CAAC,KACrB,IAAGA,EAAE,IAAI,CAAC,EAAEA,EAAE,GAAGD,EAAE,GAAG,GAAG;YAC9B;YACAlI,OAAO,CAACoH,MAAM,GAAG,WAAW,EAAE1V,IAAI,CAACO,GAAG,CAACiW,EAAE,CAAC,GAAGxW,IAAI,CAAC0W,IAAI,CAAC;YACvDpI,OAAO,CAACoH,MAAM,GAAG,WAAW,EAAE1V,IAAI,CAACO,GAAG,CAACkW,EAAE,CAAC,GAAGzW,IAAI,CAAC0W,IAAI,CAAC;UAC3D,CAAC,MAAM;YACHpI,OAAO,CAACoH,MAAM,GAAG,WAAW,EAAE1V,IAAI,CAAC2W,GAAG,CAAC,EAAE,EAAEH,EAAE,CAAC,CAAC;YAC/ClI,OAAO,CAACoH,MAAM,GAAG,WAAW,EAAE1V,IAAI,CAAC2W,GAAG,CAAC,EAAE,EAAEF,EAAE,CAAC,CAAC;UACnD;QACJ,CAAC,MAAM,IAAGH,KAAK,EAAE;UACb;UACA;UACArC,EAAE,CAACL,KAAK,GAAIK,EAAE,CAACL,KAAK,CAAC,CAAC,CAAC,GAAGK,EAAE,CAACL,KAAK,CAAC,CAAC,CAAC,GAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;QAC5D;;QAEA;QACA;QACA,IAAG1X,KAAK,CAACC,OAAO,CAACU,UAAU,CAAC+Z,SAAS,CAACC,KAAK,CAAC,IACxCha,UAAU,CAAC+Z,SAAS,CAACC,KAAK,CAACva,MAAM,IACjCO,UAAU,CAACsY,CAAC,CAACtP,KAAK,CAAC,CAAC,CAAC,CAAC,IACtBsP,CAAC,CAACtP,KAAK,CAAC,CAAC,CAAC,KAAK,YAAY,EAC7B;UACE,OAAOhJ,UAAU,CAACsY,CAAC,CAACtP,KAAK,CAAC,CAAC,CAAC,CAAC,CAACiR,QAAQ,CAACC,WAAW,CAAC,kBAAkB,CAAC;QAC1E;;QAEA;QACA;QACAtd,QAAQ,CAACqI,kBAAkB,CAAC,aAAa,EAAE,eAAe,CAAC,CAACjH,EAAE,EAAEgb,UAAU,EAAE1G,EAAE,EAAEb,OAAO,CAAC;QACxF7U,QAAQ,CAACqI,kBAAkB,CAAC,QAAQ,EAAE,eAAe,CAAC,CAACjH,EAAE,EAAEgb,UAAU,EAAE1G,EAAE,EAAEb,OAAO,CAAC;MACvF,CAAC,MAAM;QACH;QACA;QACAA,OAAO,CAACoH,MAAM,GAAG,YAAY,EAAE,IAAI,CAAC;QACpCpH,OAAO,CAACoH,MAAM,GAAG,QAAQ,EAAE,IAAI,CAAC;MACpC;MACApc,cAAc,CAACuD,UAAU,EAAE6Y,MAAM,GAAG,cAAc,CAAC,CAACrN,GAAG,CAAC,IAAI,CAAC;IACjE,CAAC,MAAM,IAAGoN,KAAK,CAACS,KAAK,CAACzb,eAAe,CAAC,EAAE;MACpC,IAAIuc,QAAQ,GAAG1d,cAAc,CAACuD,UAAU,EAAEqS,EAAE,CAAC,CAACrH,GAAG,CAAC,CAAC;MACnD,IAAIoP,OAAO,GAAG,CAAC9H,EAAE,IAAI,CAAC,CAAC,EAAE9N,IAAI;;MAE7B;MACA;MACA;MACA,IAAG,CAAC4V,OAAO,IAAIA,OAAO,KAAK,GAAG,EAAEA,OAAO,GAAG,QAAQ;MAClDxd,QAAQ,CAACqI,kBAAkB,CAAC,aAAa,EAAE,eAAe,CAAC,CAACjH,EAAE,EAAEmc,QAAQ,EAAEC,OAAO,EAAE3I,OAAO,CAAC;MAC3F7U,QAAQ,CAACqI,kBAAkB,CAAC,QAAQ,EAAE,eAAe,CAAC,CAACjH,EAAE,EAAEmc,QAAQ,EAAEC,OAAO,EAAE3I,OAAO,CAAC;IAC1F;;IAEA;;IAEA;IACA;IACA;IACA;IACA,IAAI4I,mBAAmB,GAAG7c,YAAY,CAAC6c,mBAAmB,CAAChI,EAAE,CAAC;IAC9D,IAAGgI,mBAAmB,EAAE;MACpBrC,QAAQ,GAAGqC,mBAAmB,CAACC,KAAK;MACpCxZ,CAAC,GAAGuZ,mBAAmB,CAAC3Q,KAAK;MAC7B,IAAI6Q,OAAO,GAAGF,mBAAmB,CAACG,QAAQ;MAC1C,IAAIC,eAAe,GAAG9H,SAAS,IAAI;QAAC+H,QAAQ,EAAE;MAAM,CAAC;MAErD,IAAG5Z,CAAC,KAAK,EAAE,IAAIyZ,OAAO,KAAK,EAAE,EAAE;QAC3B;QACA;QACA;QACA,IAAG/c,YAAY,CAACmd,QAAQ,CAACrI,EAAE,CAAC,EAAE;UAC1BpD,MAAM,CAACmD,EAAE,CAAC,GAAG,IAAI;QACrB,CAAC,MAAM,IAAG7U,YAAY,CAACod,WAAW,CAACtI,EAAE,CAAC,EAAE;UACpCpD,MAAM,CAACmD,EAAE,CAAC,GAAG,CAAC5V,cAAc,CAACyB,MAAM,EAAE8Z,QAAQ,CAAC,CAAChN,GAAG,CAAC,CAAC,IAAI,EAAE,EAAElK,CAAC,CAAC;QAClE,CAAC,MAAM;UACHtE,GAAG,CAACsC,IAAI,CAAC,gCAAgC,EAAEsP,IAAI,CAAC;QACpD;MACJ;MACAzQ,SAAS,CAAC2M,MAAM,CAACmE,KAAK,EAAEgM,eAAe,CAAC;;MAExC;MACA,IAAG,CAAC1C,UAAU,CAACC,QAAQ,CAAC,EAAED,UAAU,CAACC,QAAQ,CAAC,GAAG,CAAC,CAAC;MACnD,IAAI6C,QAAQ,GAAG9C,UAAU,CAACC,QAAQ,CAAC,CAAClX,CAAC,CAAC;MACtC,IAAG,CAAC+Z,QAAQ,EAAEA,QAAQ,GAAG9C,UAAU,CAACC,QAAQ,CAAC,CAAClX,CAAC,CAAC,GAAG,CAAC,CAAC;MACrD+Z,QAAQ,CAACN,OAAO,CAAC,GAAGjI,EAAE;MAEtB,OAAOlE,IAAI,CAACiE,EAAE,CAAC;IACnB,CAAC,MAAM,IAAGuG,KAAK,KAAK,SAAS,EAAE;MAC3B;;MAEA,IAAGG,QAAQ,CAAChC,KAAK,EAAEgC,QAAQ,CAAChC,KAAK,CAAC+D,OAAO,CAAC,CAAC,CAAC,KACvC;QACDrJ,OAAO,CAACoH,MAAM,GAAG,YAAY,EAAE,IAAI,CAAC;QACpCE,QAAQ,CAAChC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MAC3B;MAEA,IAAGiC,UAAU,CAAClC,SAAS,EAAErI,KAAK,CAACC,IAAI,GAAG,IAAI,CAAC,KACtCD,KAAK,CAACsG,IAAI,GAAG,IAAI;IAC1B,CAAC,MAAM;MACH,IAAG1C,EAAE,KAAK,UAAU,KAAMC,EAAE,KAAK,KAAK,IAAI2G,IAAI,KAAK,KAAK,IAAM3G,EAAE,KAAK,KAAK,IAAI2G,IAAI,KAAK,KAAM,CAAC,EAAE;QAC5FxK,KAAK,CAACsG,IAAI,GAAG,IAAI;MACrB,CAAC,MAAM,IAAI/U,UAAU,CAACG,IAAI,CAAC,cAAc,CAAC,IAAIH,UAAU,CAACG,IAAI,CAAC,MAAM,CAAC,IAChEkS,EAAE,KAAK,UAAU,KACjBC,EAAE,KAAK,OAAO,IAAIA,EAAE,KAAK,QAAQ,CAAC,IACnC,EAAE2G,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,QAAQ,CAAE,EAC3C;QACExK,KAAK,CAACsG,IAAI,GAAG,IAAI;MACrB,CAAC,MAAM,IAAG/U,UAAU,CAACG,IAAI,CAAC,MAAM,CAAC,EAAE;QAC/BsO,KAAK,CAACsG,IAAI,GAAG,IAAI;MACrB,CAAC,MAAM,IAAGpC,SAAS,EAAEhV,SAAS,CAAC2M,MAAM,CAACmE,KAAK,EAAEkE,SAAS,CAAC,CAAC,KACnDlE,KAAK,CAACC,IAAI,GAAG,IAAI;MAEtB4J,CAAC,CAAC9M,GAAG,CAAC8G,EAAE,CAAC;IACb;EACJ;;EAEA;EACA,KAAI0F,QAAQ,IAAID,UAAU,EAAE;IACxB,IAAIgD,QAAQ,GAAGvd,YAAY,CAACwd,0BAA0B,CAAChd,EAAE,EACrDyS,QAAQ,CAACvS,MAAM,EAAE8Z,QAAQ,CAAC,EAAED,UAAU,CAACC,QAAQ,CAAC,EAAEvJ,KAAK,EAAEgC,QAAQ,CAAC;IACtE,IAAG,CAACsK,QAAQ,EAAEtM,KAAK,CAACsG,IAAI,GAAG,IAAI;EACnC;;EAEA;EACA,KAAI,IAAI2B,IAAI,IAAIZ,aAAa,EAAE;IAC3BsB,EAAE,GAAGra,IAAI,CAACsa,SAAS,CAACrZ,EAAE,EAAE0Y,IAAI,CAAC;IAC7B,IAAIuE,KAAK,GAAG7D,EAAE,IAAIA,EAAE,CAAC8D,gBAAgB;IACrC,IAAGD,KAAK,EAAE;MACN;MACA;MACA;MACA;MACA;MACAxM,KAAK,CAACC,IAAI,GAAG,IAAI;MACjB,KAAI,IAAIyM,SAAS,IAAIF,KAAK,EAAE;QACxB,IAAG,CAACnF,aAAa,CAACqF,SAAS,CAAC,EAAE;UAC1Bpe,IAAI,CAACsa,SAAS,CAACrZ,EAAE,EAAEmd,SAAS,CAAC,CAACC,qBAAqB,GAAG,IAAI;QAC9D;MACJ;IACJ;EACJ;;EAEA;EACA;EACA;EACA;EACA,IAAGC,cAAc,CAACrd,EAAE,CAAC,IAAIoQ,IAAI,CAACnL,MAAM,IAAImL,IAAI,CAACpL,KAAK,EAAEyL,KAAK,CAACsG,IAAI,GAAG,IAAI;;EAErE;EACA,IAAIuG,MAAM,GAAGtb,UAAU,CAACsb,MAAM;EAC9B,KAAIxa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwa,MAAM,CAAC7b,MAAM,EAAEqB,CAAC,EAAE,EAAE;IAC/B,IAAGwa,MAAM,CAACxa,CAAC,CAAC,CAACya,UAAU,EAAE;MACrB9M,KAAK,CAACC,IAAI,GAAG,IAAI;MACjB;IACJ;EACJ;EAEA,IAAGD,KAAK,CAACsG,IAAI,IAAItG,KAAK,CAACC,IAAI,EAAE;IACzBD,KAAK,CAAC+G,YAAY,GAAG,IAAI;EAC7B;;EAEA;EACA;;EAEA,OAAO;IACH/G,KAAK,EAAEA,KAAK;IACZqH,aAAa,EAAEA,aAAa;IAC5B5G,MAAM,EAAEA,MAAM;IACdC,MAAM,EAAEA,MAAM;IACdC,SAAS,EAAEA;EACf,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASiM,cAAcA,CAACrd,EAAE,EAAE;EACxB,IAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAC/B,IAAIub,QAAQ,GAAGxb,UAAU,CAACgD,KAAK;EAC/B,IAAIyY,SAAS,GAAGzb,UAAU,CAACiD,MAAM;;EAEjC;EACA,IAAGjF,EAAE,CAACE,MAAM,CAACwd,QAAQ,EAAE5e,KAAK,CAAC6e,YAAY,CAAC3d,EAAE,EAAEA,EAAE,CAACE,MAAM,EAAE8B,UAAU,CAAC;EAEpE,OAAQA,UAAU,CAACgD,KAAK,KAAKwY,QAAQ,IAAMxb,UAAU,CAACiD,MAAM,KAAKwY,SAAU;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnR,MAAMA,CAACtM,EAAE,EAAE4d,WAAW,EAAEC,YAAY,EAAE3N,OAAO,EAAE;EACpDlQ,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EACxBP,OAAO,CAAC0Q,iBAAiB,CAACnQ,EAAE,CAAC;EAE7B,IAAG,CAACxB,GAAG,CAAC+B,aAAa,CAACqd,WAAW,CAAC,EAAEA,WAAW,GAAG,CAAC,CAAC;EACpD,IAAG,CAACpf,GAAG,CAAC+B,aAAa,CAACsd,YAAY,CAAC,EAAEA,YAAY,GAAG,CAAC,CAAC;EAEtD,IAAGrU,MAAM,CAACD,IAAI,CAACqU,WAAW,CAAC,CAACnc,MAAM,EAAEzB,EAAE,CAACqQ,OAAO,GAAG,IAAI;EACrD,IAAG7G,MAAM,CAACD,IAAI,CAACsU,YAAY,CAAC,CAACpc,MAAM,EAAEzB,EAAE,CAACqQ,OAAO,GAAG,IAAI;EAEtD,IAAIlE,MAAM,GAAG1M,OAAO,CAAC6Q,kBAAkB,CAACtQ,EAAE,EAAEkQ,OAAO,CAAC;EAEpD,IAAI4N,YAAY,GAAGtN,QAAQ,CAACxQ,EAAE,EAAExB,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAEma,WAAW,CAAC,EAAEzR,MAAM,CAAC;EACxE,IAAI4R,YAAY,GAAGD,YAAY,CAACrN,KAAK;EAErC,IAAIuN,aAAa,GAAGzG,SAAS,CAACvX,EAAE,EAAExB,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAEoa,YAAY,CAAC,CAAC;EACnE,IAAII,aAAa,GAAGD,aAAa,CAACvN,KAAK;;EAEvC;EACA,IAAGsN,YAAY,CAACrN,IAAI,IAAIuN,aAAa,CAACvN,IAAI,EAAE1Q,EAAE,CAAC2C,QAAQ,GAAG+E,SAAS;EACnE,IAAGqW,YAAY,CAACpN,cAAc,EAAElR,OAAO,CAACkR,cAAc,CAAC3Q,EAAE,EAAEmM,MAAM,EAAE0R,YAAY,CAAC;;EAEhF;EACA,IAAIvW,GAAG,GAAG,EAAE;EAEZ,IAAG2W,aAAa,CAACzG,YAAY,EAAE;IAC3B;IACA;IACAlQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAAC8X,YAAY,CAAC;EACtC,CAAC,MAAM,IAAGuG,YAAY,CAACnN,UAAU,EAAE;IAC/BtJ,GAAG,CAAC3F,IAAI,CAACX,OAAO,CAACjB,OAAO,CAAC;EAC7B,CAAC,MAAM;IACHuH,GAAG,CAAC3F,IAAI,CAAC7C,KAAK,CAACiH,gBAAgB,CAAC;IAChC0R,2BAA2B,CAACzX,EAAE,EAAEie,aAAa,EAAED,aAAa,CAAC,IAAIlf,KAAK,CAACiD,cAAc,CAAC/B,EAAE,CAAC;IAEzF,IAAG+d,YAAY,CAACrZ,KAAK,EAAE4C,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACqR,YAAY,CAAC;IACzD,IAAGgN,YAAY,CAAC/M,SAAS,IAAIiN,aAAa,CAACjN,SAAS,EAAE1J,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuR,WAAW,CAAC;IACvF,IAAGgN,aAAa,CAACvG,MAAM,EAAEpQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACiY,QAAQ,CAAC;IACvD,IAAGsG,aAAa,CAACrG,WAAW,EAAEtQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACoH,YAAY,CAAC;IAChE,IAAGmX,aAAa,CAACpG,OAAO,EAAE/G,kBAAkB,CAACxJ,GAAG,EAAE0W,aAAa,CAAClG,aAAa,CAAC;IAC9E,IAAGmG,aAAa,CAAClG,KAAK,EAAEzQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACsY,eAAe,CAAC;IAC7D,IAAGiG,aAAa,CAACrY,OAAO,EAAE0B,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuY,SAAS,CAAC;IACzD,IAAGgG,aAAa,CAAC/F,MAAM,EAAE5Q,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACyY,QAAQ,CAAC;IAEvD7Q,GAAG,CAAC3F,IAAI,CAAC0G,aAAa,CAAC;EAC3B;EAEAf,GAAG,CAAC3F,IAAI,CACJ7C,KAAK,CAACkJ,OAAO,EACblJ,KAAK,CAACmJ,MAAM,EACZnJ,KAAK,CAACoJ,QACV,CAAC;EAEDvJ,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EACRsM,MAAM,EAAE,CAACtM,EAAE,EAAE8d,YAAY,CAAC5M,MAAM,EAAE8M,aAAa,CAAC9M,MAAM,EAAE4M,YAAY,CAAC3R,MAAM,CAAC,EAC5EG,MAAM,EAAE,CAACtM,EAAE,EAAE8d,YAAY,CAAC3M,MAAM,EAAE6M,aAAa,CAAC7M,MAAM,EAAE2M,YAAY,CAAC3R,MAAM,CAC/E,CAAC;EAED,IAAIhE,QAAQ,GAAG3J,GAAG,CAACqI,WAAW,CAACS,GAAG,EAAEtH,EAAE,CAAC;EACvC,IAAG,CAACmI,QAAQ,IAAI,CAACA,QAAQ,CAACP,IAAI,EAAEO,QAAQ,GAAGxH,OAAO,CAACyH,OAAO,CAACpI,EAAE,CAAC;EAE9D,OAAOmI,QAAQ,CAACP,IAAI,CAAC,YAAW;IAC5B5H,EAAE,CAACuI,IAAI,CAAC,eAAe,EAAE;MACrBtI,IAAI,EAAE6d,YAAY,CAAC1M,SAAS;MAC5BlR,MAAM,EAAE8d,aAAa,CAAC5M;IAC1B,CAAC,CAAC;IAEF,OAAOpR,EAAE;EACb,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASke,OAAOA,CAACC,IAAI,EAAE;EACnB,OAAO,SAASC,WAAWA,CAACpe,EAAE,EAAE;IAC5BA,EAAE,CAACiC,WAAW,CAACuQ,WAAW,GAAG,IAAI;IACjC,IAAI8H,CAAC,GAAG6D,IAAI,CAACvc,KAAK,CAAC,IAAI,EAAEmN,SAAS,CAAC;IACnC/O,EAAE,CAACiC,WAAW,CAACuQ,WAAW,GAAG,KAAK;IAClC,OAAO8H,CAAC;EACZ,CAAC;AACL;;AAEA;AACA;AACA;AACA,IAAI+D,uBAAuB,GAAG,CAC1B;EAACC,OAAO,EAAE,eAAe;EAAE9Z,IAAI,EAAE;AAAmB,CAAC,EACrD;EAAC8Z,OAAO,EAAE;AAA6C,CAAC;AAExD;AACA;EAACA,OAAO,EAAE,sBAAsB;EAAE9Z,IAAI,EAAE;AAAoB,CAAC,EAC7D;EAAC8Z,OAAO,EAAE,mBAAmB;EAAE9Z,IAAI,EAAE;AAAoB,CAAC,EAE1D;EAAC8Z,OAAO,EAAE;AAAqB,CAAC,EAChC;EAACA,OAAO,EAAE;AAA0C,CAAC,EACrD;EAACA,OAAO,EAAE;AAA8C,CAAC,EACzD;EAACA,OAAO,EAAE;AAA2D,CAAC,EACtE;EAACA,OAAO,EAAE;AAAoC,CAAC,EAC/C;EAACA,OAAO,EAAE;AAA2C,CAAC,EACtD;EAACA,OAAO,EAAE;AAAwC,CAAC,EAEnD;EAACA,OAAO,EAAE,iBAAiB;EAAE9Z,IAAI,EAAE;AAAc,CAAC,EAClD;EAAC8Z,OAAO,EAAE,uBAAuB;EAAE9Z,IAAI,EAAE;AAAc,CAAC,EACxD;EAAC8Z,OAAO,EAAE,eAAe;EAAE9Z,IAAI,EAAE;AAAc,CAAC,CACnD;;AAED;AACA;AACA,IAAI+Z,sBAAsB,GAAG,CACzB;EAACD,OAAO,EAAE,kBAAkB;EAAE9Z,IAAI,EAAE;AAAmB,CAAC;AACxD;AACA;EAAC8Z,OAAO,EAAE,qBAAqB;EAAE9Z,IAAI,EAAE;AAAmB,CAAC,EAC3D;EAAC8Z,OAAO,EAAE;AAAqC,CAAC,EAChD;EAACA,OAAO,EAAE;AAAqB,CAAC;AAAE;AAClC;EAACA,OAAO,EAAE;AAAS,CAAC;AAAE;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;EAACA,OAAO,EAAE;AAAkB,CAAC;AAC7B;AACA;EAACA,OAAO,EAAE;AAAwB,CAAC,EACnC;EAACA,OAAO,EAAE,kBAAkB;EAAE9Z,IAAI,EAAE;AAAc,CAAC,CACtD;AAED,SAASga,aAAaA,CAACta,GAAG,EAAEua,YAAY,EAAE;EACtC,KAAI,IAAI3b,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2b,YAAY,CAAChd,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACzC,IAAI4b,IAAI,GAAGD,YAAY,CAAC3b,CAAC,CAAC;IAC1B,IAAIuY,KAAK,GAAGnX,GAAG,CAACmX,KAAK,CAACqD,IAAI,CAACJ,OAAO,CAAC;IACnC,IAAGjD,KAAK,EAAE;MACN,IAAIsD,IAAI,GAAGtD,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;MACzB,OAAO;QAACsD,IAAI,EAAEA,IAAI;QAAEC,IAAI,EAAE1a,GAAG,CAAC2P,MAAM,CAAC8K,IAAI,CAACld,MAAM,GAAG,CAAC,CAAC;QAAE+C,IAAI,EAAEka,IAAI,CAACla;MAAI,CAAC;IAC3E;EACJ;AACJ;;AAEA;AACA;AACA;AACA,SAASqa,SAASA,CAACC,OAAO,EAAErN,SAAS,EAAE;EACnC,IAAIsN,MAAM,GAAGtgB,cAAc,CAACgT,SAAS,EAAEqN,OAAO,CAAC,CAAC9R,GAAG,CAAC,CAAC;EACrD,IAAG+R,MAAM,KAAKrX,SAAS,EAAE,OAAOqX,MAAM;EAEtC,IAAI/T,KAAK,GAAG8T,OAAO,CAACxV,KAAK,CAAC,GAAG,CAAC;EAC9B0B,KAAK,CAACgU,GAAG,CAAC,CAAC;EACX,OAAMhU,KAAK,CAACvJ,MAAM,GAAG,CAAC,EAAE;IACpBuJ,KAAK,CAACgU,GAAG,CAAC,CAAC;IACXD,MAAM,GAAGtgB,cAAc,CAACgT,SAAS,EAAEzG,KAAK,CAAC8P,IAAI,CAAC,GAAG,CAAC,GAAG,aAAa,CAAC,CAAC9N,GAAG,CAAC,CAAC;IACzE,IAAG+R,MAAM,KAAKrX,SAAS,EAAE,OAAOqX,MAAM;EAC1C;EAEA,OAAOtN,SAAS,CAACwN,UAAU;AAC/B;AAEA,SAASC,wBAAwBA,CAACzY,GAAG,EAAEF,QAAQ,EAAE;EAC7C,KAAI,IAAIzD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,QAAQ,CAAC9E,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACrC,IAAGyD,QAAQ,CAACzD,CAAC,CAAC,CAACkR,UAAU,CAACvN,GAAG,KAAKA,GAAG,EAAE,OAAO3D,CAAC;EACnD;EACA,OAAO,CAAC,CAAC;AACb;AAEA,SAASqc,oBAAoBA,CAAC1Y,GAAG,EAAExG,IAAI,EAAE6T,MAAM,EAAE;EAC7C,KAAI,IAAIhR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7C,IAAI,CAACwB,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACjC,IAAG7C,IAAI,CAAC6C,CAAC,CAAC,CAAC2D,GAAG,KAAKA,GAAG,EAAE,OAAO3D,CAAC;EACpC;EACA;EACA,OAAQ,CAAC7C,IAAI,CAAC6T,MAAM,CAAC,IAAI7T,IAAI,CAAC6T,MAAM,CAAC,CAACrN,GAAG,GAAI,CAAC,CAAC,GAAGqN,MAAM;AAC5D;AAEA,SAASsL,SAASA,CAACC,EAAE,EAAEC,EAAE,EAAE;EACvB,IAAIC,OAAO,GAAG/gB,GAAG,CAAC+B,aAAa,CAAC8e,EAAE,CAAC;EACnC,IAAIG,SAAS,GAAGne,KAAK,CAACC,OAAO,CAAC+d,EAAE,CAAC;EACjC,IAAGE,OAAO,IAAIC,SAAS,EAAE;IACrB,OAAO,CACFD,OAAO,IAAI/gB,GAAG,CAAC+B,aAAa,CAAC+e,EAAE,CAAC,IAChCE,SAAS,IAAIne,KAAK,CAACC,OAAO,CAACge,EAAE,CAAE,KAC/BG,IAAI,CAACC,SAAS,CAACL,EAAE,CAAC,KAAKI,IAAI,CAACC,SAAS,CAACJ,EAAE,CAAC;EAClD;EACA,OAAOD,EAAE,KAAKC,EAAE;AACpB;AAEA,SAASK,gBAAgBA,CAAC1f,IAAI,EAAEC,MAAM,EAAE0f,WAAW,EAAEC,aAAa,EAAE;EAChE,IAAIC,YAAY,GAAGD,aAAa,CAACnN,OAAO;EACxC,IAAIxO,GAAG,EAAE4a,OAAO,EAAEiB,MAAM,EAAEhB,MAAM,EAAE1D,KAAK,EAAE2E,SAAS,EAAEC,KAAK,EAAElO,MAAM,EAAE4M,IAAI,EAAEC,IAAI;EAC7E,IAAIsB,oBAAoB,GAAG,EAAE;EAC7B,IAAIC,cAAc,GAAG,CAAC,CAAC;EACvB,IAAIC,gBAAgB,GAAG,CAAC,CAAC;EACzB,KAAIlc,GAAG,IAAI4b,YAAY,EAAE;IACrBzE,KAAK,GAAGmD,aAAa,CAACta,GAAG,EAAEma,uBAAuB,CAAC;IACnD,IAAGhD,KAAK,EAAE;MACNsD,IAAI,GAAGtD,KAAK,CAACsD,IAAI;MACjBC,IAAI,GAAGvD,KAAK,CAACuD,IAAI;MACjBE,OAAO,GAAGzD,KAAK,CAAC7W,IAAI,IAAKma,IAAI,GAAG,aAAc;MAC9CoB,MAAM,GAAGthB,cAAc,CAACohB,aAAa,EAAEf,OAAO,CAAC,CAAC9R,GAAG,CAAC,CAAC;MACrD+R,MAAM,GAAGgB,MAAM,IAAIlB,SAAS,CAACC,OAAO,EAAE5e,MAAM,CAAC;MAE7C,IAAG6e,MAAM,IAAKA,MAAM,KAAKgB,MAAO,EAAE;QAC9BC,SAAS,GAAGF,YAAY,CAAC5b,GAAG,CAAC;QAC7B,IAAG8b,SAAS,KAAK,IAAI,EAAEA,SAAS,GAAGtY,SAAS;QAC5CuY,KAAK,GAAGxhB,cAAc,CAACyB,MAAM,EAAEgE,GAAG,CAAC;QACnC6N,MAAM,GAAGkO,KAAK,CAACjT,GAAG,CAAC,CAAC;QAEpB,IAAGoS,SAAS,CAACrN,MAAM,EAAEiO,SAAS,CAAC,EAAE;UAC7B,IAAGjO,MAAM,KAAKrK,SAAS,IAAIkX,IAAI,KAAK,WAAW,EAAE;YAC7CsB,oBAAoB,CAACve,IAAI,CAACgd,IAAI,CAAC;UACnC;UACAsB,KAAK,CAACzS,GAAG,CAAC6D,eAAe,CAAC5S,cAAc,CAACohB,aAAa,EAAE3b,GAAG,CAAC,CAAC8I,GAAG,CAAC,CAAC,CAAC,CAAC;UACpE;QACJ,CAAC,MAAM,IAAG4R,IAAI,KAAK,WAAW,IAAIA,IAAI,CAAC/K,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,EAAE;UAC9D;UACA;UACA,IAAIwM,IAAI,GAAGP,YAAY,CAACnB,IAAI,GAAG,WAAW,CAAC;UAC3C,IAAI2B,IAAI,GAAGR,YAAY,CAACnB,IAAI,GAAG,WAAW,CAAC;UAC3C,IAAI4B,OAAO,GAAGT,YAAY,CAACnB,IAAI,GAAG,YAAY,CAAC;UAC/C,IAAG4B,OAAO,IAAKA,OAAO,KAAK,IAAI,IAAIF,IAAI,KAAK,IAAI,IAAIC,IAAI,KAAK,IAAK,EAAE;YAChE;YACA;YACA,IAAG,EAAE3B,IAAI,IAAIwB,cAAc,CAAC,EAAE;cAC1B,IAAIK,YAAY,GAAG/hB,cAAc,CAACyB,MAAM,EAAEye,IAAI,CAAC,CAAC3R,GAAG,CAAC,CAAC;cACrDmT,cAAc,CAACxB,IAAI,CAAC,GAAG6B,YAAY,KAC/BA,YAAY,CAAC1H,SAAS,IACrB0H,YAAY,CAAC1H,SAAS,KAAK,KAAK,KAC7B,CAAC0H,YAAY,CAACzH,KAAK,IAAIyH,YAAY,CAACzH,KAAK,CAACtX,MAAM,KAAK,CAAC,CACzD,CACJ;YACL;YACA,IAAG0e,cAAc,CAACxB,IAAI,CAAC,EAAE;cACrBsB,KAAK,CAACzS,GAAG,CAAC6D,eAAe,CAAC5S,cAAc,CAACohB,aAAa,EAAE3b,GAAG,CAAC,CAAC8I,GAAG,CAAC,CAAC,CAAC,CAAC;cACpE;YACJ;UACJ;QACJ;MACJ;IACJ,CAAC,MAAM;MACHxO,GAAG,CAACsC,IAAI,CAAC,yBAAyB,GAAGoD,GAAG,CAAC;IAC7C;IACA;IACA;IACA;IACA,OAAO4b,YAAY,CAAC5b,GAAG,CAAC;IAExB,IAAGmX,KAAK,IAAIA,KAAK,CAACuD,IAAI,CAAC/K,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC9CuM,gBAAgB,CAAC/E,KAAK,CAACsD,IAAI,CAAC,GAAG,CAAC;IACpC;EACJ;;EAEA;EACA;EACA;EACA;EACA,KAAI,IAAI7b,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGod,oBAAoB,CAACze,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACjD,IAAI2d,MAAM,GAAGP,oBAAoB,CAACpd,CAAC,CAAC;IACpC,IAAGsd,gBAAgB,CAACK,MAAM,CAAC,EAAE;MACzB,IAAIC,KAAK,GAAGjiB,cAAc,CAACyB,MAAM,EAAEugB,MAAM,CAAC,CAACzT,GAAG,CAAC,CAAC;MAChD,IAAG0T,KAAK,EAAE,OAAOA,KAAK,CAAC5H,SAAS;IACpC;EACJ;;EAEA;EACA;EACA,IAAI6H,cAAc,GAAGd,aAAa,CAAC9L,YAAY;EAC/C,KAAI,IAAItN,GAAG,IAAIka,cAAc,EAAE;IAC3B,IAAIC,WAAW,GAAGD,cAAc,CAACla,GAAG,CAAC;IACrC,IAAIoa,QAAQ,GAAG,IAAI;IACnB,IAAIC,SAAS;IACb,KAAI5c,GAAG,IAAI0c,WAAW,EAAE;MACpB;MACA;MACA,IAAG,CAACC,QAAQ,EAAE;QACV,IAAIE,KAAK,GAAG7B,wBAAwB,CAACzY,GAAG,EAAEmZ,WAAW,CAAC;QACtD,IAAGmB,KAAK,GAAG,CAAC,EAAE;UACV;UACA;UACA,OAAOJ,cAAc,CAACla,GAAG,CAAC;UAC1B;QACJ;QACA,IAAIua,SAAS,GAAGpB,WAAW,CAACmB,KAAK,CAAC;QAClCD,SAAS,GAAGE,SAAS,CAAChN,UAAU;QAEhC,IAAIiN,SAAS,GAAG9B,oBAAoB,CAAC1Y,GAAG,EAAExG,IAAI,EAAE6gB,SAAS,CAACpV,KAAK,CAAC;QAChE,IAAGuV,SAAS,GAAG,CAAC,EAAE;UACd;UACA,OAAON,cAAc,CAACla,GAAG,CAAC;UAC1B;QACJ;QACAoa,QAAQ,GAAG5gB,IAAI,CAACghB,SAAS,CAAC;MAC9B;MAEA5F,KAAK,GAAGmD,aAAa,CAACta,GAAG,EAAEqa,sBAAsB,CAAC;MAClD,IAAGlD,KAAK,EAAE;QACN,IAAGA,KAAK,CAAC7W,IAAI,EAAE;UACXub,MAAM,GAAGthB,cAAc,CAACohB,aAAa,EAAExE,KAAK,CAAC7W,IAAI,CAAC,CAACwI,GAAG,CAAC,CAAC;UACxD+R,MAAM,GAAGgB,MAAM,IAAIlB,SAAS,CAACxD,KAAK,CAAC7W,IAAI,EAAEtE,MAAM,CAAC;QACpD,CAAC,MAAM;UACH6f,MAAM,GAAGe,SAAS,CAAC7B,UAAU;UAC7B;UACAF,MAAM,GAAG8B,QAAQ,CAAC5B,UAAU;UAC5B,IAAGF,MAAM,KAAKrX,SAAS,EAAEqX,MAAM,GAAG7e,MAAM,CAAC+e,UAAU;QACvD;QAEA,IAAGF,MAAM,IAAIA,MAAM,KAAKgB,MAAM,EAAE;UAC5BC,SAAS,GAAGY,WAAW,CAAC1c,GAAG,CAAC;UAC5B,IAAG8b,SAAS,KAAK,IAAI,EAAEA,SAAS,GAAGtY,SAAS;UAC5CuY,KAAK,GAAGxhB,cAAc,CAACoiB,QAAQ,EAAE3c,GAAG,CAAC;UACrC6N,MAAM,GAAGkO,KAAK,CAACjT,GAAG,CAAC,CAAC;UACpB,IAAGoS,SAAS,CAACrN,MAAM,EAAEiO,SAAS,CAAC,EAAE;YAC7BC,KAAK,CAACzS,GAAG,CAAC6D,eAAe,CAAC5S,cAAc,CAACqiB,SAAS,EAAE5c,GAAG,CAAC,CAAC8I,GAAG,CAAC,CAAC,CAAC,CAAC;YAChE;UACJ;QACJ;MACJ,CAAC,MAAM;QACHxO,GAAG,CAACsC,IAAI,CAAC,yBAAyB,GAAGoD,GAAG,GAAG,gBAAgB,GAAGuC,GAAG,CAAC;MACtE;MACA,OAAOma,WAAW,CAAC1c,GAAG,CAAC;IAC3B;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgd,KAAKA,CAAClhB,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAE;EACrC,IAAIC,MAAM,EAAE+H,QAAQ;EAEpB,SAASpH,SAASA,CAAA,EAAG;IAAE,OAAOC,OAAO,CAACD,SAAS,CAACf,EAAE,EAAEI,MAAM,CAAC;EAAE;EAE7DJ,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EACxBP,OAAO,CAAC0Q,iBAAiB,CAACnQ,EAAE,CAAC;EAE7B,IAAI4f,WAAW,GAAG5f,EAAE,CAAC4C,SAAS;EAC9B,IAAIid,aAAa,GAAG7f,EAAE,CAACiC,WAAW;;EAElC;EACA,IAAG,CAACzD,GAAG,CAACqC,SAAS,CAACb,EAAE,CAAC,IAAI,CAAC4f,WAAW,IAAI,CAACC,aAAa,EAAE;IACrD1X,QAAQ,GAAGnH,OAAO,CAACmK,OAAO,CAACnL,EAAE,EAAEC,IAAI,EAAEC,MAAM,EAAEC,MAAM,CAAC;EACxD,CAAC,MAAM;IACH,IAAG3B,GAAG,CAAC+B,aAAa,CAACN,IAAI,CAAC,EAAE;MACxB,IAAIO,GAAG,GAAGP,IAAI;MACdA,IAAI,GAAGO,GAAG,CAACP,IAAI;MACfC,MAAM,GAAGM,GAAG,CAACN,MAAM;MACnBC,MAAM,GAAGK,GAAG,CAACL,MAAM;MACnBC,MAAM,GAAGI,GAAG,CAACJ,MAAM;IACvB;IAEA,IAAI+gB,aAAa,GAAG,KAAK;IACzB;IACA;IACA,IAAGhhB,MAAM,EAAE;MACP,IAAIihB,SAAS,GAAG5iB,GAAG,CAACwK,UAAU,CAAC,CAAC,CAAC,EAAEhJ,EAAE,CAACgD,QAAQ,CAAC;MAC/ChD,EAAE,CAACgD,QAAQ,GAAG0E,SAAS;MACvBzG,cAAc,CAACjB,EAAE,EAAEG,MAAM,CAAC;MAC1BghB,aAAa,GAAGE,UAAU,CAACD,SAAS,EAAEphB,EAAE,CAACgD,QAAQ,CAAC;IACtD;IAEAhD,EAAE,CAACC,IAAI,GAAGA,IAAI,IAAI,EAAE;IACpBR,OAAO,CAACiC,SAAS,CAAC1B,EAAE,CAACC,IAAI,CAAC;IAC1BD,EAAE,CAACE,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;IACxBT,OAAO,CAACqC,WAAW,CAAC9B,EAAE,CAACE,MAAM,CAAC;IAE9Byf,gBAAgB,CAAC3f,EAAE,CAACC,IAAI,EAAED,EAAE,CAACE,MAAM,EAAE0f,WAAW,EAAEC,aAAa,CAAC;;IAEhE;IACA;IACA;IACA/gB,KAAK,CAACiD,cAAc,CAAC/B,EAAE,EAAE;MAACshB,cAAc,EAAE;IAAI,CAAC,CAAC;IAEhD,IAAIC,WAAW,GAAGvhB,EAAE,CAAC4C,SAAS;IAC9B,IAAI4e,aAAa,GAAGxhB,EAAE,CAACiC,WAAW;IAClC,IAAIwf,SAAS,GAAGD,aAAa,CAACE,YAAY,KAAKha,SAAS;IACxD,IAAIia,UAAU,GAAGH,aAAa,CAACG,UAAU;IAEzC,IAAI1D,aAAa,GAAG2D,UAAU,CAAC5hB,EAAE,EAAE6f,aAAa,EAAE2B,aAAa,EAAEC,SAAS,EAAEE,UAAU,CAAC;IACvF,IAAIE,eAAe,GAAG5D,aAAa,CAAC4D,eAAe;IACnD,IAAI9D,YAAY,GAAG+D,QAAQ,CAAC9hB,EAAE,EAAE4f,WAAW,EAAE2B,WAAW,EAAEE,SAAS,EAAEE,UAAU,EAAEE,eAAe,CAAC;;IAEjG;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,IAAGxE,cAAc,CAACrd,EAAE,CAAC,EAAEie,aAAa,CAACzG,YAAY,GAAG,IAAI;;IAExD;IACA,IAAGuG,YAAY,CAACrN,IAAI,IAAIuN,aAAa,CAACvN,IAAI,EAAE;MACxC1Q,EAAE,CAAC2C,QAAQ,GAAG+E,SAAS;MACvB,IAAIqa,QAAQ,GAAGvY,MAAM,CAACwY,mBAAmB,CAACR,aAAa,CAAC;MACxD,KAAI,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAACtgB,MAAM,EAAEwgB,CAAC,EAAE,EAAE;QACrC,IAAIC,IAAI,GAAGH,QAAQ,CAACE,CAAC,CAAC;QACtB,IAAIE,KAAK,GAAGD,IAAI,CAACE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;QAChC,IAAGD,KAAK,KAAK,OAAO,IAAIA,KAAK,KAAK,OAAO,EAAE;UACvC,IAAIE,eAAe,GAAGb,aAAa,CAACU,IAAI,CAAC,CAACI,gBAAgB;UAC1D,IAAGD,eAAe,EAAEA,eAAe,CAAC,CAAC;QACzC;MACJ;MACJ;IACA,CAAC,MAAM;MACHvjB,KAAK,CAACyjB,wBAAwB,CAACviB,EAAE,CAAC2C,QAAQ,EAAE4e,WAAW,CAAC;IAC5D;;IAEA;IACA;;IAEA;IACA,IAAIja,GAAG,GAAG,EAAE;IAEZ,IAAGlH,MAAM,EAAE;MACPJ,EAAE,CAACwiB,eAAe,GAAG,CAAC,CAAC;MACvB1jB,KAAK,CAAC2jB,oBAAoB,CAACziB,EAAE,CAAC;MAC9BsH,GAAG,CAAC3F,IAAI,CAACZ,SAAS,CAAC;IACvB;;IAEA;IACA;IACA;IACA;IACA,IAAGygB,aAAa,CAACG,UAAU,IAAI,CAACR,aAAa,KAAKpD,YAAY,CAAC2E,IAAI,IAAIzE,aAAa,CAACyE,IAAI,CAAC,EAAE;MACxF,IAAGzE,aAAa,CAAClG,KAAK,EAAEzQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACsY,eAAe,CAAC;MAE7DlZ,KAAK,CAAC+D,UAAU,CAAC7C,EAAE,CAAC;MACpBN,WAAW,CAACsH,yBAAyB,CAAChH,EAAE,CAAC;MAEzCsH,GAAG,CAAC3F,IAAI,CAAC,YAAW;QAChB,OAAO7C,KAAK,CAAC6jB,mBAAmB,CAAC3iB,EAAE,EAAE+d,YAAY,EAAEE,aAAa,EAAE4B,aAAa,CAAC;MACpF,CAAC,CAAC;IACN,CAAC,MAAM,IAAG9B,YAAY,CAACnN,UAAU,IAAIqN,aAAa,CAACzG,YAAY,IAAI2J,aAAa,EAAE;MAC9EnhB,EAAE,CAACiC,WAAW,CAAC2gB,aAAa,GAAG,IAAI;MACnCtb,GAAG,CAAC3F,IAAI,CAACX,OAAO,CAACjB,OAAO,CAAC;IAC7B,CAAC,MAAM;MACH,KAAI,IAAI8iB,aAAa,IAAI5E,aAAa,CAAC6E,MAAM,EAAE;QAC3C,IAAIxX,OAAO,GAAG2S,aAAa,CAAC6E,MAAM,CAACD,aAAa,CAAC;QACjD,IAAGvX,OAAO,CAAC7J,MAAM,EAAE;UACf,IAAIshB,OAAO,GAAGnkB,QAAQ,CAACqI,kBAAkB,CAAC4b,aAAa,EAAE,SAAS,CAAC;UACnE,IAAGE,OAAO,KAAKvkB,GAAG,CAACwkB,IAAI,EAAE;YACrB,KAAI,IAAIlgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwI,OAAO,CAAC7J,MAAM,EAAEqB,CAAC,EAAE,EAAE;cACpCigB,OAAO,CAAC/iB,EAAE,EAAEsL,OAAO,CAACxI,CAAC,CAAC,CAAC;YAC3B;UACJ,CAAC,MAAM;YACH,IAAIuE,IAAI,GAAGzI,QAAQ,CAACqI,kBAAkB,CAAC4b,aAAa,EAAE,MAAM,CAAC;YAC7D,IAAGxb,IAAI,KAAK7I,GAAG,CAACwkB,IAAI,EAAE;cAClB,MAAM,IAAI9X,KAAK,CAAC,0BAA0B,GAAG2X,aAAa,CAAC;YAC/D;YACAxb,IAAI,CAACrH,EAAE,CAAC;UACZ;QACJ;MACJ;MAEAsH,GAAG,CAAC3F,IAAI,CAAC7C,KAAK,CAACiH,gBAAgB,CAAC;MAChC,IAAGgY,YAAY,CAACrZ,KAAK,EAAE4C,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACqR,YAAY,CAAC;MACzD,IAAGgN,YAAY,CAAC/M,SAAS,IAAIiN,aAAa,CAACjN,SAAS,EAAE1J,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuR,WAAW,CAAC;MACvF,IAAGgN,aAAa,CAACvG,MAAM,EAAEpQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACiY,QAAQ,CAAC;MACvD,IAAGsG,aAAa,CAACrG,WAAW,EAAEtQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACoH,YAAY,CAAC;MAChE,IAAGmX,aAAa,CAACpG,OAAO,EAAE/G,kBAAkB,CAACxJ,GAAG,CAAC;MACjD,IAAG2W,aAAa,CAAClG,KAAK,EAAEzQ,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACsY,eAAe,CAAC;MAC7D,IAAGiG,aAAa,CAACrY,OAAO,EAAE0B,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACuY,SAAS,CAAC;MACzD,IAAGgG,aAAa,CAAC/F,MAAM,EAAE5Q,GAAG,CAAC3F,IAAI,CAACjC,WAAW,CAACyY,QAAQ,CAAC;MACvD7Q,GAAG,CAAC3F,IAAI,CAAC0G,aAAa,CAAC;IAC3B;IAEAf,GAAG,CAAC3F,IAAI,CACJ7C,KAAK,CAACkJ,OAAO,EACblJ,KAAK,CAACmJ,MAAM,EACZnJ,KAAK,CAACoJ,QACV,CAAC;IAEDC,QAAQ,GAAG3J,GAAG,CAACqI,WAAW,CAACS,GAAG,EAAEtH,EAAE,CAAC;IACnC,IAAG,CAACmI,QAAQ,IAAI,CAACA,QAAQ,CAACP,IAAI,EAAEO,QAAQ,GAAGxH,OAAO,CAACyH,OAAO,CAACpI,EAAE,CAAC;EAClE;EAEA,OAAOmI,QAAQ,CAACP,IAAI,CAAC,YAAW;IAC5B5H,EAAE,CAACuI,IAAI,CAAC,cAAc,EAAE;MACpBtI,IAAI,EAAEA,IAAI;MACVC,MAAM,EAAEA;IACZ,CAAC,CAAC;IAEF,OAAOF,EAAE;EACb,CAAC,CAAC;AACN;AAEA,SAAS8hB,QAAQA,CAAC9hB,EAAE,EAAE4f,WAAW,EAAE2B,WAAW,EAAEE,SAAS,EAAEE,UAAU,EAAEE,eAAe,EAAE;EACpF,IAAIoB,eAAe,GAAGrD,WAAW,CAACne,MAAM,KAAK8f,WAAW,CAAC9f,MAAM;EAE/D,IAAG,CAACkgB,UAAU,IAAI,CAACsB,eAAe,EAAE;IAChC,OAAO;MACHrS,UAAU,EAAE,IAAI;MAChBF,IAAI,EAAE;IACV,CAAC;EACL;EAEA,IAAID,KAAK,GAAG9Q,SAAS,CAACkT,UAAU,CAAC,CAAC;EAClCpC,KAAK,CAACqS,MAAM,GAAG,CAAC,CAAC;EACjBrS,KAAK,CAACyS,QAAQ,GAAG,CAAC;EAClBzS,KAAK,CAAC0S,YAAY,GAAG,CAAC;EAEtB,IAAIrgB,CAAC,EAAEC,KAAK;EAEZ,SAASiS,iBAAiBA,CAAChK,KAAK,EAAE;IAC9B,IAAIuC,GAAG,GAAG1O,UAAU,CAACmW,iBAAiB,CAACjS,KAAK,EAAEiI,KAAK,CAAC;IACpD,IAAG,CAACjI,KAAK,CAACqgB,OAAO,CAACC,UAAU,IAAI9V,GAAG,CAACmV,IAAI,EAAE;MACtCnV,GAAG,CAACmV,IAAI,GAAG,KAAK;IACpB;IACA,OAAOnV,GAAG;EACd;EAEA,IAAI+V,QAAQ,GAAG;IACXC,YAAY,EAAEvO,iBAAiB;IAC/BvE,KAAK,EAAEA,KAAK;IACZgR,SAAS,EAAEA,SAAS;IACpBE,UAAU,EAAEA,UAAU;IACtBE,eAAe,EAAEA,eAAe;IAChC7hB,EAAE,EAAEA;EACR,CAAC;EAED,IAAIwjB,QAAQ,GAAG,CAAC,CAAC;EAEjB,KAAI1gB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8c,WAAW,CAACne,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACpC,IAAGye,WAAW,CAACze,CAAC,CAAC,EAAE;MACfC,KAAK,GAAGwe,WAAW,CAACze,CAAC,CAAC,CAACkR,UAAU;MACjC,IAAGlV,KAAK,CAAC2kB,qBAAqB,CAAC1gB,KAAK,CAAC,EAAEA,KAAK,GAAGwe,WAAW,CAACze,CAAC,CAAC;MAC7D,IAAG0gB,QAAQ,CAACzgB,KAAK,CAAC0D,GAAG,CAAC,EAAE;MACxB+c,QAAQ,CAACzgB,KAAK,CAAC0D,GAAG,CAAC,GAAG,CAAC;MAEvBid,YAAY,CAAC9D,WAAW,CAAC9c,CAAC,CAAC,CAACkR,UAAU,EAAEjR,KAAK,EAAE,EAAE,EAAEugB,QAAQ,CAAC;IAChE;EACJ;EAEA,IAAG7S,KAAK,CAACC,IAAI,IAAID,KAAK,CAACsG,IAAI,EAAE;IACzBtG,KAAK,CAACG,UAAU,GAAG,IAAI;EAC3B;EAEA,IAAG+Q,UAAU,IAAIlR,KAAK,CAACyS,QAAQ,IAAIzS,KAAK,CAAC0S,YAAY,EAAE;IACnD1S,KAAK,CAACiS,IAAI,GAAIjS,KAAK,CAACyS,QAAQ,KAAKzS,KAAK,CAAC0S,YAAY,IAAKF,eAAe,GAAG,KAAK,GAAG,MAAM;EAC5F;EAEA,OAAOxS,KAAK;AAChB;AAEA,SAASmR,UAAUA,CAAC5hB,EAAE,EAAE6f,aAAa,EAAE2B,aAAa,EAAEC,SAAS,EAAEE,UAAU,EAAE;EACzE,IAAIlR,KAAK,GAAG9Q,SAAS,CAAC0a,WAAW,CAAC,CAAC;EACnC5J,KAAK,CAACqS,MAAM,GAAG,CAAC,CAAC;EACjBrS,KAAK,CAACqH,aAAa,GAAG,CAAC,CAAC;EACxBrH,KAAK,CAACyS,QAAQ,GAAG,CAAC;EAClBzS,KAAK,CAAC0S,YAAY,GAAG,CAAC;EAEtB,SAASjI,kBAAkBA,CAAClQ,KAAK,EAAE;IAC/B,OAAOnM,UAAU,CAACqc,kBAAkB,CAACsG,aAAa,EAAExW,KAAK,CAAC;EAC9D;EAEA,IAAIsY,QAAQ,GAAG;IACXC,YAAY,EAAErI,kBAAkB;IAChCzK,KAAK,EAAEA,KAAK;IACZgR,SAAS,EAAEA,SAAS;IACpBE,UAAU,EAAEA,UAAU;IACtB3hB,EAAE,EAAEA;EACR,CAAC;EAED0jB,YAAY,CAAC7D,aAAa,EAAE2B,aAAa,EAAE,EAAE,EAAE8B,QAAQ,CAAC;EAExD,IAAG7S,KAAK,CAACsG,IAAI,IAAItG,KAAK,CAACC,IAAI,EAAE;IACzBD,KAAK,CAAC+G,YAAY,GAAG,IAAI;EAC7B;EAEA,IAAGmK,UAAU,IAAIlR,KAAK,CAACyS,QAAQ,IAAIzS,KAAK,CAAC0S,YAAY,EAAE;IACnD1S,KAAK,CAACiS,IAAI,GAAGjS,KAAK,CAACyS,QAAQ,KAAKzS,KAAK,CAAC0S,YAAY,GAAG,KAAK,GAAG,MAAM;EACvE;EAEA,OAAO1S,KAAK;AAChB;AAEA,SAASiT,YAAYA,CAACC,YAAY,EAAEnD,YAAY,EAAEoD,UAAU,EAAEC,IAAI,EAAE;EAChE,IAAIlP,SAAS,EAAEzQ,GAAG,EAAEuJ,IAAI;EAExB,IAAI8V,YAAY,GAAGM,IAAI,CAACN,YAAY;EACpC,IAAI9S,KAAK,GAAGoT,IAAI,CAACpT,KAAK;EACtB,IAAIgR,SAAS,GAAGoC,IAAI,CAACpC,SAAS;EAC9B,IAAIqC,OAAO,GAAGD,IAAI,CAACC,OAAO;EAC1B,IAAIC,UAAU,GAAGF,IAAI,CAACE,UAAU;EAEhC,SAAS1T,OAAOA,CAAA,EAAG;IACf,IAAIqM,QAAQ,GAAG/H,SAAS,CAAC+H,QAAQ;IACjC,IAAGoH,OAAO,IAAIpH,QAAQ,CAAC5Q,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE;MAChDtN,GAAG,CAACwlB,UAAU,CAACvT,KAAK,CAACqS,MAAM,CAACgB,OAAO,CAAC,EAAEC,UAAU,CAAC;MACjD;IACJ;IACApkB,SAAS,CAAC2M,MAAM,CAACmE,KAAK,EAAEkE,SAAS,CAAC;IAElC,IAAG+H,QAAQ,KAAK,MAAM,EAAE;MACpBjM,KAAK,CAACyS,QAAQ,EAAE;IACpB;;IAEA;IACA,IAAGW,IAAI,CAAClC,UAAU,IAAIhN,SAAS,CAAC+N,IAAI,EAAE;MAClCjS,KAAK,CAAC0S,YAAY,EAAE;IACxB;;IAEA;IACA,IAAGzJ,WAAW,CAACtC,IAAI,CAAC3J,IAAI,CAAC,IAAIkM,eAAe,CAACvC,IAAI,CAAC3J,IAAI,CAAC,EAAE;MACrDgD,KAAK,CAACqH,aAAa,CAAC8L,UAAU,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IAC1C;;IAEA;IACA,IAAGhK,YAAY,CAACxC,IAAI,CAAC3J,IAAI,CAAC,EAAE;MACxBhP,cAAc,CAAC+hB,YAAY,EAAE,cAAc,CAAC,CAAChT,GAAG,CAAC,IAAI,CAAC;IAC1D;;IAEA;IACA,IAAGtJ,GAAG,KAAK,cAAc,EAAE;MACvBuM,KAAK,CAACoR,eAAe,GAAG,CAAC;IAC7B;EACJ;EAEA,SAASoC,uBAAuBA,CAACtP,SAAS,EAAE;IACxC,OAAOA,SAAS,CAACuP,OAAO,KAAK,YAAY,IAAIvP,SAAS,CAAC+B,OAAO;EAClE;EAEA,KAAIxS,GAAG,IAAIyf,YAAY,EAAE;IACrB;IACA,IAAGlT,KAAK,CAACC,IAAI,IAAI,CAACmT,IAAI,CAAClC,UAAU,EAAE;IAEnC,IAAIjN,MAAM,GAAGiP,YAAY,CAACzf,GAAG,CAAC;IAC9B,IAAI6N,MAAM,GAAGyO,YAAY,CAACtc,GAAG,CAAC;IAC9B,IAAI8G,KAAK,GAAG4Y,UAAU,CAACpV,MAAM,CAACtK,GAAG,CAAC;IAClCuJ,IAAI,GAAGzC,KAAK,CAAC8P,IAAI,CAAC,GAAG,CAAC;IAEtB,IAAG5W,GAAG,CAAC0Q,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,OAAOF,MAAM,KAAK,UAAU,IAAIA,MAAM,KAAK3C,MAAM,EAAE;;IAE/E;IACA;IACA;IACA,IAAG,CAAC7N,GAAG,KAAK,OAAO,IAAIA,GAAG,KAAK,OAAO,KAAK0f,UAAU,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;MAChE,IAAIO,QAAQ,GAAG3D,YAAY,CAAC4D,QAAQ;MACpC,IAAGD,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,OAAO,IAAI,CAACA,QAAQ,EAAE;IACjE;IACA;IACA;IACA,IAAGjgB,GAAG,KAAK,OAAO,IAAIsc,YAAY,CAAC1H,SAAS,EAAE;IAC9C,IAAG,CAAC5U,GAAG,KAAK,MAAM,IAAIA,GAAG,KAAK,MAAM,KAAKsc,YAAY,CAACha,IAAI,KAAK,eAAe,EAAE;IAEhFmO,SAAS,GAAG4O,YAAY,CAACvY,KAAK,CAAC;;IAE/B;IACA,IAAG,CAAC2J,SAAS,EAAE;IAEf,IAAGA,SAAS,CAAC0P,cAAc,IAAI5E,IAAI,CAACC,SAAS,CAAChL,MAAM,CAAC,KAAK+K,IAAI,CAACC,SAAS,CAAC3N,MAAM,CAAC,EAAE;IAElF,IAAImS,OAAO,GAAGvP,SAAS,CAACuP,OAAO;IAC/B,IAAIphB,CAAC;IAEL,IAAIwhB,cAAc,GAAGL,uBAAuB,CAACtP,SAAS,CAAC;IACvD,IAAI4P,QAAQ,GAAGljB,KAAK,CAACC,OAAO,CAACoT,MAAM,CAAC;IACpC,IAAI8P,QAAQ,GAAGnjB,KAAK,CAACC,OAAO,CAACyQ,MAAM,CAAC;;IAEpC;IACA;IACA,IAAGwS,QAAQ,IAAIC,QAAQ,EAAE;MACrB,IAAIC,QAAQ,GAAG,SAAS,GAAGvgB,GAAG;MAC9B,IAAIwgB,QAAQ,GAAGf,YAAY,CAACc,QAAQ,CAAC;MACrC,IAAIE,QAAQ,GAAGnE,YAAY,CAACiE,QAAQ,CAAC;MACrC,IAAGpjB,KAAK,CAACC,OAAO,CAACojB,QAAQ,CAAC,IAAIA,QAAQ,KAAKC,QAAQ,EAAE;IACzD;IAEA,IAAG5S,MAAM,KAAKrK,SAAS,EAAE;MACrB,IAAG4c,cAAc,IAAIC,QAAQ,EAAE9T,KAAK,CAACC,IAAI,GAAG,IAAI,CAAC,KAC5CL,OAAO,CAAC,CAAC;IAClB,CAAC,MAAM,IAAGsE,SAAS,CAACiQ,gBAAgB,EAAE;MAClC,IAAIC,gBAAgB,GAAG,EAAE;MACzB,IAAIC,YAAY,GAAG,KAAK;MACxB,IAAG,CAAChB,OAAO,EAAErT,KAAK,CAACqS,MAAM,CAAC5e,GAAG,CAAC,GAAG2gB,gBAAgB;MAEjD,IAAIE,MAAM,GAAG5f,IAAI,CAAC6f,GAAG,CAACtQ,MAAM,CAACjT,MAAM,EAAEsQ,MAAM,CAACtQ,MAAM,CAAC;MACnD,IAAIyQ,MAAM,GAAG/M,IAAI,CAACgN,GAAG,CAACuC,MAAM,CAACjT,MAAM,EAAEsQ,MAAM,CAACtQ,MAAM,CAAC;MACnD,IAAGsjB,MAAM,KAAK7S,MAAM,EAAE;QAClB,IAAGyC,SAAS,CAAC+H,QAAQ,KAAK,WAAW,EAAE;UACnCoI,YAAY,GAAG,IAAI;QACvB,CAAC,MAAM;UACHzU,OAAO,CAAC,CAAC;UACT;QACJ;MACJ;MAEA,KAAIvN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiiB,MAAM,EAAEjiB,CAAC,EAAE,EAAE;QACxB4gB,YAAY,CAAChP,MAAM,CAAC5R,CAAC,CAAC,EAAEiP,MAAM,CAACjP,CAAC,CAAC,EAAEkI,KAAK,CAACwD,MAAM,CAAC1L,CAAC,CAAC;QAC9C;QACAtE,GAAG,CAACiF,UAAU,CAAC;UAACqgB,OAAO,EAAE5f,GAAG;UAAE6f,UAAU,EAAEjhB;QAAC,CAAC,EAAE+gB,IAAI,CAAC,CAAC;MAC5D;;MAEA;MACA;MACA;MACA,IAAGiB,YAAY,EAAE;QACb,KAAIhiB,CAAC,GAAGiiB,MAAM,EAAEjiB,CAAC,GAAGoP,MAAM,EAAEpP,CAAC,EAAE,EAAE;UAC7B+hB,gBAAgB,CAACljB,IAAI,CAACmB,CAAC,CAAC;QAC5B;MACJ;IACJ,CAAC,MAAM,IAAG,CAACohB,OAAO,IAAI1lB,GAAG,CAAC+B,aAAa,CAACmU,MAAM,CAAC,EAAE;MAC7CgP,YAAY,CAAChP,MAAM,EAAE3C,MAAM,EAAE/G,KAAK,EAAE6Y,IAAI,CAAC;IAC7C,CAAC,MAAM,IAAGS,cAAc,EAAE;MACtB,IAAGC,QAAQ,IAAIC,QAAQ,EAAE;QACrB;QACA;QACA,IAAG/C,SAAS,EAAE;UACVhR,KAAK,CAACC,IAAI,GAAG,IAAI;QACrB;;QAEA;QACA,IAAG+Q,SAAS,IAAIoC,IAAI,CAAChC,eAAe,EAAE;UAClCxR,OAAO,CAAC,CAAC;QACb;MACJ,CAAC,MAAM,IAAGkU,QAAQ,KAAKC,QAAQ,EAAE;QAC7B/T,KAAK,CAACC,IAAI,GAAG,IAAI;MACrB,CAAC,MAAML,OAAO,CAAC,CAAC;IACpB,CAAC,MAAM,IAAGkU,QAAQ,IAAIC,QAAQ,EAAE;MAC5B;MACA;MACA;MACA;MACA,IAAG9P,MAAM,CAACjT,MAAM,KAAKsQ,MAAM,CAACtQ,MAAM,IAAIwjB,MAAM,CAACvQ,MAAM,CAAC,KAAKuQ,MAAM,CAAClT,MAAM,CAAC,EAAE;QACrE1B,OAAO,CAAC,CAAC;MACb;IACJ,CAAC,MAAM;MACHA,OAAO,CAAC,CAAC;IACb;EACJ;EAEA,KAAInM,GAAG,IAAIsc,YAAY,EAAE;IACrB,IAAG,EAAEtc,GAAG,IAAIyf,YAAY,IAAIzf,GAAG,CAAC0Q,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,OAAO4L,YAAY,CAACtc,GAAG,CAAC,KAAK,UAAU,CAAC,EAAE;MAC3FyQ,SAAS,GAAG4O,YAAY,CAACK,UAAU,CAACpV,MAAM,CAACtK,GAAG,CAAC,CAAC;MAEhD,IAAG+f,uBAAuB,CAACtP,SAAS,CAAC,IAAItT,KAAK,CAACC,OAAO,CAACkf,YAAY,CAACtc,GAAG,CAAC,CAAC,EAAE;QACvEuM,KAAK,CAACC,IAAI,GAAG,IAAI;QACjB;MACJ,CAAC,MAAML,OAAO,CAAC,CAAC;IACpB;EACJ;AACJ;;AAEA;AACA;AACA;AACA,SAASgR,UAAUA,CAACD,SAAS,EAAE8D,SAAS,EAAE;EACtC,IAAIhhB,GAAG;EAEP,KAAIA,GAAG,IAAIkd,SAAS,EAAE;IAClB,IAAGld,GAAG,CAAC0Q,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IAC1B,IAAIF,MAAM,GAAG0M,SAAS,CAACld,GAAG,CAAC;IAC3B,IAAI6N,MAAM,GAAGmT,SAAS,CAAChhB,GAAG,CAAC;IAC3B,IAAGwQ,MAAM,KAAK3C,MAAM,EAAE;MAClB,IAAGvT,GAAG,CAAC+B,aAAa,CAACmU,MAAM,CAAC,IAAIlW,GAAG,CAAC+B,aAAa,CAACwR,MAAM,CAAC,EAAE;QACvD,IAAGsP,UAAU,CAAC3M,MAAM,EAAE3C,MAAM,CAAC,EAAE;UAC3B,OAAO,IAAI;QACf;MACJ,CAAC,MAAM,IAAG1Q,KAAK,CAACC,OAAO,CAACoT,MAAM,CAAC,IAAIrT,KAAK,CAACC,OAAO,CAACyQ,MAAM,CAAC,EAAE;QACtD,IAAG2C,MAAM,CAACjT,MAAM,KAAKsQ,MAAM,CAACtQ,MAAM,EAAE;UAChC,OAAO,IAAI;QACf;QACA,KAAI,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4R,MAAM,CAACjT,MAAM,EAAEqB,CAAC,EAAE,EAAE;UACnC,IAAG4R,MAAM,CAAC5R,CAAC,CAAC,KAAKiP,MAAM,CAACjP,CAAC,CAAC,EAAE;YACxB,IAAGtE,GAAG,CAAC+B,aAAa,CAACmU,MAAM,CAAC5R,CAAC,CAAC,CAAC,IAAItE,GAAG,CAAC+B,aAAa,CAACwR,MAAM,CAACjP,CAAC,CAAC,CAAC,EAAE;cAC7D,IAAGue,UAAU,CAAC3M,MAAM,CAAC5R,CAAC,CAAC,EAAEiP,MAAM,CAACjP,CAAC,CAAC,CAAC,EAAE;gBACjC,OAAO,IAAI;cACf;YACJ,CAAC,MAAM;cACH,OAAO,IAAI;YACf;UACJ;QACJ;MACJ,CAAC,MAAM;QACH,OAAO,IAAI;MACf;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqiB,OAAOA,CAACnlB,EAAE,EAAEolB,2BAA2B,EAAEC,aAAa,EAAE;EAC7DrlB,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAG,CAACxB,GAAG,CAACqC,SAAS,CAACb,EAAE,CAAC,EAAE;IACnB,MAAM,IAAIkL,KAAK,CACX,qCAAqC,GAAGlL,EAAE,GAAG,qCAAqC,GAClF,8DAA8D,GAC9D,2CACJ,CAAC;EACL;EAEA,IAAIslB,KAAK,GAAGtlB,EAAE,CAACwiB,eAAe;;EAE9B;EACA;EACA,IAAG,CAAC8C,KAAK,CAACC,WAAW,EAAE;IACnBD,KAAK,CAACC,WAAW,GAAG,EAAE;EAC1B;EAEAF,aAAa,GAAGvmB,KAAK,CAAC0mB,uBAAuB,CAACH,aAAa,CAAC;EAC5D,IAAII,cAAc,GAAGJ,aAAa,CAAC1D,UAAU;EAC7C,IAAI+D,SAAS,GAAGL,aAAa,CAACM,KAAK;;EAEnC;EACA;EACA;EACA;EACA,IAAGL,KAAK,CAACM,gBAAgB,KAAKle,SAAS,EAAE;IACrC4d,KAAK,CAACM,gBAAgB,GAAG,CAAC;EAC9B;EAEA,SAASC,iBAAiBA,CAAC/iB,CAAC,EAAE;IAC1B,IAAGzB,KAAK,CAACC,OAAO,CAACmkB,cAAc,CAAC,EAAE;MAC9B,IAAG3iB,CAAC,IAAI2iB,cAAc,CAAChkB,MAAM,EAAE;QAC3B,OAAOgkB,cAAc,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM;QACH,OAAOA,cAAc,CAAC3iB,CAAC,CAAC;MAC5B;IACJ,CAAC,MAAM;MACH,OAAO2iB,cAAc;IACzB;EACJ;EAEA,SAASK,YAAYA,CAAChjB,CAAC,EAAE;IACrB,IAAGzB,KAAK,CAACC,OAAO,CAACokB,SAAS,CAAC,EAAE;MACzB,IAAG5iB,CAAC,IAAI4iB,SAAS,CAACjkB,MAAM,EAAE;QACtB,OAAOikB,SAAS,CAAC,CAAC,CAAC;MACvB,CAAC,MAAM;QACH,OAAOA,SAAS,CAAC5iB,CAAC,CAAC;MACvB;IACJ,CAAC,MAAM;MACH,OAAO4iB,SAAS;IACpB;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA,SAASK,iBAAiBA,CAACC,EAAE,EAAEC,CAAC,EAAE;IAC9B,IAAIC,GAAG,GAAG,CAAC;IACX,OAAO,YAAW;MACd,IAAGF,EAAE,IAAI,EAAEE,GAAG,KAAKD,CAAC,EAAE;QAClB,OAAOD,EAAE,CAAC,CAAC;MACf;IACJ,CAAC;EACL;EAEA,OAAO,IAAIrlB,OAAO,CAAC,UAASyH,OAAO,EAAExH,MAAM,EAAE;IACzC,SAASulB,qBAAqBA,CAAA,EAAG;MAC7B,IAAGb,KAAK,CAACC,WAAW,CAAC9jB,MAAM,KAAK,CAAC,EAAE;QAC/B;MACJ;MAEA,OAAM6jB,KAAK,CAACC,WAAW,CAAC9jB,MAAM,EAAE;QAC5B,IAAI2kB,IAAI,GAAGd,KAAK,CAACC,WAAW,CAACvG,GAAG,CAAC,CAAC;QAClC,IAAGoH,IAAI,CAACC,WAAW,EAAE;UACjBD,IAAI,CAACC,WAAW,CAAC,CAAC;QACtB;MACJ;MAEArmB,EAAE,CAACuI,IAAI,CAAC,6BAA6B,EAAE,EAAE,CAAC;IAC9C;IAEA,SAAS+d,WAAWA,CAACC,SAAS,EAAE;MAC5B,IAAGA,SAAS,CAAC9kB,MAAM,KAAK,CAAC,EAAE;MAE3B,KAAI,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyjB,SAAS,CAAC9kB,MAAM,EAAEqB,CAAC,EAAE,EAAE;QACtC,IAAI0jB,aAAa;QAEjB,IAAGD,SAAS,CAACzjB,CAAC,CAAC,CAAC0D,IAAI,KAAK,QAAQ,EAAE;UAC/B;UACAggB,aAAa,GAAG1nB,KAAK,CAAC2nB,YAAY,CAACzmB,EAAE,EAAEumB,SAAS,CAACzjB,CAAC,CAAC,CAACof,IAAI,CAAC;QAC7D,CAAC,MAAM;UACH;UACA;UACAsE,aAAa,GAAGD,SAAS,CAACzjB,CAAC,CAAC,CAAC7C,IAAI;QACrC;QAEA,IAAIylB,SAAS,GAAGI,YAAY,CAAChjB,CAAC,CAAC;QAC/B,IAAI2iB,cAAc,GAAGI,iBAAiB,CAAC/iB,CAAC,CAAC;;QAEzC;QACA;QACA2iB,cAAc,CAACiB,QAAQ,GAAGvhB,IAAI,CAAC6f,GAAG,CAACS,cAAc,CAACiB,QAAQ,EAAEhB,SAAS,CAACgB,QAAQ,CAAC;QAE/E,IAAIC,SAAS,GAAG;UACZhB,KAAK,EAAEa,aAAa;UACpBtE,IAAI,EAAEqE,SAAS,CAACzjB,CAAC,CAAC,CAACof,IAAI;UACvBwD,SAAS,EAAEA,SAAS;UACpBD,cAAc,EAAEA;QACpB,CAAC;QACD,IAAG3iB,CAAC,KAAKyjB,SAAS,CAAC9kB,MAAM,GAAG,CAAC,EAAE;UAC3B;UACA;UACA;UACA;UACA;UACAklB,SAAS,CAACC,UAAU,GAAGb,iBAAiB,CAAC3d,OAAO,EAAE,CAAC,CAAC;UACpDue,SAAS,CAACN,WAAW,GAAGzlB,MAAM;QAClC;QAEA0kB,KAAK,CAACC,WAAW,CAAC5jB,IAAI,CAACglB,SAAS,CAAC;MACrC;;MAEA;MACA;MACA;MACA;MACA,IAAGtB,aAAa,CAACwB,IAAI,KAAK,WAAW,EAAE;QACnCvB,KAAK,CAACwB,YAAY,GAAG,CAACC,QAAQ;MAClC;;MAEA;MACA;MACA;MACA;MACA;MACA,IAAG,CAACzB,KAAK,CAAC0B,aAAa,EAAE;QACrBC,kBAAkB,CAAC,CAAC;MACxB;IACJ;IAEA,SAASC,iBAAiBA,CAAA,EAAG;MACzBlnB,EAAE,CAACuI,IAAI,CAAC,iBAAiB,CAAC;;MAE1B;MACAlF,MAAM,CAAC8jB,oBAAoB,CAAC7B,KAAK,CAAC0B,aAAa,CAAC;MAChD1B,KAAK,CAAC0B,aAAa,GAAG,IAAI;IAC9B;IAEA,SAASL,SAASA,CAAA,EAAG;MACjB,IAAGrB,KAAK,CAAC8B,aAAa,IAAI9B,KAAK,CAAC8B,aAAa,CAACR,UAAU,EAAE;QACtD;QACA;QACAtB,KAAK,CAAC8B,aAAa,CAACR,UAAU,CAAC,CAAC;MACpC;MAEA,IAAIS,QAAQ,GAAG/B,KAAK,CAAC8B,aAAa,GAAG9B,KAAK,CAACC,WAAW,CAAC+B,KAAK,CAAC,CAAC;MAE9D,IAAGD,QAAQ,EAAE;QACT;QACA;QACA;QACA,IAAIE,UAAU,GAAGF,QAAQ,CAACnF,IAAI,GAAGmF,QAAQ,CAACnF,IAAI,CAACsF,QAAQ,CAAC,CAAC,GAAG,IAAI;QAChExnB,EAAE,CAACiC,WAAW,CAACmlB,aAAa,GAAGG,UAAU;QAEzCjC,KAAK,CAACwB,YAAY,GAAGW,IAAI,CAACC,GAAG,CAAC,CAAC;QAC/BpC,KAAK,CAACqC,WAAW,GAAGN,QAAQ,CAAC3B,SAAS,CAACgB,QAAQ;;QAE/C;QACA;QACA;QACA5nB,KAAK,CAAC6iB,UAAU,CAAC3hB,EAAE,EACfqnB,QAAQ,CAAC1B,KAAK,CAAC1lB,IAAI,EACnBonB,QAAQ,CAAC1B,KAAK,CAACzlB,MAAM,EACrBT,OAAO,CAAC6Q,kBAAkB,CAACtQ,EAAE,EAAEqnB,QAAQ,CAAC1B,KAAK,CAACxZ,MAAM,CAAC,EACrDkb,QAAQ,CAAC3B,SAAS,EAClB2B,QAAQ,CAAC5B,cACb,CAAC,CAAC7d,IAAI,CAAC,YAAW;UACd,IAAGyf,QAAQ,CAACT,UAAU,EAAE;YACpBS,QAAQ,CAACT,UAAU,CAAC,CAAC;UACzB;QACJ,CAAC,CAAC;QAEF5mB,EAAE,CAACuI,IAAI,CAAC,uBAAuB,EAAE;UAC7B2Z,IAAI,EAAEqF,UAAU;UAChB5B,KAAK,EAAE0B,QAAQ,CAAC1B,KAAK;UACrBiC,SAAS,EAAE;YACPjC,KAAK,EAAE0B,QAAQ,CAAC3B,SAAS;YACzB/D,UAAU,EAAE0F,QAAQ,CAAC5B;UACzB;QACJ,CAAC,CAAC;MACN,CAAC,MAAM;QACH;QACAyB,iBAAiB,CAAC,CAAC;MACvB;IACJ;IAEA,SAASD,kBAAkBA,CAAA,EAAG;MAC1BjnB,EAAE,CAACuI,IAAI,CAAC,kBAAkB,CAAC;;MAE3B;MACA;MACA+c,KAAK,CAACwB,YAAY,GAAG,CAACC,QAAQ;MAC9BzB,KAAK,CAACqC,WAAW,GAAG,CAAC;MACrBrC,KAAK,CAACuC,mBAAmB,GAAG,CAAC;MAC7BvC,KAAK,CAAC8B,aAAa,GAAG,IAAI;MAE1B,IAAIU,OAAO,GAAG,SAAAA,CAAA,EAAW;QACrB;QACA;QACAxC,KAAK,CAAC0B,aAAa,GAAG3jB,MAAM,CAAC0kB,qBAAqB,CAACD,OAAO,CAAC;;QAE3D;QACA,IAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGpC,KAAK,CAACwB,YAAY,GAAGxB,KAAK,CAACqC,WAAW,EAAE;UACpDhB,SAAS,CAAC,CAAC;QACf;MACJ,CAAC;MAEDmB,OAAO,CAAC,CAAC;IACb;;IAEA;IACA;IACA,IAAIE,aAAa,GAAG,CAAC;IACrB,SAASC,mBAAmBA,CAACtC,KAAK,EAAE;MAChC,IAAGtkB,KAAK,CAACC,OAAO,CAACmkB,cAAc,CAAC,EAAE;QAC9B,IAAGuC,aAAa,IAAIvC,cAAc,CAAChkB,MAAM,EAAE;UACvCkkB,KAAK,CAACF,cAAc,GAAGA,cAAc,CAACuC,aAAa,CAAC;QACxD,CAAC,MAAM;UACHrC,KAAK,CAACF,cAAc,GAAGA,cAAc,CAAC,CAAC,CAAC;QAC5C;MACJ,CAAC,MAAM;QACHE,KAAK,CAACF,cAAc,GAAGA,cAAc;MACzC;MACAuC,aAAa,EAAE;MACf,OAAOrC,KAAK;IAChB;;IAEA;IACA,IAAI7iB,CAAC,EAAE6iB,KAAK;IACZ,IAAIY,SAAS,GAAG,EAAE;IAClB,IAAI2B,SAAS,GAAG9C,2BAA2B,KAAK1d,SAAS,IAAI0d,2BAA2B,KAAK,IAAI;IACjG,IAAI+C,YAAY,GAAG9mB,KAAK,CAACC,OAAO,CAAC8jB,2BAA2B,CAAC;IAC7D,IAAIgD,aAAa,GAAG,CAACF,SAAS,IAAI,CAACC,YAAY,IAAI3pB,GAAG,CAAC+B,aAAa,CAAC6kB,2BAA2B,CAAC;IAEjG,IAAGgD,aAAa,EAAE;MACd;MACA7B,SAAS,CAAC5kB,IAAI,CAAC;QACX6E,IAAI,EAAE,QAAQ;QACdvG,IAAI,EAAEgoB,mBAAmB,CAACzpB,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAE2hB,2BAA2B,CAAC;MAC7E,CAAC,CAAC;IACN,CAAC,MAAM,IAAG8C,SAAS,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAACpc,OAAO,CAAC,OAAOsZ,2BAA2B,CAAC,KAAK,CAAC,CAAC,EAAE;MAC5F;MACA;MACA,KAAItiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwiB,KAAK,CAAC+C,OAAO,CAAC5mB,MAAM,EAAEqB,CAAC,EAAE,EAAE;QACtC6iB,KAAK,GAAGL,KAAK,CAAC+C,OAAO,CAACvlB,CAAC,CAAC;QAExB,IAAG,CAAC6iB,KAAK,EAAE;QAEX,IAAGuC,SAAS,IAAIjD,MAAM,CAACU,KAAK,CAAC1I,KAAK,CAAC,KAAKgI,MAAM,CAACG,2BAA2B,CAAC,EAAE;UACzEmB,SAAS,CAAC5kB,IAAI,CAAC;YACX6E,IAAI,EAAE,QAAQ;YACd0b,IAAI,EAAE+C,MAAM,CAACU,KAAK,CAACzD,IAAI,CAAC;YACxBjiB,IAAI,EAAEgoB,mBAAmB,CAAC;cAAC/F,IAAI,EAAEyD,KAAK,CAACzD;YAAI,CAAC;UAChD,CAAC,CAAC;QACN;MACJ;IACJ,CAAC,MAAM,IAAGiG,YAAY,EAAE;MACpB,KAAIrlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsiB,2BAA2B,CAAC3jB,MAAM,EAAEqB,CAAC,EAAE,EAAE;QACpD,IAAIwlB,WAAW,GAAGlD,2BAA2B,CAACtiB,CAAC,CAAC;QAChD,IAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAACgJ,OAAO,CAAC,OAAOwc,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE;UACxDA,WAAW,GAAGrD,MAAM,CAACqD,WAAW,CAAC;UACjC;UACA/B,SAAS,CAAC5kB,IAAI,CAAC;YACX6E,IAAI,EAAE,QAAQ;YACd0b,IAAI,EAAEoG,WAAW;YACjBroB,IAAI,EAAEgoB,mBAAmB,CAAC;cAAC/F,IAAI,EAAEoG;YAAW,CAAC;UACjD,CAAC,CAAC;QACN,CAAC,MAAM,IAAG9pB,GAAG,CAAC+B,aAAa,CAAC+nB,WAAW,CAAC,EAAE;UACtC/B,SAAS,CAAC5kB,IAAI,CAAC;YACX6E,IAAI,EAAE,QAAQ;YACdvG,IAAI,EAAEgoB,mBAAmB,CAACzpB,GAAG,CAACiF,UAAU,CAAC,CAAC,CAAC,EAAE6kB,WAAW,CAAC;UAC7D,CAAC,CAAC;QACN;MACJ;IACJ;;IAEA;IACA,KAAIxlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyjB,SAAS,CAAC9kB,MAAM,EAAEqB,CAAC,EAAE,EAAE;MAClC6iB,KAAK,GAAGY,SAAS,CAACzjB,CAAC,CAAC;MACpB,IAAG6iB,KAAK,CAACnf,IAAI,KAAK,QAAQ,IAAI,CAAC8e,KAAK,CAACiD,UAAU,CAAC5C,KAAK,CAAC1lB,IAAI,CAACiiB,IAAI,CAAC,EAAE;QAC9D1jB,GAAG,CAACsC,IAAI,CAAC,qCAAqC,GAAG6kB,KAAK,CAAC1lB,IAAI,CAACiiB,IAAI,GAAG,GAAG,CAAC;QACvEthB,MAAM,CAAC,CAAC;QACR;MACJ;IACJ;;IAEA;IACA;IACA,IAAG,CAAC,MAAM,EAAE,WAAW,CAAC,CAACkL,OAAO,CAACuZ,aAAa,CAACwB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MACzDV,qBAAqB,CAAC,CAAC;IAC3B;IAEA,IAAGd,aAAa,CAACmD,SAAS,KAAK,SAAS,EAAE;MACtCjC,SAAS,CAACzJ,OAAO,CAAC,CAAC;IACvB;IAEA,IAAI2L,YAAY,GAAGzoB,EAAE,CAACiC,WAAW,CAACmlB,aAAa;IAC/C,IAAGqB,YAAY,IAAIpD,aAAa,CAACqD,WAAW,EAAE;MAC1C,IAAIC,GAAG,GAAG,CAAC,CAAC;MACZ,KAAI7lB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyjB,SAAS,CAAC9kB,MAAM,EAAEqB,CAAC,EAAE,EAAE;QAClC6iB,KAAK,GAAGY,SAAS,CAACzjB,CAAC,CAAC;QACpB,IAAG6iB,KAAK,CAACnf,IAAI,KAAK,QAAQ,IAAImf,KAAK,CAACzD,IAAI,KAAKuG,YAAY,EAAE;UACvDE,GAAG,GAAG7lB,CAAC;UACP;QACJ;MACJ;MAEA,IAAG6lB,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAGpC,SAAS,CAAC9kB,MAAM,GAAG,CAAC,EAAE;QACtC,IAAImnB,iBAAiB,GAAG,EAAE;QAC1B,KAAI9lB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyjB,SAAS,CAAC9kB,MAAM,EAAEqB,CAAC,EAAE,EAAE;UAClC6iB,KAAK,GAAGY,SAAS,CAACzjB,CAAC,CAAC;UACpB,IAAGyjB,SAAS,CAACzjB,CAAC,CAAC,CAAC0D,IAAI,KAAK,QAAQ,IAAI1D,CAAC,GAAG6lB,GAAG,EAAE;YAC1CC,iBAAiB,CAACjnB,IAAI,CAACgkB,KAAK,CAAC;UACjC;QACJ;QACAY,SAAS,GAAGqC,iBAAiB;MACjC;IACJ;IAEA,IAAGrC,SAAS,CAAC9kB,MAAM,GAAG,CAAC,EAAE;MACrB6kB,WAAW,CAACC,SAAS,CAAC;IAC1B,CAAC,MAAM;MACH;MACA;MACAvmB,EAAE,CAACuI,IAAI,CAAC,iBAAiB,CAAC;MAC1BH,OAAO,CAAC,CAAC;IACb;EACJ,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrH,SAASA,CAACf,EAAE,EAAEumB,SAAS,EAAEjb,OAAO,EAAE;EACvCtL,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAGumB,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK7e,SAAS,EAAE;IAC9C,OAAO/G,OAAO,CAACyH,OAAO,CAAC,CAAC;EAC5B;EAEA,IAAG,CAAC5J,GAAG,CAACqC,SAAS,CAACb,EAAE,CAAC,EAAE;IACnB,MAAM,IAAIkL,KAAK,CACX,qCAAqC,GAAGlL,EAAE,GAAG,qCAAqC,GAClF,+DAA+D,GAC/D,2CACJ,CAAC;EACL;EAEA,IAAI8C,CAAC,EAAE6iB,KAAK,EAAE5Y,CAAC,EAAE4b,GAAG;EACpB,IAAIN,OAAO,GAAGroB,EAAE,CAACwiB,eAAe,CAAC6F,OAAO;EACxC,IAAIE,UAAU,GAAGvoB,EAAE,CAACwiB,eAAe,CAAC+F,UAAU;EAG9C,IAAG,CAAClnB,KAAK,CAACC,OAAO,CAACilB,SAAS,CAAC,EAAE;IAC1B,MAAM,IAAIrb,KAAK,CAAC,oEAAoE,GAAGqb,SAAS,CAAC;EACrG;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAIsC,QAAQ,GAAGR,OAAO,CAAC5mB,MAAM,GAAG8kB,SAAS,CAAC9kB,MAAM,GAAG,CAAC;EAEpD,IAAIqnB,UAAU,GAAG,EAAE;EACnB,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,KAAIjmB,CAAC,GAAGyjB,SAAS,CAAC9kB,MAAM,GAAG,CAAC,EAAEqB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACvC,IAAG,CAACtE,GAAG,CAAC+B,aAAa,CAACgmB,SAAS,CAACzjB,CAAC,CAAC,CAAC,EAAE;;IAErC;IACA;IACA,IAAIkmB,UAAU,GAAGzC,SAAS,CAACzjB,CAAC,CAAC,CAACof,IAAI;IAClC,IAAIA,IAAI,GAAG,CAACqG,UAAU,CAACS,UAAU,CAAC,IAAID,eAAe,CAACC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE9G,IAAI;IAC7E,IAAI+G,OAAO,GAAG1C,SAAS,CAACzjB,CAAC,CAAC,CAACof,IAAI;IAC/B,IAAIgH,gBAAgB,GAAGX,UAAU,CAACrG,IAAI,CAAC,IAAI6G,eAAe,CAAC7G,IAAI,CAAC;IAEhE,IAAGA,IAAI,IAAI+G,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIC,gBAAgB,IAAIrpB,uBAAuB,GAAGC,4BAA4B,EAAE;MAC7HD,uBAAuB,EAAE;MAEzBrB,GAAG,CAACsC,IAAI,CAAC,gCAAgC,GAAG,CAACynB,UAAU,CAACrG,IAAI,CAAC,IAAI6G,eAAe,CAAC7G,IAAI,CAAC,EAAEA,IAAI,GACxF,8DAA8D,GAC9DA,IAAI,GAAG,0DAA0D,GACjE,iEAAiE,GACjE,aAAa,CAAC;MAElB,IAAGriB,uBAAuB,KAAKC,4BAA4B,EAAE;QACzDtB,GAAG,CAACsC,IAAI,CAAC,mEAAmE,GACxE,kEAAkE,GAClE,2BAA2B,CAAC;MACpC;IACJ;IAEAioB,eAAe,CAACC,UAAU,CAAC,GAAG;MAAC9G,IAAI,EAAE8G;IAAU,CAAC;IAEhDF,UAAU,CAACnnB,IAAI,CAAC;MACZgkB,KAAK,EAAE7mB,KAAK,CAACqqB,mBAAmB,CAAC5C,SAAS,CAACzjB,CAAC,CAAC,CAAC;MAC9C4I,KAAK,EAAGJ,OAAO,IAAIA,OAAO,CAACxI,CAAC,CAAC,KAAK4E,SAAS,IAAI4D,OAAO,CAACxI,CAAC,CAAC,KAAK,IAAI,GAAIwI,OAAO,CAACxI,CAAC,CAAC,GAAG+lB,QAAQ,GAAG/lB;IAClG,CAAC,CAAC;EACN;;EAEA;EACAgmB,UAAU,CAACrZ,IAAI,CAAC,UAASK,CAAC,EAAEC,CAAC,EAAE;IAC3B,IAAGD,CAAC,CAACpE,KAAK,GAAGqE,CAAC,CAACrE,KAAK,EAAE,OAAO,CAAC,CAAC;IAC/B,IAAGoE,CAAC,CAACpE,KAAK,GAAGqE,CAAC,CAACrE,KAAK,EAAE,OAAO,CAAC;IAC9B,OAAO,CAAC;EACZ,CAAC,CAAC;EAEF,IAAI0d,GAAG,GAAG,EAAE;EACZ,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,UAAU,GAAGjB,OAAO,CAAC5mB,MAAM;EAE/B,KAAIqB,CAAC,GAAGgmB,UAAU,CAACrnB,MAAM,GAAG,CAAC,EAAEqB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxC6iB,KAAK,GAAGmD,UAAU,CAAChmB,CAAC,CAAC,CAAC6iB,KAAK;IAE3B,IAAG,OAAOA,KAAK,CAACzD,IAAI,KAAK,QAAQ,EAAE;MAC/B1jB,GAAG,CAACsC,IAAI,CAAC,2EAA2E,GAChF,4BAA4B,CAAC;IACrC;IAEA,IAAG,CAAC6kB,KAAK,CAACzD,IAAI,EAAE;MACZ;MACA;MACA,OAAMqG,UAAU,CAAE5C,KAAK,CAACzD,IAAI,GAAG,QAAQ,GAAGliB,EAAE,CAACwiB,eAAe,CAAC+G,QAAQ,EAAE,CAAE,CAAC;IAC9E;IAEA,IAAGhB,UAAU,CAAC5C,KAAK,CAACzD,IAAI,CAAC,EAAE;MACvB;MACA,KAAInV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsb,OAAO,CAAC5mB,MAAM,EAAEsL,CAAC,EAAE,EAAE;QAChC,IAAG,CAACsb,OAAO,CAACtb,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEmV,IAAI,KAAKyD,KAAK,CAACzD,IAAI,EAAE;MAC/C;MACAkH,GAAG,CAACznB,IAAI,CAAC;QAAC6E,IAAI,EAAE,SAAS;QAAEkF,KAAK,EAAEqB,CAAC;QAAEX,KAAK,EAAEuZ;MAAK,CAAC,CAAC;MACnD0D,MAAM,CAACG,OAAO,CAAC;QAAChjB,IAAI,EAAE,SAAS;QAAEkF,KAAK,EAAEqB,CAAC;QAAEX,KAAK,EAAEic,OAAO,CAACtb,CAAC;MAAC,CAAC,CAAC;IAClE,CAAC,MAAM;MACH;MACA4b,GAAG,GAAGxjB,IAAI,CAACgN,GAAG,CAAC,CAAC,EAAEhN,IAAI,CAAC6f,GAAG,CAAC8D,UAAU,CAAChmB,CAAC,CAAC,CAAC4I,KAAK,EAAE4d,UAAU,CAAC,CAAC;MAE5DF,GAAG,CAACznB,IAAI,CAAC;QAAC6E,IAAI,EAAE,QAAQ;QAAEkF,KAAK,EAAEid,GAAG;QAAEvc,KAAK,EAAEuZ;MAAK,CAAC,CAAC;MACpD0D,MAAM,CAACG,OAAO,CAAC;QAAChjB,IAAI,EAAE,QAAQ;QAAEkF,KAAK,EAAEid;MAAG,CAAC,CAAC;MAC5CW,UAAU,EAAE;IAChB;EACJ;EAEA,IAAIra,QAAQ,GAAGnQ,KAAK,CAAC2qB,YAAY;EACjC,IAAIta,QAAQ,GAAGrQ,KAAK,CAAC2qB,YAAY;EACjC,IAAI7a,QAAQ,GAAG,CAAC5O,EAAE,EAAEqpB,MAAM,CAAC;EAC3B,IAAIja,QAAQ,GAAG,CAACpP,EAAE,EAAEopB,GAAG,CAAC;EAExB,IAAGzqB,KAAK,EAAEA,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEiP,QAAQ,EAAEL,QAAQ,EAAEO,QAAQ,EAAEC,QAAQ,CAAC;EAE/D,OAAOtQ,KAAK,CAAC2qB,YAAY,CAACzpB,EAAE,EAAEopB,GAAG,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,YAAYA,CAAC1pB,EAAE,EAAEumB,SAAS,EAAE;EACjCvmB,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAG,CAACxB,GAAG,CAACqC,SAAS,CAACb,EAAE,CAAC,EAAE;IACnB,MAAM,IAAIkL,KAAK,CAAC,qCAAqC,GAAGlL,EAAE,CAAC;EAC/D;EAEA,IAAI8C,CAAC,EAAE6lB,GAAG;EACV,IAAIN,OAAO,GAAGroB,EAAE,CAACwiB,eAAe,CAAC6F,OAAO;EACxC,IAAIe,GAAG,GAAG,EAAE;EACZ,IAAIC,MAAM,GAAG,EAAE;EAEf,IAAG,CAAC9C,SAAS,EAAE;IACXA,SAAS,GAAG,EAAE;IACd,KAAIzjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGulB,OAAO,CAAC5mB,MAAM,EAAEqB,CAAC,EAAE,EAAE;MAChCyjB,SAAS,CAAC5kB,IAAI,CAACmB,CAAC,CAAC;IACrB;EACJ;EAEAyjB,SAAS,GAAGA,SAAS,CAACvN,KAAK,CAAC,CAAC;EAC7BuN,SAAS,CAAC9W,IAAI,CAAC,CAAC;EAEhB,KAAI3M,CAAC,GAAGyjB,SAAS,CAAC9kB,MAAM,GAAG,CAAC,EAAEqB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACvC6lB,GAAG,GAAGpC,SAAS,CAACzjB,CAAC,CAAC;IAClBsmB,GAAG,CAACznB,IAAI,CAAC;MAAC6E,IAAI,EAAE,QAAQ;MAAEkF,KAAK,EAAEid;IAAG,CAAC,CAAC;IACtCU,MAAM,CAACG,OAAO,CAAC;MAAChjB,IAAI,EAAE,QAAQ;MAAEkF,KAAK,EAAEid,GAAG;MAAEvc,KAAK,EAAEic,OAAO,CAACM,GAAG;IAAC,CAAC,CAAC;EACrE;EAEA,IAAI1Z,QAAQ,GAAGnQ,KAAK,CAAC2qB,YAAY;EACjC,IAAIta,QAAQ,GAAGrQ,KAAK,CAAC2qB,YAAY;EACjC,IAAI7a,QAAQ,GAAG,CAAC5O,EAAE,EAAEqpB,MAAM,CAAC;EAC3B,IAAIja,QAAQ,GAAG,CAACpP,EAAE,EAAEopB,GAAG,CAAC;EAExB,IAAGzqB,KAAK,EAAEA,KAAK,CAACkQ,GAAG,CAAC7O,EAAE,EAAEiP,QAAQ,EAAEL,QAAQ,EAAEO,QAAQ,EAAEC,QAAQ,CAAC;EAE/D,OAAOtQ,KAAK,CAAC2qB,YAAY,CAACzpB,EAAE,EAAEopB,GAAG,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShe,KAAKA,CAACpL,EAAE,EAAE;EACfA,EAAE,GAAGxB,GAAG,CAAC6B,WAAW,CAACL,EAAE,CAAC;EAExB,IAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW,IAAI,CAAC,CAAC;EACrC,IAAIsE,QAAQ,GAAGvG,EAAE,CAAC4C,SAAS,IAAI,EAAE;;EAEjC;EACA9D,KAAK,CAAC6G,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,EAAEY,QAAQ,EAAEvE,UAAU,CAAC;;EAE7C;EACAlD,KAAK,CAACsM,KAAK,CAACpL,EAAE,CAAC;;EAEf;EACAtB,MAAM,CAAC0M,KAAK,CAACpL,EAAE,CAAC;;EAEhB;EACA,IAAGgC,UAAU,CAAC2nB,UAAU,EAAE3nB,UAAU,CAAC2nB,UAAU,CAAC1T,MAAM,CAAC,CAAC;;EAExD;EACA,OAAOjW,EAAE,CAACgD,QAAQ;EAElB,OAAOhD,EAAE;AACb;;AAEA;AACA,SAAS4pB,oBAAoBA,CAAC5pB,EAAE,EAAE;EAC9B,IAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAE/B,IAAI4nB,OAAO,GAAG7pB,EAAE,CAAC8pB,qBAAqB,CAAC,CAAC;EACxC,IAAGtrB,GAAG,CAACurB,aAAa,CAACF,OAAO,EAAE7nB,UAAU,CAACgoB,SAAS,CAAC,EAAE;EAErD,IAAIC,CAAC,GAAGjoB,UAAU,CAACkoB,aAAa,GAAG1rB,GAAG,CAAC2rB,sBAAsB,CAAC3rB,GAAG,CAAC4rB,sBAAsB,CAACpqB,EAAE,CAAC,CAAC;EAC7FgC,UAAU,CAACqoB,UAAU,GAAGllB,IAAI,CAACmlB,IAAI,CAACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC5FjoB,UAAU,CAACuoB,UAAU,GAAGplB,IAAI,CAACmlB,IAAI,CAACL,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC5FjoB,UAAU,CAACgoB,SAAS,GAAGH,OAAO;AAClC;;AAEA;AACA;AACA;AACA,SAASvnB,iBAAiBA,CAACtC,EAAE,EAAE;EAC3B,IAAIwqB,GAAG,GAAGpsB,EAAE,CAAC8C,MAAM,CAAClB,EAAE,CAAC;EACvB,IAAIgC,UAAU,GAAGhC,EAAE,CAACiC,WAAW;EAE/BD,UAAU,CAACyoB,qBAAqB,GAAGb,oBAAoB;EACvD5nB,UAAU,CAACyoB,qBAAqB,CAACzqB,EAAE,CAAC;;EAEpC;EACAgC,UAAU,CAAC2nB,UAAU,GAAGa,GAAG,CAACvmB,SAAS,CAAC,iBAAiB,CAAC,CAAChE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAClE+B,UAAU,CAAC2nB,UAAU,CAACrlB,KAAK,CAAC,CAAC,CACxBuI,MAAM,CAAC,KAAK,EAAE,cAAc,CAAC,CAC7B1L,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAC/BA,OAAO,CAAC,QAAQ,EAAE,IAAI;EACvB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAAA,CACCuD,KAAK,CAAC;IACHM,KAAK,EAAE,MAAM;IACbC,MAAM,EAAE;EACZ,CAAC,CAAC;;EAEN;EACAjD,UAAU,CAAC0oB,SAAS,GAAG1oB,UAAU,CAAC2nB,UAAU,CAAC1lB,SAAS,CAAC,gBAAgB,CAAC,CAAChE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAClF+B,UAAU,CAAC0oB,SAAS,CAACpmB,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,KAAK,CAAC,CACrCpD,OAAO,CAAC,kBAAkB,EAAE,IAAI,CAAC,CACjCA,OAAO,CAAC,eAAe,EAAE,IAAI,CAAC,CAC9BuD,KAAK,CAAC,UAAU,EAAE,UAAU,CAAC;;EAElC;EACA;EACA;EACA;EACA;EACA;EACA1C,UAAU,CAACgC,YAAY,GAAGhC,UAAU,CAAC0oB,SAAS,CAACzmB,SAAS,CAAC,eAAe,CAAC,CACpEhE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAEf+B,UAAU,CAACgC,YAAY,CAACM,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,KAAK,CAAC,CACxCpD,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;EAElCa,UAAU,CAAC0oB,SAAS,CAACzmB,SAAS,CAAC,WAAW,CAAC,CAACgS,MAAM,CAAC,CAAC;EACpDjU,UAAU,CAAC0oB,SAAS,CAACxpB,MAAM,CAAC,oBAAoB,CAAC,CAAC+U,MAAM,CAAC,CAAC;EAE1DjU,UAAU,CAAC2G,MAAM,GAAG3G,UAAU,CAAC0oB,SAAS,CAAC7d,MAAM,CAAC,KAAK,EAAE,cAAc,CAAC,CACjE1L,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;EAE9Ba,UAAU,CAAC2oB,SAAS,GAAG3oB,UAAU,CAAC0oB,SAAS,CAACnmB,MAAM,CAAC,KAAK,CAAC,CACpDpD,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;EAE9Ba,UAAU,CAAC8D,WAAW,GAAG9D,UAAU,CAAC0oB,SAAS,CAACnmB,MAAM,CAAC,KAAK,CAAC;EAC3D,OAAOvC,UAAU,CAAC4oB,QAAQ;EAE1B5oB,UAAU,CAAC6oB,WAAW,GAAG7oB,UAAU,CAAC0oB,SAAS,CAACnmB,MAAM,CAAC,KAAK,CAAC,CACtDpD,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;EAE9B,IAAG,CAACa,UAAU,CAAC8oB,IAAI,EAAE;IACjB,IAAIC,SAAS,GAAG,CAAC,CAAC;IAClB3sB,EAAE,CAAC6F,SAAS,CAAC,MAAM,CAAC,CAAC+mB,IAAI,CAAC,YAAW;MACjC,IAAG,IAAI,CAAC7R,EAAE,EAAE4R,SAAS,CAAC,IAAI,CAAC5R,EAAE,CAAC7P,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IACpD,CAAC,CAAC;IACFtH,UAAU,CAAC8oB,IAAI,GAAGtsB,GAAG,CAACysB,OAAO,CAACF,SAAS,CAAC;EAC5C;EAEA/oB,UAAU,CAAC0oB,SAAS,CAACzmB,SAAS,CAAC,WAAW,CAAC,CACtCO,IAAI,CAACnF,eAAe,CAAC6rB,QAAQ,CAAC;EAEnClpB,UAAU,CAACmpB,KAAK,GAAGnpB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,MAAM,CAAC,CAC9CC,IAAI,CAAC,IAAI,EAAE,OAAO,GAAGxC,UAAU,CAAC8oB,IAAI,CAAC;EAE1C9oB,UAAU,CAACopB,MAAM,GAAGppB,UAAU,CAACmpB,KAAK,CAAC5mB,MAAM,CAAC,GAAG,CAAC,CAC3CpD,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC;EAE3Ba,UAAU,CAACqpB,QAAQ,GAAGrpB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,MAAM,CAAC,CACpDC,IAAI,CAAC,IAAI,EAAE,UAAU,GAAGxC,UAAU,CAAC8oB,IAAI,CAAC;EAE7C9oB,UAAU,CAACspB,SAAS,GAAGtpB,UAAU,CAACqpB,QAAQ,CAAC9mB,MAAM,CAAC,GAAG,CAAC,CACjDpD,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC;EAE3Ba,UAAU,CAACupB,QAAQ,GAAGvpB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAC9CpD,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC;EAE7Ba,UAAU,CAACwpB,SAAS,GAAGxpB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAC/CpD,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC;;EAE/B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIsqB,UAAU,GAAGzpB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CACzCpD,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC;EACjCa,UAAU,CAAC0pB,gBAAgB,GAAGD,UAAU,CAAClnB,MAAM,CAAC,GAAG,CAAC,CAC/CpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;EAChCa,UAAU,CAAC2pB,gBAAgB,GAAGF,UAAU,CAAClnB,MAAM,CAAC,GAAG,CAAC,CAC/CpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;;EAEhC;EACAa,UAAU,CAAC4pB,eAAe,GAAG5pB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;;EAE1F;EACAa,UAAU,CAAC6pB,WAAW,GAAG7pB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;;EAElF;EACAa,UAAU,CAAC8pB,WAAW,GAAG9pB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;;EAElF;EACAa,UAAU,CAAC+pB,aAAa,GAAG/pB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;;EAEtF;EACAa,UAAU,CAACgqB,SAAS,GAAGhqB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;;EAE9E;EACAa,UAAU,CAACiqB,gBAAgB,GAAGjqB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,iBAAiB,EAAE,IAAI,CAAC;;EAE5F;EACAa,UAAU,CAACgU,SAAS,GAAGhU,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;;EAE9E;EACAa,UAAU,CAACkqB,YAAY,GAAGlqB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC;;EAEpF;EACAa,UAAU,CAACmqB,aAAa,GAAGnqB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;;EAEtF;EACAa,UAAU,CAACoqB,cAAc,GAAGpqB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,eAAe,EAAE,IAAI,CAAC;;EAExF;EACAa,UAAU,CAACqqB,eAAe,GAAGrqB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;;EAE7F;EACAa,UAAU,CAACsqB,SAAS,GAAGtqB,UAAU,CAAC2G,MAAM,CAACpE,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;;EAE9E;EACA;EACA;EACA;EACA,IAAIorB,UAAU,GAAGvqB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,GAAG,CAAC,CAC5CpD,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC;EACjCa,UAAU,CAACwqB,gBAAgB,GAAGD,UAAU,CAAChoB,MAAM,CAAC,GAAG,CAAC,CAC/CpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;EAChCa,UAAU,CAACyqB,gBAAgB,GAAGF,UAAU,CAAChoB,MAAM,CAAC,GAAG,CAAC,CAC/CpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;EAEhCa,UAAU,CAAC0qB,eAAe,GAAG1qB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;EAC7Fa,UAAU,CAAC2qB,UAAU,GAAG3qB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC;EACnFa,UAAU,CAAC4qB,UAAU,GAAG5qB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC;EACnFa,UAAU,CAAC6qB,UAAU,GAAG7qB,UAAU,CAAC2oB,SAAS,CAACpmB,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC;EACnFa,UAAU,CAAC8qB,WAAW,GAAG9qB,UAAU,CAAC6oB,WAAW,CAACtmB,MAAM,CAAC,GAAG,CAAC,CAACpD,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC;;EAEvF;EACAa,UAAU,CAAC8D,WAAW,CACjB3E,OAAO,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAClCuD,KAAK,CAAC,UAAU,EAAE,UAAU,CAAC,CAC7BA,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CACnBA,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC;EAE1B1E,EAAE,CAACuI,IAAI,CAAC,kBAAkB,CAAC;AAC/B;AAEAvH,OAAO,CAACmkB,OAAO,GAAGA,OAAO;AACzBnkB,OAAO,CAACD,SAAS,GAAGA,SAAS;AAC7BC,OAAO,CAAC0oB,YAAY,GAAGA,YAAY;AAEnC1oB,OAAO,CAACgO,SAAS,GAAGA,SAAS;AAC7BhO,OAAO,CAACkO,YAAY,GAAGA,YAAY;AACnClO,OAAO,CAAC8M,YAAY,GAAGA,YAAY;AACnC9M,OAAO,CAACsO,UAAU,GAAGA,UAAU;AAC/BtO,OAAO,CAAC8N,aAAa,GAAGA,aAAa;AAErC9N,OAAO,CAACmK,OAAO,GAAGA,OAAO;AACzBnK,OAAO,CAACjB,OAAO,GAAGA,OAAO;AACzBiB,OAAO,CAACoK,KAAK,GAAGA,KAAK;AAErBpK,OAAO,CAACkgB,KAAK,GAAGA,KAAK;AACrBlgB,OAAO,CAACiK,MAAM,GAAGA,MAAM;AACvBjK,OAAO,CAAC2G,QAAQ,GAAGA,QAAQ;AAC3B3G,OAAO,CAACgP,OAAO,GAAGA,OAAO;AAEzBhP,OAAO,CAACwH,aAAa,GAAGA,aAAa;AAErCxH,OAAO,CAACsL,MAAM,GAAGA,MAAM;AAEvBtL,OAAO,CAAC+rB,YAAY,GAAG7O,OAAO,CAACvW,QAAQ,CAAC;AACxC3G,OAAO,CAACgsB,WAAW,GAAG9O,OAAO,CAAClO,OAAO,CAAC;AACtChP,OAAO,CAACisB,UAAU,GAAG/O,OAAO,CAAC5R,MAAM,CAAC;AAEpCtL,OAAO,CAACuR,mBAAmB,GAAGA,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script"}