{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar partition = require('./partition');\nvar styleOne = require('./style').styleOne;\nvar constants = require('./constants');\nvar helpers = require('../sunburst/helpers');\nvar attachFxHandlers = require('../sunburst/fx');\nvar formatSliceLabel = require('../sunburst/plot').formatSliceLabel;\nvar onPathbar = false; // for Descendants\n\nmodule.exports = function drawDescendants(gd, cd, entry, slices, opts) {\n  var width = opts.width;\n  var height = opts.height;\n  var viewX = opts.viewX;\n  var viewY = opts.viewY;\n  var pathSlice = opts.pathSlice;\n  var toMoveInsideSlice = opts.toMoveInsideSlice;\n  var strTransform = opts.strTransform;\n  var hasTransition = opts.hasTransition;\n  var handleSlicesExit = opts.handleSlicesExit;\n  var makeUpdateSliceInterpolator = opts.makeUpdateSliceInterpolator;\n  var makeUpdateTextInterpolator = opts.makeUpdateTextInterpolator;\n  var prevEntry = opts.prevEntry;\n  var refRect = {};\n  var isStatic = gd._context.staticPlot;\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hasLeft = trace.textposition.indexOf('left') !== -1;\n  var hasRight = trace.textposition.indexOf('right') !== -1;\n  var hasBottom = trace.textposition.indexOf('bottom') !== -1;\n  var noRoomForHeader = !hasBottom && !trace.marker.pad.t || hasBottom && !trace.marker.pad.b;\n\n  // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n  var allData = partition(entry, [width, height], {\n    packing: trace.tiling.packing,\n    squarifyratio: trace.tiling.squarifyratio,\n    flipX: trace.tiling.flip.indexOf('x') > -1,\n    flipY: trace.tiling.flip.indexOf('y') > -1,\n    pad: {\n      inner: trace.tiling.pad,\n      top: trace.marker.pad.t,\n      left: trace.marker.pad.l,\n      right: trace.marker.pad.r,\n      bottom: trace.marker.pad.b\n    }\n  });\n  var sliceData = allData.descendants();\n  var minVisibleDepth = Infinity;\n  var maxVisibleDepth = -Infinity;\n  sliceData.forEach(function (pt) {\n    var depth = pt.depth;\n    if (depth >= trace._maxDepth) {\n      // hide slices that won't show up on graph\n      pt.x0 = pt.x1 = (pt.x0 + pt.x1) / 2;\n      pt.y0 = pt.y1 = (pt.y0 + pt.y1) / 2;\n    } else {\n      minVisibleDepth = Math.min(minVisibleDepth, depth);\n      maxVisibleDepth = Math.max(maxVisibleDepth, depth);\n    }\n  });\n  slices = slices.data(sliceData, helpers.getPtId);\n  trace._maxVisibleLayers = isFinite(maxVisibleDepth) ? maxVisibleDepth - minVisibleDepth + 1 : 0;\n  slices.enter().append('g').classed('slice', true);\n  handleSlicesExit(slices, onPathbar, refRect, [width, height], pathSlice);\n  slices.order();\n\n  // next coords of previous entry\n  var nextOfPrevEntry = null;\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextOfPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextOfPrevEntry = {\n          x0: pt.x0,\n          x1: pt.x1,\n          y0: pt.y0,\n          y1: pt.y1\n        };\n      }\n    });\n  }\n  var getRefRect = function () {\n    return nextOfPrevEntry || {\n      x0: 0,\n      x1: width,\n      y0: 0,\n      y1: height\n    };\n  };\n  var updateSlices = slices;\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: false,\n        isTransitioning: false\n      });\n    });\n  }\n  updateSlices.each(function (pt) {\n    var isHeader = helpers.isHeader(pt, trace);\n\n    // for bbox\n    pt._x0 = viewX(pt.x0);\n    pt._x1 = viewX(pt.x1);\n    pt._y0 = viewY(pt.y0);\n    pt._y1 = viewY(pt.y1);\n    pt._hoverX = viewX(pt.x1 - trace.marker.pad.r), pt._hoverY = hasBottom ? viewY(pt.y1 - trace.marker.pad.b / 2) : viewY(pt.y0 + trace.marker.pad.t / 2);\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', isStatic ? 'none' : 'all');\n    });\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      styleOne: styleOne,\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace, gd, {\n      hovered: false\n    });\n    if (pt.x0 === pt.x1 || pt.y0 === pt.y1) {\n      pt._text = '';\n    } else {\n      if (isHeader) {\n        pt._text = noRoomForHeader ? '' : helpers.getPtLabel(pt) || '';\n      } else {\n        pt._text = formatSliceLabel(pt, entry, trace, cd, fullLayout) || '';\n      }\n    }\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n    var text = pt._text || ' '; // use one space character instead of a blank string to avoid jumps during transition\n    var singleLineHeader = isHeader && text.indexOf('<br>') === -1;\n    sliceText.text(text).classed('slicetext', true).attr('text-anchor', hasRight ? 'end' : hasLeft || singleLineHeader ? 'start' : 'middle').call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    pt.textBB = Drawing.bBox(sliceText.node());\n    pt.transform = toMoveInsideSlice(pt, {\n      fontSize: font.size,\n      isHeader: isHeader\n    });\n    pt.transform.fontSize = font.size;\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n        return function (t) {\n          return strTransform(interp(t));\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt));\n    }\n  });\n  return nextOfPrevEntry;\n};","map":{"version":3,"names":["d3","require","Lib","Drawing","svgTextUtils","partition","styleOne","constants","helpers","attachFxHandlers","formatSliceLabel","onPathbar","module","exports","drawDescendants","gd","cd","entry","slices","opts","width","height","viewX","viewY","pathSlice","toMoveInsideSlice","strTransform","hasTransition","handleSlicesExit","makeUpdateSliceInterpolator","makeUpdateTextInterpolator","prevEntry","refRect","isStatic","_context","staticPlot","fullLayout","_fullLayout","cd0","trace","hasLeft","textposition","indexOf","hasRight","hasBottom","noRoomForHeader","marker","pad","t","b","allData","packing","tiling","squarifyratio","flipX","flip","flipY","inner","top","left","l","right","r","bottom","sliceData","descendants","minVisibleDepth","Infinity","maxVisibleDepth","forEach","pt","depth","_maxDepth","x0","x1","y0","y1","Math","min","max","data","getPtId","_maxVisibleLayers","isFinite","enter","append","classed","order","nextOfPrevEntry","prevEntryId","each","getRefRect","updateSlices","transition","sliceTop","select","setSliceCursor","hideOnRoot","hideOnLeaves","isTransitioning","isHeader","_x0","_x1","_y0","_y1","_hoverX","_hoverY","slicePath","ensureSingle","s","style","attrTween","pt2","interp","attr","call","eventDataKeys","transitionTime","CLICK_TRANSITION_TIME","transitionEasing","CLICK_TRANSITION_EASING","_transitioning","hovered","_text","getPtLabel","sliceTextGroup","sliceText","font","ensureUniformFontSize","determineTextFont","text","singleLineHeader","convertToTspans","textBB","bBox","node","transform","fontSize","size"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/treemap/draw_descendants.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar partition = require('./partition');\nvar styleOne = require('./style').styleOne;\nvar constants = require('./constants');\nvar helpers = require('../sunburst/helpers');\nvar attachFxHandlers = require('../sunburst/fx');\nvar formatSliceLabel = require('../sunburst/plot').formatSliceLabel;\n\nvar onPathbar = false; // for Descendants\n\nmodule.exports = function drawDescendants(gd, cd, entry, slices, opts) {\n    var width = opts.width;\n    var height = opts.height;\n    var viewX = opts.viewX;\n    var viewY = opts.viewY;\n    var pathSlice = opts.pathSlice;\n    var toMoveInsideSlice = opts.toMoveInsideSlice;\n    var strTransform = opts.strTransform;\n    var hasTransition = opts.hasTransition;\n    var handleSlicesExit = opts.handleSlicesExit;\n    var makeUpdateSliceInterpolator = opts.makeUpdateSliceInterpolator;\n    var makeUpdateTextInterpolator = opts.makeUpdateTextInterpolator;\n    var prevEntry = opts.prevEntry;\n    var refRect = {};\n\n    var isStatic = gd._context.staticPlot;\n\n    var fullLayout = gd._fullLayout;\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n\n    var hasLeft = trace.textposition.indexOf('left') !== -1;\n    var hasRight = trace.textposition.indexOf('right') !== -1;\n    var hasBottom = trace.textposition.indexOf('bottom') !== -1;\n\n    var noRoomForHeader = (!hasBottom && !trace.marker.pad.t) || (hasBottom && !trace.marker.pad.b);\n\n    // N.B. slice data isn't the calcdata,\n    // grab corresponding calcdata item in sliceData[i].data.data\n    var allData = partition(entry, [width, height], {\n        packing: trace.tiling.packing,\n        squarifyratio: trace.tiling.squarifyratio,\n        flipX: trace.tiling.flip.indexOf('x') > -1,\n        flipY: trace.tiling.flip.indexOf('y') > -1,\n        pad: {\n            inner: trace.tiling.pad,\n            top: trace.marker.pad.t,\n            left: trace.marker.pad.l,\n            right: trace.marker.pad.r,\n            bottom: trace.marker.pad.b,\n        }\n    });\n\n    var sliceData = allData.descendants();\n\n    var minVisibleDepth = Infinity;\n    var maxVisibleDepth = -Infinity;\n    sliceData.forEach(function(pt) {\n        var depth = pt.depth;\n        if(depth >= trace._maxDepth) {\n            // hide slices that won't show up on graph\n            pt.x0 = pt.x1 = (pt.x0 + pt.x1) / 2;\n            pt.y0 = pt.y1 = (pt.y0 + pt.y1) / 2;\n        } else {\n            minVisibleDepth = Math.min(minVisibleDepth, depth);\n            maxVisibleDepth = Math.max(maxVisibleDepth, depth);\n        }\n    });\n\n    slices = slices.data(sliceData, helpers.getPtId);\n\n    trace._maxVisibleLayers = isFinite(maxVisibleDepth) ? maxVisibleDepth - minVisibleDepth + 1 : 0;\n\n    slices.enter().append('g')\n        .classed('slice', true);\n\n    handleSlicesExit(slices, onPathbar, refRect, [width, height], pathSlice);\n\n    slices.order();\n\n    // next coords of previous entry\n    var nextOfPrevEntry = null;\n    if(hasTransition && prevEntry) {\n        var prevEntryId = helpers.getPtId(prevEntry);\n        slices.each(function(pt) {\n            if(nextOfPrevEntry === null && (helpers.getPtId(pt) === prevEntryId)) {\n                nextOfPrevEntry = {\n                    x0: pt.x0,\n                    x1: pt.x1,\n                    y0: pt.y0,\n                    y1: pt.y1\n                };\n            }\n        });\n    }\n\n    var getRefRect = function() {\n        return nextOfPrevEntry || {\n            x0: 0,\n            x1: width,\n            y0: 0,\n            y1: height\n        };\n    };\n\n    var updateSlices = slices;\n    if(hasTransition) {\n        updateSlices = updateSlices.transition().each('end', function() {\n            // N.B. gd._transitioning is (still) *true* by the time\n            // transition updates get here\n            var sliceTop = d3.select(this);\n            helpers.setSliceCursor(sliceTop, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: false,\n                isTransitioning: false\n            });\n        });\n    }\n\n    updateSlices.each(function(pt) {\n        var isHeader = helpers.isHeader(pt, trace);\n\n        // for bbox\n        pt._x0 = viewX(pt.x0);\n        pt._x1 = viewX(pt.x1);\n        pt._y0 = viewY(pt.y0);\n        pt._y1 = viewY(pt.y1);\n\n        pt._hoverX = viewX(pt.x1 - trace.marker.pad.r),\n        pt._hoverY = hasBottom ?\n                viewY(pt.y1 - trace.marker.pad.b / 2) :\n                viewY(pt.y0 + trace.marker.pad.t / 2);\n\n        var sliceTop = d3.select(this);\n\n        var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function(s) {\n            s.style('pointer-events', isStatic ? 'none' : 'all');\n        });\n\n        if(hasTransition) {\n            slicePath.transition().attrTween('d', function(pt2) {\n                var interp = makeUpdateSliceInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n                return function(t) { return pathSlice(interp(t)); };\n            });\n        } else {\n            slicePath.attr('d', pathSlice);\n        }\n\n        sliceTop\n            .call(attachFxHandlers, entry, gd, cd, {\n                styleOne: styleOne,\n                eventDataKeys: constants.eventDataKeys,\n                transitionTime: constants.CLICK_TRANSITION_TIME,\n                transitionEasing: constants.CLICK_TRANSITION_EASING\n            })\n            .call(helpers.setSliceCursor, gd, { isTransitioning: gd._transitioning });\n\n        slicePath.call(styleOne, pt, trace, gd, {\n            hovered: false\n        });\n\n        if(pt.x0 === pt.x1 || pt.y0 === pt.y1) {\n            pt._text = '';\n        } else {\n            if(isHeader) {\n                pt._text = noRoomForHeader ? '' : helpers.getPtLabel(pt) || '';\n            } else {\n                pt._text = formatSliceLabel(pt, entry, trace, cd, fullLayout) || '';\n            }\n        }\n\n        var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n        var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n\n\n        var text = pt._text || ' '; // use one space character instead of a blank string to avoid jumps during transition\n        var singleLineHeader = isHeader && text.indexOf('<br>') === -1;\n\n        sliceText.text(text)\n            .classed('slicetext', true)\n            .attr('text-anchor', hasRight ? 'end' : (hasLeft || singleLineHeader) ? 'start' : 'middle')\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        pt.textBB = Drawing.bBox(sliceText.node());\n        pt.transform = toMoveInsideSlice(pt, {\n            fontSize: font.size,\n            isHeader: isHeader\n        });\n        pt.transform.fontSize = font.size;\n\n        if(hasTransition) {\n            sliceText.transition().attrTween('transform', function(pt2) {\n                var interp = makeUpdateTextInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n                return function(t) { return strTransform(interp(t)); };\n            });\n        } else {\n            sliceText.attr('transform', strTransform(pt));\n        }\n    });\n\n    return nextOfPrevEntry;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}