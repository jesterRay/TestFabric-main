{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar formatLabels = require('../scatter/format_labels');\nvar Color = require('../../components/color');\nvar extractOpts = require('../../components/colorscale').extractOpts;\nvar makeColorScaleFuncFromTrace = require('../../components/colorscale').makeColorScaleFuncFromTrace;\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar supportsPixelatedImage = require('../../lib/supports_pixelated_image');\nvar PIXELATED_IMAGE_STYLE = require('../../constants/pixelated_image').STYLE;\nvar labelClass = 'heatmap-label';\nfunction selectLabels(plotGroup) {\n  return plotGroup.selectAll('g.' + labelClass);\n}\nfunction removeLabels(plotGroup) {\n  selectLabels(plotGroup).remove();\n}\nmodule.exports = function (gd, plotinfo, cdheatmaps, heatmapLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(heatmapLayer, cdheatmaps, 'hm').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var xGap = trace.xgap || 0;\n    var yGap = trace.ygap || 0;\n    var z = cd0.z;\n    var x = cd0.x;\n    var y = cd0.y;\n    var xc = cd0.xCenter;\n    var yc = cd0.yCenter;\n    var isContour = Registry.traceIs(trace, 'contour');\n    var zsmooth = isContour ? 'best' : trace.zsmooth;\n\n    // get z dims\n    var m = z.length;\n    var n = Lib.maxRowLength(z);\n    var xrev = false;\n    var yrev = false;\n    var left, right, temp, top, bottom, i, j, k;\n\n    // TODO: if there are multiple overlapping categorical heatmaps,\n    // or if we allow category sorting, then the categories may not be\n    // sequential... may need to reorder and/or expand z\n\n    // Get edges of png in pixels (xa.c2p() maps axes coordinates to pixel coordinates)\n    // figure out if either axis is reversed (y is usually reversed, in pixel coords)\n    // also clip the image to maximum 50% outside the visible plot area\n    // bigger image lets you pan more naturally, but slows performance.\n    // TODO: use low-resolution images outside the visible plot for panning\n    // these while loops find the first and last brick bounds that are defined\n    // (in case of log of a negative)\n    i = 0;\n    while (left === undefined && i < x.length - 1) {\n      left = xa.c2p(x[i]);\n      i++;\n    }\n    i = x.length - 1;\n    while (right === undefined && i > 0) {\n      right = xa.c2p(x[i]);\n      i--;\n    }\n    if (right < left) {\n      temp = right;\n      right = left;\n      left = temp;\n      xrev = true;\n    }\n    i = 0;\n    while (top === undefined && i < y.length - 1) {\n      top = ya.c2p(y[i]);\n      i++;\n    }\n    i = y.length - 1;\n    while (bottom === undefined && i > 0) {\n      bottom = ya.c2p(y[i]);\n      i--;\n    }\n    if (bottom < top) {\n      temp = top;\n      top = bottom;\n      bottom = temp;\n      yrev = true;\n    }\n\n    // for contours with heatmap fill, we generate the boundaries based on\n    // brick centers but then use the brick edges for drawing the bricks\n    if (isContour) {\n      xc = x;\n      yc = y;\n      x = cd0.xfill;\n      y = cd0.yfill;\n    }\n    var drawingMethod = 'default';\n    if (zsmooth) {\n      drawingMethod = zsmooth === 'best' ? 'smooth' : 'fast';\n    } else if (trace._islinear && xGap === 0 && yGap === 0 && supportsPixelatedImage()) {\n      drawingMethod = 'fast';\n    }\n\n    // make an image that goes at most half a screen off either side, to keep\n    // time reasonable when you zoom in. if drawingMethod is fast, don't worry\n    // about this, because zooming doesn't increase number of pixels\n    // if zsmooth is best, don't include anything off screen because it takes too long\n    if (drawingMethod !== 'fast') {\n      var extra = zsmooth === 'best' ? 0 : 0.5;\n      left = Math.max(-extra * xa._length, left);\n      right = Math.min((1 + extra) * xa._length, right);\n      top = Math.max(-extra * ya._length, top);\n      bottom = Math.min((1 + extra) * ya._length, bottom);\n    }\n    var imageWidth = Math.round(right - left);\n    var imageHeight = Math.round(bottom - top);\n\n    // setup image nodes\n\n    // if image is entirely off-screen, don't even draw it\n    var isOffScreen = left >= xa._length || right <= 0 || top >= ya._length || bottom <= 0;\n    if (isOffScreen) {\n      var noImage = plotGroup.selectAll('image').data([]);\n      noImage.exit().remove();\n      removeLabels(plotGroup);\n      return;\n    }\n\n    // generate image data\n\n    var canvasW, canvasH;\n    if (drawingMethod === 'fast') {\n      canvasW = n;\n      canvasH = m;\n    } else {\n      canvasW = imageWidth;\n      canvasH = imageHeight;\n    }\n    var canvas = document.createElement('canvas');\n    canvas.width = canvasW;\n    canvas.height = canvasH;\n    var context = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    var sclFunc = makeColorScaleFuncFromTrace(trace, {\n      noNumericCheck: true,\n      returnArray: true\n    });\n\n    // map brick boundaries to image pixels\n    var xpx, ypx;\n    if (drawingMethod === 'fast') {\n      xpx = xrev ? function (index) {\n        return n - 1 - index;\n      } : Lib.identity;\n      ypx = yrev ? function (index) {\n        return m - 1 - index;\n      } : Lib.identity;\n    } else {\n      xpx = function (index) {\n        return Lib.constrain(Math.round(xa.c2p(x[index]) - left), 0, imageWidth);\n      };\n      ypx = function (index) {\n        return Lib.constrain(Math.round(ya.c2p(y[index]) - top), 0, imageHeight);\n      };\n    }\n\n    // build the pixel map brick-by-brick\n    // cruise through z-matrix row-by-row\n    // build a brick at each z-matrix value\n    var yi = ypx(0);\n    var yb = [yi, yi];\n    var xbi = xrev ? 0 : 1;\n    var ybi = yrev ? 0 : 1;\n    // for collecting an average luminosity of the heatmap\n    var pixcount = 0;\n    var rcount = 0;\n    var gcount = 0;\n    var bcount = 0;\n    var xb, xi, v, row, c;\n    function setColor(v, pixsize) {\n      if (v !== undefined) {\n        var c = sclFunc(v);\n        c[0] = Math.round(c[0]);\n        c[1] = Math.round(c[1]);\n        c[2] = Math.round(c[2]);\n        pixcount += pixsize;\n        rcount += c[0] * pixsize;\n        gcount += c[1] * pixsize;\n        bcount += c[2] * pixsize;\n        return c;\n      }\n      return [0, 0, 0, 0];\n    }\n    function interpColor(r0, r1, xinterp, yinterp) {\n      var z00 = r0[xinterp.bin0];\n      if (z00 === undefined) return setColor(undefined, 1);\n      var z01 = r0[xinterp.bin1];\n      var z10 = r1[xinterp.bin0];\n      var z11 = r1[xinterp.bin1];\n      var dx = z01 - z00 || 0;\n      var dy = z10 - z00 || 0;\n      var dxy;\n\n      // the bilinear interpolation term needs different calculations\n      // for all the different permutations of missing data\n      // among the neighbors of the main point, to ensure\n      // continuity across brick boundaries.\n      if (z01 === undefined) {\n        if (z11 === undefined) dxy = 0;else if (z10 === undefined) dxy = 2 * (z11 - z00);else dxy = (2 * z11 - z10 - z00) * 2 / 3;\n      } else if (z11 === undefined) {\n        if (z10 === undefined) dxy = 0;else dxy = (2 * z00 - z01 - z10) * 2 / 3;\n      } else if (z10 === undefined) dxy = (2 * z11 - z01 - z00) * 2 / 3;else dxy = z11 + z00 - z01 - z10;\n      return setColor(z00 + xinterp.frac * dx + yinterp.frac * (dy + xinterp.frac * dxy));\n    }\n    if (drawingMethod !== 'default') {\n      // works fastest with imageData\n      var pxIndex = 0;\n      var pixels;\n      try {\n        pixels = new Uint8Array(canvasW * canvasH * 4);\n      } catch (e) {\n        pixels = new Array(canvasW * canvasH * 4);\n      }\n      if (drawingMethod === 'smooth') {\n        // zsmooth=\"best\"\n        var xForPx = xc || x;\n        var yForPx = yc || y;\n        var xPixArray = new Array(xForPx.length);\n        var yPixArray = new Array(yForPx.length);\n        var xinterpArray = new Array(imageWidth);\n        var findInterpX = xc ? findInterpFromCenters : findInterp;\n        var findInterpY = yc ? findInterpFromCenters : findInterp;\n        var yinterp, r0, r1;\n\n        // first make arrays of x and y pixel locations of brick boundaries\n        for (i = 0; i < xForPx.length; i++) xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);\n        for (i = 0; i < yForPx.length; i++) yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);\n\n        // then make arrays of interpolations\n        // (bin0=closest, bin1=next, frac=fractional dist.)\n        for (i = 0; i < imageWidth; i++) xinterpArray[i] = findInterpX(i, xPixArray);\n\n        // now do the interpolations and fill the png\n        for (j = 0; j < imageHeight; j++) {\n          yinterp = findInterpY(j, yPixArray);\n          r0 = z[yinterp.bin0];\n          r1 = z[yinterp.bin1];\n          for (i = 0; i < imageWidth; i++, pxIndex += 4) {\n            c = interpColor(r0, r1, xinterpArray[i], yinterp);\n            putColor(pixels, pxIndex, c);\n          }\n        }\n      } else {\n        // drawingMethod = \"fast\" (zsmooth = \"fast\"|false)\n        for (j = 0; j < m; j++) {\n          row = z[j];\n          yb = ypx(j);\n          for (i = 0; i < n; i++) {\n            c = setColor(row[i], 1);\n            pxIndex = (yb * n + xpx(i)) * 4;\n            putColor(pixels, pxIndex, c);\n          }\n        }\n      }\n      var imageData = context.createImageData(canvasW, canvasH);\n      try {\n        imageData.data.set(pixels);\n      } catch (e) {\n        var pxArray = imageData.data;\n        var dlen = pxArray.length;\n        for (j = 0; j < dlen; j++) {\n          pxArray[j] = pixels[j];\n        }\n      }\n      context.putImageData(imageData, 0, 0);\n    } else {\n      // rawingMethod = \"default\" (zsmooth = false)\n      // filling potentially large bricks works fastest with fillRect\n      // gaps do not need to be exact integers, but if they *are* we will get\n      // cleaner edges by rounding at least one edge\n      var xGapLeft = Math.floor(xGap / 2);\n      var yGapTop = Math.floor(yGap / 2);\n      for (j = 0; j < m; j++) {\n        row = z[j];\n        yb.reverse();\n        yb[ybi] = ypx(j + 1);\n        if (yb[0] === yb[1] || yb[0] === undefined || yb[1] === undefined) {\n          continue;\n        }\n        xi = xpx(0);\n        xb = [xi, xi];\n        for (i = 0; i < n; i++) {\n          // build one color brick!\n          xb.reverse();\n          xb[xbi] = xpx(i + 1);\n          if (xb[0] === xb[1] || xb[0] === undefined || xb[1] === undefined) {\n            continue;\n          }\n          v = row[i];\n          c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));\n          context.fillStyle = 'rgba(' + c.join(',') + ')';\n          context.fillRect(xb[0] + xGapLeft, yb[0] + yGapTop, xb[1] - xb[0] - xGap, yb[1] - yb[0] - yGap);\n        }\n      }\n    }\n    rcount = Math.round(rcount / pixcount);\n    gcount = Math.round(gcount / pixcount);\n    bcount = Math.round(bcount / pixcount);\n    var avgColor = tinycolor('rgb(' + rcount + ',' + gcount + ',' + bcount + ')');\n    gd._hmpixcount = (gd._hmpixcount || 0) + pixcount;\n    gd._hmlumcount = (gd._hmlumcount || 0) + pixcount * avgColor.getLuminance();\n    var image3 = plotGroup.selectAll('image').data(cd);\n    image3.enter().append('svg:image').attr({\n      xmlns: xmlnsNamespaces.svg,\n      preserveAspectRatio: 'none'\n    });\n    image3.attr({\n      height: imageHeight,\n      width: imageWidth,\n      x: left,\n      y: top,\n      'xlink:href': canvas.toDataURL('image/png')\n    });\n    if (drawingMethod === 'fast' && !zsmooth) {\n      image3.attr('style', PIXELATED_IMAGE_STYLE);\n    }\n    removeLabels(plotGroup);\n    var texttemplate = trace.texttemplate;\n    if (texttemplate) {\n      // dummy axis for formatting the z value\n      var cOpts = extractOpts(trace);\n      var dummyAx = {\n        type: 'linear',\n        range: [cOpts.min, cOpts.max],\n        _separators: xa._separators,\n        _numFormat: xa._numFormat\n      };\n      var aHistogram2dContour = trace.type === 'histogram2dcontour';\n      var aContour = trace.type === 'contour';\n      var iStart = aContour ? 1 : 0;\n      var iStop = aContour ? m - 1 : m;\n      var jStart = aContour ? 1 : 0;\n      var jStop = aContour ? n - 1 : n;\n      var textData = [];\n      for (i = iStart; i < iStop; i++) {\n        var yVal;\n        if (aContour) {\n          yVal = cd0.y[i];\n        } else if (aHistogram2dContour) {\n          if (i === 0 || i === m - 1) continue;\n          yVal = cd0.y[i];\n        } else if (cd0.yCenter) {\n          yVal = cd0.yCenter[i];\n        } else {\n          if (i + 1 === m && cd0.y[i + 1] === undefined) continue;\n          yVal = (cd0.y[i] + cd0.y[i + 1]) / 2;\n        }\n        var _y = Math.round(ya.c2p(yVal));\n        if (0 > _y || _y > ya._length) continue;\n        for (j = jStart; j < jStop; j++) {\n          var xVal;\n          if (aContour) {\n            xVal = cd0.x[j];\n          } else if (aHistogram2dContour) {\n            if (j === 0 || j === n - 1) continue;\n            xVal = cd0.x[j];\n          } else if (cd0.xCenter) {\n            xVal = cd0.xCenter[j];\n          } else {\n            if (j + 1 === n && cd0.x[j + 1] === undefined) continue;\n            xVal = (cd0.x[j] + cd0.x[j + 1]) / 2;\n          }\n          var _x = Math.round(xa.c2p(xVal));\n          if (0 > _x || _x > xa._length) continue;\n          var obj = formatLabels({\n            x: xVal,\n            y: yVal\n          }, trace, gd._fullLayout);\n          obj.x = xVal;\n          obj.y = yVal;\n          var zVal = cd0.z[i][j];\n          if (zVal === undefined) {\n            obj.z = '';\n            obj.zLabel = '';\n          } else {\n            obj.z = zVal;\n            obj.zLabel = Axes.tickText(dummyAx, zVal, 'hover').text;\n          }\n          var theText = cd0.text && cd0.text[i] && cd0.text[i][j];\n          if (theText === undefined || theText === false) theText = '';\n          obj.text = theText;\n          var _t = Lib.texttemplateString(texttemplate, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n          if (!_t) continue;\n          var lines = _t.split('<br>');\n          var nL = lines.length;\n          var nC = 0;\n          for (k = 0; k < nL; k++) {\n            nC = Math.max(nC, lines[k].length);\n          }\n          textData.push({\n            l: nL,\n            // number of lines\n            c: nC,\n            // maximum number of chars in a line\n            t: _t,\n            // text\n            x: _x,\n            y: _y,\n            z: zVal\n          });\n        }\n      }\n      var font = trace.textfont;\n      var fontSize = font.size;\n      var globalFontSize = gd._fullLayout.font.size;\n      if (!fontSize || fontSize === 'auto') {\n        var minW = Infinity;\n        var minH = Infinity;\n        var maxL = 0;\n        var maxC = 0;\n        for (k = 0; k < textData.length; k++) {\n          var d = textData[k];\n          maxL = Math.max(maxL, d.l);\n          maxC = Math.max(maxC, d.c);\n          if (k < textData.length - 1) {\n            var nextD = textData[k + 1];\n            var dx = Math.abs(nextD.x - d.x);\n            var dy = Math.abs(nextD.y - d.y);\n            if (dx) minW = Math.min(minW, dx);\n            if (dy) minH = Math.min(minH, dy);\n          }\n        }\n        if (!isFinite(minW) || !isFinite(minH)) {\n          fontSize = globalFontSize;\n        } else {\n          minW -= xGap;\n          minH -= yGap;\n          minW /= maxC;\n          minH /= maxL;\n          minW /= LINE_SPACING / 2;\n          minH /= LINE_SPACING;\n          fontSize = Math.min(Math.floor(minW), Math.floor(minH), globalFontSize);\n        }\n      }\n      if (fontSize <= 0 || !isFinite(fontSize)) return;\n      var xFn = function (d) {\n        return d.x;\n      };\n      var yFn = function (d) {\n        return d.y - fontSize * (d.l * LINE_SPACING / 2 - 1);\n      };\n      var labels = selectLabels(plotGroup).data(textData);\n      labels.enter().append('g').classed(labelClass, 1).append('text').attr('text-anchor', 'middle').each(function (d) {\n        var thisLabel = d3.select(this);\n        var fontColor = font.color;\n        if (!fontColor || fontColor === 'auto') {\n          fontColor = Color.contrast(d.z === undefined ? gd._fullLayout.plot_bgcolor : 'rgba(' + sclFunc(d.z).join() + ')');\n        }\n        thisLabel.attr('data-notex', 1).call(svgTextUtils.positionText, xFn(d), yFn(d)).call(Drawing.font, {\n          family: font.family,\n          size: fontSize,\n          color: fontColor,\n          weight: font.weight,\n          style: font.style,\n          variant: font.variant,\n          textcase: font.textcase,\n          lineposition: font.lineposition,\n          shadow: font.shadow\n        }).text(d.t).call(svgTextUtils.convertToTspans, gd);\n      });\n    }\n  });\n};\n\n// get interpolated bin value. Returns {bin0:closest bin, frac:fractional dist to next, bin1:next bin}\nfunction findInterp(pixel, pixArray) {\n  var maxBin = pixArray.length - 2;\n  var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);\n  var pix0 = pixArray[bin];\n  var pix1 = pixArray[bin + 1];\n  var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);\n  var bin0 = Math.round(interp);\n  var frac = Math.abs(interp - bin0);\n  if (!interp || interp === maxBin || !frac) {\n    return {\n      bin0: bin0,\n      bin1: bin0,\n      frac: 0\n    };\n  }\n  return {\n    bin0: bin0,\n    frac: frac,\n    bin1: Math.round(bin0 + frac / (interp - bin0))\n  };\n}\nfunction findInterpFromCenters(pixel, centerPixArray) {\n  var maxBin = centerPixArray.length - 1;\n  var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);\n  var pix0 = centerPixArray[bin];\n  var pix1 = centerPixArray[bin + 1];\n  var frac = (pixel - pix0) / (pix1 - pix0) || 0;\n  if (frac <= 0) {\n    return {\n      bin0: bin,\n      bin1: bin,\n      frac: 0\n    };\n  }\n  if (frac < 0.5) {\n    return {\n      bin0: bin,\n      bin1: bin + 1,\n      frac: frac\n    };\n  }\n  return {\n    bin0: bin + 1,\n    bin1: bin,\n    frac: 1 - frac\n  };\n}\nfunction putColor(pixels, pxIndex, c) {\n  pixels[pxIndex] = c[0];\n  pixels[pxIndex + 1] = c[1];\n  pixels[pxIndex + 2] = c[2];\n  pixels[pxIndex + 3] = Math.round(c[3] * 255);\n}","map":{"version":3,"names":["d3","require","tinycolor","Registry","Drawing","Axes","Lib","svgTextUtils","formatLabels","Color","extractOpts","makeColorScaleFuncFromTrace","xmlnsNamespaces","alignmentConstants","LINE_SPACING","supportsPixelatedImage","PIXELATED_IMAGE_STYLE","STYLE","labelClass","selectLabels","plotGroup","selectAll","removeLabels","remove","module","exports","gd","plotinfo","cdheatmaps","heatmapLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","select","cd0","trace","xGap","xgap","yGap","ygap","z","x","y","xc","xCenter","yc","yCenter","isContour","traceIs","zsmooth","m","length","n","maxRowLength","xrev","yrev","left","right","temp","top","bottom","i","j","k","undefined","c2p","xfill","yfill","drawingMethod","_islinear","extra","Math","max","_length","min","imageWidth","round","imageHeight","isOffScreen","noImage","data","exit","canvasW","canvasH","canvas","document","createElement","width","height","context","getContext","willReadFrequently","sclFunc","noNumericCheck","returnArray","xpx","ypx","index","identity","constrain","yi","yb","xbi","ybi","pixcount","rcount","gcount","bcount","xb","xi","v","row","c","setColor","pixsize","interpColor","r0","r1","xinterp","yinterp","z00","bin0","z01","bin1","z10","z11","dx","dy","dxy","frac","pxIndex","pixels","Uint8Array","e","Array","xForPx","yForPx","xPixArray","yPixArray","xinterpArray","findInterpX","findInterpFromCenters","findInterp","findInterpY","putColor","imageData","createImageData","set","pxArray","dlen","putImageData","xGapLeft","floor","yGapTop","reverse","fillStyle","join","fillRect","avgColor","_hmpixcount","_hmlumcount","getLuminance","image3","enter","append","attr","xmlns","svg","preserveAspectRatio","toDataURL","texttemplate","cOpts","dummyAx","type","range","_separators","_numFormat","aHistogram2dContour","aContour","iStart","iStop","jStart","jStop","textData","yVal","_y","xVal","_x","obj","_fullLayout","zVal","zLabel","tickText","text","theText","_t","texttemplateString","_d3locale","_meta","lines","split","nL","nC","push","l","t","font","textfont","fontSize","size","globalFontSize","minW","Infinity","minH","maxL","maxC","d","nextD","abs","isFinite","xFn","yFn","labels","classed","thisLabel","fontColor","color","contrast","plot_bgcolor","call","positionText","family","weight","style","variant","textcase","lineposition","shadow","convertToTspans","pixel","pixArray","maxBin","bin","findBin","pix0","pix1","interp","centerPixArray"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/heatmap/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar formatLabels = require('../scatter/format_labels');\nvar Color = require('../../components/color');\nvar extractOpts = require('../../components/colorscale').extractOpts;\nvar makeColorScaleFuncFromTrace = require('../../components/colorscale').makeColorScaleFuncFromTrace;\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar supportsPixelatedImage = require('../../lib/supports_pixelated_image');\nvar PIXELATED_IMAGE_STYLE = require('../../constants/pixelated_image').STYLE;\n\nvar labelClass = 'heatmap-label';\n\nfunction selectLabels(plotGroup) {\n    return plotGroup.selectAll('g.' + labelClass);\n}\n\nfunction removeLabels(plotGroup) {\n    selectLabels(plotGroup).remove();\n}\n\nmodule.exports = function(gd, plotinfo, cdheatmaps, heatmapLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(heatmapLayer, cdheatmaps, 'hm').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var xGap = trace.xgap || 0;\n        var yGap = trace.ygap || 0;\n\n        var z = cd0.z;\n        var x = cd0.x;\n        var y = cd0.y;\n        var xc = cd0.xCenter;\n        var yc = cd0.yCenter;\n        var isContour = Registry.traceIs(trace, 'contour');\n        var zsmooth = isContour ? 'best' : trace.zsmooth;\n\n        // get z dims\n        var m = z.length;\n        var n = Lib.maxRowLength(z);\n        var xrev = false;\n        var yrev = false;\n\n        var left, right, temp, top, bottom, i, j, k;\n\n        // TODO: if there are multiple overlapping categorical heatmaps,\n        // or if we allow category sorting, then the categories may not be\n        // sequential... may need to reorder and/or expand z\n\n        // Get edges of png in pixels (xa.c2p() maps axes coordinates to pixel coordinates)\n        // figure out if either axis is reversed (y is usually reversed, in pixel coords)\n        // also clip the image to maximum 50% outside the visible plot area\n        // bigger image lets you pan more naturally, but slows performance.\n        // TODO: use low-resolution images outside the visible plot for panning\n        // these while loops find the first and last brick bounds that are defined\n        // (in case of log of a negative)\n        i = 0;\n        while(left === undefined && i < x.length - 1) {\n            left = xa.c2p(x[i]);\n            i++;\n        }\n        i = x.length - 1;\n        while(right === undefined && i > 0) {\n            right = xa.c2p(x[i]);\n            i--;\n        }\n\n        if(right < left) {\n            temp = right;\n            right = left;\n            left = temp;\n            xrev = true;\n        }\n\n        i = 0;\n        while(top === undefined && i < y.length - 1) {\n            top = ya.c2p(y[i]);\n            i++;\n        }\n        i = y.length - 1;\n        while(bottom === undefined && i > 0) {\n            bottom = ya.c2p(y[i]);\n            i--;\n        }\n\n        if(bottom < top) {\n            temp = top;\n            top = bottom;\n            bottom = temp;\n            yrev = true;\n        }\n\n        // for contours with heatmap fill, we generate the boundaries based on\n        // brick centers but then use the brick edges for drawing the bricks\n        if(isContour) {\n            xc = x;\n            yc = y;\n            x = cd0.xfill;\n            y = cd0.yfill;\n        }\n\n        var drawingMethod = 'default';\n        if(zsmooth) {\n            drawingMethod = zsmooth === 'best' ? 'smooth' : 'fast';\n        } else if(trace._islinear && xGap === 0 && yGap === 0 && supportsPixelatedImage()) {\n            drawingMethod = 'fast';\n        }\n\n        // make an image that goes at most half a screen off either side, to keep\n        // time reasonable when you zoom in. if drawingMethod is fast, don't worry\n        // about this, because zooming doesn't increase number of pixels\n        // if zsmooth is best, don't include anything off screen because it takes too long\n        if(drawingMethod !== 'fast') {\n            var extra = zsmooth === 'best' ? 0 : 0.5;\n            left = Math.max(-extra * xa._length, left);\n            right = Math.min((1 + extra) * xa._length, right);\n            top = Math.max(-extra * ya._length, top);\n            bottom = Math.min((1 + extra) * ya._length, bottom);\n        }\n\n        var imageWidth = Math.round(right - left);\n        var imageHeight = Math.round(bottom - top);\n\n        // setup image nodes\n\n        // if image is entirely off-screen, don't even draw it\n        var isOffScreen = (\n            left >= xa._length || right <= 0 || top >= ya._length || bottom <= 0\n        );\n\n        if(isOffScreen) {\n            var noImage = plotGroup.selectAll('image').data([]);\n            noImage.exit().remove();\n\n            removeLabels(plotGroup);\n            return;\n        }\n\n        // generate image data\n\n        var canvasW, canvasH;\n        if(drawingMethod === 'fast') {\n            canvasW = n;\n            canvasH = m;\n        } else {\n            canvasW = imageWidth;\n            canvasH = imageHeight;\n        }\n\n        var canvas = document.createElement('canvas');\n        canvas.width = canvasW;\n        canvas.height = canvasH;\n        var context = canvas.getContext('2d', {willReadFrequently: true});\n\n        var sclFunc = makeColorScaleFuncFromTrace(trace, {noNumericCheck: true, returnArray: true});\n\n        // map brick boundaries to image pixels\n        var xpx,\n            ypx;\n        if(drawingMethod === 'fast') {\n            xpx = xrev ?\n                function(index) { return n - 1 - index; } :\n                Lib.identity;\n            ypx = yrev ?\n                function(index) { return m - 1 - index; } :\n                Lib.identity;\n        } else {\n            xpx = function(index) {\n                return Lib.constrain(Math.round(xa.c2p(x[index]) - left),\n                    0, imageWidth);\n            };\n            ypx = function(index) {\n                return Lib.constrain(Math.round(ya.c2p(y[index]) - top),\n                    0, imageHeight);\n            };\n        }\n\n        // build the pixel map brick-by-brick\n        // cruise through z-matrix row-by-row\n        // build a brick at each z-matrix value\n        var yi = ypx(0);\n        var yb = [yi, yi];\n        var xbi = xrev ? 0 : 1;\n        var ybi = yrev ? 0 : 1;\n        // for collecting an average luminosity of the heatmap\n        var pixcount = 0;\n        var rcount = 0;\n        var gcount = 0;\n        var bcount = 0;\n\n        var xb, xi, v, row, c;\n\n        function setColor(v, pixsize) {\n            if(v !== undefined) {\n                var c = sclFunc(v);\n                c[0] = Math.round(c[0]);\n                c[1] = Math.round(c[1]);\n                c[2] = Math.round(c[2]);\n\n                pixcount += pixsize;\n                rcount += c[0] * pixsize;\n                gcount += c[1] * pixsize;\n                bcount += c[2] * pixsize;\n                return c;\n            }\n            return [0, 0, 0, 0];\n        }\n\n        function interpColor(r0, r1, xinterp, yinterp) {\n            var z00 = r0[xinterp.bin0];\n            if(z00 === undefined) return setColor(undefined, 1);\n\n            var z01 = r0[xinterp.bin1];\n            var z10 = r1[xinterp.bin0];\n            var z11 = r1[xinterp.bin1];\n            var dx = (z01 - z00) || 0;\n            var dy = (z10 - z00) || 0;\n            var dxy;\n\n            // the bilinear interpolation term needs different calculations\n            // for all the different permutations of missing data\n            // among the neighbors of the main point, to ensure\n            // continuity across brick boundaries.\n            if(z01 === undefined) {\n                if(z11 === undefined) dxy = 0;\n                else if(z10 === undefined) dxy = 2 * (z11 - z00);\n                else dxy = (2 * z11 - z10 - z00) * 2 / 3;\n            } else if(z11 === undefined) {\n                if(z10 === undefined) dxy = 0;\n                else dxy = (2 * z00 - z01 - z10) * 2 / 3;\n            } else if(z10 === undefined) dxy = (2 * z11 - z01 - z00) * 2 / 3;\n            else dxy = (z11 + z00 - z01 - z10);\n\n            return setColor(z00 + xinterp.frac * dx + yinterp.frac * (dy + xinterp.frac * dxy));\n        }\n\n        if(drawingMethod !== 'default') { // works fastest with imageData\n            var pxIndex = 0;\n            var pixels;\n\n            try {\n                pixels = new Uint8Array(canvasW * canvasH * 4);\n            } catch(e) {\n                pixels = new Array(canvasW * canvasH * 4);\n            }\n\n            if(drawingMethod === 'smooth') { // zsmooth=\"best\"\n                var xForPx = xc || x;\n                var yForPx = yc || y;\n                var xPixArray = new Array(xForPx.length);\n                var yPixArray = new Array(yForPx.length);\n                var xinterpArray = new Array(imageWidth);\n                var findInterpX = xc ? findInterpFromCenters : findInterp;\n                var findInterpY = yc ? findInterpFromCenters : findInterp;\n                var yinterp, r0, r1;\n\n                // first make arrays of x and y pixel locations of brick boundaries\n                for(i = 0; i < xForPx.length; i++) xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);\n                for(i = 0; i < yForPx.length; i++) yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);\n\n                // then make arrays of interpolations\n                // (bin0=closest, bin1=next, frac=fractional dist.)\n                for(i = 0; i < imageWidth; i++) xinterpArray[i] = findInterpX(i, xPixArray);\n\n                // now do the interpolations and fill the png\n                for(j = 0; j < imageHeight; j++) {\n                    yinterp = findInterpY(j, yPixArray);\n                    r0 = z[yinterp.bin0];\n                    r1 = z[yinterp.bin1];\n                    for(i = 0; i < imageWidth; i++, pxIndex += 4) {\n                        c = interpColor(r0, r1, xinterpArray[i], yinterp);\n                        putColor(pixels, pxIndex, c);\n                    }\n                }\n            } else { // drawingMethod = \"fast\" (zsmooth = \"fast\"|false)\n                for(j = 0; j < m; j++) {\n                    row = z[j];\n                    yb = ypx(j);\n                    for(i = 0; i < n; i++) {\n                        c = setColor(row[i], 1);\n                        pxIndex = (yb * n + xpx(i)) * 4;\n                        putColor(pixels, pxIndex, c);\n                    }\n                }\n            }\n\n            var imageData = context.createImageData(canvasW, canvasH);\n            try {\n                imageData.data.set(pixels);\n            } catch(e) {\n                var pxArray = imageData.data;\n                var dlen = pxArray.length;\n                for(j = 0; j < dlen; j ++) {\n                    pxArray[j] = pixels[j];\n                }\n            }\n\n            context.putImageData(imageData, 0, 0);\n        } else { // rawingMethod = \"default\" (zsmooth = false)\n            // filling potentially large bricks works fastest with fillRect\n            // gaps do not need to be exact integers, but if they *are* we will get\n            // cleaner edges by rounding at least one edge\n            var xGapLeft = Math.floor(xGap / 2);\n            var yGapTop = Math.floor(yGap / 2);\n\n            for(j = 0; j < m; j++) {\n                row = z[j];\n                yb.reverse();\n                yb[ybi] = ypx(j + 1);\n                if(yb[0] === yb[1] || yb[0] === undefined || yb[1] === undefined) {\n                    continue;\n                }\n                xi = xpx(0);\n                xb = [xi, xi];\n                for(i = 0; i < n; i++) {\n                    // build one color brick!\n                    xb.reverse();\n                    xb[xbi] = xpx(i + 1);\n                    if(xb[0] === xb[1] || xb[0] === undefined || xb[1] === undefined) {\n                        continue;\n                    }\n                    v = row[i];\n                    c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));\n                    context.fillStyle = 'rgba(' + c.join(',') + ')';\n\n                    context.fillRect(xb[0] + xGapLeft, yb[0] + yGapTop,\n                        xb[1] - xb[0] - xGap, yb[1] - yb[0] - yGap);\n                }\n            }\n        }\n\n        rcount = Math.round(rcount / pixcount);\n        gcount = Math.round(gcount / pixcount);\n        bcount = Math.round(bcount / pixcount);\n        var avgColor = tinycolor('rgb(' + rcount + ',' + gcount + ',' + bcount + ')');\n\n        gd._hmpixcount = (gd._hmpixcount||0) + pixcount;\n        gd._hmlumcount = (gd._hmlumcount||0) + pixcount * avgColor.getLuminance();\n\n        var image3 = plotGroup.selectAll('image')\n            .data(cd);\n\n        image3.enter().append('svg:image').attr({\n            xmlns: xmlnsNamespaces.svg,\n            preserveAspectRatio: 'none'\n        });\n\n        image3.attr({\n            height: imageHeight,\n            width: imageWidth,\n            x: left,\n            y: top,\n            'xlink:href': canvas.toDataURL('image/png')\n        });\n\n        if(drawingMethod === 'fast' && !zsmooth) {\n            image3.attr('style', PIXELATED_IMAGE_STYLE);\n        }\n\n        removeLabels(plotGroup);\n\n        var texttemplate = trace.texttemplate;\n        if(texttemplate) {\n            // dummy axis for formatting the z value\n            var cOpts = extractOpts(trace);\n            var dummyAx = {\n                type: 'linear',\n                range: [cOpts.min, cOpts.max],\n                _separators: xa._separators,\n                _numFormat: xa._numFormat\n            };\n\n            var aHistogram2dContour = trace.type === 'histogram2dcontour';\n            var aContour = trace.type === 'contour';\n            var iStart = aContour ? 1 : 0;\n            var iStop = aContour ? m - 1 : m;\n            var jStart = aContour ? 1 : 0;\n            var jStop = aContour ? n - 1 : n;\n\n            var textData = [];\n            for(i = iStart; i < iStop; i++) {\n                var yVal;\n                if(aContour) {\n                    yVal = cd0.y[i];\n                } else if(aHistogram2dContour) {\n                    if(i === 0 || i === m - 1) continue;\n                    yVal = cd0.y[i];\n                } else if(cd0.yCenter) {\n                    yVal = cd0.yCenter[i];\n                } else {\n                    if(i + 1 === m && cd0.y[i + 1] === undefined) continue;\n                    yVal = (cd0.y[i] + cd0.y[i + 1]) / 2;\n                }\n\n                var _y = Math.round(ya.c2p(yVal));\n                if(0 > _y || _y > ya._length) continue;\n\n                for(j = jStart; j < jStop; j++) {\n                    var xVal;\n                    if(aContour) {\n                        xVal = cd0.x[j];\n                    } else if(aHistogram2dContour) {\n                        if(j === 0 || j === n - 1) continue;\n                        xVal = cd0.x[j];\n                    } else if(cd0.xCenter) {\n                        xVal = cd0.xCenter[j];\n                    } else {\n                        if(j + 1 === n && cd0.x[j + 1] === undefined) continue;\n                        xVal = (cd0.x[j] + cd0.x[j + 1]) / 2;\n                    }\n\n                    var _x = Math.round(xa.c2p(xVal));\n                    if(0 > _x || _x > xa._length) continue;\n\n                    var obj = formatLabels({\n                        x: xVal,\n                        y: yVal\n                    }, trace, gd._fullLayout);\n\n                    obj.x = xVal;\n                    obj.y = yVal;\n\n                    var zVal = cd0.z[i][j];\n                    if(zVal === undefined) {\n                        obj.z = '';\n                        obj.zLabel = '';\n                    } else {\n                        obj.z = zVal;\n                        obj.zLabel = Axes.tickText(dummyAx, zVal, 'hover').text;\n                    }\n\n                    var theText = cd0.text && cd0.text[i] && cd0.text[i][j];\n                    if(theText === undefined || theText === false) theText = '';\n                    obj.text = theText;\n\n                    var _t = Lib.texttemplateString(texttemplate, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n                    if(!_t) continue;\n\n                    var lines = _t.split('<br>');\n                    var nL = lines.length;\n                    var nC = 0;\n                    for(k = 0; k < nL; k++) {\n                        nC = Math.max(nC, lines[k].length);\n                    }\n\n                    textData.push({\n                        l: nL, // number of lines\n                        c: nC, // maximum number of chars in a line\n                        t: _t, // text\n                        x: _x,\n                        y: _y,\n                        z: zVal\n                    });\n                }\n            }\n\n            var font = trace.textfont;\n            var fontSize = font.size;\n            var globalFontSize = gd._fullLayout.font.size;\n\n            if(!fontSize || fontSize === 'auto') {\n                var minW = Infinity;\n                var minH = Infinity;\n                var maxL = 0;\n                var maxC = 0;\n\n                for(k = 0; k < textData.length; k++) {\n                    var d = textData[k];\n                    maxL = Math.max(maxL, d.l);\n                    maxC = Math.max(maxC, d.c);\n\n                    if(k < textData.length - 1) {\n                        var nextD = textData[k + 1];\n                        var dx = Math.abs(nextD.x - d.x);\n                        var dy = Math.abs(nextD.y - d.y);\n\n                        if(dx) minW = Math.min(minW, dx);\n                        if(dy) minH = Math.min(minH, dy);\n                    }\n                }\n\n                if(\n                    !isFinite(minW) ||\n                    !isFinite(minH)\n                ) {\n                    fontSize = globalFontSize;\n                } else {\n                    minW -= xGap;\n                    minH -= yGap;\n\n                    minW /= maxC;\n                    minH /= maxL;\n\n                    minW /= LINE_SPACING / 2;\n                    minH /= LINE_SPACING;\n\n                    fontSize = Math.min(\n                        Math.floor(minW),\n                        Math.floor(minH),\n                        globalFontSize\n                    );\n                }\n            }\n            if(fontSize <= 0 || !isFinite(fontSize)) return;\n\n            var xFn = function(d) { return d.x; };\n            var yFn = function(d) {\n                return d.y - fontSize * ((d.l * LINE_SPACING) / 2 - 1);\n            };\n\n            var labels = selectLabels(plotGroup).data(textData);\n\n            labels\n                .enter()\n                .append('g')\n                .classed(labelClass, 1)\n                .append('text')\n                .attr('text-anchor', 'middle')\n                .each(function(d) {\n                    var thisLabel = d3.select(this);\n\n                    var fontColor = font.color;\n                    if(!fontColor || fontColor === 'auto') {\n                        fontColor = Color.contrast(\n                            d.z === undefined ? gd._fullLayout.plot_bgcolor :\n                            'rgba(' +\n                                sclFunc(d.z).join() +\n                            ')'\n                        );\n                    }\n\n                    thisLabel\n                        .attr('data-notex', 1)\n                        .call(svgTextUtils.positionText, xFn(d), yFn(d))\n                        .call(Drawing.font, {\n                            family: font.family,\n                            size: fontSize,\n                            color: fontColor,\n                            weight: font.weight,\n                            style: font.style,\n                            variant: font.variant,\n                            textcase: font.textcase,\n                            lineposition: font.lineposition,\n                            shadow: font.shadow,\n                        })\n                        .text(d.t)\n                        .call(svgTextUtils.convertToTspans, gd);\n                });\n        }\n    });\n};\n\n// get interpolated bin value. Returns {bin0:closest bin, frac:fractional dist to next, bin1:next bin}\nfunction findInterp(pixel, pixArray) {\n    var maxBin = pixArray.length - 2;\n    var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);\n    var pix0 = pixArray[bin];\n    var pix1 = pixArray[bin + 1];\n    var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);\n    var bin0 = Math.round(interp);\n    var frac = Math.abs(interp - bin0);\n\n    if(!interp || interp === maxBin || !frac) {\n        return {\n            bin0: bin0,\n            bin1: bin0,\n            frac: 0\n        };\n    }\n    return {\n        bin0: bin0,\n        frac: frac,\n        bin1: Math.round(bin0 + frac / (interp - bin0))\n    };\n}\n\nfunction findInterpFromCenters(pixel, centerPixArray) {\n    var maxBin = centerPixArray.length - 1;\n    var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);\n    var pix0 = centerPixArray[bin];\n    var pix1 = centerPixArray[bin + 1];\n    var frac = ((pixel - pix0) / (pix1 - pix0)) || 0;\n    if(frac <= 0) {\n        return {\n            bin0: bin,\n            bin1: bin,\n            frac: 0\n        };\n    }\n    if(frac < 0.5) {\n        return {\n            bin0: bin,\n            bin1: bin + 1,\n            frac: frac\n        };\n    }\n    return {\n        bin0: bin + 1,\n        bin1: bin,\n        frac: 1 - frac\n    };\n}\n\nfunction putColor(pixels, pxIndex, c) {\n    pixels[pxIndex] = c[0];\n    pixels[pxIndex + 1] = c[1];\n    pixels[pxIndex + 2] = c[2];\n    pixels[pxIndex + 3] = Math.round(c[3] * 255);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}