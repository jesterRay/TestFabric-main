{"ast":null,"code":"'use strict';\n\nvar c = require('./constants');\nvar d3 = require('@plotly/d3');\nvar keyFun = require('../../lib/gup').keyFun;\nvar repeat = require('../../lib/gup').repeat;\nvar sortAsc = require('../../lib').sorterAsc;\nvar strTranslate = require('../../lib').strTranslate;\nvar snapRatio = c.bar.snapRatio;\nfunction snapOvershoot(v, vAdjacent) {\n  return v * (1 - snapRatio) + vAdjacent * snapRatio;\n}\nvar snapClose = c.bar.snapClose;\nfunction closeToCovering(v, vAdjacent) {\n  return v * (1 - snapClose) + vAdjacent * snapClose;\n}\n\n// snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\nfunction ordinalScaleSnap(isHigh, a, v, existingRanges) {\n  if (overlappingExisting(v, existingRanges)) return v;\n  var dir = isHigh ? -1 : 1;\n  var first = 0;\n  var last = a.length - 1;\n  if (dir < 0) {\n    var tmp = first;\n    first = last;\n    last = tmp;\n  }\n  var aHere = a[first];\n  var aPrev = aHere;\n  for (var i = first; dir * i < dir * last; i += dir) {\n    var nextI = i + dir;\n    var aNext = a[nextI];\n\n    // very close to the previous - snap down to it\n    if (dir * v < dir * closeToCovering(aHere, aNext)) return snapOvershoot(aHere, aPrev);\n    if (dir * v < dir * aNext || nextI === last) return snapOvershoot(aNext, aHere);\n    aPrev = aHere;\n    aHere = aNext;\n  }\n}\nfunction overlappingExisting(v, existingRanges) {\n  for (var i = 0; i < existingRanges.length; i++) {\n    if (v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n  }\n  return false;\n}\nfunction barHorizontalSetup(selection) {\n  selection.attr('x', -c.bar.captureWidth / 2).attr('width', c.bar.captureWidth);\n}\nfunction backgroundBarHorizontalSetup(selection) {\n  selection.attr('visibility', 'visible').style('visibility', 'visible').attr('fill', 'yellow').attr('opacity', 0);\n}\nfunction setHighlight(d) {\n  if (!d.brush.filterSpecified) {\n    return '0,' + d.height;\n  }\n  var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n  var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n  var p, sectionHeight, iNext;\n  var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n  for (var i = 0; i < pixelRanges.length; i++) {\n    p = pixelRanges[i];\n    sectionHeight = p[1] - p[0];\n    dashArray.push(currentGap);\n    dashArray.push(sectionHeight);\n    iNext = i + 1;\n    if (iNext < pixelRanges.length) {\n      currentGap = pixelRanges[iNext][0] - p[1];\n    }\n  }\n  dashArray.push(d.height);\n  // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n  // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n  // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n  // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n  return dashArray;\n}\nfunction unitToPx(unitRanges, height) {\n  return unitRanges.map(function (pr) {\n    return pr.map(function (v) {\n      return Math.max(0, v * height);\n    }).sort(sortAsc);\n  });\n}\n\n// is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\nfunction getRegion(fPix, y) {\n  var pad = c.bar.handleHeight;\n  if (y > fPix[1] + pad || y < fPix[0] - pad) return;\n  if (y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n  if (y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n  return 'ns';\n}\nfunction clearCursor() {\n  d3.select(document.body).style('cursor', null);\n}\nfunction styleHighlight(selection) {\n  // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n  // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n  // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n  // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n  selection.attr('stroke-dasharray', setHighlight);\n}\nfunction renderHighlight(root, tweenCallback) {\n  var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n  var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n  styleHighlight(barToStyle);\n}\nfunction getInterval(d, y) {\n  var b = d.brush;\n  var active = b.filterSpecified;\n  var closestInterval = NaN;\n  var out = {};\n  var i;\n  if (active) {\n    var height = d.height;\n    var intervals = b.filter.getConsolidated();\n    var pixIntervals = unitToPx(intervals, height);\n    var hoveredInterval = NaN;\n    var previousInterval = NaN;\n    var nextInterval = NaN;\n    for (i = 0; i <= pixIntervals.length; i++) {\n      var p = pixIntervals[i];\n      if (p && p[0] <= y && y <= p[1]) {\n        // over a bar\n        hoveredInterval = i;\n        break;\n      } else {\n        // between bars, or before/after the first/last bar\n        previousInterval = i ? i - 1 : NaN;\n        if (p && p[0] > y) {\n          nextInterval = i;\n          break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n        }\n      }\n    }\n    closestInterval = hoveredInterval;\n    if (isNaN(closestInterval)) {\n      if (isNaN(previousInterval) || isNaN(nextInterval)) {\n        closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n      } else {\n        closestInterval = y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y ? previousInterval : nextInterval;\n      }\n    }\n    if (!isNaN(closestInterval)) {\n      var fPix = pixIntervals[closestInterval];\n      var region = getRegion(fPix, y);\n      if (region) {\n        out.interval = intervals[closestInterval];\n        out.intervalPix = fPix;\n        out.region = region;\n      }\n    }\n  }\n  if (d.ordinal && !out.region) {\n    var a = d.unitTickvals;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n    for (i = 0; i < a.length; i++) {\n      var rangei = [a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75, a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75];\n      if (unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n        out.clickableOrdinalRange = rangei;\n        break;\n      }\n    }\n  }\n  return out;\n}\nfunction dragstart(lThis, d) {\n  d3.event.sourceEvent.stopPropagation();\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var unitLocation = d.unitToPaddedPx.invert(y);\n  var b = d.brush;\n  var interval = getInterval(d, y);\n  var unitRange = interval.interval;\n  var s = b.svgBrush;\n  s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n  s.grabbingBar = interval.region === 'ns';\n  if (s.grabbingBar) {\n    var pixelRange = unitRange.map(d.unitToPaddedPx);\n    s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n    s.barLength = pixelRange[1] - pixelRange[0];\n  }\n  s.clickableOrdinalRange = interval.clickableOrdinalRange;\n  s.stayingIntervals = d.multiselect && b.filterSpecified ? b.filter.getConsolidated() : [];\n  if (unitRange) {\n    s.stayingIntervals = s.stayingIntervals.filter(function (int2) {\n      return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n    });\n  }\n  s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n  d.parent.inBrushDrag = true;\n  s.brushStartCallback();\n}\nfunction drag(lThis, d) {\n  d3.event.sourceEvent.stopPropagation();\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var s = d.brush.svgBrush;\n  s.wasDragged = true;\n  s._dragging = true;\n  if (s.grabbingBar) {\n    // moving the bar\n    s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n  } else {\n    // south/north drag or new bar creation\n    s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n  }\n  d.brush.filterSpecified = true;\n  s.extent = s.stayingIntervals.concat([s.newExtent]);\n  s.brushCallback(d);\n  renderHighlight(lThis.parentNode);\n}\nfunction dragend(lThis, d) {\n  var brush = d.brush;\n  var filter = brush.filter;\n  var s = brush.svgBrush;\n  if (!s._dragging) {\n    // i.e. click\n    // mock zero drag\n    mousemove(lThis, d);\n    drag(lThis, d);\n    // remember it is a click not a drag\n    d.brush.svgBrush.wasDragged = false;\n  }\n  s._dragging = false;\n  var e = d3.event;\n  e.sourceEvent.stopPropagation();\n  var grabbingBar = s.grabbingBar;\n  s.grabbingBar = false;\n  s.grabLocation = undefined;\n  d.parent.inBrushDrag = false;\n  clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n  if (!s.wasDragged) {\n    // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n    s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n    if (s.clickableOrdinalRange) {\n      if (brush.filterSpecified && d.multiselect) {\n        s.extent.push(s.clickableOrdinalRange);\n      } else {\n        s.extent = [s.clickableOrdinalRange];\n        brush.filterSpecified = true;\n      }\n    } else if (grabbingBar) {\n      s.extent = s.stayingIntervals;\n      if (s.extent.length === 0) {\n        brushClear(brush);\n      }\n    } else {\n      brushClear(brush);\n    }\n    s.brushCallback(d);\n    renderHighlight(lThis.parentNode);\n    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n    return; // no need to fuse intervals or snap to ordinals, so we can bail early\n  }\n  var mergeIntervals = function () {\n    // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n    // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n    filter.set(filter.getConsolidated());\n  };\n  if (d.ordinal) {\n    var a = d.unitTickvals;\n    if (a[a.length - 1] < a[0]) a.reverse();\n    s.newExtent = [ordinalScaleSnap(0, a, s.newExtent[0], s.stayingIntervals), ordinalScaleSnap(1, a, s.newExtent[1], s.stayingIntervals)];\n    var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n    s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n    if (!s.extent.length) {\n      brushClear(brush);\n    }\n    s.brushCallback(d);\n    if (hasNewExtent) {\n      // merging intervals post the snap tween\n      renderHighlight(lThis.parentNode, mergeIntervals);\n    } else {\n      // if no new interval, don't animate, just redraw the highlight immediately\n      mergeIntervals();\n      renderHighlight(lThis.parentNode);\n    }\n  } else {\n    mergeIntervals(); // merging intervals immediately\n  }\n  s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n}\nfunction mousemove(lThis, d) {\n  var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n  var interval = getInterval(d, y);\n  var cursor = 'crosshair';\n  if (interval.clickableOrdinalRange) cursor = 'pointer';else if (interval.region) cursor = interval.region + '-resize';\n  d3.select(document.body).style('cursor', cursor);\n}\nfunction attachDragBehavior(selection) {\n  // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n  // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n  // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n  selection.on('mousemove', function (d) {\n    d3.event.preventDefault();\n    if (!d.parent.inBrushDrag) mousemove(this, d);\n  }).on('mouseleave', function (d) {\n    if (!d.parent.inBrushDrag) clearCursor();\n  }).call(d3.behavior.drag().on('dragstart', function (d) {\n    dragstart(this, d);\n  }).on('drag', function (d) {\n    drag(this, d);\n  }).on('dragend', function (d) {\n    dragend(this, d);\n  }));\n}\nfunction startAsc(a, b) {\n  return a[0] - b[0];\n}\nfunction renderAxisBrush(axisBrush, paperColor, gd) {\n  var isStatic = gd._context.staticPlot;\n  var background = axisBrush.selectAll('.background').data(repeat);\n  background.enter().append('rect').classed('background', true).call(barHorizontalSetup).call(backgroundBarHorizontalSetup).style('pointer-events', isStatic ? 'none' : 'auto') // parent pointer events are disabled; we must have it to register events\n  .attr('transform', strTranslate(0, c.verticalPadding));\n  background.call(attachDragBehavior).attr('height', function (d) {\n    return d.height - c.verticalPadding;\n  });\n  var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n  highlightShadow.enter().append('line').classed('highlight-shadow', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width + c.bar.strokeWidth).attr('stroke', paperColor).attr('opacity', c.bar.strokeOpacity).attr('stroke-linecap', 'butt');\n  highlightShadow.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n  var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n  highlight.enter().append('line').classed('highlight', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width - c.bar.strokeWidth).attr('stroke', c.bar.fillColor).attr('opacity', c.bar.fillOpacity).attr('stroke-linecap', 'butt');\n  highlight.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n}\nfunction ensureAxisBrush(axisOverlays, paperColor, gd) {\n  var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush).data(repeat, keyFun);\n  axisBrush.enter().append('g').classed(c.cn.axisBrush, true);\n  renderAxisBrush(axisBrush, paperColor, gd);\n}\nfunction getBrushExtent(brush) {\n  return brush.svgBrush.extent.map(function (e) {\n    return e.slice();\n  });\n}\nfunction brushClear(brush) {\n  brush.filterSpecified = false;\n  brush.svgBrush.extent = [[-Infinity, Infinity]];\n}\nfunction axisBrushMoved(callback) {\n  return function axisBrushMoved(dimension) {\n    var brush = dimension.brush;\n    var extent = getBrushExtent(brush);\n    var newExtent = extent.slice();\n    brush.filter.set(newExtent);\n    callback();\n  };\n}\nfunction dedupeRealRanges(intervals) {\n  // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n  // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n  var queue = intervals.slice();\n  var result = [];\n  var currentInterval;\n  var current = queue.shift();\n  while (current) {\n    // [].shift === undefined, so we don't descend into an empty array\n    currentInterval = current.slice();\n    while ((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */currentInterval[1]) {\n      currentInterval[1] = Math.max(currentInterval[1], current[1]);\n    }\n    result.push(currentInterval);\n  }\n  if (result.length === 1 && result[0][0] > result[0][1]) {\n    // discard result\n    result = [];\n  }\n  return result;\n}\nfunction makeFilter() {\n  var filter = [];\n  var consolidated;\n  var bounds;\n  return {\n    set: function (a) {\n      filter = a.map(function (d) {\n        return d.slice().sort(sortAsc);\n      }).sort(startAsc);\n\n      // handle unselected case\n      if (filter.length === 1 && filter[0][0] === -Infinity && filter[0][1] === Infinity) {\n        filter = [[0, -1]];\n      }\n      consolidated = dedupeRealRanges(filter);\n      bounds = filter.reduce(function (p, n) {\n        return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n      }, [Infinity, -Infinity]);\n    },\n    get: function () {\n      return filter.slice();\n    },\n    getConsolidated: function () {\n      return consolidated;\n    },\n    getBounds: function () {\n      return bounds;\n    }\n  };\n}\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n  var filter = makeFilter();\n  filter.set(initialRange);\n  return {\n    filter: filter,\n    filterSpecified: rangeSpecified,\n    // there's a difference between not filtering and filtering a non-proper subset\n    svgBrush: {\n      extent: [],\n      // this is where the svgBrush writes contents into\n      brushStartCallback: brushStartCallback,\n      brushCallback: axisBrushMoved(brushCallback),\n      brushEndCallback: brushEndCallback\n    }\n  };\n}\n\n// for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\nfunction cleanRanges(ranges, dimension) {\n  if (Array.isArray(ranges[0])) {\n    ranges = ranges.map(function (ri) {\n      return ri.sort(sortAsc);\n    });\n    if (!dimension.multiselect) ranges = [ranges[0]];else ranges = dedupeRealRanges(ranges.sort(startAsc));\n  } else ranges = [ranges.sort(sortAsc)];\n\n  // ordinal snapping\n  if (dimension.tickvals) {\n    var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n    ranges = ranges.map(function (ri) {\n      var rSnapped = [ordinalScaleSnap(0, sortedTickVals, ri[0], []), ordinalScaleSnap(1, sortedTickVals, ri[1], [])];\n      if (rSnapped[1] > rSnapped[0]) return rSnapped;\n    }).filter(function (ri) {\n      return ri;\n    });\n    if (!ranges.length) return;\n  }\n  return ranges.length > 1 ? ranges : ranges[0];\n}\nmodule.exports = {\n  makeBrush: makeBrush,\n  ensureAxisBrush: ensureAxisBrush,\n  cleanRanges: cleanRanges\n};","map":{"version":3,"names":["c","require","d3","keyFun","repeat","sortAsc","sorterAsc","strTranslate","snapRatio","bar","snapOvershoot","v","vAdjacent","snapClose","closeToCovering","ordinalScaleSnap","isHigh","a","existingRanges","overlappingExisting","dir","first","last","length","tmp","aHere","aPrev","i","nextI","aNext","barHorizontalSetup","selection","attr","captureWidth","backgroundBarHorizontalSetup","style","setHighlight","d","brush","filterSpecified","height","pixelRanges","unitToPx","filter","getConsolidated","dashArray","p","sectionHeight","iNext","currentGap","push","unitRanges","map","pr","Math","max","sort","getRegion","fPix","y","pad","handleHeight","clearCursor","select","document","body","styleHighlight","renderHighlight","root","tweenCallback","selectAll","barToStyle","transition","duration","snapDuration","each","getInterval","b","active","closestInterval","NaN","out","intervals","pixIntervals","hoveredInterval","previousInterval","nextInterval","isNaN","region","interval","intervalPix","ordinal","unitTickvals","unitLocation","unitToPaddedPx","invert","rangei","min","clickableOrdinalRange","dragstart","lThis","event","sourceEvent","stopPropagation","mouse","verticalPadding","unitRange","s","svgBrush","wasDragged","grabbingBar","pixelRange","grabPoint","barLength","stayingIntervals","multiselect","int2","startExtent","parent","inBrushDrag","brushStartCallback","drag","_dragging","newExtent","extent","concat","brushCallback","parentNode","dragend","mousemove","e","grabLocation","undefined","brushClear","brushEndCallback","mergeIntervals","set","reverse","hasNewExtent","cursor","attachDragBehavior","on","preventDefault","call","behavior","startAsc","renderAxisBrush","axisBrush","paperColor","gd","isStatic","_context","staticPlot","background","data","enter","append","classed","highlightShadow","width","strokeWidth","strokeOpacity","highlight","fillColor","fillOpacity","ensureAxisBrush","axisOverlays","cn","getBrushExtent","slice","Infinity","axisBrushMoved","callback","dimension","dedupeRealRanges","queue","result","currentInterval","current","shift","makeFilter","consolidated","bounds","reduce","n","get","getBounds","makeBrush","state","rangeSpecified","initialRange","cleanRanges","ranges","Array","isArray","ri","tickvals","sortedTickVals","rSnapped","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/parcoords/axisbrush.js"],"sourcesContent":["'use strict';\n\nvar c = require('./constants');\nvar d3 = require('@plotly/d3');\nvar keyFun = require('../../lib/gup').keyFun;\nvar repeat = require('../../lib/gup').repeat;\nvar sortAsc = require('../../lib').sorterAsc;\nvar strTranslate = require('../../lib').strTranslate;\n\nvar snapRatio = c.bar.snapRatio;\nfunction snapOvershoot(v, vAdjacent) { return v * (1 - snapRatio) + vAdjacent * snapRatio; }\n\nvar snapClose = c.bar.snapClose;\nfunction closeToCovering(v, vAdjacent) { return v * (1 - snapClose) + vAdjacent * snapClose; }\n\n// snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\nfunction ordinalScaleSnap(isHigh, a, v, existingRanges) {\n    if(overlappingExisting(v, existingRanges)) return v;\n\n    var dir = isHigh ? -1 : 1;\n\n    var first = 0;\n    var last = a.length - 1;\n    if(dir < 0) {\n        var tmp = first;\n        first = last;\n        last = tmp;\n    }\n\n    var aHere = a[first];\n    var aPrev = aHere;\n    for(var i = first; dir * i < dir * last; i += dir) {\n        var nextI = i + dir;\n        var aNext = a[nextI];\n\n        // very close to the previous - snap down to it\n        if(dir * v < dir * closeToCovering(aHere, aNext)) return snapOvershoot(aHere, aPrev);\n        if(dir * v < dir * aNext || nextI === last) return snapOvershoot(aNext, aHere);\n\n        aPrev = aHere;\n        aHere = aNext;\n    }\n}\n\nfunction overlappingExisting(v, existingRanges) {\n    for(var i = 0; i < existingRanges.length; i++) {\n        if(v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n    }\n    return false;\n}\n\nfunction barHorizontalSetup(selection) {\n    selection\n        .attr('x', -c.bar.captureWidth / 2)\n        .attr('width', c.bar.captureWidth);\n}\n\nfunction backgroundBarHorizontalSetup(selection) {\n    selection\n        .attr('visibility', 'visible')\n        .style('visibility', 'visible')\n        .attr('fill', 'yellow')\n        .attr('opacity', 0);\n}\n\nfunction setHighlight(d) {\n    if(!d.brush.filterSpecified) {\n        return '0,' + d.height;\n    }\n\n    var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n    var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n    var p, sectionHeight, iNext;\n    var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n    for(var i = 0; i < pixelRanges.length; i++) {\n        p = pixelRanges[i];\n        sectionHeight = p[1] - p[0];\n        dashArray.push(currentGap);\n        dashArray.push(sectionHeight);\n        iNext = i + 1;\n        if(iNext < pixelRanges.length) {\n            currentGap = pixelRanges[iNext][0] - p[1];\n        }\n    }\n    dashArray.push(d.height);\n    // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n    // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n    // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n    // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n    return dashArray;\n}\n\nfunction unitToPx(unitRanges, height) {\n    return unitRanges.map(function(pr) {\n        return pr.map(function(v) { return Math.max(0, v * height); }).sort(sortAsc);\n    });\n}\n\n// is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\nfunction getRegion(fPix, y) {\n    var pad = c.bar.handleHeight;\n    if(y > fPix[1] + pad || y < fPix[0] - pad) return;\n    if(y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n    if(y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n    return 'ns';\n}\n\nfunction clearCursor() {\n    d3.select(document.body)\n        .style('cursor', null);\n}\n\nfunction styleHighlight(selection) {\n    // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n    // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n    // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n    // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n    selection.attr('stroke-dasharray', setHighlight);\n}\n\nfunction renderHighlight(root, tweenCallback) {\n    var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n    var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n    styleHighlight(barToStyle);\n}\n\nfunction getInterval(d, y) {\n    var b = d.brush;\n    var active = b.filterSpecified;\n    var closestInterval = NaN;\n    var out = {};\n    var i;\n\n    if(active) {\n        var height = d.height;\n        var intervals = b.filter.getConsolidated();\n        var pixIntervals = unitToPx(intervals, height);\n        var hoveredInterval = NaN;\n        var previousInterval = NaN;\n        var nextInterval = NaN;\n        for(i = 0; i <= pixIntervals.length; i++) {\n            var p = pixIntervals[i];\n            if(p && p[0] <= y && y <= p[1]) {\n                // over a bar\n                hoveredInterval = i;\n                break;\n            } else {\n                // between bars, or before/after the first/last bar\n                previousInterval = i ? i - 1 : NaN;\n                if(p && p[0] > y) {\n                    nextInterval = i;\n                    break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n                }\n            }\n        }\n\n        closestInterval = hoveredInterval;\n        if(isNaN(closestInterval)) {\n            if(isNaN(previousInterval) || isNaN(nextInterval)) {\n                closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n            } else {\n                closestInterval = (y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y) ?\n                    previousInterval : nextInterval;\n            }\n        }\n\n        if(!isNaN(closestInterval)) {\n            var fPix = pixIntervals[closestInterval];\n            var region = getRegion(fPix, y);\n\n            if(region) {\n                out.interval = intervals[closestInterval];\n                out.intervalPix = fPix;\n                out.region = region;\n            }\n        }\n    }\n\n    if(d.ordinal && !out.region) {\n        var a = d.unitTickvals;\n        var unitLocation = d.unitToPaddedPx.invert(y);\n        for(i = 0; i < a.length; i++) {\n            var rangei = [\n                a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75,\n                a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75\n            ];\n            if(unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n                out.clickableOrdinalRange = rangei;\n                break;\n            }\n        }\n    }\n\n    return out;\n}\n\nfunction dragstart(lThis, d) {\n    d3.event.sourceEvent.stopPropagation();\n    var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n    var b = d.brush;\n    var interval = getInterval(d, y);\n    var unitRange = interval.interval;\n    var s = b.svgBrush;\n    s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n    s.grabbingBar = interval.region === 'ns';\n    if(s.grabbingBar) {\n        var pixelRange = unitRange.map(d.unitToPaddedPx);\n        s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n        s.barLength = pixelRange[1] - pixelRange[0];\n    }\n    s.clickableOrdinalRange = interval.clickableOrdinalRange;\n    s.stayingIntervals = (d.multiselect && b.filterSpecified) ? b.filter.getConsolidated() : [];\n    if(unitRange) {\n        s.stayingIntervals = s.stayingIntervals.filter(function(int2) {\n            return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n        });\n    }\n    s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n    d.parent.inBrushDrag = true;\n    s.brushStartCallback();\n}\n\nfunction drag(lThis, d) {\n    d3.event.sourceEvent.stopPropagation();\n    var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n    var s = d.brush.svgBrush;\n    s.wasDragged = true;\n    s._dragging = true;\n\n    if(s.grabbingBar) { // moving the bar\n        s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n    } else { // south/north drag or new bar creation\n        s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n    }\n\n    d.brush.filterSpecified = true;\n    s.extent = s.stayingIntervals.concat([s.newExtent]);\n    s.brushCallback(d);\n    renderHighlight(lThis.parentNode);\n}\n\nfunction dragend(lThis, d) {\n    var brush = d.brush;\n    var filter = brush.filter;\n    var s = brush.svgBrush;\n\n    if(!s._dragging) { // i.e. click\n        // mock zero drag\n        mousemove(lThis, d);\n        drag(lThis, d);\n        // remember it is a click not a drag\n        d.brush.svgBrush.wasDragged = false;\n    }\n    s._dragging = false;\n\n    var e = d3.event;\n    e.sourceEvent.stopPropagation();\n    var grabbingBar = s.grabbingBar;\n    s.grabbingBar = false;\n    s.grabLocation = undefined;\n    d.parent.inBrushDrag = false;\n    clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n    if(!s.wasDragged) { // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n        s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n        if(s.clickableOrdinalRange) {\n            if(brush.filterSpecified && d.multiselect) {\n                s.extent.push(s.clickableOrdinalRange);\n            } else {\n                s.extent = [s.clickableOrdinalRange];\n                brush.filterSpecified = true;\n            }\n        } else if(grabbingBar) {\n            s.extent = s.stayingIntervals;\n            if(s.extent.length === 0) {\n                brushClear(brush);\n            }\n        } else {\n            brushClear(brush);\n        }\n        s.brushCallback(d);\n        renderHighlight(lThis.parentNode);\n        s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n        return; // no need to fuse intervals or snap to ordinals, so we can bail early\n    }\n\n    var mergeIntervals = function() {\n        // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n        // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n        filter.set(filter.getConsolidated());\n    };\n\n    if(d.ordinal) {\n        var a = d.unitTickvals;\n        if(a[a.length - 1] < a[0]) a.reverse();\n        s.newExtent = [\n            ordinalScaleSnap(0, a, s.newExtent[0], s.stayingIntervals),\n            ordinalScaleSnap(1, a, s.newExtent[1], s.stayingIntervals)\n        ];\n        var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n        s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n        if(!s.extent.length) {\n            brushClear(brush);\n        }\n        s.brushCallback(d);\n        if(hasNewExtent) {\n            // merging intervals post the snap tween\n            renderHighlight(lThis.parentNode, mergeIntervals);\n        } else {\n            // if no new interval, don't animate, just redraw the highlight immediately\n            mergeIntervals();\n            renderHighlight(lThis.parentNode);\n        }\n    } else {\n        mergeIntervals(); // merging intervals immediately\n    }\n    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n}\n\nfunction mousemove(lThis, d) {\n    var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;\n    var interval = getInterval(d, y);\n\n    var cursor = 'crosshair';\n    if(interval.clickableOrdinalRange) cursor = 'pointer';\n    else if(interval.region) cursor = interval.region + '-resize';\n    d3.select(document.body)\n        .style('cursor', cursor);\n}\n\nfunction attachDragBehavior(selection) {\n    // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n    // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n    // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n    selection\n        .on('mousemove', function(d) {\n            d3.event.preventDefault();\n            if(!d.parent.inBrushDrag) mousemove(this, d);\n        })\n        .on('mouseleave', function(d) {\n            if(!d.parent.inBrushDrag) clearCursor();\n        })\n        .call(d3.behavior.drag()\n            .on('dragstart', function(d) { dragstart(this, d); })\n            .on('drag', function(d) { drag(this, d); })\n            .on('dragend', function(d) { dragend(this, d); })\n        );\n}\n\nfunction startAsc(a, b) { return a[0] - b[0]; }\n\nfunction renderAxisBrush(axisBrush, paperColor, gd) {\n    var isStatic = gd._context.staticPlot;\n\n    var background = axisBrush.selectAll('.background').data(repeat);\n\n    background.enter()\n        .append('rect')\n        .classed('background', true)\n        .call(barHorizontalSetup)\n        .call(backgroundBarHorizontalSetup)\n        .style('pointer-events', isStatic ? 'none' : 'auto') // parent pointer events are disabled; we must have it to register events\n        .attr('transform', strTranslate(0, c.verticalPadding));\n\n    background\n        .call(attachDragBehavior)\n        .attr('height', function(d) {\n            return d.height - c.verticalPadding;\n        });\n\n    var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n    highlightShadow.enter()\n        .append('line')\n        .classed('highlight-shadow', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width + c.bar.strokeWidth)\n        .attr('stroke', paperColor)\n        .attr('opacity', c.bar.strokeOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlightShadow\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n\n    var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n    highlight.enter()\n        .append('line')\n        .classed('highlight', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width - c.bar.strokeWidth)\n        .attr('stroke', c.bar.fillColor)\n        .attr('opacity', c.bar.fillOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlight\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n}\n\nfunction ensureAxisBrush(axisOverlays, paperColor, gd) {\n    var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush)\n        .data(repeat, keyFun);\n\n    axisBrush.enter()\n        .append('g')\n        .classed(c.cn.axisBrush, true);\n\n    renderAxisBrush(axisBrush, paperColor, gd);\n}\n\nfunction getBrushExtent(brush) {\n    return brush.svgBrush.extent.map(function(e) {return e.slice();});\n}\n\nfunction brushClear(brush) {\n    brush.filterSpecified = false;\n    brush.svgBrush.extent = [[-Infinity, Infinity]];\n}\n\nfunction axisBrushMoved(callback) {\n    return function axisBrushMoved(dimension) {\n        var brush = dimension.brush;\n        var extent = getBrushExtent(brush);\n        var newExtent = extent.slice();\n        brush.filter.set(newExtent);\n        callback();\n    };\n}\n\nfunction dedupeRealRanges(intervals) {\n    // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n    // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n    var queue = intervals.slice();\n    var result = [];\n    var currentInterval;\n    var current = queue.shift();\n    while(current) { // [].shift === undefined, so we don't descend into an empty array\n        currentInterval = current.slice();\n        while((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */ currentInterval[1]) {\n            currentInterval[1] = Math.max(currentInterval[1], current[1]);\n        }\n        result.push(currentInterval);\n    }\n\n    if(\n        result.length === 1 &&\n        result[0][0] > result[0][1]\n    ) {\n        // discard result\n        result = [];\n    }\n\n    return result;\n}\n\nfunction makeFilter() {\n    var filter = [];\n    var consolidated;\n    var bounds;\n    return {\n        set: function(a) {\n            filter = a\n                .map(function(d) { return d.slice().sort(sortAsc); })\n                .sort(startAsc);\n\n            // handle unselected case\n            if(filter.length === 1 &&\n                filter[0][0] === -Infinity &&\n                filter[0][1] === Infinity) {\n                filter = [[0, -1]];\n            }\n\n            consolidated = dedupeRealRanges(filter);\n            bounds = filter.reduce(function(p, n) {\n                return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n            }, [Infinity, -Infinity]);\n        },\n        get: function() { return filter.slice(); },\n        getConsolidated: function() { return consolidated; },\n        getBounds: function() { return bounds; }\n    };\n}\n\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n    var filter = makeFilter();\n    filter.set(initialRange);\n    return {\n        filter: filter,\n        filterSpecified: rangeSpecified, // there's a difference between not filtering and filtering a non-proper subset\n        svgBrush: {\n            extent: [], // this is where the svgBrush writes contents into\n            brushStartCallback: brushStartCallback,\n            brushCallback: axisBrushMoved(brushCallback),\n            brushEndCallback: brushEndCallback\n        }\n    };\n}\n\n// for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\nfunction cleanRanges(ranges, dimension) {\n    if(Array.isArray(ranges[0])) {\n        ranges = ranges.map(function(ri) { return ri.sort(sortAsc); });\n\n        if(!dimension.multiselect) ranges = [ranges[0]];\n        else ranges = dedupeRealRanges(ranges.sort(startAsc));\n    } else ranges = [ranges.sort(sortAsc)];\n\n    // ordinal snapping\n    if(dimension.tickvals) {\n        var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n        ranges = ranges.map(function(ri) {\n            var rSnapped = [\n                ordinalScaleSnap(0, sortedTickVals, ri[0], []),\n                ordinalScaleSnap(1, sortedTickVals, ri[1], [])\n            ];\n            if(rSnapped[1] > rSnapped[0]) return rSnapped;\n        })\n        .filter(function(ri) { return ri; });\n\n        if(!ranges.length) return;\n    }\n    return ranges.length > 1 ? ranges : ranges[0];\n}\n\nmodule.exports = {\n    makeBrush: makeBrush,\n    ensureAxisBrush: ensureAxisBrush,\n    cleanRanges: cleanRanges\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}