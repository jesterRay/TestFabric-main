{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar _ = Lib._;\nvar Axes = require('../../plots/cartesian/axes');\nvar alignPeriod = require('../../plots/cartesian/align_period');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nfunction calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var tickLen = convertTickWidth(gd, xa, trace);\n  var minDiff = trace._minDiff;\n  trace._minDiff = null;\n  var origX = trace._origX;\n  trace._origX = null;\n  var x = trace._xcalc;\n  trace._xcalc = null;\n  var cd = calcCommon(gd, trace, origX, x, ya, ptFunc);\n  trace._extremes[xa._id] = Axes.findExtremes(xa, x, {\n    vpad: minDiff / 2\n  });\n  if (cd.length) {\n    Lib.extendFlat(cd[0].t, {\n      wHover: minDiff / 2,\n      tickLen: tickLen\n    });\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n}\nfunction ptFunc(o, h, l, c) {\n  return {\n    o: o,\n    h: h,\n    l: l,\n    c: c\n  };\n}\n\n// shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\nfunction calcCommon(gd, trace, origX, x, ya, ptFunc) {\n  var o = ya.makeCalcdata(trace, 'open');\n  var h = ya.makeCalcdata(trace, 'high');\n  var l = ya.makeCalcdata(trace, 'low');\n  var c = ya.makeCalcdata(trace, 'close');\n  var hasTextArray = Lib.isArrayOrTypedArray(trace.text);\n  var hasHovertextArray = Lib.isArrayOrTypedArray(trace.hovertext);\n\n  // we're optimists - before we have any changing data, assume increasing\n  var increasing = true;\n  var cPrev = null;\n  var hasPeriod = !!trace.xperiodalignment;\n  var cd = [];\n  for (var i = 0; i < x.length; i++) {\n    var xi = x[i];\n    var oi = o[i];\n    var hi = h[i];\n    var li = l[i];\n    var ci = c[i];\n    if (xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n      if (ci === oi) {\n        // if open == close, look for a change from the previous close\n        if (cPrev !== null && ci !== cPrev) increasing = ci > cPrev;\n        // else (c === cPrev or cPrev is null) no change\n      } else increasing = ci > oi;\n      cPrev = ci;\n      var pt = ptFunc(oi, hi, li, ci);\n      pt.pos = xi;\n      pt.yc = (oi + ci) / 2;\n      pt.i = i;\n      pt.dir = increasing ? 'increasing' : 'decreasing';\n\n      // For categoryorder, store low and high\n      pt.x = pt.pos;\n      pt.y = [li, hi];\n      if (hasPeriod) pt.orig_p = origX[i]; // used by hover\n      if (hasTextArray) pt.tx = trace.text[i];\n      if (hasHovertextArray) pt.htx = trace.hovertext[i];\n      cd.push(pt);\n    } else {\n      cd.push({\n        pos: xi,\n        empty: true\n      });\n    }\n  }\n  trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {\n    padded: true\n  });\n  if (cd.length) {\n    cd[0].t = {\n      labels: {\n        open: _(gd, 'open:') + ' ',\n        high: _(gd, 'high:') + ' ',\n        low: _(gd, 'low:') + ' ',\n        close: _(gd, 'close:') + ' '\n      }\n    };\n  }\n  return cd;\n}\n\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc (and _origX) on the trace\n */\nfunction convertTickWidth(gd, xa, trace) {\n  var minDiff = trace._minDiff;\n  if (!minDiff) {\n    var fullData = gd._fullData;\n    var ohlcTracesOnThisXaxis = [];\n    minDiff = Infinity;\n    var i;\n    for (i = 0; i < fullData.length; i++) {\n      var tracei = fullData[i];\n      if (tracei.type === 'ohlc' && tracei.visible === true && tracei.xaxis === xa._id) {\n        ohlcTracesOnThisXaxis.push(tracei);\n        var origX = xa.makeCalcdata(tracei, 'x');\n        tracei._origX = origX;\n        var xcalc = alignPeriod(trace, xa, 'x', origX).vals;\n        tracei._xcalc = xcalc;\n        var _minDiff = Lib.distinctVals(xcalc).minDiff;\n        if (_minDiff && isFinite(_minDiff)) {\n          minDiff = Math.min(minDiff, _minDiff);\n        }\n      }\n    }\n\n    // if minDiff is still Infinity here, set it to 1\n    if (minDiff === Infinity) minDiff = 1;\n    for (i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n      ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n    }\n  }\n  return minDiff * trace.tickwidth;\n}\nmodule.exports = {\n  calc: calc,\n  calcCommon: calcCommon\n};","map":{"version":3,"names":["Lib","require","_","Axes","alignPeriod","BADNUM","calc","gd","trace","xa","getFromId","xaxis","ya","yaxis","tickLen","convertTickWidth","minDiff","_minDiff","origX","_origX","x","_xcalc","cd","calcCommon","ptFunc","_extremes","_id","findExtremes","vpad","length","extendFlat","t","wHover","empty","o","h","l","c","makeCalcdata","hasTextArray","isArrayOrTypedArray","text","hasHovertextArray","hovertext","increasing","cPrev","hasPeriod","xperiodalignment","i","xi","oi","hi","li","ci","pt","pos","yc","dir","y","orig_p","tx","htx","push","concat","padded","labels","open","high","low","close","fullData","_fullData","ohlcTracesOnThisXaxis","Infinity","tracei","type","visible","xcalc","vals","distinctVals","isFinite","Math","min","tickwidth","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/ohlc/calc.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar _ = Lib._;\nvar Axes = require('../../plots/cartesian/axes');\nvar alignPeriod = require('../../plots/cartesian/align_period');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis);\n    var ya = Axes.getFromId(gd, trace.yaxis);\n\n    var tickLen = convertTickWidth(gd, xa, trace);\n    var minDiff = trace._minDiff;\n    trace._minDiff = null;\n    var origX = trace._origX;\n    trace._origX = null;\n    var x = trace._xcalc;\n    trace._xcalc = null;\n\n    var cd = calcCommon(gd, trace, origX, x, ya, ptFunc);\n\n    trace._extremes[xa._id] = Axes.findExtremes(xa, x, {vpad: minDiff / 2});\n    if(cd.length) {\n        Lib.extendFlat(cd[0].t, {\n            wHover: minDiff / 2,\n            tickLen: tickLen\n        });\n        return cd;\n    } else {\n        return [{t: {empty: true}}];\n    }\n}\n\nfunction ptFunc(o, h, l, c) {\n    return {\n        o: o,\n        h: h,\n        l: l,\n        c: c\n    };\n}\n\n\n// shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\nfunction calcCommon(gd, trace, origX, x, ya, ptFunc) {\n    var o = ya.makeCalcdata(trace, 'open');\n    var h = ya.makeCalcdata(trace, 'high');\n    var l = ya.makeCalcdata(trace, 'low');\n    var c = ya.makeCalcdata(trace, 'close');\n\n    var hasTextArray = Lib.isArrayOrTypedArray(trace.text);\n    var hasHovertextArray = Lib.isArrayOrTypedArray(trace.hovertext);\n\n    // we're optimists - before we have any changing data, assume increasing\n    var increasing = true;\n    var cPrev = null;\n\n    var hasPeriod = !!trace.xperiodalignment;\n\n    var cd = [];\n    for(var i = 0; i < x.length; i++) {\n        var xi = x[i];\n        var oi = o[i];\n        var hi = h[i];\n        var li = l[i];\n        var ci = c[i];\n\n        if(xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n            if(ci === oi) {\n                // if open == close, look for a change from the previous close\n                if(cPrev !== null && ci !== cPrev) increasing = ci > cPrev;\n                // else (c === cPrev or cPrev is null) no change\n            } else increasing = ci > oi;\n\n            cPrev = ci;\n\n            var pt = ptFunc(oi, hi, li, ci);\n\n            pt.pos = xi;\n            pt.yc = (oi + ci) / 2;\n            pt.i = i;\n            pt.dir = increasing ? 'increasing' : 'decreasing';\n\n            // For categoryorder, store low and high\n            pt.x = pt.pos;\n            pt.y = [li, hi];\n\n            if(hasPeriod) pt.orig_p = origX[i]; // used by hover\n            if(hasTextArray) pt.tx = trace.text[i];\n            if(hasHovertextArray) pt.htx = trace.hovertext[i];\n\n            cd.push(pt);\n        } else {\n            cd.push({pos: xi, empty: true});\n        }\n    }\n\n    trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {padded: true});\n\n    if(cd.length) {\n        cd[0].t = {\n            labels: {\n                open: _(gd, 'open:') + ' ',\n                high: _(gd, 'high:') + ' ',\n                low: _(gd, 'low:') + ' ',\n                close: _(gd, 'close:') + ' '\n            }\n        };\n    }\n\n    return cd;\n}\n\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc (and _origX) on the trace\n */\nfunction convertTickWidth(gd, xa, trace) {\n    var minDiff = trace._minDiff;\n\n    if(!minDiff) {\n        var fullData = gd._fullData;\n        var ohlcTracesOnThisXaxis = [];\n\n        minDiff = Infinity;\n\n        var i;\n\n        for(i = 0; i < fullData.length; i++) {\n            var tracei = fullData[i];\n\n            if(tracei.type === 'ohlc' &&\n                tracei.visible === true &&\n                tracei.xaxis === xa._id\n            ) {\n                ohlcTracesOnThisXaxis.push(tracei);\n\n                var origX = xa.makeCalcdata(tracei, 'x');\n                tracei._origX = origX;\n\n                var xcalc = alignPeriod(trace, xa, 'x', origX).vals;\n                tracei._xcalc = xcalc;\n\n                var _minDiff = Lib.distinctVals(xcalc).minDiff;\n                if(_minDiff && isFinite(_minDiff)) {\n                    minDiff = Math.min(minDiff, _minDiff);\n                }\n            }\n        }\n\n        // if minDiff is still Infinity here, set it to 1\n        if(minDiff === Infinity) minDiff = 1;\n\n        for(i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n            ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n        }\n    }\n\n    return minDiff * trace.tickwidth;\n}\n\nmodule.exports = {\n    calc: calc,\n    calcCommon: calcCommon\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}