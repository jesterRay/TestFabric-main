{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar countryRegex = require('country-regex');\nvar {\n  area: turfArea\n} = require('@turf/area');\nvar {\n  centroid: turfCentroid\n} = require('@turf/centroid');\nvar {\n  bbox: turfBbox\n} = require('@turf/bbox');\nvar identity = require('./identity');\nvar loggers = require('./loggers');\nvar isPlainObject = require('./is_plain_object');\nvar nestedProperty = require('./nested_property');\nvar polygon = require('./polygon');\n\n// make list of all country iso3 ids from at runtime\nvar countryIds = Object.keys(countryRegex);\nvar locationmodeToIdFinder = {\n  'ISO-3': identity,\n  'USA-states': identity,\n  'country names': countryNameToISO3\n};\nfunction countryNameToISO3(countryName) {\n  for (var i = 0; i < countryIds.length; i++) {\n    var iso3 = countryIds[i];\n    var regex = new RegExp(countryRegex[iso3]);\n    if (regex.test(countryName.trim().toLowerCase())) return iso3;\n  }\n  loggers.log('Unrecognized country name: ' + countryName + '.');\n  return false;\n}\nfunction locationToFeature(locationmode, location, features) {\n  if (!location || typeof location !== 'string') return false;\n  var locationId = locationmodeToIdFinder[locationmode](location);\n  var filteredFeatures;\n  var f, i;\n  if (locationId) {\n    if (locationmode === 'USA-states') {\n      // Filter out features out in USA\n      //\n      // This is important as the Natural Earth files\n      // include state/provinces from USA, Canada, Australia and Brazil\n      // which have some overlay in their two-letter ids. For example,\n      // 'WA' is used for both Washington state and Western Australia.\n      filteredFeatures = [];\n      for (i = 0; i < features.length; i++) {\n        f = features[i];\n        if (f.properties && f.properties.gu && f.properties.gu === 'USA') {\n          filteredFeatures.push(f);\n        }\n      }\n    } else {\n      filteredFeatures = features;\n    }\n    for (i = 0; i < filteredFeatures.length; i++) {\n      f = filteredFeatures[i];\n      if (f.id === locationId) return f;\n    }\n    loggers.log(['Location with id', locationId, 'does not have a matching topojson feature at this resolution.'].join(' '));\n  }\n  return false;\n}\nfunction feature2polygons(feature) {\n  var geometry = feature.geometry;\n  var coords = geometry.coordinates;\n  var loc = feature.id;\n  var polygons = [];\n  var appendPolygon, j, k, m;\n  function doesCrossAntiMerdian(pts) {\n    for (var l = 0; l < pts.length - 1; l++) {\n      if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n    }\n    return null;\n  }\n  if (loc === 'RUS' || loc === 'FJI') {\n    // Russia and Fiji have landmasses that cross the antimeridian,\n    // we need to add +360 to their longitude coordinates, so that\n    // polygon 'contains' doesn't get confused when crossing the antimeridian.\n    //\n    // Note that other countries have polygons on either side of the antimeridian\n    // (e.g. some Aleutian island for the USA), but those don't confuse\n    // the 'contains' method; these are skipped here.\n    appendPolygon = function (_pts) {\n      var pts;\n      if (doesCrossAntiMerdian(_pts) === null) {\n        pts = _pts;\n      } else {\n        pts = new Array(_pts.length);\n        for (m = 0; m < _pts.length; m++) {\n          // do not mutate calcdata[i][j].geojson !!\n          pts[m] = [_pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0], _pts[m][1]];\n        }\n      }\n      polygons.push(polygon.tester(pts));\n    };\n  } else if (loc === 'ATA') {\n    // Antarctica has a landmass that wraps around every longitudes which\n    // confuses the 'contains' methods.\n    appendPolygon = function (pts) {\n      var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n      // polygon that do not cross anti-meridian need no special handling\n      if (crossAntiMeridianIndex === null) {\n        return polygons.push(polygon.tester(pts));\n      }\n\n      // stitch polygon by adding pt over South Pole,\n      // so that it covers the projected region covers all latitudes\n      //\n      // Note that the algorithm below only works for polygons that\n      // start and end on longitude -180 (like the ones built by\n      // https://github.com/etpinard/sane-topojson).\n      var stitch = new Array(pts.length + 1);\n      var si = 0;\n      for (m = 0; m < pts.length; m++) {\n        if (m > crossAntiMeridianIndex) {\n          stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n        } else if (m === crossAntiMeridianIndex) {\n          stitch[si++] = pts[m];\n          stitch[si++] = [pts[m][0], -90];\n        } else {\n          stitch[si++] = pts[m];\n        }\n      }\n\n      // polygon.tester by default appends pt[0] to the points list,\n      // we must remove it here, to avoid a jump in longitude from 180 to -180,\n      // that would confuse the 'contains' method\n      var tester = polygon.tester(stitch);\n      tester.pts.pop();\n      polygons.push(tester);\n    };\n  } else {\n    // otherwise using same array ref is fine\n    appendPolygon = function (pts) {\n      polygons.push(polygon.tester(pts));\n    };\n  }\n  switch (geometry.type) {\n    case 'MultiPolygon':\n      for (j = 0; j < coords.length; j++) {\n        for (k = 0; k < coords[j].length; k++) {\n          appendPolygon(coords[j][k]);\n        }\n      }\n      break;\n    case 'Polygon':\n      for (j = 0; j < coords.length; j++) {\n        appendPolygon(coords[j]);\n      }\n      break;\n  }\n  return polygons;\n}\nfunction getTraceGeojson(trace) {\n  var g = trace.geojson;\n  var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n  var geojsonIn = typeof g === 'string' ? PlotlyGeoAssets[g] : g;\n\n  // This should not happen, but just in case something goes\n  // really wrong when fetching the GeoJSON\n  if (!isPlainObject(geojsonIn)) {\n    loggers.error('Oops ... something went wrong when fetching ' + g);\n    return false;\n  }\n  return geojsonIn;\n}\nfunction extractTraceFeature(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var geojsonIn = getTraceGeojson(trace);\n  if (!geojsonIn) return false;\n  var lookup = {};\n  var featuresOut = [];\n  var i;\n  for (i = 0; i < trace._length; i++) {\n    var cdi = calcTrace[i];\n    if (cdi.loc || cdi.loc === 0) {\n      lookup[cdi.loc] = cdi;\n    }\n  }\n  function appendFeature(fIn) {\n    var id = nestedProperty(fIn, trace.featureidkey || 'id').get();\n    var cdi = lookup[id];\n    if (cdi) {\n      var geometry = fIn.geometry;\n      if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n        var fOut = {\n          type: 'Feature',\n          id: id,\n          geometry: geometry,\n          properties: {}\n        };\n\n        // Compute centroid, add it to the properties\n        if (fOut.geometry.coordinates.length > 0) {\n          fOut.properties.ct = findCentroid(fOut);\n        } else {\n          fOut.properties.ct = [NaN, NaN];\n        }\n\n        // Mutate in in/out features into calcdata\n        cdi.fIn = fIn;\n        cdi.fOut = fOut;\n        featuresOut.push(fOut);\n      } else {\n        loggers.log(['Location', cdi.loc, 'does not have a valid GeoJSON geometry.', 'Traces with locationmode *geojson-id* only support', '*Polygon* and *MultiPolygon* geometries.'].join(' '));\n      }\n    }\n\n    // remove key from lookup, so that we can track (if any)\n    // the locations that did not have a corresponding GeoJSON feature\n    delete lookup[id];\n  }\n  switch (geojsonIn.type) {\n    case 'FeatureCollection':\n      var featuresIn = geojsonIn.features;\n      for (i = 0; i < featuresIn.length; i++) {\n        appendFeature(featuresIn[i]);\n      }\n      break;\n    case 'Feature':\n      appendFeature(geojsonIn);\n      break;\n    default:\n      loggers.warn(['Invalid GeoJSON type', (geojsonIn.type || 'none') + '.', 'Traces with locationmode *geojson-id* only support', '*FeatureCollection* and *Feature* types.'].join(' '));\n      return false;\n  }\n  for (var loc in lookup) {\n    loggers.log(['Location *' + loc + '*', 'does not have a matching feature with id-key', '*' + trace.featureidkey + '*.'].join(' '));\n  }\n  return featuresOut;\n}\n\n// TODO this find the centroid of the polygon of maxArea\n// (just like we currently do for geo choropleth polygons),\n// maybe instead it would make more sense to compute the centroid\n// of each polygon and consider those on hover/select\nfunction findCentroid(feature) {\n  var geometry = feature.geometry;\n  var poly;\n  if (geometry.type === 'MultiPolygon') {\n    var coords = geometry.coordinates;\n    var maxArea = 0;\n    for (var i = 0; i < coords.length; i++) {\n      var polyi = {\n        type: 'Polygon',\n        coordinates: coords[i]\n      };\n      var area = turfArea(polyi);\n      if (area > maxArea) {\n        maxArea = area;\n        poly = polyi;\n      }\n    }\n  } else {\n    poly = geometry;\n  }\n  return turfCentroid(poly).geometry.coordinates;\n}\nfunction fetchTraceGeoData(calcData) {\n  var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n  var promises = [];\n  function fetch(url) {\n    return new Promise(function (resolve, reject) {\n      d3.json(url, function (err, d) {\n        if (err) {\n          delete PlotlyGeoAssets[url];\n          var msg = err.status === 404 ? 'GeoJSON at URL \"' + url + '\" does not exist.' : 'Unexpected error while fetching from ' + url;\n          return reject(new Error(msg));\n        }\n        PlotlyGeoAssets[url] = d;\n        return resolve(d);\n      });\n    });\n  }\n  function wait(url) {\n    return new Promise(function (resolve, reject) {\n      var cnt = 0;\n      var interval = setInterval(function () {\n        if (PlotlyGeoAssets[url] && PlotlyGeoAssets[url] !== 'pending') {\n          clearInterval(interval);\n          return resolve(PlotlyGeoAssets[url]);\n        }\n        if (cnt > 100) {\n          clearInterval(interval);\n          return reject('Unexpected error while fetching from ' + url);\n        }\n        cnt++;\n      }, 50);\n    });\n  }\n  for (var i = 0; i < calcData.length; i++) {\n    var trace = calcData[i][0].trace;\n    var url = trace.geojson;\n    if (typeof url === 'string') {\n      if (!PlotlyGeoAssets[url]) {\n        PlotlyGeoAssets[url] = 'pending';\n        promises.push(fetch(url));\n      } else if (PlotlyGeoAssets[url] === 'pending') {\n        promises.push(wait(url));\n      }\n    }\n  }\n  return promises;\n}\n\n// TODO `turf/bbox` gives wrong result when the input feature/geometry\n// crosses the anti-meridian. We should try to implement our own bbox logic.\nfunction computeBbox(d) {\n  return turfBbox(d);\n}\nmodule.exports = {\n  locationToFeature: locationToFeature,\n  feature2polygons: feature2polygons,\n  getTraceGeojson: getTraceGeojson,\n  extractTraceFeature: extractTraceFeature,\n  fetchTraceGeoData: fetchTraceGeoData,\n  computeBbox: computeBbox\n};","map":{"version":3,"names":["d3","require","countryRegex","area","turfArea","centroid","turfCentroid","bbox","turfBbox","identity","loggers","isPlainObject","nestedProperty","polygon","countryIds","Object","keys","locationmodeToIdFinder","countryNameToISO3","countryName","i","length","iso3","regex","RegExp","test","trim","toLowerCase","log","locationToFeature","locationmode","location","features","locationId","filteredFeatures","f","properties","gu","push","id","join","feature2polygons","feature","geometry","coords","coordinates","loc","polygons","appendPolygon","j","k","m","doesCrossAntiMerdian","pts","l","_pts","Array","tester","crossAntiMeridianIndex","stitch","si","pop","type","getTraceGeojson","trace","g","geojson","PlotlyGeoAssets","window","geojsonIn","error","extractTraceFeature","calcTrace","lookup","featuresOut","_length","cdi","appendFeature","fIn","featureidkey","get","fOut","ct","findCentroid","NaN","featuresIn","warn","poly","maxArea","polyi","fetchTraceGeoData","calcData","promises","fetch","url","Promise","resolve","reject","json","err","d","msg","status","Error","wait","cnt","interval","setInterval","clearInterval","computeBbox","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/lib/geo_location_utils.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar countryRegex = require('country-regex');\nvar { area: turfArea } = require('@turf/area');\nvar { centroid: turfCentroid } = require('@turf/centroid');\nvar { bbox: turfBbox } = require('@turf/bbox');\n\nvar identity = require('./identity');\nvar loggers = require('./loggers');\nvar isPlainObject = require('./is_plain_object');\nvar nestedProperty = require('./nested_property');\nvar polygon = require('./polygon');\n\n// make list of all country iso3 ids from at runtime\nvar countryIds = Object.keys(countryRegex);\n\nvar locationmodeToIdFinder = {\n    'ISO-3': identity,\n    'USA-states': identity,\n    'country names': countryNameToISO3\n};\n\nfunction countryNameToISO3(countryName) {\n    for(var i = 0; i < countryIds.length; i++) {\n        var iso3 = countryIds[i];\n        var regex = new RegExp(countryRegex[iso3]);\n\n        if(regex.test(countryName.trim().toLowerCase())) return iso3;\n    }\n\n    loggers.log('Unrecognized country name: ' + countryName + '.');\n\n    return false;\n}\n\nfunction locationToFeature(locationmode, location, features) {\n    if(!location || typeof location !== 'string') return false;\n\n    var locationId = locationmodeToIdFinder[locationmode](location);\n    var filteredFeatures;\n    var f, i;\n\n    if(locationId) {\n        if(locationmode === 'USA-states') {\n            // Filter out features out in USA\n            //\n            // This is important as the Natural Earth files\n            // include state/provinces from USA, Canada, Australia and Brazil\n            // which have some overlay in their two-letter ids. For example,\n            // 'WA' is used for both Washington state and Western Australia.\n            filteredFeatures = [];\n            for(i = 0; i < features.length; i++) {\n                f = features[i];\n                if(f.properties && f.properties.gu && f.properties.gu === 'USA') {\n                    filteredFeatures.push(f);\n                }\n            }\n        } else {\n            filteredFeatures = features;\n        }\n\n        for(i = 0; i < filteredFeatures.length; i++) {\n            f = filteredFeatures[i];\n            if(f.id === locationId) return f;\n        }\n\n        loggers.log([\n            'Location with id', locationId,\n            'does not have a matching topojson feature at this resolution.'\n        ].join(' '));\n    }\n\n    return false;\n}\n\nfunction feature2polygons(feature) {\n    var geometry = feature.geometry;\n    var coords = geometry.coordinates;\n    var loc = feature.id;\n\n    var polygons = [];\n    var appendPolygon, j, k, m;\n\n    function doesCrossAntiMerdian(pts) {\n        for(var l = 0; l < pts.length - 1; l++) {\n            if(pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n        }\n        return null;\n    }\n\n    if(loc === 'RUS' || loc === 'FJI') {\n        // Russia and Fiji have landmasses that cross the antimeridian,\n        // we need to add +360 to their longitude coordinates, so that\n        // polygon 'contains' doesn't get confused when crossing the antimeridian.\n        //\n        // Note that other countries have polygons on either side of the antimeridian\n        // (e.g. some Aleutian island for the USA), but those don't confuse\n        // the 'contains' method; these are skipped here.\n        appendPolygon = function(_pts) {\n            var pts;\n\n            if(doesCrossAntiMerdian(_pts) === null) {\n                pts = _pts;\n            } else {\n                pts = new Array(_pts.length);\n                for(m = 0; m < _pts.length; m++) {\n                    // do not mutate calcdata[i][j].geojson !!\n                    pts[m] = [\n                        _pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0],\n                        _pts[m][1]\n                    ];\n                }\n            }\n\n            polygons.push(polygon.tester(pts));\n        };\n    } else if(loc === 'ATA') {\n        // Antarctica has a landmass that wraps around every longitudes which\n        // confuses the 'contains' methods.\n        appendPolygon = function(pts) {\n            var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n            // polygon that do not cross anti-meridian need no special handling\n            if(crossAntiMeridianIndex === null) {\n                return polygons.push(polygon.tester(pts));\n            }\n\n            // stitch polygon by adding pt over South Pole,\n            // so that it covers the projected region covers all latitudes\n            //\n            // Note that the algorithm below only works for polygons that\n            // start and end on longitude -180 (like the ones built by\n            // https://github.com/etpinard/sane-topojson).\n            var stitch = new Array(pts.length + 1);\n            var si = 0;\n\n            for(m = 0; m < pts.length; m++) {\n                if(m > crossAntiMeridianIndex) {\n                    stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n                } else if(m === crossAntiMeridianIndex) {\n                    stitch[si++] = pts[m];\n                    stitch[si++] = [pts[m][0], -90];\n                } else {\n                    stitch[si++] = pts[m];\n                }\n            }\n\n            // polygon.tester by default appends pt[0] to the points list,\n            // we must remove it here, to avoid a jump in longitude from 180 to -180,\n            // that would confuse the 'contains' method\n            var tester = polygon.tester(stitch);\n            tester.pts.pop();\n            polygons.push(tester);\n        };\n    } else {\n        // otherwise using same array ref is fine\n        appendPolygon = function(pts) {\n            polygons.push(polygon.tester(pts));\n        };\n    }\n\n    switch(geometry.type) {\n        case 'MultiPolygon':\n            for(j = 0; j < coords.length; j++) {\n                for(k = 0; k < coords[j].length; k++) {\n                    appendPolygon(coords[j][k]);\n                }\n            }\n            break;\n        case 'Polygon':\n            for(j = 0; j < coords.length; j++) {\n                appendPolygon(coords[j]);\n            }\n            break;\n    }\n\n    return polygons;\n}\n\nfunction getTraceGeojson(trace) {\n    var g = trace.geojson;\n    var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n    var geojsonIn = typeof g === 'string' ? PlotlyGeoAssets[g] : g;\n\n    // This should not happen, but just in case something goes\n    // really wrong when fetching the GeoJSON\n    if(!isPlainObject(geojsonIn)) {\n        loggers.error('Oops ... something went wrong when fetching ' + g);\n        return false;\n    }\n\n    return geojsonIn;\n}\n\nfunction extractTraceFeature(calcTrace) {\n    var trace = calcTrace[0].trace;\n\n    var geojsonIn = getTraceGeojson(trace);\n    if(!geojsonIn) return false;\n\n    var lookup = {};\n    var featuresOut = [];\n    var i;\n\n    for(i = 0; i < trace._length; i++) {\n        var cdi = calcTrace[i];\n        if(cdi.loc || cdi.loc === 0) {\n            lookup[cdi.loc] = cdi;\n        }\n    }\n\n    function appendFeature(fIn) {\n        var id = nestedProperty(fIn, trace.featureidkey || 'id').get();\n        var cdi = lookup[id];\n\n        if(cdi) {\n            var geometry = fIn.geometry;\n\n            if(geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n                var fOut = {\n                    type: 'Feature',\n                    id: id,\n                    geometry: geometry,\n                    properties: {}\n                };\n\n                // Compute centroid, add it to the properties\n                if (fOut.geometry.coordinates.length > 0) {\n                    fOut.properties.ct = findCentroid(fOut);\n                } else {\n                    fOut.properties.ct = [NaN, NaN];\n                }\n\n                // Mutate in in/out features into calcdata\n                cdi.fIn = fIn;\n                cdi.fOut = fOut;\n\n                featuresOut.push(fOut);\n            } else {\n                loggers.log([\n                    'Location', cdi.loc, 'does not have a valid GeoJSON geometry.',\n                    'Traces with locationmode *geojson-id* only support',\n                    '*Polygon* and *MultiPolygon* geometries.'\n                ].join(' '));\n            }\n        }\n\n        // remove key from lookup, so that we can track (if any)\n        // the locations that did not have a corresponding GeoJSON feature\n        delete lookup[id];\n    }\n\n    switch(geojsonIn.type) {\n        case 'FeatureCollection':\n            var featuresIn = geojsonIn.features;\n            for(i = 0; i < featuresIn.length; i++) {\n                appendFeature(featuresIn[i]);\n            }\n            break;\n        case 'Feature':\n            appendFeature(geojsonIn);\n            break;\n        default:\n            loggers.warn([\n                'Invalid GeoJSON type', (geojsonIn.type || 'none') + '.',\n                'Traces with locationmode *geojson-id* only support',\n                '*FeatureCollection* and *Feature* types.'\n            ].join(' '));\n            return false;\n    }\n\n    for(var loc in lookup) {\n        loggers.log([\n            'Location *' + loc + '*',\n            'does not have a matching feature with id-key',\n            '*' + trace.featureidkey + '*.'\n        ].join(' '));\n    }\n\n    return featuresOut;\n}\n\n// TODO this find the centroid of the polygon of maxArea\n// (just like we currently do for geo choropleth polygons),\n// maybe instead it would make more sense to compute the centroid\n// of each polygon and consider those on hover/select\nfunction findCentroid(feature) {\n    var geometry = feature.geometry;\n    var poly;\n\n    if(geometry.type === 'MultiPolygon') {\n        var coords = geometry.coordinates;\n        var maxArea = 0;\n\n        for(var i = 0; i < coords.length; i++) {\n            var polyi = {type: 'Polygon', coordinates: coords[i]};\n            var area = turfArea(polyi);\n            if(area > maxArea) {\n                maxArea = area;\n                poly = polyi;\n            }\n        }\n    } else {\n        poly = geometry;\n    }\n\n    return turfCentroid(poly).geometry.coordinates;\n}\n\nfunction fetchTraceGeoData(calcData) {\n    var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n    var promises = [];\n\n    function fetch(url) {\n        return new Promise(function(resolve, reject) {\n            d3.json(url, function(err, d) {\n                if(err) {\n                    delete PlotlyGeoAssets[url];\n                    var msg = err.status === 404 ?\n                        ('GeoJSON at URL \"' + url + '\" does not exist.') :\n                        ('Unexpected error while fetching from ' + url);\n                    return reject(new Error(msg));\n                }\n\n                PlotlyGeoAssets[url] = d;\n                return resolve(d);\n            });\n        });\n    }\n\n    function wait(url) {\n        return new Promise(function(resolve, reject) {\n            var cnt = 0;\n            var interval = setInterval(function() {\n                if(PlotlyGeoAssets[url] && PlotlyGeoAssets[url] !== 'pending') {\n                    clearInterval(interval);\n                    return resolve(PlotlyGeoAssets[url]);\n                }\n                if(cnt > 100) {\n                    clearInterval(interval);\n                    return reject('Unexpected error while fetching from ' + url);\n                }\n                cnt++;\n            }, 50);\n        });\n    }\n\n    for(var i = 0; i < calcData.length; i++) {\n        var trace = calcData[i][0].trace;\n        var url = trace.geojson;\n\n        if(typeof url === 'string') {\n            if(!PlotlyGeoAssets[url]) {\n                PlotlyGeoAssets[url] = 'pending';\n                promises.push(fetch(url));\n            } else if(PlotlyGeoAssets[url] === 'pending') {\n                promises.push(wait(url));\n            }\n        }\n    }\n\n    return promises;\n}\n\n// TODO `turf/bbox` gives wrong result when the input feature/geometry\n// crosses the anti-meridian. We should try to implement our own bbox logic.\nfunction computeBbox(d) {\n    return turfBbox(d);\n}\n\nmodule.exports = {\n    locationToFeature: locationToFeature,\n    feature2polygons: feature2polygons,\n    getTraceGeojson: getTraceGeojson,\n    extractTraceFeature: extractTraceFeature,\n    fetchTraceGeoData: fetchTraceGeoData,\n    computeBbox: computeBbox\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}