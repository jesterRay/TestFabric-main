{"ast":null,"code":"'use strict';\n\nvar c = require('./constants');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar isNumeric = require('fast-isnumeric');\nvar isTypedArray = require('../../lib/array').isTypedArray;\nvar isArrayOrTypedArray = require('../../lib/array').isArrayOrTypedArray;\n\n// pure functions, don't alter but passes on `gd` and parts of `trace` without deep copying\nmodule.exports = function calc(gd, trace) {\n  var cellsValues = squareStringMatrix(trace.cells.values);\n  var slicer = function (a) {\n    return a.slice(trace.header.values.length, a.length);\n  };\n  var headerValuesIn = squareStringMatrix(trace.header.values);\n  if (headerValuesIn.length && !headerValuesIn[0].length) {\n    headerValuesIn[0] = [''];\n    headerValuesIn = squareStringMatrix(headerValuesIn);\n  }\n  var headerValues = headerValuesIn.concat(slicer(cellsValues).map(function () {\n    return emptyStrings((headerValuesIn[0] || ['']).length);\n  }));\n  var domain = trace.domain;\n  var groupWidth = Math.floor(gd._fullLayout._size.w * (domain.x[1] - domain.x[0]));\n  var groupHeight = Math.floor(gd._fullLayout._size.h * (domain.y[1] - domain.y[0]));\n  var headerRowHeights = trace.header.values.length ? headerValues[0].map(function () {\n    return trace.header.height;\n  }) : [c.emptyHeaderHeight];\n  var rowHeights = cellsValues.length ? cellsValues[0].map(function () {\n    return trace.cells.height;\n  }) : [];\n  var headerHeight = headerRowHeights.reduce(sum, 0);\n  var scrollHeight = groupHeight - headerHeight;\n  var minimumFillHeight = scrollHeight + c.uplift;\n  var anchorToRowBlock = makeAnchorToRowBlock(rowHeights, minimumFillHeight);\n  var anchorToHeaderRowBlock = makeAnchorToRowBlock(headerRowHeights, headerHeight);\n  var headerRowBlocks = makeRowBlock(anchorToHeaderRowBlock, []);\n  var rowBlocks = makeRowBlock(anchorToRowBlock, headerRowBlocks);\n  var uniqueKeys = {};\n  var columnOrder = trace._fullInput.columnorder;\n  if (isArrayOrTypedArray(columnOrder)) columnOrder = Array.from(columnOrder);\n  columnOrder = columnOrder.concat(slicer(cellsValues.map(function (d, i) {\n    return i;\n  })));\n  var columnWidths = headerValues.map(function (d, i) {\n    var value = isArrayOrTypedArray(trace.columnwidth) ? trace.columnwidth[Math.min(i, trace.columnwidth.length - 1)] : trace.columnwidth;\n    return isNumeric(value) ? Number(value) : 1;\n  });\n  var totalColumnWidths = columnWidths.reduce(sum, 0);\n\n  // fit columns in the available vertical space as there's no vertical scrolling now\n  columnWidths = columnWidths.map(function (d) {\n    return d / totalColumnWidths * groupWidth;\n  });\n  var maxLineWidth = Math.max(arrayMax(trace.header.line.width), arrayMax(trace.cells.line.width));\n  var calcdata = {\n    // include staticPlot in the key so if it changes we delete and redraw\n    key: trace.uid + gd._context.staticPlot,\n    translateX: domain.x[0] * gd._fullLayout._size.w,\n    translateY: gd._fullLayout._size.h * (1 - domain.y[1]),\n    size: gd._fullLayout._size,\n    width: groupWidth,\n    maxLineWidth: maxLineWidth,\n    height: groupHeight,\n    columnOrder: columnOrder,\n    // will be mutated on column move, todo use in callback\n    groupHeight: groupHeight,\n    rowBlocks: rowBlocks,\n    headerRowBlocks: headerRowBlocks,\n    scrollY: 0,\n    // will be mutated on scroll\n    cells: extendFlat({}, trace.cells, {\n      values: cellsValues\n    }),\n    headerCells: extendFlat({}, trace.header, {\n      values: headerValues\n    }),\n    gdColumns: headerValues.map(function (d) {\n      return d[0];\n    }),\n    gdColumnsOriginalOrder: headerValues.map(function (d) {\n      return d[0];\n    }),\n    prevPages: [0, 0],\n    scrollbarState: {\n      scrollbarScrollInProgress: false\n    },\n    columns: headerValues.map(function (label, i) {\n      var foundKey = uniqueKeys[label];\n      uniqueKeys[label] = (foundKey || 0) + 1;\n      var key = label + '__' + uniqueKeys[label];\n      return {\n        key: key,\n        label: label,\n        specIndex: i,\n        xIndex: columnOrder[i],\n        xScale: xScale,\n        x: undefined,\n        // initialized below\n        calcdata: undefined,\n        // initialized below\n        columnWidth: columnWidths[i]\n      };\n    })\n  };\n  calcdata.columns.forEach(function (col) {\n    col.calcdata = calcdata;\n    col.x = xScale(col);\n  });\n  return calcdata;\n};\nfunction arrayMax(maybeArray) {\n  if (isArrayOrTypedArray(maybeArray)) {\n    var max = 0;\n    for (var i = 0; i < maybeArray.length; i++) {\n      max = Math.max(max, arrayMax(maybeArray[i]));\n    }\n    return max;\n  }\n  return maybeArray;\n}\nfunction sum(a, b) {\n  return a + b;\n}\n\n// fill matrix in place to equal lengths\n// and ensure it's uniformly 2D\nfunction squareStringMatrix(matrixIn) {\n  var matrix = matrixIn.slice();\n  var minLen = Infinity;\n  var maxLen = 0;\n  var i;\n  for (i = 0; i < matrix.length; i++) {\n    if (isTypedArray(matrix[i])) matrix[i] = Array.from(matrix[i]);else if (!isArrayOrTypedArray(matrix[i])) matrix[i] = [matrix[i]];\n    minLen = Math.min(minLen, matrix[i].length);\n    maxLen = Math.max(maxLen, matrix[i].length);\n  }\n  if (minLen !== maxLen) {\n    for (i = 0; i < matrix.length; i++) {\n      var padLen = maxLen - matrix[i].length;\n      if (padLen) matrix[i] = matrix[i].concat(emptyStrings(padLen));\n    }\n  }\n  return matrix;\n}\nfunction emptyStrings(len) {\n  var padArray = new Array(len);\n  for (var j = 0; j < len; j++) padArray[j] = '';\n  return padArray;\n}\nfunction xScale(d) {\n  return d.calcdata.columns.reduce(function (prev, next) {\n    return next.xIndex < d.xIndex ? prev + next.columnWidth : prev;\n  }, 0);\n}\nfunction makeRowBlock(anchorToRowBlock, auxiliary) {\n  var blockAnchorKeys = Object.keys(anchorToRowBlock);\n  return blockAnchorKeys.map(function (k) {\n    return extendFlat({}, anchorToRowBlock[k], {\n      auxiliaryBlocks: auxiliary\n    });\n  });\n}\nfunction makeAnchorToRowBlock(rowHeights, minimumFillHeight) {\n  var anchorToRowBlock = {};\n  var currentRowHeight;\n  var currentAnchor = 0;\n  var currentBlockHeight = 0;\n  var currentBlock = makeIdentity();\n  var currentFirstRowIndex = 0;\n  var blockCounter = 0;\n  for (var i = 0; i < rowHeights.length; i++) {\n    currentRowHeight = rowHeights[i];\n    currentBlock.rows.push({\n      rowIndex: i,\n      rowHeight: currentRowHeight\n    });\n    currentBlockHeight += currentRowHeight;\n    if (currentBlockHeight >= minimumFillHeight || i === rowHeights.length - 1) {\n      anchorToRowBlock[currentAnchor] = currentBlock;\n      currentBlock.key = blockCounter++;\n      currentBlock.firstRowIndex = currentFirstRowIndex;\n      currentBlock.lastRowIndex = i;\n      currentBlock = makeIdentity();\n      currentAnchor += currentBlockHeight;\n      currentFirstRowIndex = i + 1;\n      currentBlockHeight = 0;\n    }\n  }\n  return anchorToRowBlock;\n}\nfunction makeIdentity() {\n  return {\n    firstRowIndex: null,\n    lastRowIndex: null,\n    rows: []\n  };\n}","map":{"version":3,"names":["c","require","extendFlat","isNumeric","isTypedArray","isArrayOrTypedArray","module","exports","calc","gd","trace","cellsValues","squareStringMatrix","cells","values","slicer","a","slice","header","length","headerValuesIn","headerValues","concat","map","emptyStrings","domain","groupWidth","Math","floor","_fullLayout","_size","w","x","groupHeight","h","y","headerRowHeights","height","emptyHeaderHeight","rowHeights","headerHeight","reduce","sum","scrollHeight","minimumFillHeight","uplift","anchorToRowBlock","makeAnchorToRowBlock","anchorToHeaderRowBlock","headerRowBlocks","makeRowBlock","rowBlocks","uniqueKeys","columnOrder","_fullInput","columnorder","Array","from","d","i","columnWidths","value","columnwidth","min","Number","totalColumnWidths","maxLineWidth","max","arrayMax","line","width","calcdata","key","uid","_context","staticPlot","translateX","translateY","size","scrollY","headerCells","gdColumns","gdColumnsOriginalOrder","prevPages","scrollbarState","scrollbarScrollInProgress","columns","label","foundKey","specIndex","xIndex","xScale","undefined","columnWidth","forEach","col","maybeArray","b","matrixIn","matrix","minLen","Infinity","maxLen","padLen","len","padArray","j","prev","next","auxiliary","blockAnchorKeys","Object","keys","k","auxiliaryBlocks","currentRowHeight","currentAnchor","currentBlockHeight","currentBlock","makeIdentity","currentFirstRowIndex","blockCounter","rows","push","rowIndex","rowHeight","firstRowIndex","lastRowIndex"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/table/data_preparation_helper.js"],"sourcesContent":["'use strict';\n\nvar c = require('./constants');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar isNumeric = require('fast-isnumeric');\nvar isTypedArray = require('../../lib/array').isTypedArray;\nvar isArrayOrTypedArray = require('../../lib/array').isArrayOrTypedArray;\n\n// pure functions, don't alter but passes on `gd` and parts of `trace` without deep copying\nmodule.exports = function calc(gd, trace) {\n    var cellsValues = squareStringMatrix(trace.cells.values);\n    var slicer = function(a) {\n        return a.slice(trace.header.values.length, a.length);\n    };\n    var headerValuesIn = squareStringMatrix(trace.header.values);\n    if(headerValuesIn.length && !headerValuesIn[0].length) {\n        headerValuesIn[0] = [''];\n        headerValuesIn = squareStringMatrix(headerValuesIn);\n    }\n    var headerValues = headerValuesIn\n        .concat(slicer(cellsValues).map(function() {\n            return emptyStrings((headerValuesIn[0] || ['']).length);\n        }));\n\n    var domain = trace.domain;\n    var groupWidth = Math.floor(gd._fullLayout._size.w * (domain.x[1] - domain.x[0]));\n    var groupHeight = Math.floor(gd._fullLayout._size.h * (domain.y[1] - domain.y[0]));\n    var headerRowHeights = trace.header.values.length ?\n        headerValues[0].map(function() { return trace.header.height; }) :\n        [c.emptyHeaderHeight];\n    var rowHeights = cellsValues.length ? cellsValues[0].map(function() { return trace.cells.height; }) : [];\n    var headerHeight = headerRowHeights.reduce(sum, 0);\n    var scrollHeight = groupHeight - headerHeight;\n    var minimumFillHeight = scrollHeight + c.uplift;\n    var anchorToRowBlock = makeAnchorToRowBlock(rowHeights, minimumFillHeight);\n    var anchorToHeaderRowBlock = makeAnchorToRowBlock(headerRowHeights, headerHeight);\n    var headerRowBlocks = makeRowBlock(anchorToHeaderRowBlock, []);\n    var rowBlocks = makeRowBlock(anchorToRowBlock, headerRowBlocks);\n    var uniqueKeys = {};\n\n    var columnOrder = trace._fullInput.columnorder;\n    if(isArrayOrTypedArray(columnOrder)) columnOrder = Array.from(columnOrder);\n    columnOrder = columnOrder.concat(slicer(cellsValues.map(function(d, i) {return i;})));\n\n    var columnWidths = headerValues.map(function(d, i) {\n        var value = isArrayOrTypedArray(trace.columnwidth) ?\n            trace.columnwidth[Math.min(i, trace.columnwidth.length - 1)] :\n            trace.columnwidth;\n        return isNumeric(value) ? Number(value) : 1;\n    });\n    var totalColumnWidths = columnWidths.reduce(sum, 0);\n\n    // fit columns in the available vertical space as there's no vertical scrolling now\n    columnWidths = columnWidths.map(function(d) { return d / totalColumnWidths * groupWidth; });\n\n    var maxLineWidth = Math.max(arrayMax(trace.header.line.width), arrayMax(trace.cells.line.width));\n\n    var calcdata = {\n        // include staticPlot in the key so if it changes we delete and redraw\n        key: trace.uid + gd._context.staticPlot,\n        translateX: domain.x[0] * gd._fullLayout._size.w,\n        translateY: gd._fullLayout._size.h * (1 - domain.y[1]),\n        size: gd._fullLayout._size,\n        width: groupWidth,\n        maxLineWidth: maxLineWidth,\n        height: groupHeight,\n        columnOrder: columnOrder, // will be mutated on column move, todo use in callback\n        groupHeight: groupHeight,\n        rowBlocks: rowBlocks,\n        headerRowBlocks: headerRowBlocks,\n        scrollY: 0, // will be mutated on scroll\n        cells: extendFlat({}, trace.cells, {values: cellsValues}),\n        headerCells: extendFlat({}, trace.header, {values: headerValues}),\n        gdColumns: headerValues.map(function(d) {return d[0];}),\n        gdColumnsOriginalOrder: headerValues.map(function(d) {return d[0];}),\n        prevPages: [0, 0],\n        scrollbarState: {scrollbarScrollInProgress: false},\n        columns: headerValues.map(function(label, i) {\n            var foundKey = uniqueKeys[label];\n            uniqueKeys[label] = (foundKey || 0) + 1;\n            var key = label + '__' + uniqueKeys[label];\n            return {\n                key: key,\n                label: label,\n                specIndex: i,\n                xIndex: columnOrder[i],\n                xScale: xScale,\n                x: undefined, // initialized below\n                calcdata: undefined, // initialized below\n                columnWidth: columnWidths[i]\n            };\n        })\n    };\n\n    calcdata.columns.forEach(function(col) {\n        col.calcdata = calcdata;\n        col.x = xScale(col);\n    });\n\n    return calcdata;\n};\n\nfunction arrayMax(maybeArray) {\n    if(isArrayOrTypedArray(maybeArray)) {\n        var max = 0;\n        for(var i = 0; i < maybeArray.length; i++) {\n            max = Math.max(max, arrayMax(maybeArray[i]));\n        }\n        return max;\n    }\n    return maybeArray;\n}\n\nfunction sum(a, b) { return a + b; }\n\n// fill matrix in place to equal lengths\n// and ensure it's uniformly 2D\nfunction squareStringMatrix(matrixIn) {\n    var matrix = matrixIn.slice();\n    var minLen = Infinity;\n    var maxLen = 0;\n    var i;\n    for(i = 0; i < matrix.length; i++) {\n        if(isTypedArray(matrix[i])) matrix[i] = Array.from(matrix[i]);\n        else if(!isArrayOrTypedArray(matrix[i])) matrix[i] = [matrix[i]];\n        minLen = Math.min(minLen, matrix[i].length);\n        maxLen = Math.max(maxLen, matrix[i].length);\n    }\n\n    if(minLen !== maxLen) {\n        for(i = 0; i < matrix.length; i++) {\n            var padLen = maxLen - matrix[i].length;\n            if(padLen) matrix[i] = matrix[i].concat(emptyStrings(padLen));\n        }\n    }\n    return matrix;\n}\n\nfunction emptyStrings(len) {\n    var padArray = new Array(len);\n    for(var j = 0; j < len; j++) padArray[j] = '';\n    return padArray;\n}\n\nfunction xScale(d) {\n    return d.calcdata.columns.reduce(function(prev, next) {\n        return next.xIndex < d.xIndex ? prev + next.columnWidth : prev;\n    }, 0);\n}\n\nfunction makeRowBlock(anchorToRowBlock, auxiliary) {\n    var blockAnchorKeys = Object.keys(anchorToRowBlock);\n    return blockAnchorKeys.map(function(k) {return extendFlat({}, anchorToRowBlock[k], {auxiliaryBlocks: auxiliary});});\n}\n\nfunction makeAnchorToRowBlock(rowHeights, minimumFillHeight) {\n    var anchorToRowBlock = {};\n    var currentRowHeight;\n    var currentAnchor = 0;\n    var currentBlockHeight = 0;\n    var currentBlock = makeIdentity();\n    var currentFirstRowIndex = 0;\n    var blockCounter = 0;\n    for(var i = 0; i < rowHeights.length; i++) {\n        currentRowHeight = rowHeights[i];\n        currentBlock.rows.push({\n            rowIndex: i,\n            rowHeight: currentRowHeight\n        });\n        currentBlockHeight += currentRowHeight;\n        if(currentBlockHeight >= minimumFillHeight || i === rowHeights.length - 1) {\n            anchorToRowBlock[currentAnchor] = currentBlock;\n            currentBlock.key = blockCounter++;\n            currentBlock.firstRowIndex = currentFirstRowIndex;\n            currentBlock.lastRowIndex = i;\n            currentBlock = makeIdentity();\n            currentAnchor += currentBlockHeight;\n            currentFirstRowIndex = i + 1;\n            currentBlockHeight = 0;\n        }\n    }\n\n    return anchorToRowBlock;\n}\n\nfunction makeIdentity() {\n    return {\n        firstRowIndex: null,\n        lastRowIndex: null,\n        rows: []\n    };\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;AAC9B,IAAIC,UAAU,GAAGD,OAAO,CAAC,kBAAkB,CAAC,CAACC,UAAU;AACvD,IAAIC,SAAS,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACzC,IAAIG,YAAY,GAAGH,OAAO,CAAC,iBAAiB,CAAC,CAACG,YAAY;AAC1D,IAAIC,mBAAmB,GAAGJ,OAAO,CAAC,iBAAiB,CAAC,CAACI,mBAAmB;;AAExE;AACAC,MAAM,CAACC,OAAO,GAAG,SAASC,IAAIA,CAACC,EAAE,EAAEC,KAAK,EAAE;EACtC,IAAIC,WAAW,GAAGC,kBAAkB,CAACF,KAAK,CAACG,KAAK,CAACC,MAAM,CAAC;EACxD,IAAIC,MAAM,GAAG,SAAAA,CAASC,CAAC,EAAE;IACrB,OAAOA,CAAC,CAACC,KAAK,CAACP,KAAK,CAACQ,MAAM,CAACJ,MAAM,CAACK,MAAM,EAAEH,CAAC,CAACG,MAAM,CAAC;EACxD,CAAC;EACD,IAAIC,cAAc,GAAGR,kBAAkB,CAACF,KAAK,CAACQ,MAAM,CAACJ,MAAM,CAAC;EAC5D,IAAGM,cAAc,CAACD,MAAM,IAAI,CAACC,cAAc,CAAC,CAAC,CAAC,CAACD,MAAM,EAAE;IACnDC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;IACxBA,cAAc,GAAGR,kBAAkB,CAACQ,cAAc,CAAC;EACvD;EACA,IAAIC,YAAY,GAAGD,cAAc,CAC5BE,MAAM,CAACP,MAAM,CAACJ,WAAW,CAAC,CAACY,GAAG,CAAC,YAAW;IACvC,OAAOC,YAAY,CAAC,CAACJ,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAED,MAAM,CAAC;EAC3D,CAAC,CAAC,CAAC;EAEP,IAAIM,MAAM,GAAGf,KAAK,CAACe,MAAM;EACzB,IAAIC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACnB,EAAE,CAACoB,WAAW,CAACC,KAAK,CAACC,CAAC,IAAIN,MAAM,CAACO,CAAC,CAAC,CAAC,CAAC,GAAGP,MAAM,CAACO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACjF,IAAIC,WAAW,GAAGN,IAAI,CAACC,KAAK,CAACnB,EAAE,CAACoB,WAAW,CAACC,KAAK,CAACI,CAAC,IAAIT,MAAM,CAACU,CAAC,CAAC,CAAC,CAAC,GAAGV,MAAM,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAClF,IAAIC,gBAAgB,GAAG1B,KAAK,CAACQ,MAAM,CAACJ,MAAM,CAACK,MAAM,GAC7CE,YAAY,CAAC,CAAC,CAAC,CAACE,GAAG,CAAC,YAAW;IAAE,OAAOb,KAAK,CAACQ,MAAM,CAACmB,MAAM;EAAE,CAAC,CAAC,GAC/D,CAACrC,CAAC,CAACsC,iBAAiB,CAAC;EACzB,IAAIC,UAAU,GAAG5B,WAAW,CAACQ,MAAM,GAAGR,WAAW,CAAC,CAAC,CAAC,CAACY,GAAG,CAAC,YAAW;IAAE,OAAOb,KAAK,CAACG,KAAK,CAACwB,MAAM;EAAE,CAAC,CAAC,GAAG,EAAE;EACxG,IAAIG,YAAY,GAAGJ,gBAAgB,CAACK,MAAM,CAACC,GAAG,EAAE,CAAC,CAAC;EAClD,IAAIC,YAAY,GAAGV,WAAW,GAAGO,YAAY;EAC7C,IAAII,iBAAiB,GAAGD,YAAY,GAAG3C,CAAC,CAAC6C,MAAM;EAC/C,IAAIC,gBAAgB,GAAGC,oBAAoB,CAACR,UAAU,EAAEK,iBAAiB,CAAC;EAC1E,IAAII,sBAAsB,GAAGD,oBAAoB,CAACX,gBAAgB,EAAEI,YAAY,CAAC;EACjF,IAAIS,eAAe,GAAGC,YAAY,CAACF,sBAAsB,EAAE,EAAE,CAAC;EAC9D,IAAIG,SAAS,GAAGD,YAAY,CAACJ,gBAAgB,EAAEG,eAAe,CAAC;EAC/D,IAAIG,UAAU,GAAG,CAAC,CAAC;EAEnB,IAAIC,WAAW,GAAG3C,KAAK,CAAC4C,UAAU,CAACC,WAAW;EAC9C,IAAGlD,mBAAmB,CAACgD,WAAW,CAAC,EAAEA,WAAW,GAAGG,KAAK,CAACC,IAAI,CAACJ,WAAW,CAAC;EAC1EA,WAAW,GAAGA,WAAW,CAAC/B,MAAM,CAACP,MAAM,CAACJ,WAAW,CAACY,GAAG,CAAC,UAASmC,CAAC,EAAEC,CAAC,EAAE;IAAC,OAAOA,CAAC;EAAC,CAAC,CAAC,CAAC,CAAC;EAErF,IAAIC,YAAY,GAAGvC,YAAY,CAACE,GAAG,CAAC,UAASmC,CAAC,EAAEC,CAAC,EAAE;IAC/C,IAAIE,KAAK,GAAGxD,mBAAmB,CAACK,KAAK,CAACoD,WAAW,CAAC,GAC9CpD,KAAK,CAACoD,WAAW,CAACnC,IAAI,CAACoC,GAAG,CAACJ,CAAC,EAAEjD,KAAK,CAACoD,WAAW,CAAC3C,MAAM,GAAG,CAAC,CAAC,CAAC,GAC5DT,KAAK,CAACoD,WAAW;IACrB,OAAO3D,SAAS,CAAC0D,KAAK,CAAC,GAAGG,MAAM,CAACH,KAAK,CAAC,GAAG,CAAC;EAC/C,CAAC,CAAC;EACF,IAAII,iBAAiB,GAAGL,YAAY,CAACnB,MAAM,CAACC,GAAG,EAAE,CAAC,CAAC;;EAEnD;EACAkB,YAAY,GAAGA,YAAY,CAACrC,GAAG,CAAC,UAASmC,CAAC,EAAE;IAAE,OAAOA,CAAC,GAAGO,iBAAiB,GAAGvC,UAAU;EAAE,CAAC,CAAC;EAE3F,IAAIwC,YAAY,GAAGvC,IAAI,CAACwC,GAAG,CAACC,QAAQ,CAAC1D,KAAK,CAACQ,MAAM,CAACmD,IAAI,CAACC,KAAK,CAAC,EAAEF,QAAQ,CAAC1D,KAAK,CAACG,KAAK,CAACwD,IAAI,CAACC,KAAK,CAAC,CAAC;EAEhG,IAAIC,QAAQ,GAAG;IACX;IACAC,GAAG,EAAE9D,KAAK,CAAC+D,GAAG,GAAGhE,EAAE,CAACiE,QAAQ,CAACC,UAAU;IACvCC,UAAU,EAAEnD,MAAM,CAACO,CAAC,CAAC,CAAC,CAAC,GAAGvB,EAAE,CAACoB,WAAW,CAACC,KAAK,CAACC,CAAC;IAChD8C,UAAU,EAAEpE,EAAE,CAACoB,WAAW,CAACC,KAAK,CAACI,CAAC,IAAI,CAAC,GAAGT,MAAM,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC;IACtD2C,IAAI,EAAErE,EAAE,CAACoB,WAAW,CAACC,KAAK;IAC1BwC,KAAK,EAAE5C,UAAU;IACjBwC,YAAY,EAAEA,YAAY;IAC1B7B,MAAM,EAAEJ,WAAW;IACnBoB,WAAW,EAAEA,WAAW;IAAE;IAC1BpB,WAAW,EAAEA,WAAW;IACxBkB,SAAS,EAAEA,SAAS;IACpBF,eAAe,EAAEA,eAAe;IAChC8B,OAAO,EAAE,CAAC;IAAE;IACZlE,KAAK,EAAEX,UAAU,CAAC,CAAC,CAAC,EAAEQ,KAAK,CAACG,KAAK,EAAE;MAACC,MAAM,EAAEH;IAAW,CAAC,CAAC;IACzDqE,WAAW,EAAE9E,UAAU,CAAC,CAAC,CAAC,EAAEQ,KAAK,CAACQ,MAAM,EAAE;MAACJ,MAAM,EAAEO;IAAY,CAAC,CAAC;IACjE4D,SAAS,EAAE5D,YAAY,CAACE,GAAG,CAAC,UAASmC,CAAC,EAAE;MAAC,OAAOA,CAAC,CAAC,CAAC,CAAC;IAAC,CAAC,CAAC;IACvDwB,sBAAsB,EAAE7D,YAAY,CAACE,GAAG,CAAC,UAASmC,CAAC,EAAE;MAAC,OAAOA,CAAC,CAAC,CAAC,CAAC;IAAC,CAAC,CAAC;IACpEyB,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACjBC,cAAc,EAAE;MAACC,yBAAyB,EAAE;IAAK,CAAC;IAClDC,OAAO,EAAEjE,YAAY,CAACE,GAAG,CAAC,UAASgE,KAAK,EAAE5B,CAAC,EAAE;MACzC,IAAI6B,QAAQ,GAAGpC,UAAU,CAACmC,KAAK,CAAC;MAChCnC,UAAU,CAACmC,KAAK,CAAC,GAAG,CAACC,QAAQ,IAAI,CAAC,IAAI,CAAC;MACvC,IAAIhB,GAAG,GAAGe,KAAK,GAAG,IAAI,GAAGnC,UAAU,CAACmC,KAAK,CAAC;MAC1C,OAAO;QACHf,GAAG,EAAEA,GAAG;QACRe,KAAK,EAAEA,KAAK;QACZE,SAAS,EAAE9B,CAAC;QACZ+B,MAAM,EAAErC,WAAW,CAACM,CAAC,CAAC;QACtBgC,MAAM,EAAEA,MAAM;QACd3D,CAAC,EAAE4D,SAAS;QAAE;QACdrB,QAAQ,EAAEqB,SAAS;QAAE;QACrBC,WAAW,EAAEjC,YAAY,CAACD,CAAC;MAC/B,CAAC;IACL,CAAC;EACL,CAAC;EAEDY,QAAQ,CAACe,OAAO,CAACQ,OAAO,CAAC,UAASC,GAAG,EAAE;IACnCA,GAAG,CAACxB,QAAQ,GAAGA,QAAQ;IACvBwB,GAAG,CAAC/D,CAAC,GAAG2D,MAAM,CAACI,GAAG,CAAC;EACvB,CAAC,CAAC;EAEF,OAAOxB,QAAQ;AACnB,CAAC;AAED,SAASH,QAAQA,CAAC4B,UAAU,EAAE;EAC1B,IAAG3F,mBAAmB,CAAC2F,UAAU,CAAC,EAAE;IAChC,IAAI7B,GAAG,GAAG,CAAC;IACX,KAAI,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,UAAU,CAAC7E,MAAM,EAAEwC,CAAC,EAAE,EAAE;MACvCQ,GAAG,GAAGxC,IAAI,CAACwC,GAAG,CAACA,GAAG,EAAEC,QAAQ,CAAC4B,UAAU,CAACrC,CAAC,CAAC,CAAC,CAAC;IAChD;IACA,OAAOQ,GAAG;EACd;EACA,OAAO6B,UAAU;AACrB;AAEA,SAAStD,GAAGA,CAAC1B,CAAC,EAAEiF,CAAC,EAAE;EAAE,OAAOjF,CAAC,GAAGiF,CAAC;AAAE;;AAEnC;AACA;AACA,SAASrF,kBAAkBA,CAACsF,QAAQ,EAAE;EAClC,IAAIC,MAAM,GAAGD,QAAQ,CAACjF,KAAK,CAAC,CAAC;EAC7B,IAAImF,MAAM,GAAGC,QAAQ;EACrB,IAAIC,MAAM,GAAG,CAAC;EACd,IAAI3C,CAAC;EACL,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,MAAM,CAAChF,MAAM,EAAEwC,CAAC,EAAE,EAAE;IAC/B,IAAGvD,YAAY,CAAC+F,MAAM,CAACxC,CAAC,CAAC,CAAC,EAAEwC,MAAM,CAACxC,CAAC,CAAC,GAAGH,KAAK,CAACC,IAAI,CAAC0C,MAAM,CAACxC,CAAC,CAAC,CAAC,CAAC,KACzD,IAAG,CAACtD,mBAAmB,CAAC8F,MAAM,CAACxC,CAAC,CAAC,CAAC,EAAEwC,MAAM,CAACxC,CAAC,CAAC,GAAG,CAACwC,MAAM,CAACxC,CAAC,CAAC,CAAC;IAChEyC,MAAM,GAAGzE,IAAI,CAACoC,GAAG,CAACqC,MAAM,EAAED,MAAM,CAACxC,CAAC,CAAC,CAACxC,MAAM,CAAC;IAC3CmF,MAAM,GAAG3E,IAAI,CAACwC,GAAG,CAACmC,MAAM,EAAEH,MAAM,CAACxC,CAAC,CAAC,CAACxC,MAAM,CAAC;EAC/C;EAEA,IAAGiF,MAAM,KAAKE,MAAM,EAAE;IAClB,KAAI3C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,MAAM,CAAChF,MAAM,EAAEwC,CAAC,EAAE,EAAE;MAC/B,IAAI4C,MAAM,GAAGD,MAAM,GAAGH,MAAM,CAACxC,CAAC,CAAC,CAACxC,MAAM;MACtC,IAAGoF,MAAM,EAAEJ,MAAM,CAACxC,CAAC,CAAC,GAAGwC,MAAM,CAACxC,CAAC,CAAC,CAACrC,MAAM,CAACE,YAAY,CAAC+E,MAAM,CAAC,CAAC;IACjE;EACJ;EACA,OAAOJ,MAAM;AACjB;AAEA,SAAS3E,YAAYA,CAACgF,GAAG,EAAE;EACvB,IAAIC,QAAQ,GAAG,IAAIjD,KAAK,CAACgD,GAAG,CAAC;EAC7B,KAAI,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAED,QAAQ,CAACC,CAAC,CAAC,GAAG,EAAE;EAC7C,OAAOD,QAAQ;AACnB;AAEA,SAASd,MAAMA,CAACjC,CAAC,EAAE;EACf,OAAOA,CAAC,CAACa,QAAQ,CAACe,OAAO,CAAC7C,MAAM,CAAC,UAASkE,IAAI,EAAEC,IAAI,EAAE;IAClD,OAAOA,IAAI,CAAClB,MAAM,GAAGhC,CAAC,CAACgC,MAAM,GAAGiB,IAAI,GAAGC,IAAI,CAACf,WAAW,GAAGc,IAAI;EAClE,CAAC,EAAE,CAAC,CAAC;AACT;AAEA,SAASzD,YAAYA,CAACJ,gBAAgB,EAAE+D,SAAS,EAAE;EAC/C,IAAIC,eAAe,GAAGC,MAAM,CAACC,IAAI,CAAClE,gBAAgB,CAAC;EACnD,OAAOgE,eAAe,CAACvF,GAAG,CAAC,UAAS0F,CAAC,EAAE;IAAC,OAAO/G,UAAU,CAAC,CAAC,CAAC,EAAE4C,gBAAgB,CAACmE,CAAC,CAAC,EAAE;MAACC,eAAe,EAAEL;IAAS,CAAC,CAAC;EAAC,CAAC,CAAC;AACvH;AAEA,SAAS9D,oBAAoBA,CAACR,UAAU,EAAEK,iBAAiB,EAAE;EACzD,IAAIE,gBAAgB,GAAG,CAAC,CAAC;EACzB,IAAIqE,gBAAgB;EACpB,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,IAAIC,YAAY,GAAGC,YAAY,CAAC,CAAC;EACjC,IAAIC,oBAAoB,GAAG,CAAC;EAC5B,IAAIC,YAAY,GAAG,CAAC;EACpB,KAAI,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,UAAU,CAACpB,MAAM,EAAEwC,CAAC,EAAE,EAAE;IACvCwD,gBAAgB,GAAG5E,UAAU,CAACoB,CAAC,CAAC;IAChC2D,YAAY,CAACI,IAAI,CAACC,IAAI,CAAC;MACnBC,QAAQ,EAAEjE,CAAC;MACXkE,SAAS,EAAEV;IACf,CAAC,CAAC;IACFE,kBAAkB,IAAIF,gBAAgB;IACtC,IAAGE,kBAAkB,IAAIzE,iBAAiB,IAAIe,CAAC,KAAKpB,UAAU,CAACpB,MAAM,GAAG,CAAC,EAAE;MACvE2B,gBAAgB,CAACsE,aAAa,CAAC,GAAGE,YAAY;MAC9CA,YAAY,CAAC9C,GAAG,GAAGiD,YAAY,EAAE;MACjCH,YAAY,CAACQ,aAAa,GAAGN,oBAAoB;MACjDF,YAAY,CAACS,YAAY,GAAGpE,CAAC;MAC7B2D,YAAY,GAAGC,YAAY,CAAC,CAAC;MAC7BH,aAAa,IAAIC,kBAAkB;MACnCG,oBAAoB,GAAG7D,CAAC,GAAG,CAAC;MAC5B0D,kBAAkB,GAAG,CAAC;IAC1B;EACJ;EAEA,OAAOvE,gBAAgB;AAC3B;AAEA,SAASyE,YAAYA,CAAA,EAAG;EACpB,OAAO;IACHO,aAAa,EAAE,IAAI;IACnBC,YAAY,EAAE,IAAI;IAClBL,IAAI,EAAE;EACV,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"script"}