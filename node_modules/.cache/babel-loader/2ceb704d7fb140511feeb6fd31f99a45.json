{"ast":null,"code":"var tarjan = require('strongly-connected-components');\nmodule.exports = function findCircuits(edges, cb) {\n  var circuits = []; // Output\n\n  var stack = [];\n  var blocked = [];\n  var B = {};\n  var Ak = [];\n  var s;\n  function unblock(u) {\n    blocked[u] = false;\n    if (B.hasOwnProperty(u)) {\n      Object.keys(B[u]).forEach(function (w) {\n        delete B[u][w];\n        if (blocked[w]) {\n          unblock(w);\n        }\n      });\n    }\n  }\n  function circuit(v) {\n    var found = false;\n    stack.push(v);\n    blocked[v] = true;\n\n    // L1\n    var i;\n    var w;\n    for (i = 0; i < Ak[v].length; i++) {\n      w = Ak[v][i];\n      if (w === s) {\n        output(s, stack);\n        found = true;\n      } else if (!blocked[w]) {\n        found = circuit(w);\n      }\n    }\n\n    // L2\n    if (found) {\n      unblock(v);\n    } else {\n      for (i = 0; i < Ak[v].length; i++) {\n        w = Ak[v][i];\n        var entry = B[w];\n        if (!entry) {\n          entry = {};\n          B[w] = entry;\n        }\n        entry[w] = true;\n      }\n    }\n    stack.pop();\n    return found;\n  }\n  function output(start, stack) {\n    var cycle = [].concat(stack).concat(start);\n    if (cb) {\n      cb(cycle);\n    } else {\n      circuits.push(cycle);\n    }\n  }\n  function subgraph(minId) {\n    // Remove edges with indice smaller than minId\n    for (var i = 0; i < edges.length; i++) {\n      if (i < minId || !edges[i]) edges[i] = [];\n      edges[i] = edges[i].filter(function (i) {\n        return i >= minId;\n      });\n    }\n  }\n  function adjacencyStructureSCC(from) {\n    // Make subgraph starting from vertex minId\n    subgraph(from);\n    var g = edges;\n\n    // Find strongly connected components using Tarjan algorithm\n    var sccs = tarjan(g);\n\n    // Filter out trivial connected components (ie. made of one node)\n    var ccs = sccs.components.filter(function (scc) {\n      return scc.length > 1;\n    });\n\n    // Find least vertex\n    var leastVertex = Infinity;\n    var leastVertexComponent;\n    for (var i = 0; i < ccs.length; i++) {\n      for (var j = 0; j < ccs[i].length; j++) {\n        if (ccs[i][j] < leastVertex) {\n          leastVertex = ccs[i][j];\n          leastVertexComponent = i;\n        }\n      }\n    }\n    var cc = ccs[leastVertexComponent];\n    if (!cc) return false;\n\n    // Return the adjacency list of first component\n    var adjList = edges.map(function (l, index) {\n      if (cc.indexOf(index) === -1) return [];\n      return l.filter(function (i) {\n        return cc.indexOf(i) !== -1;\n      });\n    });\n    return {\n      leastVertex: leastVertex,\n      adjList: adjList\n    };\n  }\n  s = 0;\n  var n = edges.length;\n  while (s < n) {\n    // find strong component with least vertex in\n    // subgraph starting from vertex `s`\n    var p = adjacencyStructureSCC(s);\n\n    // Its least vertex\n    s = p.leastVertex;\n    // Its adjacency list\n    Ak = p.adjList;\n    if (Ak) {\n      for (var i = 0; i < Ak.length; i++) {\n        for (var j = 0; j < Ak[i].length; j++) {\n          var vertexId = Ak[i][j];\n          blocked[+vertexId] = false;\n          B[vertexId] = {};\n        }\n      }\n      circuit(s);\n      s = s + 1;\n    } else {\n      s = n;\n    }\n  }\n  if (cb) {\n    return;\n  } else {\n    return circuits;\n  }\n};","map":{"version":3,"names":["tarjan","require","module","exports","findCircuits","edges","cb","circuits","stack","blocked","B","Ak","s","unblock","u","hasOwnProperty","Object","keys","forEach","w","circuit","v","found","push","i","length","output","entry","pop","start","cycle","concat","subgraph","minId","filter","adjacencyStructureSCC","from","g","sccs","ccs","components","scc","leastVertex","Infinity","leastVertexComponent","j","cc","adjList","map","l","index","indexOf","n","p","vertexId"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/elementary-circuits-directed-graph/johnson.js"],"sourcesContent":["var tarjan = require('strongly-connected-components');\n\nmodule.exports = function findCircuits(edges, cb) {\n    var circuits = []; // Output\n\n    var stack = [];\n    var blocked = [];\n    var B = {};\n    var Ak = [];\n    var s;\n\n    function unblock(u) {\n        blocked[u] = false;\n        if(B.hasOwnProperty(u)) {\n            Object.keys(B[u]).forEach(function(w) {\n                delete B[u][w];\n                if(blocked[w]) {unblock(w);}\n            });\n        }\n    }\n\n    function circuit(v) {\n        var found = false;\n\n        stack.push(v);\n        blocked[v] = true;\n\n        // L1\n        var i;\n        var w;\n        for(i = 0; i < Ak[v].length; i++) {\n            w = Ak[v][i];\n            if(w === s) {\n                output(s, stack);\n                found = true;\n            } else if(!blocked[w]) {\n                found = circuit(w);\n            }\n        }\n\n        // L2\n        if(found) {\n            unblock(v);\n        } else {\n            for(i = 0; i < Ak[v].length; i++) {\n                w = Ak[v][i];\n                var entry = B[w];\n\n                if(!entry) {\n                    entry = {};\n                    B[w] = entry;\n                }\n\n                entry[w] = true;\n            }\n        }\n        stack.pop();\n        return found;\n    }\n\n    function output(start, stack) {\n        var cycle = [].concat(stack).concat(start);\n        if(cb) {\n            cb(cycle);\n        } else {\n            circuits.push(cycle);\n        }\n    }\n\n    function subgraph(minId) {\n      // Remove edges with indice smaller than minId\n        for(var i = 0; i < edges.length; i++) {\n            if(i < minId || !edges[i]) edges[i] = [];\n            edges[i] = edges[i].filter(function(i) {\n                return i >= minId;\n            });\n        }\n    }\n\n    function adjacencyStructureSCC(from) {\n        // Make subgraph starting from vertex minId\n        subgraph(from);\n        var g = edges;\n\n        // Find strongly connected components using Tarjan algorithm\n        var sccs = tarjan(g);\n\n        // Filter out trivial connected components (ie. made of one node)\n        var ccs = sccs.components.filter(function(scc) {\n            return scc.length > 1;\n        });\n\n        // Find least vertex\n        var leastVertex = Infinity;\n        var leastVertexComponent;\n        for(var i = 0; i < ccs.length; i++) {\n            for(var j = 0; j < ccs[i].length; j++) {\n                if(ccs[i][j] < leastVertex) {\n                    leastVertex = ccs[i][j];\n                    leastVertexComponent = i;\n                }\n            }\n        }\n\n        var cc = ccs[leastVertexComponent];\n\n        if(!cc) return false;\n\n        // Return the adjacency list of first component\n        var adjList = edges.map(function(l, index) {\n            if(cc.indexOf(index) === -1) return [];\n            return l.filter(function(i) {\n                return cc.indexOf(i) !== -1;\n            });\n        });\n\n        return {\n            leastVertex: leastVertex,\n            adjList: adjList\n        };\n    }\n\n    s = 0;\n    var n = edges.length;\n    while(s < n) {\n        // find strong component with least vertex in\n        // subgraph starting from vertex `s`\n        var p = adjacencyStructureSCC(s);\n\n        // Its least vertex\n        s = p.leastVertex;\n        // Its adjacency list\n        Ak = p.adjList;\n\n        if(Ak) {\n            for(var i = 0; i < Ak.length; i++) {\n                for(var j = 0; j < Ak[i].length; j++) {\n                    var vertexId = Ak[i][j];\n                    blocked[+vertexId] = false;\n                    B[vertexId] = {};\n                }\n            }\n            circuit(s);\n            s = s + 1;\n        } else {\n            s = n;\n        }\n\n    }\n\n    if(cb) {\n        return;\n    } else {\n        return circuits;\n    }\n};\n"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,+BAA+B,CAAC;AAErDC,MAAM,CAACC,OAAO,GAAG,SAASC,YAAYA,CAACC,KAAK,EAAEC,EAAE,EAAE;EAC9C,IAAIC,QAAQ,GAAG,EAAE,CAAC,CAAC;;EAEnB,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,CAAC,GAAG,CAAC,CAAC;EACV,IAAIC,EAAE,GAAG,EAAE;EACX,IAAIC,CAAC;EAEL,SAASC,OAAOA,CAACC,CAAC,EAAE;IAChBL,OAAO,CAACK,CAAC,CAAC,GAAG,KAAK;IAClB,IAAGJ,CAAC,CAACK,cAAc,CAACD,CAAC,CAAC,EAAE;MACpBE,MAAM,CAACC,IAAI,CAACP,CAAC,CAACI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,UAASC,CAAC,EAAE;QAClC,OAAOT,CAAC,CAACI,CAAC,CAAC,CAACK,CAAC,CAAC;QACd,IAAGV,OAAO,CAACU,CAAC,CAAC,EAAE;UAACN,OAAO,CAACM,CAAC,CAAC;QAAC;MAC/B,CAAC,CAAC;IACN;EACJ;EAEA,SAASC,OAAOA,CAACC,CAAC,EAAE;IAChB,IAAIC,KAAK,GAAG,KAAK;IAEjBd,KAAK,CAACe,IAAI,CAACF,CAAC,CAAC;IACbZ,OAAO,CAACY,CAAC,CAAC,GAAG,IAAI;;IAEjB;IACA,IAAIG,CAAC;IACL,IAAIL,CAAC;IACL,KAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,EAAE,CAACU,CAAC,CAAC,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MAC9BL,CAAC,GAAGR,EAAE,CAACU,CAAC,CAAC,CAACG,CAAC,CAAC;MACZ,IAAGL,CAAC,KAAKP,CAAC,EAAE;QACRc,MAAM,CAACd,CAAC,EAAEJ,KAAK,CAAC;QAChBc,KAAK,GAAG,IAAI;MAChB,CAAC,MAAM,IAAG,CAACb,OAAO,CAACU,CAAC,CAAC,EAAE;QACnBG,KAAK,GAAGF,OAAO,CAACD,CAAC,CAAC;MACtB;IACJ;;IAEA;IACA,IAAGG,KAAK,EAAE;MACNT,OAAO,CAACQ,CAAC,CAAC;IACd,CAAC,MAAM;MACH,KAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,EAAE,CAACU,CAAC,CAAC,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;QAC9BL,CAAC,GAAGR,EAAE,CAACU,CAAC,CAAC,CAACG,CAAC,CAAC;QACZ,IAAIG,KAAK,GAAGjB,CAAC,CAACS,CAAC,CAAC;QAEhB,IAAG,CAACQ,KAAK,EAAE;UACPA,KAAK,GAAG,CAAC,CAAC;UACVjB,CAAC,CAACS,CAAC,CAAC,GAAGQ,KAAK;QAChB;QAEAA,KAAK,CAACR,CAAC,CAAC,GAAG,IAAI;MACnB;IACJ;IACAX,KAAK,CAACoB,GAAG,CAAC,CAAC;IACX,OAAON,KAAK;EAChB;EAEA,SAASI,MAAMA,CAACG,KAAK,EAAErB,KAAK,EAAE;IAC1B,IAAIsB,KAAK,GAAG,EAAE,CAACC,MAAM,CAACvB,KAAK,CAAC,CAACuB,MAAM,CAACF,KAAK,CAAC;IAC1C,IAAGvB,EAAE,EAAE;MACHA,EAAE,CAACwB,KAAK,CAAC;IACb,CAAC,MAAM;MACHvB,QAAQ,CAACgB,IAAI,CAACO,KAAK,CAAC;IACxB;EACJ;EAEA,SAASE,QAAQA,CAACC,KAAK,EAAE;IACvB;IACE,KAAI,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,KAAK,CAACoB,MAAM,EAAED,CAAC,EAAE,EAAE;MAClC,IAAGA,CAAC,GAAGS,KAAK,IAAI,CAAC5B,KAAK,CAACmB,CAAC,CAAC,EAAEnB,KAAK,CAACmB,CAAC,CAAC,GAAG,EAAE;MACxCnB,KAAK,CAACmB,CAAC,CAAC,GAAGnB,KAAK,CAACmB,CAAC,CAAC,CAACU,MAAM,CAAC,UAASV,CAAC,EAAE;QACnC,OAAOA,CAAC,IAAIS,KAAK;MACrB,CAAC,CAAC;IACN;EACJ;EAEA,SAASE,qBAAqBA,CAACC,IAAI,EAAE;IACjC;IACAJ,QAAQ,CAACI,IAAI,CAAC;IACd,IAAIC,CAAC,GAAGhC,KAAK;;IAEb;IACA,IAAIiC,IAAI,GAAGtC,MAAM,CAACqC,CAAC,CAAC;;IAEpB;IACA,IAAIE,GAAG,GAAGD,IAAI,CAACE,UAAU,CAACN,MAAM,CAAC,UAASO,GAAG,EAAE;MAC3C,OAAOA,GAAG,CAAChB,MAAM,GAAG,CAAC;IACzB,CAAC,CAAC;;IAEF;IACA,IAAIiB,WAAW,GAAGC,QAAQ;IAC1B,IAAIC,oBAAoB;IACxB,KAAI,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,GAAG,CAACd,MAAM,EAAED,CAAC,EAAE,EAAE;MAChC,KAAI,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,GAAG,CAACf,CAAC,CAAC,CAACC,MAAM,EAAEoB,CAAC,EAAE,EAAE;QACnC,IAAGN,GAAG,CAACf,CAAC,CAAC,CAACqB,CAAC,CAAC,GAAGH,WAAW,EAAE;UACxBA,WAAW,GAAGH,GAAG,CAACf,CAAC,CAAC,CAACqB,CAAC,CAAC;UACvBD,oBAAoB,GAAGpB,CAAC;QAC5B;MACJ;IACJ;IAEA,IAAIsB,EAAE,GAAGP,GAAG,CAACK,oBAAoB,CAAC;IAElC,IAAG,CAACE,EAAE,EAAE,OAAO,KAAK;;IAEpB;IACA,IAAIC,OAAO,GAAG1C,KAAK,CAAC2C,GAAG,CAAC,UAASC,CAAC,EAAEC,KAAK,EAAE;MACvC,IAAGJ,EAAE,CAACK,OAAO,CAACD,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,EAAE;MACtC,OAAOD,CAAC,CAACf,MAAM,CAAC,UAASV,CAAC,EAAE;QACxB,OAAOsB,EAAE,CAACK,OAAO,CAAC3B,CAAC,CAAC,KAAK,CAAC,CAAC;MAC/B,CAAC,CAAC;IACN,CAAC,CAAC;IAEF,OAAO;MACHkB,WAAW,EAAEA,WAAW;MACxBK,OAAO,EAAEA;IACb,CAAC;EACL;EAEAnC,CAAC,GAAG,CAAC;EACL,IAAIwC,CAAC,GAAG/C,KAAK,CAACoB,MAAM;EACpB,OAAMb,CAAC,GAAGwC,CAAC,EAAE;IACT;IACA;IACA,IAAIC,CAAC,GAAGlB,qBAAqB,CAACvB,CAAC,CAAC;;IAEhC;IACAA,CAAC,GAAGyC,CAAC,CAACX,WAAW;IACjB;IACA/B,EAAE,GAAG0C,CAAC,CAACN,OAAO;IAEd,IAAGpC,EAAE,EAAE;MACH,KAAI,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,EAAE,CAACc,MAAM,EAAED,CAAC,EAAE,EAAE;QAC/B,KAAI,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlC,EAAE,CAACa,CAAC,CAAC,CAACC,MAAM,EAAEoB,CAAC,EAAE,EAAE;UAClC,IAAIS,QAAQ,GAAG3C,EAAE,CAACa,CAAC,CAAC,CAACqB,CAAC,CAAC;UACvBpC,OAAO,CAAC,CAAC6C,QAAQ,CAAC,GAAG,KAAK;UAC1B5C,CAAC,CAAC4C,QAAQ,CAAC,GAAG,CAAC,CAAC;QACpB;MACJ;MACAlC,OAAO,CAACR,CAAC,CAAC;MACVA,CAAC,GAAGA,CAAC,GAAG,CAAC;IACb,CAAC,MAAM;MACHA,CAAC,GAAGwC,CAAC;IACT;EAEJ;EAEA,IAAG9C,EAAE,EAAE;IACH;EACJ,CAAC,MAAM;IACH,OAAOC,QAAQ;EACnB;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}