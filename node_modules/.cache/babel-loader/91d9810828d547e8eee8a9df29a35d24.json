{"ast":null,"code":"// index.ts\nimport { earthRadius } from \"@turf/helpers\";\nimport { geomReduce } from \"@turf/meta\";\nfunction area(geojson) {\n  return geomReduce(geojson, (value, geom) => {\n    return value + calculateArea(geom);\n  }, 0);\n}\nfunction calculateArea(geom) {\n  let total = 0;\n  let i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\nfunction polygonArea(coords) {\n  let total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (let i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\nvar FACTOR = earthRadius * earthRadius / 2;\nvar PI_OVER_180 = Math.PI / 180;\nfunction ringArea(coords) {\n  const coordsLength = coords.length - 1;\n  if (coordsLength <= 2) return 0;\n  let total = 0;\n  let i = 0;\n  while (i < coordsLength) {\n    const lower = coords[i];\n    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n    const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n    const lowerX = lower[0] * PI_OVER_180;\n    const middleY = middle[1] * PI_OVER_180;\n    const upperX = upper[0] * PI_OVER_180;\n    total += (upperX - lowerX) * Math.sin(middleY);\n    i++;\n  }\n  return total * FACTOR;\n}\nvar turf_area_default = area;\nexport { area, turf_area_default as default };","map":{"version":3,"sources":["../../index.ts"],"names":[],"mappings":";AACA,SAAS,WAAA,QAAmB,eAAA;AAC5B,SAAS,UAAA,QAAkB,YAAA;AAiB3B,SAAS,IAAA,CAAK,OAAA,EAA2D;EACvE,OAAO,UAAA,CACL,OAAA,EACA,CAAC,KAAA,EAAO,IAAA,KAAS;IACf,OAAO,KAAA,GAAQ,aAAA,CAAc,IAAI,CAAA;EACnC,CAAA,EACA,CACF,CAAA;AACF;AASA,SAAS,aAAA,CAAc,IAAA,EAAwB;EAC7C,IAAI,KAAA,GAAQ,CAAA;EACZ,IAAI,CAAA;EACJ,QAAQ,IAAA,CAAK,IAAA;IACX,KAAK,SAAA;MACH,OAAO,WAAA,CAAY,IAAA,CAAK,WAAW,CAAA;IACrC,KAAK,cAAA;MACH,KAAK,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,WAAA,CAAY,MAAA,EAAQ,CAAA,EAAA,EAAK;QAC5C,KAAA,IAAS,WAAA,CAAY,IAAA,CAAK,WAAA,CAAY,CAAC,CAAC,CAAA;MAC1C;MACA,OAAO,KAAA;IACT,KAAK,OAAA;IACL,KAAK,YAAA;IACL,KAAK,YAAA;IACL,KAAK,iBAAA;MACH,OAAO,CAAA;EACX;EACA,OAAO,CAAA;AACT;AAEA,SAAS,WAAA,CAAY,MAAA,EAAa;EAChC,IAAI,KAAA,GAAQ,CAAA;EACZ,IAAI,MAAA,IAAU,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;IAC/B,KAAA,IAAS,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA;IACrC,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,MAAA,EAAQ,CAAA,EAAA,EAAK;MACtC,KAAA,IAAS,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA;IACvC;EACF;EACA,OAAO,KAAA;AACT;AASA,IAAM,MAAA,GAAU,WAAA,GAAc,WAAA,GAAe,CAAA;AAS7C,IAAM,WAAA,GAAc,IAAA,CAAK,EAAA,GAAK,GAAA;AAe9B,SAAS,QAAA,CAAS,MAAA,EAA4B;EAC5C,MAAM,YAAA,GAAe,MAAA,CAAO,MAAA,GAAS,CAAA;EAErC,IAAI,YAAA,IAAgB,CAAA,EAAG,OAAO,CAAA;EAC9B,IAAI,KAAA,GAAQ,CAAA;EAEZ,IAAI,CAAA,GAAI,CAAA;EACR,OAAO,CAAA,GAAI,YAAA,EAAc;IACvB,MAAM,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA;IACtB,MAAM,MAAA,GAAS,MAAA,CAAO,CAAA,GAAI,CAAA,KAAM,YAAA,GAAe,CAAA,GAAI,CAAA,GAAI,CAAC,CAAA;IACxD,MAAM,KAAA,GACJ,MAAA,CAAO,CAAA,GAAI,CAAA,IAAK,YAAA,GAAA,CAAgB,CAAA,GAAI,CAAA,IAAK,YAAA,GAAe,CAAA,GAAI,CAAC,CAAA;IAE/D,MAAM,MAAA,GAAS,KAAA,CAAM,CAAC,CAAA,GAAI,WAAA;IAC1B,MAAM,OAAA,GAAU,MAAA,CAAO,CAAC,CAAA,GAAI,WAAA;IAC5B,MAAM,MAAA,GAAS,KAAA,CAAM,CAAC,CAAA,GAAI,WAAA;IAE1B,KAAA,IAAA,CAAU,MAAA,GAAS,MAAA,IAAU,IAAA,CAAK,GAAA,CAAI,OAAO,CAAA;IAE7C,CAAA,EAAA;EACF;EAEA,OAAO,KAAA,GAAQ,MAAA;AACjB;AAGA,IAAO,iBAAA,GAAQ,IAAA","sourcesContent":["import { Feature, FeatureCollection, Geometry } from \"geojson\";\nimport { earthRadius } from \"@turf/helpers\";\nimport { geomReduce } from \"@turf/meta\";\n\n/**\n * Calculates the geodesic area in square meters of one or more polygons.\n *\n * @function\n * @param {GeoJSON} geojson input polygon(s) as {@link Geometry}, {@link Feature}, or {@link FeatureCollection}\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson: Feature<any> | FeatureCollection<any> | Geometry) {\n  return geomReduce(\n    geojson,\n    (value, geom) => {\n      return value + calculateArea(geom);\n    },\n    0\n  );\n}\n\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom: Geometry): number {\n  let total = 0;\n  let i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\n\nfunction polygonArea(coords: any) {\n  let total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (let i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\n\n/**\n * @private\n * A constant factor used to compute the area of a polygon.\n * It's derived from the square of the Earth's radius divided by 2.\n *\n * @type {number}\n */\nconst FACTOR = (earthRadius * earthRadius) / 2;\n\n/**\n * @private\n * A constant used for converting degrees to radians.\n * Represents the ratio of PI to 180.\n *\n * @type {number}\n */\nconst PI_OVER_180 = Math.PI / 180;\n\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords: number[][]): number {\n  const coordsLength = coords.length - 1;\n\n  if (coordsLength <= 2) return 0;\n  let total = 0;\n\n  let i = 0;\n  while (i < coordsLength) {\n    const lower = coords[i];\n    const middle = coords[i + 1 === coordsLength ? 0 : i + 1];\n    const upper =\n      coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];\n\n    const lowerX = lower[0] * PI_OVER_180;\n    const middleY = middle[1] * PI_OVER_180;\n    const upperX = upper[0] * PI_OVER_180;\n\n    total += (upperX - lowerX) * Math.sin(middleY);\n\n    i++;\n  }\n\n  return total * FACTOR;\n}\n\nexport { area };\nexport default area;\n"]},"metadata":{},"sourceType":"module"}