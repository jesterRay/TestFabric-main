{"ast":null,"code":"import { min, ascending, max, mean, sum } from 'd3-array';\nimport { map, nest } from 'd3-collection';\nimport { linkHorizontal } from 'd3-shape';\nimport findCircuits from 'elementary-circuits-directed-graph';\n\n// For a given link, return the target node's depth\nfunction targetDepth(d) {\n  return d.target.depth;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'left'\nfunction left(node) {\n  return node.depth;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'right'\nfunction right(node, n) {\n  return n - 1 - node.height;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'justify'\nfunction justify(node, n) {\n  return node.sourceLinks.length ? node.depth : n - 1;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'center'\nfunction center(node) {\n  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;\n}\n\n// returns a function, using the parameter given to the sankey setting\nfunction constant(x) {\n  return function () {\n    return x;\n  };\n}\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n/// https://github.com/tomshanley/d3-sankeyCircular-circular\n\n// sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\n\n// sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\n\n// sort nodes' breadth (ie top to bottom in a column)\n// if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node\n// else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom\nfunction ascendingBreadth(a, b) {\n  if (a.partOfCycle === b.partOfCycle) {\n    return a.y0 - b.y0;\n  } else {\n    if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\n// return the value of a node or link\nfunction value(d) {\n  return d.value;\n}\n\n// return the vertical center of a node\nfunction nodeCenter(node) {\n  return (node.y0 + node.y1) / 2;\n}\n\n// return the vertical center of a link's source node\nfunction linkSourceCenter(link) {\n  return nodeCenter(link.source);\n}\n\n// return the vertical center of a link's target node\nfunction linkTargetCenter(link) {\n  return nodeCenter(link.target);\n}\n\n// Return the default value for ID for node, d.index\nfunction defaultId(d) {\n  return d.index;\n}\n\n// Return the default object the graph's nodes, graph.nodes\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\n\n// Return the default object the graph's nodes, graph.links\nfunction defaultLinks(graph) {\n  return graph.links;\n}\n\n// Return the node from the collection that matches the provided ID, or throw an error if no match\nfunction find(nodeById, id) {\n  var node = nodeById.get(id);\n  if (!node) throw new Error('missing: ' + id);\n  return node;\n}\nfunction getNodeID(node, id) {\n  return id(node);\n}\n\n// The main sankeyCircular functions\n\n// Some constants for circular link calculations\nvar verticalMargin = 25;\nvar baseRadius = 10;\nvar scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped\n\nfunction sankeyCircular() {\n  // Set the default values\n  var x0 = 0,\n    y0 = 0,\n    x1 = 1,\n    y1 = 1,\n    // extent\n    dx = 24,\n    // nodeWidth\n    py,\n    // nodePadding, for vertical postioning\n    id = defaultId,\n    align = justify,\n    nodes = defaultNodes,\n    links = defaultLinks,\n    iterations = 32,\n    circularLinkGap = 2,\n    paddingRatio,\n    sortNodes = null;\n  function sankeyCircular() {\n    var graph = {\n      nodes: nodes.apply(null, arguments),\n      links: links.apply(null, arguments)\n\n      // Process the graph's nodes and links, setting their positions\n\n      // 1.  Associate the nodes with their respective links, and vice versa\n    };\n    computeNodeLinks(graph);\n\n    // 2.  Determine which links result in a circular path in the graph\n    identifyCircles(graph, id, sortNodes);\n\n    // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links\n    computeNodeValues(graph);\n\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    computeNodeDepths(graph);\n\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id);\n\n    // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    computeNodeBreadths(graph, iterations, id);\n    computeLinkBreadths(graph);\n\n    // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n      resolveNodeLinkOverlaps(graph, y0, y1, id);\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n    }\n\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    fillHeight(graph, y0, y1);\n\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n    addCircularPathData(graph, circularLinkGap, y1, id);\n    return graph;\n  } // end of sankeyCircular function\n\n  // Set the sankeyCircular parameters\n  // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap\n  sankeyCircular.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : id;\n  };\n  sankeyCircular.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : align;\n  };\n  sankeyCircular.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankeyCircular) : dx;\n  };\n  sankeyCircular.nodePadding = function (_) {\n    return arguments.length ? (py = +_, sankeyCircular) : py;\n  };\n  sankeyCircular.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : nodes;\n  };\n  sankeyCircular.links = function (_) {\n    return arguments.length ? (links = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : links;\n  };\n  sankeyCircular.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];\n  };\n  sankeyCircular.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];\n  };\n  sankeyCircular.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankeyCircular) : iterations;\n  };\n  sankeyCircular.circularLinkGap = function (_) {\n    return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;\n  };\n  sankeyCircular.nodePaddingRatio = function (_) {\n    return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;\n  };\n  sankeyCircular.sortNodes = function (_) {\n    return arguments.length ? (sortNodes = _, sankeyCircular) : sortNodes;\n  };\n  sankeyCircular.update = function (graph) {\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    // computeNodeDepths(graph)\n\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id);\n\n    // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    // computeNodeBreadths(graph, iterations, id)\n    computeLinkBreadths(graph);\n\n    // Force position of circular link type based on position\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        link.circularLinkType = link.y0 + link.y1 < y1 ? 'top' : 'bottom';\n        link.source.circularLinkType = link.circularLinkType;\n        link.target.circularLinkType = link.circularLinkType;\n      }\n    });\n    sortSourceLinks(graph, y1, id, false); // Sort links but do not move nodes\n    sortTargetLinks(graph, y1, id);\n\n    // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    // var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    // for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n    //\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //   resolveNodeLinkOverlaps(graph, y0, y1, id)\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //\n    // }\n\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    // fillHeight(graph, y0, y1)\n\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n    addCircularPathData(graph, circularLinkGap, y1, id);\n    return graph;\n  };\n\n  // Populate the sourceLinks and targetLinks for each node.\n  // Also, if the source and target are not objects, assume they are indices.\n  function computeNodeLinks(graph) {\n    graph.nodes.forEach(function (node, i) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    });\n    var nodeById = map(graph.nodes, id);\n    graph.links.forEach(function (link, i) {\n      link.index = i;\n      var source = link.source;\n      var target = link.target;\n      if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) !== 'object') {\n        source = link.source = find(nodeById, source);\n      }\n      if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== 'object') {\n        target = link.target = find(nodeById, target);\n      }\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    });\n    return graph;\n  }\n\n  // Compute the value (size) and cycleness of each node by summing the associated links.\n  function computeNodeValues(graph) {\n    graph.nodes.forEach(function (node) {\n      node.partOfCycle = false;\n      node.value = Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value));\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    });\n  }\n  function getCircleMargins(graph) {\n    var totalTopLinksWidth = 0,\n      totalBottomLinksWidth = 0,\n      totalRightLinksWidth = 0,\n      totalLeftLinksWidth = 0;\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        if (link.circularLinkType == 'top') {\n          totalTopLinksWidth = totalTopLinksWidth + link.width;\n        } else {\n          totalBottomLinksWidth = totalBottomLinksWidth + link.width;\n        }\n        if (link.target.column == 0) {\n          totalLeftLinksWidth = totalLeftLinksWidth + link.width;\n        }\n        if (link.source.column == maxColumn) {\n          totalRightLinksWidth = totalRightLinksWidth + link.width;\n        }\n      }\n    });\n\n    //account for radius of curves and padding between links\n    totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;\n    totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;\n    totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;\n    totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;\n    return {\n      \"top\": totalTopLinksWidth,\n      \"bottom\": totalBottomLinksWidth,\n      \"left\": totalLeftLinksWidth,\n      \"right\": totalRightLinksWidth\n    };\n  }\n\n  // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links\n  function scaleSankeySize(graph, margin) {\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n    var currentWidth = x1 - x0;\n    var currentHeight = y1 - y0;\n    var newWidth = currentWidth + margin.right + margin.left;\n    var newHeight = currentHeight + margin.top + margin.bottom;\n    var scaleX = currentWidth / newWidth;\n    var scaleY = currentHeight / newHeight;\n    x0 = x0 * scaleX + margin.left;\n    x1 = margin.right == 0 ? x1 : x1 * scaleX;\n    y0 = y0 * scaleY + margin.top;\n    y1 = y1 * scaleY;\n    graph.nodes.forEach(function (node) {\n      node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);\n      node.x1 = node.x0 + dx;\n    });\n    return scaleY;\n  }\n\n  // Iteratively assign the depth for each node.\n  // Nodes are assigned the maximum depth of incoming neighbors plus one;\n  // nodes with no incoming links are assigned depth zero, while\n  // nodes with no outgoing links are assigned the maximum depth.\n  function computeNodeDepths(graph) {\n    var nodes, next, x;\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.depth = x;\n        node.sourceLinks.forEach(function (link) {\n          if (next.indexOf(link.target) < 0 && !link.circular) {\n            next.push(link.target);\n          }\n        });\n      });\n    }\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.height = x;\n        node.targetLinks.forEach(function (link) {\n          if (next.indexOf(link.source) < 0 && !link.circular) {\n            next.push(link.source);\n          }\n        });\n      });\n    }\n\n    // assign column numbers, and get max value\n    graph.nodes.forEach(function (node) {\n      node.column = Math.floor(align.call(null, node, x));\n    });\n  }\n\n  // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)\n  function computeNodeBreadths(graph, iterations, id) {\n    var columns = nest().key(function (d) {\n      return d.column;\n    }).sortKeys(ascending).entries(graph.nodes).map(function (d) {\n      return d.values;\n    });\n    initializeNodeBreadth(id);\n    resolveCollisions();\n    for (var alpha = 1, n = iterations; n > 0; --n) {\n      relaxLeftAndRight(alpha *= 0.99, id);\n      resolveCollisions();\n    }\n    function initializeNodeBreadth(id) {\n      //override py if nodePadding has been set\n      if (paddingRatio) {\n        var padding = Infinity;\n        columns.forEach(function (nodes) {\n          var thisPadding = y1 * paddingRatio / (nodes.length + 1);\n          padding = thisPadding < padding ? thisPadding : padding;\n        });\n        py = padding;\n      }\n      var ky = min(columns, function (nodes) {\n        return (y1 - y0 - (nodes.length - 1) * py) / sum(nodes, value);\n      });\n\n      //calculate the widths of the links\n      ky = ky * scale;\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n\n      //determine how much to scale down the chart, based on circular links\n      var margin = getCircleMargins(graph);\n      var ratio = scaleSankeySize(graph, margin);\n\n      //re-calculate widths\n      ky = ky * ratio;\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n      columns.forEach(function (nodes) {\n        var nodesLength = nodes.length;\n        nodes.forEach(function (node, i) {\n          if (node.depth == columns.length - 1 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.depth == 0 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.partOfCycle) {\n            if (numberOfNonSelfLinkingCycles(node, id) == 0) {\n              node.y0 = y1 / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else if (node.circularLinkType == 'top') {\n              node.y0 = y0 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = y1 - node.value * ky - i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          } else {\n            if (margin.top == 0 || margin.bottom == 0) {\n              node.y0 = (y1 - y0) / nodesLength * i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          }\n        });\n      });\n    }\n\n    // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position\n    // and shift up/down to be closer to the vertical middle of those targets and sources\n    function relaxLeftAndRight(alpha, id) {\n      var columnsLength = columns.length;\n      columns.forEach(function (nodes) {\n        var n = nodes.length;\n        var depth = nodes[0].depth;\n        nodes.forEach(function (node) {\n          // check the node is not an orphan\n          var nodeHeight;\n          if (node.sourceLinks.length || node.targetLinks.length) {\n            if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) ;else if (depth == 0 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else if (depth == columnsLength - 1 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else {\n              var avg = 0;\n              var avgTargetY = mean(node.sourceLinks, linkTargetCenter);\n              var avgSourceY = mean(node.targetLinks, linkSourceCenter);\n              if (avgTargetY && avgSourceY) {\n                avg = (avgTargetY + avgSourceY) / 2;\n              } else {\n                avg = avgTargetY || avgSourceY;\n              }\n              var dy = (avg - nodeCenter(node)) * alpha;\n              // positive if it node needs to move down\n              node.y0 += dy;\n              node.y1 += dy;\n            }\n          }\n        });\n      });\n    }\n\n    // For each column, check if nodes are overlapping, and if so, shift up/down\n    function resolveCollisions() {\n      columns.forEach(function (nodes) {\n        var node,\n          dy,\n          y = y0,\n          n = nodes.length,\n          i;\n\n        // Push any overlapping nodes down.\n        nodes.sort(ascendingBreadth);\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          dy = y - node.y0;\n          if (dy > 0) {\n            node.y0 += dy;\n            node.y1 += dy;\n          }\n          y = node.y1 + py;\n        }\n\n        // If the bottommost node goes outside the bounds, push it back up.\n        dy = y - py - y1;\n        if (dy > 0) {\n          y = node.y0 -= dy, node.y1 -= dy;\n\n          // Push any overlapping nodes back up.\n          for (i = n - 2; i >= 0; --i) {\n            node = nodes[i];\n            dy = node.y1 + py - y;\n            if (dy > 0) node.y0 -= dy, node.y1 -= dy;\n            y = node.y0;\n          }\n        }\n      });\n    }\n  }\n\n  // Assign the links y0 and y1 based on source/target nodes position,\n  // plus the link's relative position to other links to the same node\n  function computeLinkBreadths(graph) {\n    graph.nodes.forEach(function (node) {\n      node.sourceLinks.sort(ascendingTargetBreadth);\n      node.targetLinks.sort(ascendingSourceBreadth);\n    });\n    graph.nodes.forEach(function (node) {\n      var y0 = node.y0;\n      var y1 = y0;\n\n      // start from the bottom of the node for cycle links\n      var y0cycle = node.y1;\n      var y1cycle = y0cycle;\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y0 = y0cycle - link.width / 2;\n          y0cycle = y0cycle - link.width;\n        } else {\n          link.y0 = y0 + link.width / 2;\n          y0 += link.width;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y1 = y1cycle - link.width / 2;\n          y1cycle = y1cycle - link.width;\n        } else {\n          link.y1 = y1 + link.width / 2;\n          y1 += link.width;\n        }\n      });\n    });\n  }\n  return sankeyCircular;\n}\n\n/// /////////////////////////////////////////////////////////////////////////////////\n// Cycle functions\n// portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043\n\n// Identify circles in the link objects\nfunction identifyCircles(graph, id, sortNodes) {\n  var circularLinkID = 0;\n  if (sortNodes === null) {\n    // Building adjacency graph\n    var adjList = [];\n    for (var i = 0; i < graph.links.length; i++) {\n      var link = graph.links[i];\n      var source = link.source.index;\n      var target = link.target.index;\n      if (!adjList[source]) adjList[source] = [];\n      if (!adjList[target]) adjList[target] = [];\n\n      // Add links if not already in set\n      if (adjList[source].indexOf(target) === -1) adjList[source].push(target);\n    }\n\n    // Find all elementary circuits\n    var cycles = findCircuits(adjList);\n\n    // Sort by circuits length\n    cycles.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var circularLinks = {};\n    for (i = 0; i < cycles.length; i++) {\n      var cycle = cycles[i];\n      var last = cycle.slice(-2);\n      if (!circularLinks[last[0]]) circularLinks[last[0]] = {};\n      circularLinks[last[0]][last[1]] = true;\n    }\n    graph.links.forEach(function (link) {\n      var target = link.target.index;\n      var source = link.source.index;\n      // If self-linking or a back-edge\n      if (target === source || circularLinks[source] && circularLinks[source][target]) {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      } else {\n        link.circular = false;\n      }\n    });\n  } else {\n    graph.links.forEach(function (link) {\n      if (link.source[sortNodes] < link.target[sortNodes]) {\n        link.circular = false;\n      } else {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      }\n    });\n  }\n}\n\n// Assign a circular link type (top or bottom), based on:\n// - if the source/target node already has circular links, then use the same type\n// - if not, choose the type with fewer links\nfunction selectCircularLinkTypes(graph, id) {\n  var numberOfTops = 0;\n  var numberOfBottoms = 0;\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      // if either souce or target has type already use that\n      if (link.source.circularLinkType || link.target.circularLinkType) {\n        // default to source type if available\n        link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;\n      } else {\n        link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';\n      }\n      if (link.circularLinkType == 'top') {\n        numberOfTops = numberOfTops + 1;\n      } else {\n        numberOfBottoms = numberOfBottoms + 1;\n      }\n      graph.nodes.forEach(function (node) {\n        if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    }\n  });\n\n  //correct self-linking links to be same direction as node\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      //if both source and target node are same type, then link should have same type\n      if (link.source.circularLinkType == link.target.circularLinkType) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n      //if link is selflinking, then link should have same type as node\n      if (selfLinking(link, id)) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n    }\n  });\n}\n\n// Return the angle between a straight line between the source and target of the link, and the vertical plane of the node\nfunction linkAngle(link) {\n  var adjacent = Math.abs(link.y1 - link.y0);\n  var opposite = Math.abs(link.target.x0 - link.source.x1);\n  return Math.atan(opposite / adjacent);\n}\n\n// Check if two circular links potentially overlap\nfunction circularLinksCross(link1, link2) {\n  if (link1.source.column < link2.target.column) {\n    return false;\n  } else if (link1.target.column > link2.source.column) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// Return the number of circular links for node, not including self linking links\nfunction numberOfNonSelfLinkingCycles(node, id) {\n  var sourceCount = 0;\n  node.sourceLinks.forEach(function (l) {\n    sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;\n  });\n  var targetCount = 0;\n  node.targetLinks.forEach(function (l) {\n    targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;\n  });\n  return sourceCount + targetCount;\n}\n\n// Check if a circular link is the only circular link for both its source and target node\nfunction onlyCircularLink(link) {\n  var nodeSourceLinks = link.source.sourceLinks;\n  var sourceCount = 0;\n  nodeSourceLinks.forEach(function (l) {\n    sourceCount = l.circular ? sourceCount + 1 : sourceCount;\n  });\n  var nodeTargetLinks = link.target.targetLinks;\n  var targetCount = 0;\n  nodeTargetLinks.forEach(function (l) {\n    targetCount = l.circular ? targetCount + 1 : targetCount;\n  });\n  if (sourceCount > 1 || targetCount > 1) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// creates vertical buffer values per set of top/bottom links\nfunction calcVerticalBuffer(links, circularLinkGap, id) {\n  links.sort(sortLinkColumnAscending);\n  links.forEach(function (link, i) {\n    var buffer = 0;\n    if (selfLinking(link, id) && onlyCircularLink(link)) {\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    } else {\n      var j = 0;\n      for (j; j < i; j++) {\n        if (circularLinksCross(links[i], links[j])) {\n          var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;\n          buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;\n        }\n      }\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    }\n  });\n  return links;\n}\n\n// calculate the optimum path for a link to reduce overlaps\nfunction addCircularPathData(graph, circularLinkGap, y1, id) {\n  //var baseRadius = 10\n  var buffer = 5;\n  //var verticalMargin = 25\n\n  var minY = min(graph.links, function (link) {\n    return link.source.y0;\n  });\n\n  // create object for circular Path Data\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData = {};\n    }\n  });\n\n  // calc vertical offsets per top/bottom links\n  var topLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'top';\n  });\n  /* topLinks = */\n  calcVerticalBuffer(topLinks, circularLinkGap, id);\n  var bottomLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'bottom';\n  });\n  /* bottomLinks = */\n  calcVerticalBuffer(bottomLinks, circularLinkGap, id);\n\n  // add the base data for each link\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData.arcRadius = link.width + baseRadius;\n      link.circularPathData.leftNodeBuffer = buffer;\n      link.circularPathData.rightNodeBuffer = buffer;\n      link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;\n      link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;\n      link.circularPathData.targetX = link.target.x0;\n      link.circularPathData.sourceY = link.y0;\n      link.circularPathData.targetY = link.y1;\n\n      // for self linking paths, and that the only circular link in/out of that node\n      if (selfLinking(link, id) && onlyCircularLink(link)) {\n        link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      } else {\n        // else calculate normally\n        // add left extent coordinates, based on links with same source column and circularLink type\n        var thisColumn = link.source.column;\n        var thisCircularLinkType = link.circularLinkType;\n        var sameColumnLinks = graph.links.filter(function (l) {\n          return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkSourceYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkSourceYAscending);\n        }\n        var radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n          radiusOffset = radiusOffset + l.width;\n        });\n\n        // add right extent coordinates, based on links with same target column and circularLink type\n        thisColumn = link.target.column;\n        sameColumnLinks = graph.links.filter(function (l) {\n          return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkTargetYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkTargetYAscending);\n        }\n        radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n          radiusOffset = radiusOffset + l.width;\n        });\n\n        // bottom links\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = Math.max(y1, link.source.y1, link.target.y1) + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      }\n\n      // all links\n      link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;\n      link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;\n    }\n    if (link.circular) {\n      link.path = createCircularPathString(link);\n    } else {\n      var normalPath = linkHorizontal().source(function (d) {\n        var x = d.source.x0 + (d.source.x1 - d.source.x0);\n        var y = d.y0;\n        return [x, y];\n      }).target(function (d) {\n        var x = d.target.x0;\n        var y = d.y1;\n        return [x, y];\n      });\n      link.path = normalPath(link);\n    }\n  });\n}\n\n// create a d path using the addCircularPathData\nfunction createCircularPathString(link) {\n  var pathString = '';\n  // 'pathData' is assigned a value but never used\n  // var pathData = {}\n\n  if (link.circularLinkType == 'top') {\n    pathString =\n    // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +\n    // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' +\n    // End of arc X\n    // line up to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' +\n    // End of arc X\n    // line down\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' +\n    // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  } else {\n    // bottom path\n    pathString =\n    // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +\n    // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' +\n    // End of arc X\n    // line down to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' +\n    // End of arc X\n    // line up\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' +\n    // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  }\n  return pathString;\n}\n\n// sort links based on the distance between the source and tartget node columns\n// if the same, then use Y position of the source node\nfunction sortLinkColumnAscending(link1, link2) {\n  if (linkColumnDistance(link1) == linkColumnDistance(link2)) {\n    return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);\n  } else {\n    return linkColumnDistance(link2) - linkColumnDistance(link1);\n  }\n}\n\n// sort ascending links by their source vertical position, y0\nfunction sortLinkSourceYAscending(link1, link2) {\n  return link1.y0 - link2.y0;\n}\n\n// sort descending links by their source vertical position, y0\nfunction sortLinkSourceYDescending(link1, link2) {\n  return link2.y0 - link1.y0;\n}\n\n// sort ascending links by their target vertical position, y1\nfunction sortLinkTargetYAscending(link1, link2) {\n  return link1.y1 - link2.y1;\n}\n\n// sort descending links by their target vertical position, y1\nfunction sortLinkTargetYDescending(link1, link2) {\n  return link2.y1 - link1.y1;\n}\n\n// return the distance between the link's target and source node, in terms of the nodes' column\nfunction linkColumnDistance(link) {\n  return link.target.column - link.source.column;\n}\n\n// return the distance between the link's target and source node, in terms of the nodes' X coordinate\nfunction linkXLength(link) {\n  return link.target.x0 - link.source.x1;\n}\n\n// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\nfunction linkPerpendicularYToLinkSource(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink);\n\n  // get the adjacent length to the other link's x position\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);\n\n  // add or subtract from longer link1's original y1, depending on the slope\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;\n  return yPerpendicular;\n}\n\n// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\nfunction linkPerpendicularYToLinkTarget(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink);\n\n  // get the adjacent length to the other link's x position\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);\n\n  // add or subtract from longer link's original y1, depending on the slope\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;\n  return yPerpendicular;\n}\n\n// Move any nodes that overlap links which span 2+ columns\nfunction resolveNodeLinkOverlaps(graph, y0, y1, id) {\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      return;\n    }\n    if (link.target.column - link.source.column > 1) {\n      var columnToTest = link.source.column + 1;\n      var maxColumnToTest = link.target.column - 1;\n      var i = 1;\n      var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;\n      for (i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {\n        graph.nodes.forEach(function (node) {\n          if (node.column == columnToTest) {\n            var t = i / (numberOfColumnsToTest + 1);\n\n            // Find all the points of a cubic bezier curve in javascript\n            // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript\n\n            var B0_t = Math.pow(1 - t, 3);\n            var B1_t = 3 * t * Math.pow(1 - t, 2);\n            var B2_t = 3 * Math.pow(t, 2) * (1 - t);\n            var B3_t = Math.pow(t, 3);\n            var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;\n            var linkY0AtColumn = py_t - link.width / 2;\n            var linkY1AtColumn = py_t + link.width / 2;\n            var dy;\n\n            // If top of link overlaps node, push node up\n            if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {\n              dy = node.y1 - linkY0AtColumn + 10;\n              dy = node.circularLinkType == 'bottom' ? dy : -dy;\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              // check if other nodes need to move up too\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (nodesOverlap(node, otherNode)) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {\n              // If bottom of link overlaps node, push node down\n              dy = linkY1AtColumn - node.y0 + 10;\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              // check if other nodes need to move down too\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {\n              // if link completely overlaps node\n              dy = linkY1AtColumn - node.y0 + 10;\n              node = adjustNodeHeight(node, dy, y0, y1);\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n  });\n}\n\n// check if two nodes overlap\nfunction nodesOverlap(nodeA, nodeB) {\n  // test if nodeA top partially overlaps nodeB\n  if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {\n    return true;\n  } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {\n    // test if nodeA bottom partially overlaps nodeB\n    return true;\n  } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {\n    // test if nodeA covers nodeB\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// update a node, and its associated links, vertical positions (y0, y1)\nfunction adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {\n  if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {\n    node.y0 = node.y0 + dy;\n    node.y1 = node.y1 + dy;\n    node.targetLinks.forEach(function (l) {\n      l.y1 = l.y1 + dy;\n    });\n    node.sourceLinks.forEach(function (l) {\n      l.y0 = l.y0 + dy;\n    });\n  }\n  return node;\n}\n\n// sort and set the links' y0 for each node\nfunction sortSourceLinks(graph, y1, id, moveNodes) {\n  graph.nodes.forEach(function (node) {\n    // move any nodes up which are off the bottom\n    if (moveNodes && node.y + (node.y1 - node.y0) > y1) {\n      node.y = node.y - (node.y + (node.y1 - node.y0) - y1);\n    }\n    var nodesSourceLinks = graph.links.filter(function (l) {\n      return getNodeID(l.source, id) == getNodeID(node, id);\n    });\n    var nodeSourceLinksLength = nodesSourceLinks.length;\n\n    // if more than 1 link then sort\n    if (nodeSourceLinksLength > 1) {\n      nodesSourceLinks.sort(function (link1, link2) {\n        // if both are not circular...\n        if (!link1.circular && !link2.circular) {\n          // if the target nodes are the same column, then sort by the link's target y\n          if (link1.target.column == link2.target.column) {\n            return link1.y1 - link2.y1;\n          } else if (!sameInclines(link1, link2)) {\n            // if the links slope in different directions, then sort by the link's target y\n            return link1.y1 - link2.y1;\n\n            // if the links slope in same directions, then sort by any overlap\n          } else {\n            if (link1.target.column > link2.target.column) {\n              var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);\n              return link1.y1 - link2Adj;\n            }\n            if (link2.target.column > link1.target.column) {\n              var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);\n              return link1Adj - link2.y1;\n            }\n          }\n        }\n\n        // if only one is circular, the move top links up, or bottom links down\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        }\n\n        // if both links are circular...\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link1.target.y1 - link2.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.target.column - link1.target.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link2.target.y1 - link1.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.target.column - link2.target.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    }\n\n    // update y0 for links\n    var ySourceOffset = node.y0;\n    nodesSourceLinks.forEach(function (link) {\n      link.y0 = ySourceOffset + link.width / 2;\n      ySourceOffset = ySourceOffset + link.width;\n    });\n\n    // correct any circular bottom links so they are at the bottom of the node\n    nodesSourceLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0;\n        // sum the widths of any links that are below this link\n        for (j; j < nodeSourceLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;\n        }\n        link.y0 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n}\n\n// sort and set the links' y1 for each node\nfunction sortTargetLinks(graph, y1, id) {\n  graph.nodes.forEach(function (node) {\n    var nodesTargetLinks = graph.links.filter(function (l) {\n      return getNodeID(l.target, id) == getNodeID(node, id);\n    });\n    var nodesTargetLinksLength = nodesTargetLinks.length;\n    if (nodesTargetLinksLength > 1) {\n      nodesTargetLinks.sort(function (link1, link2) {\n        // if both are not circular, the base on the source y position\n        if (!link1.circular && !link2.circular) {\n          if (link1.source.column == link2.source.column) {\n            return link1.y0 - link2.y0;\n          } else if (!sameInclines(link1, link2)) {\n            return link1.y0 - link2.y0;\n          } else {\n            // get the angle of the link to the further source node (ie the smaller column)\n            if (link2.source.column < link1.source.column) {\n              var link2Adj = linkPerpendicularYToLinkSource(link2, link1);\n              return link1.y0 - link2Adj;\n            }\n            if (link1.source.column < link2.source.column) {\n              var link1Adj = linkPerpendicularYToLinkSource(link1, link2);\n              return link1Adj - link2.y0;\n            }\n          }\n        }\n\n        // if only one is circular, the move top links up, or bottom links down\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        }\n\n        // if both links are circular...\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.source.column - link2.source.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.source.column - link1.source.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    }\n\n    // update y1 for links\n    var yTargetOffset = node.y0;\n    nodesTargetLinks.forEach(function (link) {\n      link.y1 = yTargetOffset + link.width / 2;\n      yTargetOffset = yTargetOffset + link.width;\n    });\n\n    // correct any circular bottom links so they are at the bottom of the node\n    nodesTargetLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0;\n        // sum the widths of any links that are below this link\n        for (j; j < nodesTargetLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;\n        }\n        link.y1 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n}\n\n// test if links both slope up, or both slope down\nfunction sameInclines(link1, link2) {\n  return incline(link1) == incline(link2);\n}\n\n// returns the slope of a link, from source to target\n// up => slopes up from source to target\n// down => slopes down from source to target\nfunction incline(link) {\n  return link.y0 - link.y1 > 0 ? 'up' : 'down';\n}\n\n// check if link is self linking, ie links a node to the same node\nfunction selfLinking(link, id) {\n  return getNodeID(link.source, id) == getNodeID(link.target, id);\n}\nfunction fillHeight(graph, y0, y1) {\n  var nodes = graph.nodes;\n  var links = graph.links;\n  var top = false;\n  var bottom = false;\n  links.forEach(function (link) {\n    if (link.circularLinkType == \"top\") {\n      top = true;\n    } else if (link.circularLinkType == \"bottom\") {\n      bottom = true;\n    }\n  });\n  if (top == false || bottom == false) {\n    var minY0 = min(nodes, function (node) {\n      return node.y0;\n    });\n    var maxY1 = max(nodes, function (node) {\n      return node.y1;\n    });\n    var currentHeight = maxY1 - minY0;\n    var chartHeight = y1 - y0;\n    var ratio = chartHeight / currentHeight;\n    nodes.forEach(function (node) {\n      var nodeHeight = (node.y1 - node.y0) * ratio;\n      node.y0 = (node.y0 - minY0) * ratio;\n      node.y1 = node.y0 + nodeHeight;\n    });\n    links.forEach(function (link) {\n      link.y0 = (link.y0 - minY0) * ratio;\n      link.y1 = (link.y1 - minY0) * ratio;\n      link.width = link.width * ratio;\n    });\n  }\n}\nexport { sankeyCircular, center as sankeyCenter, left as sankeyLeft, right as sankeyRight, justify as sankeyJustify };","map":{"version":3,"names":["min","ascending","max","mean","sum","map","nest","linkHorizontal","findCircuits","targetDepth","d","target","depth","left","node","right","n","height","justify","sourceLinks","length","center","targetLinks","constant","x","_typeof","Symbol","iterator","obj","constructor","prototype","ascendingSourceBreadth","a","b","ascendingBreadth","source","index","ascendingTargetBreadth","partOfCycle","y0","circularLinkType","value","nodeCenter","y1","linkSourceCenter","link","linkTargetCenter","defaultId","defaultNodes","graph","nodes","defaultLinks","links","find","nodeById","id","get","Error","getNodeID","verticalMargin","baseRadius","scale","sankeyCircular","x0","x1","dx","py","align","iterations","circularLinkGap","paddingRatio","sortNodes","apply","arguments","computeNodeLinks","identifyCircles","computeNodeValues","computeNodeDepths","selectCircularLinkTypes","computeNodeBreadths","computeLinkBreadths","linkSortingIterations","iteration","sortSourceLinks","sortTargetLinks","resolveNodeLinkOverlaps","fillHeight","addCircularPathData","nodeId","_","nodeAlign","nodeWidth","nodePadding","size","extent","nodePaddingRatio","update","forEach","circular","i","push","Math","getCircleMargins","totalTopLinksWidth","totalBottomLinksWidth","totalRightLinksWidth","totalLeftLinksWidth","maxColumn","column","width","scaleSankeySize","margin","currentWidth","currentHeight","newWidth","newHeight","top","bottom","scaleX","scaleY","next","indexOf","floor","call","columns","key","sortKeys","entries","values","initializeNodeBreadth","resolveCollisions","alpha","relaxLeftAndRight","padding","Infinity","thisPadding","ky","ratio","nodesLength","numberOfNonSelfLinkingCycles","columnsLength","nodeHeight","avg","avgTargetY","avgSourceY","dy","y","sort","y0cycle","y1cycle","circularLinkID","adjList","cycles","circularLinks","cycle","last","slice","numberOfTops","numberOfBottoms","selfLinking","linkAngle","adjacent","abs","opposite","atan","circularLinksCross","link1","link2","sourceCount","l","targetCount","onlyCircularLink","nodeSourceLinks","nodeTargetLinks","calcVerticalBuffer","sortLinkColumnAscending","buffer","circularPathData","verticalBuffer","j","bufferOverThisLink","minY","topLinks","filter","bottomLinks","arcRadius","leftNodeBuffer","rightNodeBuffer","sourceWidth","sourceX","targetX","sourceY","targetY","leftSmallArcRadius","leftLargeArcRadius","rightSmallArcRadius","rightLargeArcRadius","verticalFullExtent","verticalLeftInnerExtent","verticalRightInnerExtent","thisColumn","thisCircularLinkType","sameColumnLinks","sortLinkSourceYDescending","sortLinkSourceYAscending","radiusOffset","sortLinkTargetYDescending","sortLinkTargetYAscending","leftInnerExtent","rightInnerExtent","leftFullExtent","rightFullExtent","path","createCircularPathString","normalPath","pathString","linkColumnDistance","linkXLength","linkPerpendicularYToLinkSource","longerLink","shorterLink","angle","heightFromY1ToPependicular","tan","yPerpendicular","incline","linkPerpendicularYToLinkTarget","columnToTest","maxColumnToTest","numberOfColumnsToTest","t","B0_t","pow","B1_t","B2_t","B3_t","py_t","linkY0AtColumn","linkY1AtColumn","adjustNodeHeight","otherNode","nodesOverlap","nodeA","nodeB","sankeyY0","sankeyY1","moveNodes","nodesSourceLinks","nodeSourceLinksLength","sameInclines","link2Adj","link1Adj","ySourceOffset","offsetFromBottom","nodesTargetLinks","nodesTargetLinksLength","yTargetOffset","minY0","maxY1","chartHeight","sankeyCenter","sankeyLeft","sankeyRight","sankeyJustify"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/@plotly/d3-sankey-circular/dist/d3-sankey-circular.es.js"],"sourcesContent":["import { min, ascending, max, mean, sum } from 'd3-array';\nimport { map, nest } from 'd3-collection';\nimport { linkHorizontal } from 'd3-shape';\nimport findCircuits from 'elementary-circuits-directed-graph';\n\n// For a given link, return the target node's depth\nfunction targetDepth(d) {\n  return d.target.depth;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'left'\nfunction left(node) {\n  return node.depth;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'right'\nfunction right(node, n) {\n  return n - 1 - node.height;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'justify'\nfunction justify(node, n) {\n  return node.sourceLinks.length ? node.depth : n - 1;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'center'\nfunction center(node) {\n  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;\n}\n\n// returns a function, using the parameter given to the sankey setting\nfunction constant(x) {\n  return function () {\n    return x;\n  };\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n/// https://github.com/tomshanley/d3-sankeyCircular-circular\n\n// sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\n\n// sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\n\n// sort nodes' breadth (ie top to bottom in a column)\n// if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node\n// else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom\nfunction ascendingBreadth(a, b) {\n  if (a.partOfCycle === b.partOfCycle) {\n    return a.y0 - b.y0;\n  } else {\n    if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\n// return the value of a node or link\nfunction value(d) {\n  return d.value;\n}\n\n// return the vertical center of a node\nfunction nodeCenter(node) {\n  return (node.y0 + node.y1) / 2;\n}\n\n// return the vertical center of a link's source node\nfunction linkSourceCenter(link) {\n  return nodeCenter(link.source);\n}\n\n// return the vertical center of a link's target node\nfunction linkTargetCenter(link) {\n  return nodeCenter(link.target);\n}\n\n// Return the default value for ID for node, d.index\nfunction defaultId(d) {\n  return d.index;\n}\n\n// Return the default object the graph's nodes, graph.nodes\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\n\n// Return the default object the graph's nodes, graph.links\nfunction defaultLinks(graph) {\n  return graph.links;\n}\n\n// Return the node from the collection that matches the provided ID, or throw an error if no match\nfunction find(nodeById, id) {\n  var node = nodeById.get(id);\n  if (!node) throw new Error('missing: ' + id);\n  return node;\n}\n\nfunction getNodeID(node, id) {\n  return id(node);\n}\n\n// The main sankeyCircular functions\n\n// Some constants for circular link calculations\nvar verticalMargin = 25;\nvar baseRadius = 10;\nvar scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped\n\nfunction sankeyCircular () {\n  // Set the default values\n  var x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1,\n      // extent\n  dx = 24,\n      // nodeWidth\n  py,\n      // nodePadding, for vertical postioning\n  id = defaultId,\n      align = justify,\n      nodes = defaultNodes,\n      links = defaultLinks,\n      iterations = 32,\n      circularLinkGap = 2,\n      paddingRatio,\n      sortNodes = null;\n\n  function sankeyCircular() {\n    var graph = {\n      nodes: nodes.apply(null, arguments),\n      links: links.apply(null, arguments)\n\n      // Process the graph's nodes and links, setting their positions\n\n      // 1.  Associate the nodes with their respective links, and vice versa\n    };computeNodeLinks(graph);\n\n    // 2.  Determine which links result in a circular path in the graph\n    identifyCircles(graph, id, sortNodes);\n\n    // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links\n    computeNodeValues(graph);\n\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    computeNodeDepths(graph);\n\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id);\n\n    // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    computeNodeBreadths(graph, iterations, id);\n    computeLinkBreadths(graph);\n\n    // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n      resolveNodeLinkOverlaps(graph, y0, y1, id);\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n    }\n\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    fillHeight(graph, y0, y1);\n\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n    addCircularPathData(graph, circularLinkGap, y1, id);\n\n    return graph;\n  } // end of sankeyCircular function\n\n\n  // Set the sankeyCircular parameters\n  // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap\n  sankeyCircular.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : id;\n  };\n\n  sankeyCircular.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : align;\n  };\n\n  sankeyCircular.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankeyCircular) : dx;\n  };\n\n  sankeyCircular.nodePadding = function (_) {\n    return arguments.length ? (py = +_, sankeyCircular) : py;\n  };\n\n  sankeyCircular.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : nodes;\n  };\n\n  sankeyCircular.links = function (_) {\n    return arguments.length ? (links = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : links;\n  };\n\n  sankeyCircular.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];\n  };\n\n  sankeyCircular.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];\n  };\n\n  sankeyCircular.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankeyCircular) : iterations;\n  };\n\n  sankeyCircular.circularLinkGap = function (_) {\n    return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;\n  };\n\n  sankeyCircular.nodePaddingRatio = function (_) {\n    return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;\n  };\n\n  sankeyCircular.sortNodes = function (_) {\n    return arguments.length ? (sortNodes = _, sankeyCircular) : sortNodes;\n  };\n\n  sankeyCircular.update = function (graph) {\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    // computeNodeDepths(graph)\n\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id);\n\n    // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    // computeNodeBreadths(graph, iterations, id)\n    computeLinkBreadths(graph);\n\n    // Force position of circular link type based on position\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        link.circularLinkType = link.y0 + link.y1 < y1 ? 'top' : 'bottom';\n\n        link.source.circularLinkType = link.circularLinkType;\n        link.target.circularLinkType = link.circularLinkType;\n      }\n    });\n\n    sortSourceLinks(graph, y1, id, false); // Sort links but do not move nodes\n    sortTargetLinks(graph, y1, id);\n\n    // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    // var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    // for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n    //\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //   resolveNodeLinkOverlaps(graph, y0, y1, id)\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //\n    // }\n\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    // fillHeight(graph, y0, y1)\n\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n    addCircularPathData(graph, circularLinkGap, y1, id);\n    return graph;\n  };\n\n  // Populate the sourceLinks and targetLinks for each node.\n  // Also, if the source and target are not objects, assume they are indices.\n  function computeNodeLinks(graph) {\n    graph.nodes.forEach(function (node, i) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    });\n    var nodeById = map(graph.nodes, id);\n    graph.links.forEach(function (link, i) {\n      link.index = i;\n      var source = link.source;\n      var target = link.target;\n      if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) !== 'object') {\n        source = link.source = find(nodeById, source);\n      }\n      if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== 'object') {\n        target = link.target = find(nodeById, target);\n      }\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    });\n    return graph;\n  }\n\n  // Compute the value (size) and cycleness of each node by summing the associated links.\n  function computeNodeValues(graph) {\n    graph.nodes.forEach(function (node) {\n      node.partOfCycle = false;\n      node.value = Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value));\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    });\n  }\n\n  function getCircleMargins(graph) {\n    var totalTopLinksWidth = 0,\n        totalBottomLinksWidth = 0,\n        totalRightLinksWidth = 0,\n        totalLeftLinksWidth = 0;\n\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        if (link.circularLinkType == 'top') {\n          totalTopLinksWidth = totalTopLinksWidth + link.width;\n        } else {\n          totalBottomLinksWidth = totalBottomLinksWidth + link.width;\n        }\n\n        if (link.target.column == 0) {\n          totalLeftLinksWidth = totalLeftLinksWidth + link.width;\n        }\n\n        if (link.source.column == maxColumn) {\n          totalRightLinksWidth = totalRightLinksWidth + link.width;\n        }\n      }\n    });\n\n    //account for radius of curves and padding between links\n    totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;\n    totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;\n    totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;\n    totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;\n\n    return { \"top\": totalTopLinksWidth, \"bottom\": totalBottomLinksWidth, \"left\": totalLeftLinksWidth, \"right\": totalRightLinksWidth };\n  }\n\n  // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links\n  function scaleSankeySize(graph, margin) {\n\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n\n    var currentWidth = x1 - x0;\n    var currentHeight = y1 - y0;\n\n    var newWidth = currentWidth + margin.right + margin.left;\n    var newHeight = currentHeight + margin.top + margin.bottom;\n\n    var scaleX = currentWidth / newWidth;\n    var scaleY = currentHeight / newHeight;\n\n    x0 = x0 * scaleX + margin.left;\n    x1 = margin.right == 0 ? x1 : x1 * scaleX;\n    y0 = y0 * scaleY + margin.top;\n    y1 = y1 * scaleY;\n\n    graph.nodes.forEach(function (node) {\n      node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);\n      node.x1 = node.x0 + dx;\n    });\n\n    return scaleY;\n  }\n\n  // Iteratively assign the depth for each node.\n  // Nodes are assigned the maximum depth of incoming neighbors plus one;\n  // nodes with no incoming links are assigned depth zero, while\n  // nodes with no outgoing links are assigned the maximum depth.\n  function computeNodeDepths(graph) {\n    var nodes, next, x;\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.depth = x;\n        node.sourceLinks.forEach(function (link) {\n          if (next.indexOf(link.target) < 0 && !link.circular) {\n            next.push(link.target);\n          }\n        });\n      });\n    }\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.height = x;\n        node.targetLinks.forEach(function (link) {\n          if (next.indexOf(link.source) < 0 && !link.circular) {\n            next.push(link.source);\n          }\n        });\n      });\n    }\n\n    // assign column numbers, and get max value\n    graph.nodes.forEach(function (node) {\n      node.column = Math.floor(align.call(null, node, x));\n    });\n  }\n\n  // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)\n  function computeNodeBreadths(graph, iterations, id) {\n    var columns = nest().key(function (d) {\n      return d.column;\n    }).sortKeys(ascending).entries(graph.nodes).map(function (d) {\n      return d.values;\n    });\n\n    initializeNodeBreadth(id);\n    resolveCollisions();\n\n    for (var alpha = 1, n = iterations; n > 0; --n) {\n      relaxLeftAndRight(alpha *= 0.99, id);\n      resolveCollisions();\n    }\n\n    function initializeNodeBreadth(id) {\n\n      //override py if nodePadding has been set\n      if (paddingRatio) {\n        var padding = Infinity;\n        columns.forEach(function (nodes) {\n          var thisPadding = y1 * paddingRatio / (nodes.length + 1);\n          padding = thisPadding < padding ? thisPadding : padding;\n        });\n        py = padding;\n      }\n\n      var ky = min(columns, function (nodes) {\n        return (y1 - y0 - (nodes.length - 1) * py) / sum(nodes, value);\n      });\n\n      //calculate the widths of the links\n      ky = ky * scale;\n\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n\n      //determine how much to scale down the chart, based on circular links\n      var margin = getCircleMargins(graph);\n      var ratio = scaleSankeySize(graph, margin);\n\n      //re-calculate widths\n      ky = ky * ratio;\n\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n\n      columns.forEach(function (nodes) {\n        var nodesLength = nodes.length;\n        nodes.forEach(function (node, i) {\n          if (node.depth == columns.length - 1 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.depth == 0 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.partOfCycle) {\n            if (numberOfNonSelfLinkingCycles(node, id) == 0) {\n              node.y0 = y1 / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else if (node.circularLinkType == 'top') {\n              node.y0 = y0 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = y1 - node.value * ky - i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          } else {\n            if (margin.top == 0 || margin.bottom == 0) {\n              node.y0 = (y1 - y0) / nodesLength * i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          }\n        });\n      });\n    }\n\n    // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position\n    // and shift up/down to be closer to the vertical middle of those targets and sources\n    function relaxLeftAndRight(alpha, id) {\n      var columnsLength = columns.length;\n\n      columns.forEach(function (nodes) {\n        var n = nodes.length;\n        var depth = nodes[0].depth;\n\n        nodes.forEach(function (node) {\n          // check the node is not an orphan\n          var nodeHeight;\n          if (node.sourceLinks.length || node.targetLinks.length) {\n            if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) ; else if (depth == 0 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else if (depth == columnsLength - 1 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else {\n              var avg = 0;\n\n              var avgTargetY = mean(node.sourceLinks, linkTargetCenter);\n              var avgSourceY = mean(node.targetLinks, linkSourceCenter);\n\n              if (avgTargetY && avgSourceY) {\n                avg = (avgTargetY + avgSourceY) / 2;\n              } else {\n                avg = avgTargetY || avgSourceY;\n              }\n\n              var dy = (avg - nodeCenter(node)) * alpha;\n              // positive if it node needs to move down\n              node.y0 += dy;\n              node.y1 += dy;\n            }\n          }\n        });\n      });\n    }\n\n    // For each column, check if nodes are overlapping, and if so, shift up/down\n    function resolveCollisions() {\n      columns.forEach(function (nodes) {\n        var node,\n            dy,\n            y = y0,\n            n = nodes.length,\n            i;\n\n        // Push any overlapping nodes down.\n        nodes.sort(ascendingBreadth);\n\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          dy = y - node.y0;\n\n          if (dy > 0) {\n            node.y0 += dy;\n            node.y1 += dy;\n          }\n          y = node.y1 + py;\n        }\n\n        // If the bottommost node goes outside the bounds, push it back up.\n        dy = y - py - y1;\n        if (dy > 0) {\n          y = node.y0 -= dy, node.y1 -= dy;\n\n          // Push any overlapping nodes back up.\n          for (i = n - 2; i >= 0; --i) {\n            node = nodes[i];\n            dy = node.y1 + py - y;\n            if (dy > 0) node.y0 -= dy, node.y1 -= dy;\n            y = node.y0;\n          }\n        }\n      });\n    }\n  }\n\n  // Assign the links y0 and y1 based on source/target nodes position,\n  // plus the link's relative position to other links to the same node\n  function computeLinkBreadths(graph) {\n    graph.nodes.forEach(function (node) {\n      node.sourceLinks.sort(ascendingTargetBreadth);\n      node.targetLinks.sort(ascendingSourceBreadth);\n    });\n    graph.nodes.forEach(function (node) {\n      var y0 = node.y0;\n      var y1 = y0;\n\n      // start from the bottom of the node for cycle links\n      var y0cycle = node.y1;\n      var y1cycle = y0cycle;\n\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y0 = y0cycle - link.width / 2;\n          y0cycle = y0cycle - link.width;\n        } else {\n          link.y0 = y0 + link.width / 2;\n          y0 += link.width;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y1 = y1cycle - link.width / 2;\n          y1cycle = y1cycle - link.width;\n        } else {\n          link.y1 = y1 + link.width / 2;\n          y1 += link.width;\n        }\n      });\n    });\n  }\n\n  return sankeyCircular;\n}\n\n/// /////////////////////////////////////////////////////////////////////////////////\n// Cycle functions\n// portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043\n\n// Identify circles in the link objects\nfunction identifyCircles(graph, id, sortNodes) {\n  var circularLinkID = 0;\n  if (sortNodes === null) {\n\n    // Building adjacency graph\n    var adjList = [];\n    for (var i = 0; i < graph.links.length; i++) {\n      var link = graph.links[i];\n      var source = link.source.index;\n      var target = link.target.index;\n      if (!adjList[source]) adjList[source] = [];\n      if (!adjList[target]) adjList[target] = [];\n\n      // Add links if not already in set\n      if (adjList[source].indexOf(target) === -1) adjList[source].push(target);\n    }\n\n    // Find all elementary circuits\n    var cycles = findCircuits(adjList);\n\n    // Sort by circuits length\n    cycles.sort(function (a, b) {\n      return a.length - b.length;\n    });\n\n    var circularLinks = {};\n    for (i = 0; i < cycles.length; i++) {\n      var cycle = cycles[i];\n      var last = cycle.slice(-2);\n      if (!circularLinks[last[0]]) circularLinks[last[0]] = {};\n      circularLinks[last[0]][last[1]] = true;\n    }\n\n    graph.links.forEach(function (link) {\n      var target = link.target.index;\n      var source = link.source.index;\n      // If self-linking or a back-edge\n      if (target === source || circularLinks[source] && circularLinks[source][target]) {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      } else {\n        link.circular = false;\n      }\n    });\n  } else {\n    graph.links.forEach(function (link) {\n      if (link.source[sortNodes] < link.target[sortNodes]) {\n        link.circular = false;\n      } else {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      }\n    });\n  }\n}\n\n// Assign a circular link type (top or bottom), based on:\n// - if the source/target node already has circular links, then use the same type\n// - if not, choose the type with fewer links\nfunction selectCircularLinkTypes(graph, id) {\n  var numberOfTops = 0;\n  var numberOfBottoms = 0;\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      // if either souce or target has type already use that\n      if (link.source.circularLinkType || link.target.circularLinkType) {\n        // default to source type if available\n        link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;\n      } else {\n        link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';\n      }\n\n      if (link.circularLinkType == 'top') {\n        numberOfTops = numberOfTops + 1;\n      } else {\n        numberOfBottoms = numberOfBottoms + 1;\n      }\n\n      graph.nodes.forEach(function (node) {\n        if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    }\n  });\n\n  //correct self-linking links to be same direction as node\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      //if both source and target node are same type, then link should have same type\n      if (link.source.circularLinkType == link.target.circularLinkType) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n      //if link is selflinking, then link should have same type as node\n      if (selfLinking(link, id)) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n    }\n  });\n}\n\n// Return the angle between a straight line between the source and target of the link, and the vertical plane of the node\nfunction linkAngle(link) {\n  var adjacent = Math.abs(link.y1 - link.y0);\n  var opposite = Math.abs(link.target.x0 - link.source.x1);\n\n  return Math.atan(opposite / adjacent);\n}\n\n// Check if two circular links potentially overlap\nfunction circularLinksCross(link1, link2) {\n  if (link1.source.column < link2.target.column) {\n    return false;\n  } else if (link1.target.column > link2.source.column) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// Return the number of circular links for node, not including self linking links\nfunction numberOfNonSelfLinkingCycles(node, id) {\n  var sourceCount = 0;\n  node.sourceLinks.forEach(function (l) {\n    sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;\n  });\n\n  var targetCount = 0;\n  node.targetLinks.forEach(function (l) {\n    targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;\n  });\n\n  return sourceCount + targetCount;\n}\n\n// Check if a circular link is the only circular link for both its source and target node\nfunction onlyCircularLink(link) {\n  var nodeSourceLinks = link.source.sourceLinks;\n  var sourceCount = 0;\n  nodeSourceLinks.forEach(function (l) {\n    sourceCount = l.circular ? sourceCount + 1 : sourceCount;\n  });\n\n  var nodeTargetLinks = link.target.targetLinks;\n  var targetCount = 0;\n  nodeTargetLinks.forEach(function (l) {\n    targetCount = l.circular ? targetCount + 1 : targetCount;\n  });\n\n  if (sourceCount > 1 || targetCount > 1) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// creates vertical buffer values per set of top/bottom links\nfunction calcVerticalBuffer(links, circularLinkGap, id) {\n  links.sort(sortLinkColumnAscending);\n  links.forEach(function (link, i) {\n    var buffer = 0;\n\n    if (selfLinking(link, id) && onlyCircularLink(link)) {\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    } else {\n      var j = 0;\n      for (j; j < i; j++) {\n        if (circularLinksCross(links[i], links[j])) {\n          var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;\n          buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;\n        }\n      }\n\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    }\n  });\n\n  return links;\n}\n\n// calculate the optimum path for a link to reduce overlaps\nfunction addCircularPathData(graph, circularLinkGap, y1, id) {\n  //var baseRadius = 10\n  var buffer = 5;\n  //var verticalMargin = 25\n\n  var minY = min(graph.links, function (link) {\n    return link.source.y0;\n  });\n\n  // create object for circular Path Data\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData = {};\n    }\n  });\n\n  // calc vertical offsets per top/bottom links\n  var topLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'top';\n  });\n  /* topLinks = */calcVerticalBuffer(topLinks, circularLinkGap, id);\n\n  var bottomLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'bottom';\n  });\n  /* bottomLinks = */calcVerticalBuffer(bottomLinks, circularLinkGap, id);\n\n  // add the base data for each link\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData.arcRadius = link.width + baseRadius;\n      link.circularPathData.leftNodeBuffer = buffer;\n      link.circularPathData.rightNodeBuffer = buffer;\n      link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;\n      link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;\n      link.circularPathData.targetX = link.target.x0;\n      link.circularPathData.sourceY = link.y0;\n      link.circularPathData.targetY = link.y1;\n\n      // for self linking paths, and that the only circular link in/out of that node\n      if (selfLinking(link, id) && onlyCircularLink(link)) {\n        link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;\n\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      } else {\n        // else calculate normally\n        // add left extent coordinates, based on links with same source column and circularLink type\n        var thisColumn = link.source.column;\n        var thisCircularLinkType = link.circularLinkType;\n        var sameColumnLinks = graph.links.filter(function (l) {\n          return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkSourceYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkSourceYAscending);\n        }\n\n        var radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n          radiusOffset = radiusOffset + l.width;\n        });\n\n        // add right extent coordinates, based on links with same target column and circularLink type\n        thisColumn = link.target.column;\n        sameColumnLinks = graph.links.filter(function (l) {\n          return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkTargetYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkTargetYAscending);\n        }\n\n        radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n          radiusOffset = radiusOffset + l.width;\n        });\n\n        // bottom links\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = Math.max(y1, link.source.y1, link.target.y1) + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      }\n\n      // all links\n      link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;\n      link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;\n    }\n\n    if (link.circular) {\n      link.path = createCircularPathString(link);\n    } else {\n      var normalPath = linkHorizontal().source(function (d) {\n        var x = d.source.x0 + (d.source.x1 - d.source.x0);\n        var y = d.y0;\n        return [x, y];\n      }).target(function (d) {\n        var x = d.target.x0;\n        var y = d.y1;\n        return [x, y];\n      });\n      link.path = normalPath(link);\n    }\n  });\n}\n\n// create a d path using the addCircularPathData\nfunction createCircularPathString(link) {\n  var pathString = '';\n  // 'pathData' is assigned a value but never used\n  // var pathData = {}\n\n  if (link.circularLinkType == 'top') {\n    pathString =\n    // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +\n    // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X\n    // line up to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X\n    // line down\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  } else {\n    // bottom path\n    pathString =\n    // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +\n    // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X\n    // line down to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X\n    // line up\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  }\n\n  return pathString;\n}\n\n// sort links based on the distance between the source and tartget node columns\n// if the same, then use Y position of the source node\nfunction sortLinkColumnAscending(link1, link2) {\n  if (linkColumnDistance(link1) == linkColumnDistance(link2)) {\n    return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);\n  } else {\n    return linkColumnDistance(link2) - linkColumnDistance(link1);\n  }\n}\n\n// sort ascending links by their source vertical position, y0\nfunction sortLinkSourceYAscending(link1, link2) {\n  return link1.y0 - link2.y0;\n}\n\n// sort descending links by their source vertical position, y0\nfunction sortLinkSourceYDescending(link1, link2) {\n  return link2.y0 - link1.y0;\n}\n\n// sort ascending links by their target vertical position, y1\nfunction sortLinkTargetYAscending(link1, link2) {\n  return link1.y1 - link2.y1;\n}\n\n// sort descending links by their target vertical position, y1\nfunction sortLinkTargetYDescending(link1, link2) {\n  return link2.y1 - link1.y1;\n}\n\n// return the distance between the link's target and source node, in terms of the nodes' column\nfunction linkColumnDistance(link) {\n  return link.target.column - link.source.column;\n}\n\n// return the distance between the link's target and source node, in terms of the nodes' X coordinate\nfunction linkXLength(link) {\n  return link.target.x0 - link.source.x1;\n}\n\n// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\nfunction linkPerpendicularYToLinkSource(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink);\n\n  // get the adjacent length to the other link's x position\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);\n\n  // add or subtract from longer link1's original y1, depending on the slope\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;\n\n  return yPerpendicular;\n}\n\n// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\nfunction linkPerpendicularYToLinkTarget(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink);\n\n  // get the adjacent length to the other link's x position\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);\n\n  // add or subtract from longer link's original y1, depending on the slope\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;\n\n  return yPerpendicular;\n}\n\n// Move any nodes that overlap links which span 2+ columns\nfunction resolveNodeLinkOverlaps(graph, y0, y1, id) {\n\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      return;\n    }\n\n    if (link.target.column - link.source.column > 1) {\n      var columnToTest = link.source.column + 1;\n      var maxColumnToTest = link.target.column - 1;\n\n      var i = 1;\n      var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;\n\n      for (i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {\n        graph.nodes.forEach(function (node) {\n          if (node.column == columnToTest) {\n            var t = i / (numberOfColumnsToTest + 1);\n\n            // Find all the points of a cubic bezier curve in javascript\n            // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript\n\n            var B0_t = Math.pow(1 - t, 3);\n            var B1_t = 3 * t * Math.pow(1 - t, 2);\n            var B2_t = 3 * Math.pow(t, 2) * (1 - t);\n            var B3_t = Math.pow(t, 3);\n\n            var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;\n\n            var linkY0AtColumn = py_t - link.width / 2;\n            var linkY1AtColumn = py_t + link.width / 2;\n            var dy;\n\n            // If top of link overlaps node, push node up\n            if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {\n\n              dy = node.y1 - linkY0AtColumn + 10;\n              dy = node.circularLinkType == 'bottom' ? dy : -dy;\n\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              // check if other nodes need to move up too\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (nodesOverlap(node, otherNode)) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {\n              // If bottom of link overlaps node, push node down\n              dy = linkY1AtColumn - node.y0 + 10;\n\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              // check if other nodes need to move down too\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {\n              // if link completely overlaps node\n              dy = linkY1AtColumn - node.y0 + 10;\n\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n  });\n}\n\n// check if two nodes overlap\nfunction nodesOverlap(nodeA, nodeB) {\n  // test if nodeA top partially overlaps nodeB\n  if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {\n    return true;\n  } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {\n    // test if nodeA bottom partially overlaps nodeB\n    return true;\n  } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {\n    // test if nodeA covers nodeB\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// update a node, and its associated links, vertical positions (y0, y1)\nfunction adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {\n  if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {\n    node.y0 = node.y0 + dy;\n    node.y1 = node.y1 + dy;\n\n    node.targetLinks.forEach(function (l) {\n      l.y1 = l.y1 + dy;\n    });\n\n    node.sourceLinks.forEach(function (l) {\n      l.y0 = l.y0 + dy;\n    });\n  }\n  return node;\n}\n\n// sort and set the links' y0 for each node\nfunction sortSourceLinks(graph, y1, id, moveNodes) {\n  graph.nodes.forEach(function (node) {\n    // move any nodes up which are off the bottom\n    if (moveNodes && node.y + (node.y1 - node.y0) > y1) {\n      node.y = node.y - (node.y + (node.y1 - node.y0) - y1);\n    }\n\n    var nodesSourceLinks = graph.links.filter(function (l) {\n      return getNodeID(l.source, id) == getNodeID(node, id);\n    });\n\n    var nodeSourceLinksLength = nodesSourceLinks.length;\n\n    // if more than 1 link then sort\n    if (nodeSourceLinksLength > 1) {\n      nodesSourceLinks.sort(function (link1, link2) {\n        // if both are not circular...\n        if (!link1.circular && !link2.circular) {\n          // if the target nodes are the same column, then sort by the link's target y\n          if (link1.target.column == link2.target.column) {\n            return link1.y1 - link2.y1;\n          } else if (!sameInclines(link1, link2)) {\n            // if the links slope in different directions, then sort by the link's target y\n            return link1.y1 - link2.y1;\n\n            // if the links slope in same directions, then sort by any overlap\n          } else {\n            if (link1.target.column > link2.target.column) {\n              var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);\n              return link1.y1 - link2Adj;\n            }\n            if (link2.target.column > link1.target.column) {\n              var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);\n              return link1Adj - link2.y1;\n            }\n          }\n        }\n\n        // if only one is circular, the move top links up, or bottom links down\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        }\n\n        // if both links are circular...\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link1.target.y1 - link2.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.target.column - link1.target.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link2.target.y1 - link1.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.target.column - link2.target.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    }\n\n    // update y0 for links\n    var ySourceOffset = node.y0;\n\n    nodesSourceLinks.forEach(function (link) {\n      link.y0 = ySourceOffset + link.width / 2;\n      ySourceOffset = ySourceOffset + link.width;\n    });\n\n    // correct any circular bottom links so they are at the bottom of the node\n    nodesSourceLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0;\n        // sum the widths of any links that are below this link\n        for (j; j < nodeSourceLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;\n        }\n        link.y0 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n}\n\n// sort and set the links' y1 for each node\nfunction sortTargetLinks(graph, y1, id) {\n  graph.nodes.forEach(function (node) {\n    var nodesTargetLinks = graph.links.filter(function (l) {\n      return getNodeID(l.target, id) == getNodeID(node, id);\n    });\n\n    var nodesTargetLinksLength = nodesTargetLinks.length;\n\n    if (nodesTargetLinksLength > 1) {\n      nodesTargetLinks.sort(function (link1, link2) {\n        // if both are not circular, the base on the source y position\n        if (!link1.circular && !link2.circular) {\n          if (link1.source.column == link2.source.column) {\n            return link1.y0 - link2.y0;\n          } else if (!sameInclines(link1, link2)) {\n            return link1.y0 - link2.y0;\n          } else {\n            // get the angle of the link to the further source node (ie the smaller column)\n            if (link2.source.column < link1.source.column) {\n              var link2Adj = linkPerpendicularYToLinkSource(link2, link1);\n\n              return link1.y0 - link2Adj;\n            }\n            if (link1.source.column < link2.source.column) {\n              var link1Adj = linkPerpendicularYToLinkSource(link1, link2);\n\n              return link1Adj - link2.y0;\n            }\n          }\n        }\n\n        // if only one is circular, the move top links up, or bottom links down\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        }\n\n        // if both links are circular...\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.source.column - link2.source.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.source.column - link1.source.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    }\n\n    // update y1 for links\n    var yTargetOffset = node.y0;\n\n    nodesTargetLinks.forEach(function (link) {\n      link.y1 = yTargetOffset + link.width / 2;\n      yTargetOffset = yTargetOffset + link.width;\n    });\n\n    // correct any circular bottom links so they are at the bottom of the node\n    nodesTargetLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0;\n        // sum the widths of any links that are below this link\n        for (j; j < nodesTargetLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;\n        }\n        link.y1 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n}\n\n// test if links both slope up, or both slope down\nfunction sameInclines(link1, link2) {\n  return incline(link1) == incline(link2);\n}\n\n// returns the slope of a link, from source to target\n// up => slopes up from source to target\n// down => slopes down from source to target\nfunction incline(link) {\n  return link.y0 - link.y1 > 0 ? 'up' : 'down';\n}\n\n// check if link is self linking, ie links a node to the same node\nfunction selfLinking(link, id) {\n  return getNodeID(link.source, id) == getNodeID(link.target, id);\n}\n\nfunction fillHeight(graph, y0, y1) {\n\n  var nodes = graph.nodes;\n  var links = graph.links;\n\n  var top = false;\n  var bottom = false;\n\n  links.forEach(function (link) {\n    if (link.circularLinkType == \"top\") {\n      top = true;\n    } else if (link.circularLinkType == \"bottom\") {\n      bottom = true;\n    }\n  });\n\n  if (top == false || bottom == false) {\n    var minY0 = min(nodes, function (node) {\n      return node.y0;\n    });\n    var maxY1 = max(nodes, function (node) {\n      return node.y1;\n    });\n    var currentHeight = maxY1 - minY0;\n    var chartHeight = y1 - y0;\n    var ratio = chartHeight / currentHeight;\n\n    nodes.forEach(function (node) {\n      var nodeHeight = (node.y1 - node.y0) * ratio;\n      node.y0 = (node.y0 - minY0) * ratio;\n      node.y1 = node.y0 + nodeHeight;\n    });\n\n    links.forEach(function (link) {\n      link.y0 = (link.y0 - minY0) * ratio;\n      link.y1 = (link.y1 - minY0) * ratio;\n      link.width = link.width * ratio;\n    });\n  }\n}\n\nexport { sankeyCircular, center as sankeyCenter, left as sankeyLeft, right as sankeyRight, justify as sankeyJustify };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}