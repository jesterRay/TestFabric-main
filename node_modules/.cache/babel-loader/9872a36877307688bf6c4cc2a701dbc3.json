{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function (s, font) {\n  var variant = font.variant;\n  var style = font.style;\n  var weight = font.weight;\n  var color = font.color;\n  var size = font.size;\n  var family = font.family;\n  var shadow = font.shadow;\n  var lineposition = font.lineposition;\n  var textcase = font.textcase;\n  if (family) s.style('font-family', family);\n  if (size + 1) s.style('font-size', size + 'px');\n  if (color) s.call(Color.fill, color);\n  if (weight) s.style('font-weight', weight);\n  if (style) s.style('font-style', style);\n  if (variant) s.style('font-variant', variant);\n  if (textcase) s.style('text-transform', dropNone(textcase2transform(textcase)));\n  if (shadow) s.style('text-shadow', shadow === 'auto' ? svgTextUtils.makeTextShadow(Color.contrast(color)) : dropNone(shadow));\n  if (lineposition) s.style('text-decoration-line', dropNone(lineposition2decorationLine(lineposition)));\n};\nfunction dropNone(a) {\n  return a === 'none' ? undefined : a;\n}\nvar textcase2transformOptions = {\n  normal: 'none',\n  lower: 'lowercase',\n  upper: 'uppercase',\n  'word caps': 'capitalize'\n};\nfunction textcase2transform(textcase) {\n  return textcase2transformOptions[textcase];\n}\nfunction lineposition2decorationLine(lineposition) {\n  return lineposition.replace('under', 'underline').replace('over', 'overline').replace('through', 'line-through').split('+').join(' ');\n}\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function (s, x, y) {\n  s.attr('x', x).attr('y', y);\n};\ndrawing.setSize = function (s, w, h) {\n  s.attr('width', w).attr('height', h);\n};\ndrawing.setRect = function (s, x, y, w, h) {\n  s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function (d, sel, xa, ya) {\n  var x = xa.c2p(d.x);\n  var y = ya.c2p(d.y);\n  if (isNumeric(x) && isNumeric(y) && sel.node()) {\n    // for multiline text this works better\n    if (sel.node().nodeName === 'text') {\n      sel.attr('x', x).attr('y', y);\n    } else {\n      sel.attr('transform', strTranslate(x, y));\n    }\n  } else {\n    return false;\n  }\n  return true;\n};\ndrawing.translatePoints = function (s, xa, ya) {\n  s.each(function (d) {\n    var sel = d3.select(this);\n    drawing.translatePoint(d, sel, xa, ya);\n  });\n};\ndrawing.hideOutsideRangePoint = function (d, sel, xa, ya, xcalendar, ycalendar) {\n  sel.attr('display', xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : 'none');\n};\ndrawing.hideOutsideRangePoints = function (traceGroups, subplot) {\n  if (!subplot._hasClipOnAxisFalse) return;\n  var xa = subplot.xaxis;\n  var ya = subplot.yaxis;\n  traceGroups.each(function (d) {\n    var trace = d[0].trace;\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n    traceGroups.selectAll(selector).each(function (d) {\n      drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n    });\n  });\n};\ndrawing.crispRound = function (gd, lineWidth, dflt) {\n  // for lines that disable antialiasing we want to\n  // make sure the width is an integer, and at least 1 if it's nonzero\n\n  if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n  // but not for static plots - these don't get antialiased anyway.\n  if (gd._context.staticPlot) return lineWidth;\n  if (lineWidth < 1) return 1;\n  return Math.round(lineWidth);\n};\ndrawing.singleLineStyle = function (d, s, lw, lc, ld) {\n  s.style('fill', 'none');\n  var line = (((d || [])[0] || {}).trace || {}).line || {};\n  var lw1 = lw || line.width || 0;\n  var dash = ld || line.dash || '';\n  Color.stroke(s, lc || line.color);\n  drawing.dashLine(s, dash, lw1);\n};\ndrawing.lineGroupStyle = function (s, lw, lc, ld) {\n  s.style('fill', 'none').each(function (d) {\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n    d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);\n  });\n};\ndrawing.dashLine = function (s, dash, lineWidth) {\n  lineWidth = +lineWidth || 0;\n  dash = drawing.dashStyle(dash, lineWidth);\n  s.style({\n    'stroke-dasharray': dash,\n    'stroke-width': lineWidth + 'px'\n  });\n};\ndrawing.dashStyle = function (dash, lineWidth) {\n  lineWidth = +lineWidth || 1;\n  var dlw = Math.max(lineWidth, 3);\n  if (dash === 'solid') dash = '';else if (dash === 'dot') dash = dlw + 'px,' + dlw + 'px';else if (dash === 'dash') dash = 3 * dlw + 'px,' + 3 * dlw + 'px';else if (dash === 'longdash') dash = 5 * dlw + 'px,' + 5 * dlw + 'px';else if (dash === 'dashdot') {\n    dash = 3 * dlw + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n  } else if (dash === 'longdashdot') {\n    dash = 5 * dlw + 'px,' + 2 * dlw + 'px,' + dlw + 'px,' + 2 * dlw + 'px';\n  }\n  // otherwise user wrote the dasharray themselves - leave it be\n\n  return dash;\n};\nfunction setFillStyle(sel, trace, gd, forLegend) {\n  var markerPattern = trace.fillpattern;\n  var fillgradient = trace.fillgradient;\n  var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n  if (patternShape) {\n    var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n    var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n    var patternFGOpacity = markerPattern.fgopacity;\n    var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n    var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n    var patternID = trace.uid;\n    drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, undefined, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n  } else if (fillgradient && fillgradient.type !== 'none') {\n    var direction = fillgradient.type;\n    var gradientID = 'scatterfill-' + trace.uid;\n    if (forLegend) {\n      gradientID = 'legendfill-' + trace.uid;\n    }\n    if (!forLegend && (fillgradient.start !== undefined || fillgradient.stop !== undefined)) {\n      var start, stop;\n      if (direction === 'horizontal') {\n        start = {\n          x: fillgradient.start,\n          y: 0\n        };\n        stop = {\n          x: fillgradient.stop,\n          y: 0\n        };\n      } else if (direction === 'vertical') {\n        start = {\n          x: 0,\n          y: fillgradient.start\n        };\n        stop = {\n          x: 0,\n          y: fillgradient.stop\n        };\n      }\n      start.x = trace._xA.c2p(start.x === undefined ? trace._extremes.x.min[0].val : start.x, true);\n      start.y = trace._yA.c2p(start.y === undefined ? trace._extremes.y.min[0].val : start.y, true);\n      stop.x = trace._xA.c2p(stop.x === undefined ? trace._extremes.x.max[0].val : stop.x, true);\n      stop.y = trace._yA.c2p(stop.y === undefined ? trace._extremes.y.max[0].val : stop.y, true);\n      sel.call(gradientWithBounds, gd, gradientID, 'linear', fillgradient.colorscale, 'fill', start, stop, true, false);\n    } else {\n      if (direction === 'horizontal') {\n        direction = direction + 'reversed';\n      }\n      sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, 'fill');\n    }\n  } else if (trace.fillcolor) {\n    sel.call(Color.fill, trace.fillcolor);\n  }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function (sel, gd) {\n  var node = d3.select(sel.node());\n  var data = node.data();\n  var trace = ((data[0] || [])[0] || {}).trace || {};\n  setFillStyle(sel, trace, gd, false);\n};\ndrawing.fillGroupStyle = function (s, gd, forLegend) {\n  s.style('stroke-width', 0).each(function (d) {\n    var shape = d3.select(this);\n    // N.B. 'd' won't be a calcdata item when\n    // fill !== 'none' on a segment-less and marker-less trace\n    if (d[0].trace) {\n      setFillStyle(shape, d[0].trace, gd, forLegend);\n    }\n  });\n};\nvar SYMBOLDEFS = require('./symbol_defs');\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\nObject.keys(SYMBOLDEFS).forEach(function (k) {\n  var symDef = SYMBOLDEFS[k];\n  var n = symDef.n;\n  drawing.symbolList.push(n, String(n), k, n + 100, String(n + 100), k + '-open');\n  drawing.symbolNames[n] = k;\n  drawing.symbolFuncs[n] = symDef.f;\n  drawing.symbolBackOffs[n] = symDef.backoff || 0;\n  if (symDef.needLine) {\n    drawing.symbolNeedLines[n] = true;\n  }\n  if (symDef.noDot) {\n    drawing.symbolNoDot[n] = true;\n  } else {\n    drawing.symbolList.push(n + 200, String(n + 200), k + '-dot', n + 300, String(n + 300), k + '-open-dot');\n  }\n  if (symDef.noFill) {\n    drawing.symbolNoFill[n] = true;\n  }\n});\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\ndrawing.symbolNumber = function (v) {\n  if (isNumeric(v)) {\n    v = +v;\n  } else if (typeof v === 'string') {\n    var vbase = 0;\n    if (v.indexOf('-open') > 0) {\n      vbase = 100;\n      v = v.replace('-open', '');\n    }\n    if (v.indexOf('-dot') > 0) {\n      vbase += 200;\n      v = v.replace('-dot', '');\n    }\n    v = drawing.symbolNames.indexOf(v);\n    if (v >= 0) {\n      v += vbase;\n    }\n  }\n  return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));\n};\nfunction makePointPath(symbolNumber, r, t, s) {\n  var base = symbolNumber % 100;\n  return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n  radial: {\n    type: 'radial'\n  },\n  radialreversed: {\n    type: 'radial',\n    reversed: true\n  },\n  horizontal: {\n    type: 'linear',\n    start: {\n      x: 1,\n      y: 0\n    },\n    stop: {\n      x: 0,\n      y: 0\n    }\n  },\n  horizontalreversed: {\n    type: 'linear',\n    start: {\n      x: 1,\n      y: 0\n    },\n    stop: {\n      x: 0,\n      y: 0\n    },\n    reversed: true\n  },\n  vertical: {\n    type: 'linear',\n    start: {\n      x: 0,\n      y: 1\n    },\n    stop: {\n      x: 0,\n      y: 0\n    }\n  },\n  verticalreversed: {\n    type: 'linear',\n    start: {\n      x: 0,\n      y: 1\n    },\n    stop: {\n      x: 0,\n      y: 0\n    },\n    reversed: true\n  }\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function (sel, gd, gradientID, type, colorscale, prop) {\n  var info = gradientInfo[type];\n  return gradientWithBounds(sel, gd, gradientID, info.type, colorscale, prop, info.start, info.stop, false, info.reversed);\n};\n\n/**\n * gradient_with_bounds: create and apply a gradient fill for defined start and stop positions\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial' or 'linear'. Radial goes center to edge,\n *     horizontal goes as defined by start and stop\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n * @param {object} start: start point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {object} stop: stop point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {boolean} inUserSpace: If true, start and stop give absolute values in the plot.\n *     If false, start and stop are fractions of the traces extent along each axis.\n * @param {boolean} reversed: If true, the gradient is reversed between normal start and stop,\n *     i.e., the colorscale is applied in order from stop to start for linear, from edge\n *     to center for radial gradients.\n */\nfunction gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {\n  var len = colorscale.length;\n  var info;\n  if (type === 'linear') {\n    info = {\n      node: 'linearGradient',\n      attrs: {\n        x1: start.x,\n        y1: start.y,\n        x2: stop.x,\n        y2: stop.y,\n        gradientUnits: inUserSpace ? 'userSpaceOnUse' : 'objectBoundingBox'\n      },\n      reversed: reversed\n    };\n  } else if (type === 'radial') {\n    info = {\n      node: 'radialGradient',\n      reversed: reversed\n    };\n  }\n  var colorStops = new Array(len);\n  for (var i = 0; i < len; i++) {\n    if (info.reversed) {\n      colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n    } else {\n      colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n  var gradient = fullLayout._defs.select('.gradients').selectAll('#' + fullID).data([type + colorStops.join(';')], Lib.identity);\n  gradient.exit().remove();\n  gradient.enter().append(info.node).each(function () {\n    var el = d3.select(this);\n    if (info.attrs) el.attr(info.attrs);\n    el.attr('id', fullID);\n    var stops = el.selectAll('stop').data(colorStops);\n    stops.exit().remove();\n    stops.enter().append('stop');\n    stops.each(function (d) {\n      var tc = tinycolor(d[1]);\n      d3.select(this).attr({\n        offset: d[0] + '%',\n        'stop-color': Color.tinyRGB(tc),\n        'stop-opacity': tc.getAlpha()\n      });\n    });\n  });\n  sel.style(prop, getFullUrl(fullID, gd)).style(prop + '-opacity', null);\n  sel.classed('gradient_filled', true);\n}\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function (sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n  var isLegend = calledBy === 'legend';\n  if (mcc) {\n    if (fillmode === 'overlay') {\n      bgcolor = mcc;\n      fgcolor = Color.contrast(bgcolor);\n    } else {\n      bgcolor = undefined;\n      fgcolor = mcc;\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'p' + fullLayout._uid + '-' + patternID;\n  var width, height;\n\n  // linear interpolation\n  var linearFn = function (x, x0, x1, y0, y1) {\n    return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n  };\n  var path, linewidth, radius;\n  var patternTag;\n  var patternAttrs = {};\n  var fgC = tinycolor(fgcolor);\n  var fgRGB = Color.tinyRGB(fgC);\n  var fgAlpha = fgC.getAlpha();\n  var opacity = fgopacity * fgAlpha;\n  switch (shape) {\n    case '/':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '\\\\':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case 'x':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2 + 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '|':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '-':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '+':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height + 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '.':\n      width = size;\n      height = size;\n      if (solidity < Math.PI / 4) {\n        radius = Math.sqrt(solidity * size * size / Math.PI);\n      } else {\n        radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n      }\n      patternTag = 'circle';\n      patternAttrs = {\n        cx: width / 2,\n        cy: height / 2,\n        r: radius,\n        opacity: opacity,\n        fill: fgRGB\n      };\n      break;\n  }\n  var str = [shape || 'noSh', bgcolor || 'noBg', fgcolor || 'noFg', size, solidity].join(';');\n  var pattern = fullLayout._defs.select('.patterns').selectAll('#' + fullID).data([str], Lib.identity);\n  pattern.exit().remove();\n  pattern.enter().append('pattern').each(function () {\n    var el = d3.select(this);\n    el.attr({\n      id: fullID,\n      width: width + 'px',\n      height: height + 'px',\n      patternUnits: 'userSpaceOnUse',\n      // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n      patternTransform: isLegend ? 'scale(0.8)' : ''\n    });\n    if (bgcolor) {\n      var bgC = tinycolor(bgcolor);\n      var bgRGB = Color.tinyRGB(bgC);\n      var bgAlpha = bgC.getAlpha();\n      var rects = el.selectAll('rect').data([0]);\n      rects.exit().remove();\n      rects.enter().append('rect').attr({\n        width: width + 'px',\n        height: height + 'px',\n        fill: bgRGB,\n        'fill-opacity': bgAlpha\n      });\n    }\n    var patterns = el.selectAll(patternTag).data([0]);\n    patterns.exit().remove();\n    patterns.enter().append(patternTag).attr(patternAttrs);\n  });\n  sel.style('fill', getFullUrl(fullID, gd)).style('fill-opacity', null);\n  sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n  gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n  d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\ndrawing.initPatterns = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n  patternsGroup.selectAll('pattern').remove();\n  d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\ndrawing.getPatternAttr = function (mp, i, dflt) {\n  if (mp && Lib.isArrayOrTypedArray(mp)) {\n    return i < mp.length ? mp[i] : dflt;\n  }\n  return mp;\n};\ndrawing.pointStyle = function (s, trace, gd, pt) {\n  if (!s.size()) return;\n  var fns = drawing.makePointStyleFns(trace);\n  s.each(function (d) {\n    drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);\n  });\n};\ndrawing.singlePointStyle = function (d, sel, trace, fns, gd, pt) {\n  var marker = trace.marker;\n  var markerLine = marker.line;\n  if (pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;\n  sel.style('opacity', fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === undefined ? marker.opacity : d.mo);\n  if (fns.ms2mrc) {\n    var r;\n\n    // handle multi-trace graph edit case\n    if (d.ms === 'various' || marker.size === 'various') {\n      r = 3;\n    } else {\n      r = fns.ms2mrc(d.ms);\n    }\n\n    // store the calculated size so hover can use it\n    d.mrc = r;\n    if (fns.selectedSizeFn) {\n      r = d.mrc = fns.selectedSizeFn(d);\n    }\n\n    // turn the symbol into a sanitized number\n    var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n    // save if this marker is open\n    // because that impacts how to handle colors\n    d.om = x % 200 >= 100;\n    var angle = getMarkerAngle(d, trace);\n    var standoff = getMarkerStandoff(d, trace);\n    sel.attr('d', makePointPath(x, r, angle, standoff));\n  }\n  var perPointGradient = false;\n  var fillColor, lineColor, lineWidth;\n\n  // 'so' is suspected outliers, for box plots\n  if (d.so) {\n    lineWidth = markerLine.outlierwidth;\n    lineColor = markerLine.outliercolor;\n    fillColor = marker.outliercolor;\n  } else {\n    var markerLineWidth = (markerLine || {}).width;\n    lineWidth = (d.mlw + 1 || markerLineWidth + 1 ||\n    // TODO: we need the latter for legends... can we get rid of it?\n    (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;\n    if ('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n    // weird case: array wasn't long enough to apply to every point\n    else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;else lineColor = markerLine.color;\n    if (Lib.isArrayOrTypedArray(marker.color)) {\n      fillColor = Color.defaultLine;\n      perPointGradient = true;\n    }\n    if ('mc' in d) {\n      fillColor = d.mcc = fns.markerScale(d.mc);\n    } else {\n      fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';\n    }\n    if (fns.selectedColorFn) {\n      fillColor = fns.selectedColorFn(d);\n    }\n  }\n  if (d.om) {\n    // open markers can't have zero linewidth, default to 1px,\n    // and use fill color as stroke color\n    sel.call(Color.stroke, fillColor).style({\n      'stroke-width': (lineWidth || 1) + 'px',\n      fill: 'none'\n    });\n  } else {\n    sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n    var markerGradient = marker.gradient;\n    var gradientType = d.mgt;\n    if (gradientType) perPointGradient = true;else gradientType = markerGradient && markerGradient.type;\n\n    // for legend - arrays will propagate through here, but we don't need\n    // to treat it as per-point.\n    if (Lib.isArrayOrTypedArray(gradientType)) {\n      gradientType = gradientType[0];\n      if (!gradientInfo[gradientType]) gradientType = 0;\n    }\n    var markerPattern = marker.pattern;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n    if (gradientType && gradientType !== 'none') {\n      var gradientColor = d.mgc;\n      if (gradientColor) perPointGradient = true;else gradientColor = markerGradient.color;\n      var gradientID = trace.uid;\n      if (perPointGradient) gradientID += '-' + d.i;\n      drawing.gradient(sel, gd, gradientID, gradientType, [[0, gradientColor], [1, fillColor]], 'fill');\n    } else if (patternShape) {\n      var perPointPattern = false;\n      var fgcolor = markerPattern.fgcolor;\n      if (!fgcolor && pt && pt.color) {\n        fgcolor = pt.color;\n        perPointPattern = true;\n      }\n      var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);\n      var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n      var patternFGOpacity = markerPattern.fgopacity;\n      var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n      var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n      perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);\n      var patternID = trace.uid;\n      if (perPointPattern) patternID += '-' + d.i;\n      drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, d.mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n    } else {\n      Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);\n    }\n    if (lineWidth) {\n      Color.stroke(sel, lineColor);\n    }\n  }\n};\ndrawing.makePointStyleFns = function (trace) {\n  var out = {};\n  var marker = trace.marker;\n\n  // allow array marker and marker line colors to be\n  // scaled by given max and min to colorscales\n  out.markerScale = drawing.tryColorscale(marker, '');\n  out.lineScale = drawing.tryColorscale(marker, 'line');\n  if (Registry.traceIs(trace, 'symbols')) {\n    out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function () {\n      return (marker.size || 6) / 2;\n    };\n  }\n  if (trace.selectedpoints) {\n    Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n  }\n  return out;\n};\ndrawing.makeSelectedPointStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var marker = trace.marker || {};\n  var selectedMarker = selectedAttrs.marker || {};\n  var unselectedMarker = unselectedAttrs.marker || {};\n  var mo = marker.opacity;\n  var smo = selectedMarker.opacity;\n  var usmo = unselectedMarker.opacity;\n  var smoIsDefined = smo !== undefined;\n  var usmoIsDefined = usmo !== undefined;\n  if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n    out.selectedOpacityFn = function (d) {\n      var base = d.mo === undefined ? marker.opacity : d.mo;\n      if (d.selected) {\n        return smoIsDefined ? smo : base;\n      } else {\n        return usmoIsDefined ? usmo : DESELECTDIM * base;\n      }\n    };\n  }\n  var mc = marker.color;\n  var smc = selectedMarker.color;\n  var usmc = unselectedMarker.color;\n  if (smc || usmc) {\n    out.selectedColorFn = function (d) {\n      var base = d.mcc || mc;\n      if (d.selected) {\n        return smc || base;\n      } else {\n        return usmc || base;\n      }\n    };\n  }\n  var ms = marker.size;\n  var sms = selectedMarker.size;\n  var usms = unselectedMarker.size;\n  var smsIsDefined = sms !== undefined;\n  var usmsIsDefined = usms !== undefined;\n  if (Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n    out.selectedSizeFn = function (d) {\n      var base = d.mrc || ms / 2;\n      if (d.selected) {\n        return smsIsDefined ? sms / 2 : base;\n      } else {\n        return usmsIsDefined ? usms / 2 : base;\n      }\n    };\n  }\n  return out;\n};\ndrawing.makeSelectedTextStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var textFont = trace.textfont || {};\n  var selectedTextFont = selectedAttrs.textfont || {};\n  var unselectedTextFont = unselectedAttrs.textfont || {};\n  var tc = textFont.color;\n  var stc = selectedTextFont.color;\n  var utc = unselectedTextFont.color;\n  out.selectedTextColorFn = function (d) {\n    var base = d.tc || tc;\n    if (d.selected) {\n      return stc || base;\n    } else {\n      if (utc) return utc;else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n    }\n  };\n  return out;\n};\ndrawing.selectedPointStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedPointStyleFns(trace);\n  var marker = trace.marker || {};\n  var seq = [];\n  if (fns.selectedOpacityFn) {\n    seq.push(function (pt, d) {\n      pt.style('opacity', fns.selectedOpacityFn(d));\n    });\n  }\n  if (fns.selectedColorFn) {\n    seq.push(function (pt, d) {\n      Color.fill(pt, fns.selectedColorFn(d));\n    });\n  }\n  if (fns.selectedSizeFn) {\n    seq.push(function (pt, d) {\n      var mx = d.mx || marker.symbol || 0;\n      var mrc2 = fns.selectedSizeFn(d);\n      pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n      // save for Drawing.selectedTextStyle\n      d.mrc2 = mrc2;\n    });\n  }\n  if (seq.length) {\n    s.each(function (d) {\n      var pt = d3.select(this);\n      for (var i = 0; i < seq.length; i++) {\n        seq[i](pt, d);\n      }\n    });\n  }\n};\ndrawing.tryColorscale = function (marker, prefix) {\n  var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n  if (cont) {\n    var colorArray = cont.color;\n    if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n      return Colorscale.makeColorScaleFuncFromTrace(cont);\n    }\n  }\n  return Lib.identity;\n};\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  end: -1,\n  middle: 0,\n  bottom: 1,\n  top: -1\n};\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n  var group = d3.select(s.node().parentNode);\n  var v = textPosition.indexOf('top') !== -1 ? 'top' : textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n  var h = textPosition.indexOf('left') !== -1 ? 'end' : textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n  // if markers are shown, offset a little more than\n  // the nominal marker size\n  // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n  var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n  var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n  var dx = TEXTOFFSETSIGN[h] * r;\n  var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n  // fix the overall text group position\n  s.attr('text-anchor', h);\n  if (!dontTouchParent) {\n    group.attr('transform', strTranslate(dx, dy));\n  }\n}\nfunction extracTextFontSize(d, trace) {\n  var fontSize = d.ts || trace.textfont.size;\n  return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function (s, trace, gd) {\n  if (!s.size()) return;\n  var selectedTextColorFn;\n  if (trace.selectedpoints) {\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n    selectedTextColorFn = fns.selectedTextColorFn;\n  }\n  var texttemplate = trace.texttemplate;\n  var fullLayout = gd._fullLayout;\n  s.each(function (d) {\n    var p = d3.select(this);\n    var text = texttemplate ? Lib.extractOption(d, trace, 'txt', 'texttemplate') : Lib.extractOption(d, trace, 'tx', 'text');\n    if (!text && text !== 0) {\n      p.remove();\n      return;\n    }\n    if (texttemplate) {\n      var fn = trace._module.formatLabels;\n      var labels = fn ? fn(d, trace, fullLayout) : {};\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, d.i);\n      var meta = trace._meta || {};\n      text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n    }\n    var pos = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;\n    p.call(drawing.font, {\n      family: d.tf || trace.textfont.family,\n      weight: d.tw || trace.textfont.weight,\n      style: d.ty || trace.textfont.style,\n      variant: d.tv || trace.textfont.variant,\n      textcase: d.tC || trace.textfont.textcase,\n      lineposition: d.tE || trace.textfont.lineposition,\n      shadow: d.tS || trace.textfont.shadow,\n      size: fontSize,\n      color: fontColor\n    }).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);\n  });\n};\ndrawing.selectedTextStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedTextStyleFns(trace);\n  s.each(function (d) {\n    var tx = d3.select(this);\n    var tc = fns.selectedTextColorFn(d);\n    var tp = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    Color.fill(tx, tc);\n    var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n    textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n  });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L');\n  }\n  var path = 'M' + pts[0];\n  var tangents = [];\n  var i;\n  for (i = 1; i < pts.length - 1; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  path += 'Q' + tangents[0][0] + ' ' + pts[1];\n  for (i = 2; i < pts.length - 1; i++) {\n    path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n  }\n  path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n  return path;\n};\ndrawing.smoothclosed = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L') + 'Z';\n  }\n  var path = 'M' + pts[0];\n  var pLast = pts.length - 1;\n  var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n  var i;\n  for (i = 1; i < pLast; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));\n  for (i = 1; i <= pLast; i++) {\n    path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n  }\n  path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n  return path;\n};\nvar lastDrawnX, lastDrawnY;\nfunction roundEnd(pt, isY, isLastPoint) {\n  if (isLastPoint) pt = applyBackoff(pt);\n  return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\nfunction roundX(p) {\n  var v = d3.round(p, 2);\n  lastDrawnX = v;\n  return v;\n}\nfunction roundY(p) {\n  var v = d3.round(p, 2);\n  lastDrawnY = v;\n  return v;\n}\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n  var d1x = prevpt[0] - thispt[0];\n  var d1y = prevpt[1] - thispt[1];\n  var d2x = nextpt[0] - thispt[0];\n  var d2y = nextpt[1] - thispt[1];\n  var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n  var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n  var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n  var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n  var denom1 = 3 * d2a * (d1a + d2a);\n  var denom2 = 3 * d1a * (d1a + d2a);\n  return [[roundX(thispt[0] + (denom1 && numx / denom1)), roundY(thispt[1] + (denom1 && numy / denom1))], [roundX(thispt[0] - (denom2 && numx / denom2)), roundY(thispt[1] - (denom2 && numy / denom2))]];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n  hv: function (p0, p1, isLastPoint) {\n    return 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  },\n  vh: function (p0, p1, isLastPoint) {\n    return 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  hvh: function (p0, p1, isLastPoint) {\n    return 'H' + roundX((p0[0] + p1[0]) / 2) + 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  vhv: function (p0, p1, isLastPoint) {\n    return 'V' + roundY((p0[1] + p1[1]) / 2) + 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  }\n};\nvar STEPLINEAR = function (p0, p1, isLastPoint) {\n  return 'L' + roundEnd(p1, 0, isLastPoint) + ',' + roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function (shape) {\n  var onestep = STEPPATH[shape] || STEPLINEAR;\n  return function (pts) {\n    var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n    var len = pts.length;\n    for (var i = 1; i < len; i++) {\n      path += onestep(pts[i - 1], pts[i], i === len - 1);\n    }\n    return path;\n  };\n};\nfunction applyBackoff(pt, start) {\n  var backoff = pt.backoff;\n  var trace = pt.trace;\n  var d = pt.d;\n  var i = pt.i;\n  if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== 'spline') {\n    var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n    var end = pt;\n    var x1 = start ? start[0] : lastDrawnX || 0;\n    var y1 = start ? start[1] : lastDrawnY || 0;\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var t = Math.atan2(dy, dx);\n    var b = arrayBackoff ? backoff[i] : backoff;\n    if (b === 'auto') {\n      var endI = end.i;\n      if (trace.type === 'scatter') endI--; // Why we need this hack?\n\n      var endMarker = end.marker;\n      var endMarkerSymbol = endMarker.symbol;\n      if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n      var endMarkerSize = endMarker.size;\n      if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n      b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n      b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n    }\n    var x = x2 - b * Math.cos(t);\n    var y = y2 - b * Math.sin(t);\n    if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {\n      pt = [x, y];\n    }\n  }\n  return pt;\n}\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function () {\n  var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function (s) {\n    s.attr(xmlnsNamespaces.svgAttrs).style({\n      position: 'absolute',\n      left: '-10000px',\n      top: '-10000px',\n      width: '9000px',\n      height: '9000px',\n      'z-index': '1'\n    });\n  });\n\n  // browsers differ on how they describe the bounding rect of\n  // the svg if its contents spill over... so make a 1x1px\n  // reference point we can measure off of.\n  var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function (s) {\n    s.attr('d', 'M0,0H1V1H0Z').style({\n      'stroke-width': 0,\n      fill: 'black'\n    });\n  });\n  drawing.tester = tester;\n  drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\ndrawing.bBox = function (node, inTester, hash) {\n  /*\n   * Cache elements we've already measured so we don't have to\n   * remeasure the same thing many times\n   * We have a few bBox callers though who pass a node larger than\n   * a <text> or a MathJax <g>, such as an axis group containing many labels.\n   * These will not generate a hash (unless we figure out an appropriate\n   * hash key for them) and thus we will not hash them.\n   */\n  if (!hash) hash = nodeHash(node);\n  var out;\n  if (hash) {\n    out = drawing.savedBBoxes[hash];\n    if (out) return Lib.extendFlat({}, out);\n  } else if (node.childNodes.length === 1) {\n    /*\n     * If we have only one child element, which is itself hashable, make\n     * a new hash from this element plus its x,y,transform\n     * These bounding boxes *include* x,y,transform - mostly for use by\n     * callers trying to avoid overlaps (ie titles)\n     */\n    var innerNode = node.childNodes[0];\n    hash = nodeHash(innerNode);\n    if (hash) {\n      var x = +innerNode.getAttribute('x') || 0;\n      var y = +innerNode.getAttribute('y') || 0;\n      var transform = innerNode.getAttribute('transform');\n      if (!transform) {\n        // in this case, just varying x and y, don't bother caching\n        // the final bBox because the alteration is quick.\n        var innerBB = drawing.bBox(innerNode, false, hash);\n        if (x) {\n          innerBB.left += x;\n          innerBB.right += x;\n        }\n        if (y) {\n          innerBB.top += y;\n          innerBB.bottom += y;\n        }\n        return innerBB;\n      }\n      /*\n       * else we have a transform - rather than make a complicated\n       * (and error-prone and probably slow) transform parser/calculator,\n       * just continue on calculating the boundingClientRect of the group\n       * and use the new composite hash to cache it.\n       * That said, `innerNode.transform.baseVal` is an array of\n       * `SVGTransform` objects, that *do* seem to have a nice matrix\n       * multiplication interface that we could use to avoid making\n       * another getBoundingClientRect call...\n       */\n      hash += '~' + x + '~' + y + '~' + transform;\n      out = drawing.savedBBoxes[hash];\n      if (out) return Lib.extendFlat({}, out);\n    }\n  }\n  var testNode, tester;\n  if (inTester) {\n    testNode = node;\n  } else {\n    tester = drawing.tester.node();\n\n    // copy the node to test into the tester\n    testNode = node.cloneNode(true);\n    tester.appendChild(testNode);\n  }\n\n  // standardize its position (and newline tspans if any)\n  d3.select(testNode).attr('transform', null).call(svgTextUtils.positionText, 0, 0);\n  var testRect = testNode.getBoundingClientRect();\n  var refRect = drawing.testref.node().getBoundingClientRect();\n  if (!inTester) tester.removeChild(testNode);\n  var bb = {\n    height: testRect.height,\n    width: testRect.width,\n    left: testRect.left - refRect.left,\n    top: testRect.top - refRect.top,\n    right: testRect.right - refRect.left,\n    bottom: testRect.bottom - refRect.top\n  };\n\n  // make sure we don't have too many saved boxes,\n  // or a long session could overload on memory\n  // by saving boxes for long-gone elements\n  if (savedBBoxesCount >= maxSavedBBoxes) {\n    drawing.savedBBoxes = {};\n    savedBBoxesCount = 0;\n  }\n\n  // cache this bbox\n  if (hash) drawing.savedBBoxes[hash] = bb;\n  savedBBoxesCount++;\n  return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n  var inputText = node.getAttribute('data-unformatted');\n  if (inputText === null) return;\n  return inputText + node.getAttribute('data-math') + node.getAttribute('text-anchor') + node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function (s, localId, gd) {\n  s.attr('clip-path', getFullUrl(localId, gd));\n};\nfunction getFullUrl(localId, gd) {\n  if (!localId) return null;\n  var context = gd._context;\n  var baseUrl = context._exportedPlot ? '' : context._baseUrl || '';\n  return baseUrl ? 'url(\\'' + baseUrl + '#' + localId + '\\')' : 'url(#' + localId + ')';\n}\ndrawing.getTranslate = function (element) {\n  // Note the separator [^\\d] between x and y in this regex\n  // We generally use ',' but IE will convert it to ' '\n  var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 0,\n    y: +translate[1] || 0\n  };\n};\ndrawing.setTranslate = function (element, x, y) {\n  var re = /(\\btranslate\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 0;\n  y = y || 0;\n  transform = transform.replace(re, '').trim();\n  transform += strTranslate(x, y);\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\ndrawing.getScale = function (element) {\n  var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 1,\n    y: +translate[1] || 1\n  };\n};\ndrawing.setScale = function (element, x, y) {\n  var re = /(\\bscale\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 1;\n  y = y || 1;\n  transform = transform.replace(re, '').trim();\n  transform += 'scale(' + x + ',' + y + ')';\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\nvar SCALE_RE = /\\s*sc.*/;\ndrawing.setPointGroupScale = function (selection, xScale, yScale) {\n  xScale = xScale || 1;\n  yScale = yScale || 1;\n  if (!selection) return;\n\n  // The same scale transform for every point:\n  var scale = xScale === 1 && yScale === 1 ? '' : 'scale(' + xScale + ',' + yScale + ')';\n  selection.each(function () {\n    var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n    t += scale;\n    t = t.trim();\n    this.setAttribute('transform', t);\n  });\n};\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\ndrawing.setTextPointsScale = function (selection, xScale, yScale) {\n  if (!selection) return;\n  selection.each(function () {\n    var transforms;\n    var el = d3.select(this);\n    var text = el.select('text');\n    if (!text.node()) return;\n    var x = parseFloat(text.attr('x') || 0);\n    var y = parseFloat(text.attr('y') || 0);\n    var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n    if (xScale === 1 && yScale === 1) {\n      transforms = [];\n    } else {\n      transforms = [strTranslate(x, y), 'scale(' + xScale + ',' + yScale + ')', strTranslate(-x, -y)];\n    }\n    if (existingTransform) {\n      transforms.push(existingTransform);\n    }\n    el.attr('transform', transforms.join(''));\n  });\n};\nfunction getMarkerStandoff(d, trace) {\n  var standoff;\n  if (d) standoff = d.mf;\n  if (standoff === undefined) {\n    standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n  }\n  if (!trace._geo && !trace._xA) {\n    // case of legends\n    return -standoff;\n  }\n  return standoff;\n}\ndrawing.getMarkerStandoff = getMarkerStandoff;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\nfunction rotate(t, xy) {\n  var x = xy[0];\n  var y = xy[1];\n  return [x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)];\n}\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\nfunction getMarkerAngle(d, trace) {\n  var angle = d.ma;\n  if (angle === undefined) {\n    angle = trace.marker.angle;\n    if (!angle || Lib.isArrayOrTypedArray(angle)) {\n      angle = 0;\n    }\n  }\n  var x, y;\n  var ref = trace.marker.angleref;\n  if (ref === 'previous' || ref === 'north') {\n    if (trace._geo) {\n      var p = trace._geo.project(d.lonlat);\n      x = p[0];\n      y = p[1];\n    } else {\n      var xa = trace._xA;\n      var ya = trace._yA;\n      if (xa && ya) {\n        x = xa.c2p(d.x);\n        y = ya.c2p(d.y);\n      } else {\n        // case of legends\n        return 90;\n      }\n    }\n    if (trace._geo) {\n      var lon = d.lonlat[0];\n      var lat = d.lonlat[1];\n      var north = trace._geo.project([lon, lat + 1e-5 // epsilon\n      ]);\n      var east = trace._geo.project([lon + 1e-5,\n      // epsilon\n      lat]);\n      var u = atan2(east[1] - y, east[0] - x);\n      var v = atan2(north[1] - y, north[0] - x);\n      var t;\n      if (ref === 'north') {\n        t = angle / 180 * Math.PI;\n        // To use counter-clockwise angles i.e.\n        // East: 90, West: -90\n        // to facilitate wind visualisations\n        // in future we should use t = -t here.\n      } else if (ref === 'previous') {\n        var lon1 = lon / 180 * Math.PI;\n        var lat1 = lat / 180 * Math.PI;\n        var lon2 = previousLon / 180 * Math.PI;\n        var lat2 = previousLat / 180 * Math.PI;\n        var dLon = lon2 - lon1;\n        var deltaY = cos(lat2) * sin(dLon);\n        var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n        t = -atan2(deltaY, deltaX) - Math.PI;\n        previousLon = lon;\n        previousLat = lat;\n      }\n      var A = rotate(u, [cos(t), 0]);\n      var B = rotate(v, [sin(t), 0]);\n      angle = atan2(A[1] + B[1], A[0] + B[0]) / Math.PI * 180;\n      if (ref === 'previous' && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {\n        angle = null;\n      }\n    }\n    if (ref === 'previous' && !trace._geo) {\n      if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {\n        var dX = x - previousX;\n        var dY = y - previousY;\n        var shape = trace.line ? trace.line.shape || '' : '';\n        var lastShapeChar = shape.slice(shape.length - 1);\n        if (lastShapeChar === 'h') dY = 0;\n        if (lastShapeChar === 'v') dX = 0;\n        angle += atan2(dY, dX) / Math.PI * 180 + 90;\n      } else {\n        angle = null;\n      }\n    }\n  }\n  previousX = x;\n  previousY = y;\n  previousI = d.i;\n  previousTraceUid = trace.uid;\n  return angle;\n}\ndrawing.getMarkerAngle = getMarkerAngle;","map":{"version":3,"names":["d3","require","Lib","numberFormat","isNumeric","tinycolor","Registry","Color","Colorscale","strTranslate","svgTextUtils","xmlnsNamespaces","alignment","LINE_SPACING","DESELECTDIM","subTypes","makeBubbleSizeFn","appendArrayPointValue","drawing","module","exports","font","s","variant","style","weight","color","size","family","shadow","lineposition","textcase","call","fill","dropNone","textcase2transform","makeTextShadow","contrast","lineposition2decorationLine","a","undefined","textcase2transformOptions","normal","lower","upper","replace","split","join","setPosition","x","y","attr","setSize","w","h","setRect","translatePoint","d","sel","xa","ya","c2p","node","nodeName","translatePoints","each","select","hideOutsideRangePoint","xcalendar","ycalendar","isPtWithinRange","hideOutsideRangePoints","traceGroups","subplot","_hasClipOnAxisFalse","xaxis","yaxis","trace","selector","traceIs","selectAll","crispRound","gd","lineWidth","dflt","_context","staticPlot","Math","round","singleLineStyle","lw","lc","ld","line","lw1","width","dash","stroke","dashLine","lineGroupStyle","dashStyle","dlw","max","setFillStyle","forLegend","markerPattern","fillpattern","fillgradient","patternShape","getPatternAttr","shape","patternBGColor","bgcolor","patternFGColor","fgcolor","patternFGOpacity","fgopacity","patternSize","patternSolidity","solidity","patternID","uid","pattern","fillmode","type","direction","gradientID","start","stop","_xA","_extremes","min","val","_yA","gradientWithBounds","colorscale","gradient","fillcolor","singleFillStyle","data","fillGroupStyle","SYMBOLDEFS","symbolNames","symbolFuncs","symbolBackOffs","symbolNeedLines","symbolNoDot","symbolNoFill","symbolList","Object","keys","forEach","k","symDef","n","push","String","f","backoff","needLine","noDot","noFill","MAXSYMBOL","length","DOTPATH","symbolNumber","v","vbase","indexOf","floor","makePointPath","r","t","base","stopFormatter","gradientInfo","radial","radialreversed","reversed","horizontal","horizontalreversed","vertical","verticalreversed","prop","info","inUserSpace","len","attrs","x1","y1","x2","y2","gradientUnits","colorStops","Array","i","fullLayout","_fullLayout","fullID","_uid","_defs","identity","exit","remove","enter","append","el","stops","tc","offset","tinyRGB","getAlpha","getFullUrl","classed","calledBy","mcc","isLegend","height","linearFn","x0","y0","path","linewidth","radius","patternTag","patternAttrs","fgC","fgRGB","fgAlpha","opacity","sqrt","PI","cx","cy","str","id","patternUnits","patternTransform","bgC","bgRGB","bgAlpha","rects","patterns","initGradients","gradientsGroup","ensureSingle","initPatterns","patternsGroup","mp","isArrayOrTypedArray","pointStyle","pt","fns","makePointStyleFns","singlePointStyle","marker","markerLine","selectedOpacityFn","mo","ms2mrc","ms","mrc","selectedSizeFn","mx","symbol","om","angle","getMarkerAngle","standoff","getMarkerStandoff","perPointGradient","fillColor","lineColor","so","outlierwidth","outliercolor","markerLineWidth","mlw","mlcc","lineScale","mlc","defaultLine","markerScale","mc","colors","selectedColorFn","isBlank","markerGradient","gradientType","mgt","gradientColor","mgc","perPointPattern","out","tryColorscale","isBubble","selectedpoints","extendFlat","makeSelectedPointStyleFns","selectedAttrs","selected","unselectedAttrs","unselected","selectedMarker","unselectedMarker","smo","usmo","smoIsDefined","usmoIsDefined","smc","usmc","sms","usms","smsIsDefined","usmsIsDefined","makeSelectedTextStyleFns","textFont","textfont","selectedTextFont","unselectedTextFont","stc","utc","selectedTextColorFn","addOpacity","selectedPointStyle","seq","mrc2","prefix","cont","nestedProperty","get","colorArray","_colorAx","makeColorScaleFuncFromTrace","TEXTOFFSETSIGN","end","middle","bottom","top","textPointPosition","textPosition","fontSize","markerRadius","dontTouchParent","group","parentNode","numLines","lineCount","dx","dy","extracTextFontSize","ts","textPointStyle","texttemplate","p","text","extractOption","fn","_module","formatLabels","labels","pointValues","meta","_meta","texttemplateString","_d3locale","pos","tp","textposition","fontColor","tf","tw","ty","tv","tC","tE","tS","convertToTspans","selectedTextStyle","tx","CatmullRomExp","smoothopen","pts","smoothness","tangents","makeTangent","smoothclosed","pLast","lastDrawnX","lastDrawnY","roundEnd","isY","isLastPoint","applyBackoff","roundY","roundX","prevpt","thispt","nextpt","d1x","d1y","d2x","d2y","d1a","pow","d2a","numx","numy","denom1","denom2","STEPPATH","hv","p0","p1","vh","hvh","vhv","STEPLINEAR","steps","onestep","arrayBackoff","atan2","b","endI","endMarker","endMarkerSymbol","endMarkerSize","cos","sin","makeTester","tester","ensureSingleById","svgAttrs","position","left","testref","savedBBoxes","savedBBoxesCount","maxSavedBBoxes","bBox","inTester","hash","nodeHash","childNodes","innerNode","getAttribute","transform","innerBB","right","testNode","cloneNode","appendChild","positionText","testRect","getBoundingClientRect","refRect","removeChild","bb","inputText","setClipUrl","localId","context","baseUrl","_exportedPlot","_baseUrl","getTranslate","element","re","getter","translate","match","p2","setTranslate","setter","trim","getScale","setScale","SCALE_RE","setPointGroupScale","selection","xScale","yScale","scale","setAttribute","TEXT_POINT_LAST_TRANSLATION_RE","setTextPointsScale","transforms","parseFloat","existingTransform","mf","_geo","rotate","xy","previousLon","previousLat","previousX","previousY","previousI","previousTraceUid","ma","ref","angleref","project","lonlat","lon","lat","north","east","u","lon1","lat1","lon2","lat2","dLon","deltaY","deltaX","A","B","dX","dY","lastShapeChar","slice"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/drawing/index.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function(s, font) {\n    var variant = font.variant;\n    var style = font.style;\n    var weight = font.weight;\n    var color = font.color;\n    var size = font.size;\n    var family = font.family;\n    var shadow = font.shadow;\n    var lineposition = font.lineposition;\n    var textcase = font.textcase;\n\n    if(family) s.style('font-family', family);\n    if(size + 1) s.style('font-size', size + 'px');\n    if(color) s.call(Color.fill, color);\n\n    if(weight) s.style('font-weight', weight);\n    if(style) s.style('font-style', style);\n    if(variant) s.style('font-variant', variant);\n\n    if(textcase) s.style('text-transform', dropNone(textcase2transform(textcase)));\n    if(shadow) s.style('text-shadow', shadow === 'auto' ? svgTextUtils.makeTextShadow(Color.contrast(color)) : dropNone(shadow));\n    if(lineposition) s.style('text-decoration-line', dropNone(lineposition2decorationLine(lineposition)));\n};\n\nfunction dropNone(a) {\n    return a === 'none' ? undefined : a;\n}\n\nvar textcase2transformOptions = {\n    normal: 'none',\n    lower: 'lowercase',\n    upper: 'uppercase',\n    'word caps': 'capitalize'\n};\n\nfunction textcase2transform(textcase) {\n    return textcase2transformOptions[textcase];\n}\n\nfunction lineposition2decorationLine(lineposition) {\n    return (\n        lineposition\n            .replace('under', 'underline')\n            .replace('over', 'overline')\n            .replace('through', 'line-through')\n            .split('+')\n            .join(' ')\n    );\n}\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function(s, x, y) { s.attr('x', x).attr('y', y); };\ndrawing.setSize = function(s, w, h) { s.attr('width', w).attr('height', h); };\ndrawing.setRect = function(s, x, y, w, h) {\n    s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function(d, sel, xa, ya) {\n    var x = xa.c2p(d.x);\n    var y = ya.c2p(d.y);\n\n    if(isNumeric(x) && isNumeric(y) && sel.node()) {\n        // for multiline text this works better\n        if(sel.node().nodeName === 'text') {\n            sel.attr('x', x).attr('y', y);\n        } else {\n            sel.attr('transform', strTranslate(x, y));\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n};\n\ndrawing.translatePoints = function(s, xa, ya) {\n    s.each(function(d) {\n        var sel = d3.select(this);\n        drawing.translatePoint(d, sel, xa, ya);\n    });\n};\n\ndrawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {\n    sel.attr(\n        'display',\n        (xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar)) ? null : 'none'\n    );\n};\n\ndrawing.hideOutsideRangePoints = function(traceGroups, subplot) {\n    if(!subplot._hasClipOnAxisFalse) return;\n\n    var xa = subplot.xaxis;\n    var ya = subplot.yaxis;\n\n    traceGroups.each(function(d) {\n        var trace = d[0].trace;\n        var xcalendar = trace.xcalendar;\n        var ycalendar = trace.ycalendar;\n        var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n\n        traceGroups.selectAll(selector).each(function(d) {\n            drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n        });\n    });\n};\n\ndrawing.crispRound = function(gd, lineWidth, dflt) {\n    // for lines that disable antialiasing we want to\n    // make sure the width is an integer, and at least 1 if it's nonzero\n\n    if(!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n    // but not for static plots - these don't get antialiased anyway.\n    if(gd._context.staticPlot) return lineWidth;\n\n    if(lineWidth < 1) return 1;\n    return Math.round(lineWidth);\n};\n\ndrawing.singleLineStyle = function(d, s, lw, lc, ld) {\n    s.style('fill', 'none');\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n\n    Color.stroke(s, lc || line.color);\n    drawing.dashLine(s, dash, lw1);\n};\n\ndrawing.lineGroupStyle = function(s, lw, lc, ld) {\n    s.style('fill', 'none')\n    .each(function(d) {\n        var line = (((d || [])[0] || {}).trace || {}).line || {};\n        var lw1 = lw || line.width || 0;\n        var dash = ld || line.dash || '';\n\n        d3.select(this)\n            .call(Color.stroke, lc || line.color)\n            .call(drawing.dashLine, dash, lw1);\n    });\n};\n\ndrawing.dashLine = function(s, dash, lineWidth) {\n    lineWidth = +lineWidth || 0;\n\n    dash = drawing.dashStyle(dash, lineWidth);\n\n    s.style({\n        'stroke-dasharray': dash,\n        'stroke-width': lineWidth + 'px'\n    });\n};\n\ndrawing.dashStyle = function(dash, lineWidth) {\n    lineWidth = +lineWidth || 1;\n    var dlw = Math.max(lineWidth, 3);\n\n    if(dash === 'solid') dash = '';\n    else if(dash === 'dot') dash = dlw + 'px,' + dlw + 'px';\n    else if(dash === 'dash') dash = (3 * dlw) + 'px,' + (3 * dlw) + 'px';\n    else if(dash === 'longdash') dash = (5 * dlw) + 'px,' + (5 * dlw) + 'px';\n    else if(dash === 'dashdot') {\n        dash = (3 * dlw) + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n    } else if(dash === 'longdashdot') {\n        dash = (5 * dlw) + 'px,' + (2 * dlw) + 'px,' + dlw + 'px,' + (2 * dlw) + 'px';\n    }\n    // otherwise user wrote the dasharray themselves - leave it be\n\n    return dash;\n};\n\nfunction setFillStyle(sel, trace, gd, forLegend) {\n    var markerPattern = trace.fillpattern;\n    var fillgradient = trace.fillgradient;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n    if(patternShape) {\n        var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n        var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n        var patternFGOpacity = markerPattern.fgopacity;\n        var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n        var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n        var patternID = trace.uid;\n        drawing.pattern(sel, 'point', gd, patternID,\n            patternShape, patternSize, patternSolidity,\n            undefined, markerPattern.fillmode,\n            patternBGColor, patternFGColor, patternFGOpacity\n        );\n    } else if(fillgradient && fillgradient.type !== 'none') {\n        var direction = fillgradient.type;\n        var gradientID = 'scatterfill-' + trace.uid;\n        if(forLegend) {\n            gradientID = 'legendfill-' + trace.uid;\n        }\n\n        if(!forLegend && (fillgradient.start !== undefined || fillgradient.stop !== undefined)) {\n            var start, stop;\n            if(direction === 'horizontal') {\n                start = {\n                    x: fillgradient.start,\n                    y: 0,\n                };\n                stop = {\n                    x: fillgradient.stop,\n                    y: 0,\n                };\n            } else if(direction === 'vertical') {\n                start = {\n                    x: 0,\n                    y: fillgradient.start,\n                };\n                stop = {\n                    x: 0,\n                    y: fillgradient.stop,\n                };\n            }\n\n            start.x = trace._xA.c2p(\n                (start.x === undefined) ? trace._extremes.x.min[0].val : start.x, true\n            );\n            start.y = trace._yA.c2p(\n                (start.y === undefined) ? trace._extremes.y.min[0].val : start.y, true\n            );\n\n            stop.x = trace._xA.c2p(\n                (stop.x === undefined) ? trace._extremes.x.max[0].val : stop.x, true\n            );\n            stop.y = trace._yA.c2p(\n                (stop.y === undefined) ? trace._extremes.y.max[0].val : stop.y, true\n            );\n            sel.call(gradientWithBounds, gd, gradientID, 'linear', fillgradient.colorscale, 'fill', start, stop, true, false);\n        } else {\n            if(direction === 'horizontal') {\n                direction = direction + 'reversed';\n            }\n            sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, 'fill');\n        }\n    } else if(trace.fillcolor) {\n        sel.call(Color.fill, trace.fillcolor);\n    }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function(sel, gd) {\n    var node = d3.select(sel.node());\n    var data = node.data();\n    var trace = ((data[0] || [])[0] || {}).trace || {};\n    setFillStyle(sel, trace, gd, false);\n};\n\ndrawing.fillGroupStyle = function(s, gd, forLegend) {\n    s.style('stroke-width', 0)\n    .each(function(d) {\n        var shape = d3.select(this);\n        // N.B. 'd' won't be a calcdata item when\n        // fill !== 'none' on a segment-less and marker-less trace\n        if(d[0].trace) {\n            setFillStyle(shape, d[0].trace, gd, forLegend);\n        }\n    });\n};\n\nvar SYMBOLDEFS = require('./symbol_defs');\n\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\n\nObject.keys(SYMBOLDEFS).forEach(function(k) {\n    var symDef = SYMBOLDEFS[k];\n    var n = symDef.n;\n    drawing.symbolList.push(\n        n,\n        String(n),\n        k,\n\n        n + 100,\n        String(n + 100),\n        k + '-open'\n    );\n    drawing.symbolNames[n] = k;\n    drawing.symbolFuncs[n] = symDef.f;\n    drawing.symbolBackOffs[n] = symDef.backoff || 0;\n\n    if(symDef.needLine) {\n        drawing.symbolNeedLines[n] = true;\n    }\n    if(symDef.noDot) {\n        drawing.symbolNoDot[n] = true;\n    } else {\n        drawing.symbolList.push(\n            n + 200,\n            String(n + 200),\n            k + '-dot',\n\n            n + 300,\n            String(n + 300),\n            k + '-open-dot'\n        );\n    }\n    if(symDef.noFill) {\n        drawing.symbolNoFill[n] = true;\n    }\n});\n\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\n\ndrawing.symbolNumber = function(v) {\n    if(isNumeric(v)) {\n        v = +v;\n    } else if(typeof v === 'string') {\n        var vbase = 0;\n        if(v.indexOf('-open') > 0) {\n            vbase = 100;\n            v = v.replace('-open', '');\n        }\n        if(v.indexOf('-dot') > 0) {\n            vbase += 200;\n            v = v.replace('-dot', '');\n        }\n        v = drawing.symbolNames.indexOf(v);\n        if(v >= 0) { v += vbase; }\n    }\n\n    return (v % 100 >= MAXSYMBOL || v >= 400) ?\n        0 : Math.floor(Math.max(v, 0));\n};\n\nfunction makePointPath(symbolNumber, r, t, s) {\n    var base = symbolNumber % 100;\n    return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\n\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n    radial: {type: 'radial'},\n    radialreversed: {type: 'radial', reversed: true},\n    horizontal: {type: 'linear', start: {x: 1, y: 0}, stop: {x: 0, y: 0}},\n    horizontalreversed: {type: 'linear', start: {x: 1, y: 0}, stop: {x: 0, y: 0}, reversed: true},\n    vertical: {type: 'linear', start: {x: 0, y: 1}, stop: {x: 0, y: 0}},\n    verticalreversed: {type: 'linear', start: {x: 0, y: 1}, stop: {x: 0, y: 0}, reversed: true}\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {\n    var info = gradientInfo[type];\n    return gradientWithBounds(\n        sel, gd, gradientID, info.type, colorscale, prop, info.start, info.stop, false, info.reversed\n    );\n};\n\n/**\n * gradient_with_bounds: create and apply a gradient fill for defined start and stop positions\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial' or 'linear'. Radial goes center to edge,\n *     horizontal goes as defined by start and stop\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n * @param {object} start: start point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {object} stop: stop point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {boolean} inUserSpace: If true, start and stop give absolute values in the plot.\n *     If false, start and stop are fractions of the traces extent along each axis.\n * @param {boolean} reversed: If true, the gradient is reversed between normal start and stop,\n *     i.e., the colorscale is applied in order from stop to start for linear, from edge\n *     to center for radial gradients.\n */\nfunction gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {\n    var len = colorscale.length;\n\n    var info;\n    if(type === 'linear') {\n        info = {\n            node: 'linearGradient',\n            attrs: {\n                x1: start.x,\n                y1: start.y,\n                x2: stop.x,\n                y2: stop.y,\n                gradientUnits: inUserSpace ? 'userSpaceOnUse' : 'objectBoundingBox',\n            },\n            reversed: reversed,\n        };\n    } else if(type === 'radial') {\n        info = {\n            node: 'radialGradient',\n            reversed: reversed,\n        };\n    }\n\n    var colorStops = new Array(len);\n    for(var i = 0; i < len; i++) {\n        if(info.reversed) {\n            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n        } else {\n            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n\n    var gradient = fullLayout._defs.select('.gradients')\n        .selectAll('#' + fullID)\n        .data([type + colorStops.join(';')], Lib.identity);\n\n    gradient.exit().remove();\n\n    gradient.enter()\n        .append(info.node)\n        .each(function() {\n            var el = d3.select(this);\n            if(info.attrs) el.attr(info.attrs);\n\n            el.attr('id', fullID);\n\n            var stops = el.selectAll('stop')\n                .data(colorStops);\n            stops.exit().remove();\n            stops.enter().append('stop');\n\n            stops.each(function(d) {\n                var tc = tinycolor(d[1]);\n                d3.select(this).attr({\n                    offset: d[0] + '%',\n                    'stop-color': Color.tinyRGB(tc),\n                    'stop-opacity': tc.getAlpha()\n                });\n            });\n        });\n\n    sel.style(prop, getFullUrl(fullID, gd))\n        .style(prop + '-opacity', null);\n\n    sel.classed('gradient_filled', true);\n}\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n    var isLegend = calledBy === 'legend';\n\n    if(mcc) {\n        if(fillmode === 'overlay') {\n            bgcolor = mcc;\n            fgcolor = Color.contrast(bgcolor);\n        } else {\n            bgcolor = undefined;\n            fgcolor = mcc;\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'p' + fullLayout._uid + '-' + patternID;\n    var width, height;\n\n    // linear interpolation\n    var linearFn = function(x, x0, x1, y0, y1) {\n        return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n    };\n\n    var path, linewidth, radius;\n    var patternTag;\n    var patternAttrs = {};\n\n    var fgC = tinycolor(fgcolor);\n    var fgRGB = Color.tinyRGB(fgC);\n    var fgAlpha = fgC.getAlpha();\n    var opacity = fgopacity * fgAlpha;\n\n    switch(shape) {\n        case '/':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '\\\\':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case 'x':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '|':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height;\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '-':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '+':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height +\n                   'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '.':\n            width = size;\n            height = size;\n            if(solidity < Math.PI / 4) {\n                radius = Math.sqrt(solidity * size * size / Math.PI);\n            } else {\n                radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n            }\n            patternTag = 'circle';\n            patternAttrs = {\n                cx: width / 2,\n                cy: height / 2,\n                r: radius,\n                opacity: opacity,\n                fill: fgRGB\n            };\n            break;\n    }\n\n    var str = [\n        shape || 'noSh',\n        bgcolor || 'noBg',\n        fgcolor || 'noFg',\n        size,\n        solidity\n    ].join(';');\n\n    var pattern = fullLayout._defs.select('.patterns')\n        .selectAll('#' + fullID)\n        .data([str], Lib.identity);\n\n    pattern.exit().remove();\n\n    pattern.enter()\n        .append('pattern')\n        .each(function() {\n            var el = d3.select(this);\n\n            el.attr({\n                id: fullID,\n                width: width + 'px',\n                height: height + 'px',\n                patternUnits: 'userSpaceOnUse',\n                // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n                patternTransform: isLegend ? 'scale(0.8)' : ''\n            });\n\n            if(bgcolor) {\n                var bgC = tinycolor(bgcolor);\n                var bgRGB = Color.tinyRGB(bgC);\n                var bgAlpha = bgC.getAlpha();\n\n                var rects = el.selectAll('rect').data([0]);\n                rects.exit().remove();\n                rects.enter()\n                    .append('rect')\n                    .attr({\n                        width: width + 'px',\n                        height: height + 'px',\n                        fill: bgRGB,\n                        'fill-opacity': bgAlpha,\n                    });\n            }\n\n            var patterns = el.selectAll(patternTag).data([0]);\n            patterns.exit().remove();\n            patterns.enter()\n                .append(patternTag)\n                .attr(patternAttrs);\n        });\n\n    sel.style('fill', getFullUrl(fullID, gd))\n        .style('fill-opacity', null);\n\n    sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n    gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n\n    d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\n\ndrawing.initPatterns = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n    patternsGroup.selectAll('pattern').remove();\n\n    d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\n\ndrawing.getPatternAttr = function(mp, i, dflt) {\n    if(mp && Lib.isArrayOrTypedArray(mp)) {\n        return i < mp.length ? mp[i] : dflt;\n    }\n    return mp;\n};\n\ndrawing.pointStyle = function(s, trace, gd, pt) {\n    if(!s.size()) return;\n\n    var fns = drawing.makePointStyleFns(trace);\n\n    s.each(function(d) {\n        drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);\n    });\n};\n\ndrawing.singlePointStyle = function(d, sel, trace, fns, gd, pt) {\n    var marker = trace.marker;\n    var markerLine = marker.line;\n\n    if(pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;\n\n    sel.style('opacity',\n        fns.selectedOpacityFn ? fns.selectedOpacityFn(d) :\n            (d.mo === undefined ? marker.opacity : d.mo)\n    );\n\n    if(fns.ms2mrc) {\n        var r;\n\n        // handle multi-trace graph edit case\n        if(d.ms === 'various' || marker.size === 'various') {\n            r = 3;\n        } else {\n            r = fns.ms2mrc(d.ms);\n        }\n\n        // store the calculated size so hover can use it\n        d.mrc = r;\n\n        if(fns.selectedSizeFn) {\n            r = d.mrc = fns.selectedSizeFn(d);\n        }\n\n        // turn the symbol into a sanitized number\n        var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n        // save if this marker is open\n        // because that impacts how to handle colors\n        d.om = x % 200 >= 100;\n\n        var angle = getMarkerAngle(d, trace);\n        var standoff = getMarkerStandoff(d, trace);\n\n        sel.attr('d', makePointPath(x, r, angle, standoff));\n    }\n\n    var perPointGradient = false;\n    var fillColor, lineColor, lineWidth;\n\n    // 'so' is suspected outliers, for box plots\n    if(d.so) {\n        lineWidth = markerLine.outlierwidth;\n        lineColor = markerLine.outliercolor;\n        fillColor = marker.outliercolor;\n    } else {\n        var markerLineWidth = (markerLine || {}).width;\n\n        lineWidth = (\n            d.mlw + 1 ||\n            markerLineWidth + 1 ||\n            // TODO: we need the latter for legends... can we get rid of it?\n            (d.trace ? (d.trace.marker.line || {}).width : 0) + 1\n        ) - 1 || 0;\n\n        if('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n        // weird case: array wasn't long enough to apply to every point\n        else if(Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;\n        else lineColor = markerLine.color;\n\n        if(Lib.isArrayOrTypedArray(marker.color)) {\n            fillColor = Color.defaultLine;\n            perPointGradient = true;\n        }\n\n        if('mc' in d) {\n            fillColor = d.mcc = fns.markerScale(d.mc);\n        } else {\n            fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';\n        }\n\n        if(fns.selectedColorFn) {\n            fillColor = fns.selectedColorFn(d);\n        }\n    }\n\n    if(d.om) {\n        // open markers can't have zero linewidth, default to 1px,\n        // and use fill color as stroke color\n        sel.call(Color.stroke, fillColor)\n            .style({\n                'stroke-width': (lineWidth || 1) + 'px',\n                fill: 'none'\n            });\n    } else {\n        sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n\n        var markerGradient = marker.gradient;\n\n        var gradientType = d.mgt;\n        if(gradientType) perPointGradient = true;\n        else gradientType = markerGradient && markerGradient.type;\n\n        // for legend - arrays will propagate through here, but we don't need\n        // to treat it as per-point.\n        if(Lib.isArrayOrTypedArray(gradientType)) {\n            gradientType = gradientType[0];\n            if(!gradientInfo[gradientType]) gradientType = 0;\n        }\n\n        var markerPattern = marker.pattern;\n        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n\n        if(gradientType && gradientType !== 'none') {\n            var gradientColor = d.mgc;\n            if(gradientColor) perPointGradient = true;\n            else gradientColor = markerGradient.color;\n\n            var gradientID = trace.uid;\n            if(perPointGradient) gradientID += '-' + d.i;\n\n            drawing.gradient(sel, gd, gradientID, gradientType,\n                [[0, gradientColor], [1, fillColor]], 'fill');\n        } else if(patternShape) {\n            var perPointPattern = false;\n            var fgcolor = markerPattern.fgcolor;\n            if(!fgcolor && pt && pt.color) {\n                fgcolor = pt.color;\n                perPointPattern = true;\n            }\n            var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, (pt && pt.color) || null);\n\n            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n            var patternFGOpacity = markerPattern.fgopacity;\n            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n            perPointPattern = perPointPattern || d.mcc ||\n                Lib.isArrayOrTypedArray(markerPattern.shape) ||\n                Lib.isArrayOrTypedArray(markerPattern.bgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.fgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.size) ||\n                Lib.isArrayOrTypedArray(markerPattern.solidity);\n\n            var patternID = trace.uid;\n            if(perPointPattern) patternID += '-' + d.i;\n\n            drawing.pattern(\n                sel, 'point', gd, patternID,\n                patternShape, patternSize, patternSolidity,\n                d.mcc, markerPattern.fillmode,\n                patternBGColor, patternFGColor, patternFGOpacity\n            );\n        } else {\n            Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);\n        }\n\n        if(lineWidth) {\n            Color.stroke(sel, lineColor);\n        }\n    }\n};\n\ndrawing.makePointStyleFns = function(trace) {\n    var out = {};\n    var marker = trace.marker;\n\n    // allow array marker and marker line colors to be\n    // scaled by given max and min to colorscales\n    out.markerScale = drawing.tryColorscale(marker, '');\n    out.lineScale = drawing.tryColorscale(marker, 'line');\n\n    if(Registry.traceIs(trace, 'symbols')) {\n        out.ms2mrc = subTypes.isBubble(trace) ?\n            makeBubbleSizeFn(trace) :\n            function() { return (marker.size || 6) / 2; };\n    }\n\n    if(trace.selectedpoints) {\n        Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedPointStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var marker = trace.marker || {};\n    var selectedMarker = selectedAttrs.marker || {};\n    var unselectedMarker = unselectedAttrs.marker || {};\n\n    var mo = marker.opacity;\n    var smo = selectedMarker.opacity;\n    var usmo = unselectedMarker.opacity;\n    var smoIsDefined = smo !== undefined;\n    var usmoIsDefined = usmo !== undefined;\n\n    if(Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n        out.selectedOpacityFn = function(d) {\n            var base = d.mo === undefined ? marker.opacity : d.mo;\n\n            if(d.selected) {\n                return smoIsDefined ? smo : base;\n            } else {\n                return usmoIsDefined ? usmo : DESELECTDIM * base;\n            }\n        };\n    }\n\n    var mc = marker.color;\n    var smc = selectedMarker.color;\n    var usmc = unselectedMarker.color;\n\n    if(smc || usmc) {\n        out.selectedColorFn = function(d) {\n            var base = d.mcc || mc;\n\n            if(d.selected) {\n                return smc || base;\n            } else {\n                return usmc || base;\n            }\n        };\n    }\n\n    var ms = marker.size;\n    var sms = selectedMarker.size;\n    var usms = unselectedMarker.size;\n    var smsIsDefined = sms !== undefined;\n    var usmsIsDefined = usms !== undefined;\n\n    if(Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n        out.selectedSizeFn = function(d) {\n            var base = d.mrc || ms / 2;\n\n            if(d.selected) {\n                return smsIsDefined ? sms / 2 : base;\n            } else {\n                return usmsIsDefined ? usms / 2 : base;\n            }\n        };\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedTextStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var textFont = trace.textfont || {};\n    var selectedTextFont = selectedAttrs.textfont || {};\n    var unselectedTextFont = unselectedAttrs.textfont || {};\n\n    var tc = textFont.color;\n    var stc = selectedTextFont.color;\n    var utc = unselectedTextFont.color;\n\n    out.selectedTextColorFn = function(d) {\n        var base = d.tc || tc;\n\n        if(d.selected) {\n            return stc || base;\n        } else {\n            if(utc) return utc;\n            else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n        }\n    };\n\n    return out;\n};\n\ndrawing.selectedPointStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedPointStyleFns(trace);\n    var marker = trace.marker || {};\n    var seq = [];\n\n    if(fns.selectedOpacityFn) {\n        seq.push(function(pt, d) {\n            pt.style('opacity', fns.selectedOpacityFn(d));\n        });\n    }\n\n    if(fns.selectedColorFn) {\n        seq.push(function(pt, d) {\n            Color.fill(pt, fns.selectedColorFn(d));\n        });\n    }\n\n    if(fns.selectedSizeFn) {\n        seq.push(function(pt, d) {\n            var mx = d.mx || marker.symbol || 0;\n            var mrc2 = fns.selectedSizeFn(d);\n\n            pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n            // save for Drawing.selectedTextStyle\n            d.mrc2 = mrc2;\n        });\n    }\n\n    if(seq.length) {\n        s.each(function(d) {\n            var pt = d3.select(this);\n            for(var i = 0; i < seq.length; i++) {\n                seq[i](pt, d);\n            }\n        });\n    }\n};\n\ndrawing.tryColorscale = function(marker, prefix) {\n    var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n\n    if(cont) {\n        var colorArray = cont.color;\n        if((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n            return Colorscale.makeColorScaleFuncFromTrace(cont);\n        }\n    }\n    return Lib.identity;\n};\n\nvar TEXTOFFSETSIGN = {\n    start: 1, end: -1, middle: 0, bottom: 1, top: -1\n};\n\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n    var group = d3.select(s.node().parentNode);\n\n    var v = textPosition.indexOf('top') !== -1 ?\n        'top' :\n        textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n    var h = textPosition.indexOf('left') !== -1 ?\n        'end' :\n        textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n    // if markers are shown, offset a little more than\n    // the nominal marker size\n    // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n    var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n\n    var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n    var dx = TEXTOFFSETSIGN[h] * r;\n    var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r +\n        (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n    // fix the overall text group position\n    s.attr('text-anchor', h);\n    if(!dontTouchParent) {\n        group.attr('transform', strTranslate(dx, dy));\n    }\n}\n\nfunction extracTextFontSize(d, trace) {\n    var fontSize = d.ts || trace.textfont.size;\n    return (isNumeric(fontSize) && fontSize > 0) ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function(s, trace, gd) {\n    if(!s.size()) return;\n\n    var selectedTextColorFn;\n    if(trace.selectedpoints) {\n        var fns = drawing.makeSelectedTextStyleFns(trace);\n        selectedTextColorFn = fns.selectedTextColorFn;\n    }\n\n    var texttemplate = trace.texttemplate;\n    var fullLayout = gd._fullLayout;\n\n    s.each(function(d) {\n        var p = d3.select(this);\n\n        var text = texttemplate ?\n            Lib.extractOption(d, trace, 'txt', 'texttemplate') :\n            Lib.extractOption(d, trace, 'tx', 'text');\n\n        if(!text && text !== 0) {\n            p.remove();\n            return;\n        }\n\n        if(texttemplate) {\n            var fn = trace._module.formatLabels;\n            var labels = fn ? fn(d, trace, fullLayout) : {};\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, d.i);\n            var meta = trace._meta || {};\n            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n        }\n\n        var pos = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n        var fontColor = selectedTextColorFn ?\n            selectedTextColorFn(d) :\n            (d.tc || trace.textfont.color);\n\n        p.call(drawing.font, {\n            family: d.tf || trace.textfont.family,\n            weight: d.tw || trace.textfont.weight,\n            style: d.ty || trace.textfont.style,\n            variant: d.tv || trace.textfont.variant,\n            textcase: d.tC || trace.textfont.textcase,\n            lineposition: d.tE || trace.textfont.lineposition,\n            shadow: d.tS || trace.textfont.shadow,\n            size: fontSize,\n            color: fontColor\n        })\n            .text(text)\n            .call(svgTextUtils.convertToTspans, gd)\n            .call(textPointPosition, pos, fontSize, d.mrc);\n    });\n};\n\ndrawing.selectedTextStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n\n    s.each(function(d) {\n        var tx = d3.select(this);\n        var tc = fns.selectedTextColorFn(d);\n        var tp = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n\n        Color.fill(tx, tc);\n        var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n        textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n    });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L');}\n    var path = 'M' + pts[0];\n    var tangents = [];\n    var i;\n    for(i = 1; i < pts.length - 1; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    path += 'Q' + tangents[0][0] + ' ' + pts[1];\n    for(i = 2; i < pts.length - 1; i++) {\n        path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n    }\n    path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n    return path;\n};\n\ndrawing.smoothclosed = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L') + 'Z'; }\n    var path = 'M' + pts[0];\n    var pLast = pts.length - 1;\n    var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n    var i;\n    for(i = 1; i < pLast; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    tangents.push(\n        makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)\n    );\n\n    for(i = 1; i <= pLast; i++) {\n        path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n    }\n    path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n    return path;\n};\n\nvar lastDrawnX, lastDrawnY;\n\nfunction roundEnd(pt, isY, isLastPoint) {\n    if(isLastPoint) pt = applyBackoff(pt);\n\n    return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\n\nfunction roundX(p) {\n    var v = d3.round(p, 2);\n    lastDrawnX = v;\n    return v;\n}\n\nfunction roundY(p) {\n    var v = d3.round(p, 2);\n    lastDrawnY = v;\n    return v;\n}\n\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n    var d1x = prevpt[0] - thispt[0];\n    var d1y = prevpt[1] - thispt[1];\n    var d2x = nextpt[0] - thispt[0];\n    var d2y = nextpt[1] - thispt[1];\n    var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n    var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n    var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n    var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n    var denom1 = 3 * d2a * (d1a + d2a);\n    var denom2 = 3 * d1a * (d1a + d2a);\n    return [\n        [\n            roundX(thispt[0] + (denom1 && numx / denom1)),\n            roundY(thispt[1] + (denom1 && numy / denom1))\n        ], [\n            roundX(thispt[0] - (denom2 && numx / denom2)),\n            roundY(thispt[1] - (denom2 && numy / denom2))\n        ]\n    ];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n    hv: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    },\n    vh: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    hvh: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX((p0[0] + p1[0]) / 2) + 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    vhv: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY((p0[1] + p1[1]) / 2) + 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    }\n};\nvar STEPLINEAR = function(p0, p1, isLastPoint) {\n    return 'L' +\n        roundEnd(p1, 0, isLastPoint) + ',' +\n        roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function(shape) {\n    var onestep = STEPPATH[shape] || STEPLINEAR;\n    return function(pts) {\n        var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n        var len = pts.length;\n        for(var i = 1; i < len; i++) {\n            path += onestep(pts[i - 1], pts[i], i === len - 1);\n        }\n        return path;\n    };\n};\n\nfunction applyBackoff(pt, start) {\n    var backoff = pt.backoff;\n    var trace = pt.trace;\n    var d = pt.d;\n    var i = pt.i;\n\n    if(backoff && trace &&\n        trace.marker &&\n        trace.marker.angle % 360 === 0 &&\n        trace.line &&\n        trace.line.shape !== 'spline'\n    ) {\n        var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n        var end = pt;\n\n        var x1 = start ? start[0] : lastDrawnX || 0;\n        var y1 = start ? start[1] : lastDrawnY || 0;\n\n        var x2 = end[0];\n        var y2 = end[1];\n\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n\n        var t = Math.atan2(dy, dx);\n\n        var b = arrayBackoff ? backoff[i] : backoff;\n\n        if(b === 'auto') {\n            var endI = end.i;\n            if(trace.type === 'scatter') endI--; // Why we need this hack?\n\n            var endMarker = end.marker;\n            var endMarkerSymbol = endMarker.symbol;\n            if(Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n\n            var endMarkerSize = endMarker.size;\n            if(Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n\n            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n            b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n        }\n\n        var x = x2 - b * Math.cos(t);\n        var y = y2 - b * Math.sin(t);\n\n        if(\n            ((x <= x2 && x >= x1) || (x >= x2 && x <= x1)) &&\n            ((y <= y2 && y >= y1) || (y >= y2 && y <= y1))\n        ) {\n            pt = [x, y];\n        }\n    }\n\n    return pt;\n}\n\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function() {\n    var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function(s) {\n        s.attr(xmlnsNamespaces.svgAttrs)\n            .style({\n                position: 'absolute',\n                left: '-10000px',\n                top: '-10000px',\n                width: '9000px',\n                height: '9000px',\n                'z-index': '1'\n            });\n    });\n\n    // browsers differ on how they describe the bounding rect of\n    // the svg if its contents spill over... so make a 1x1px\n    // reference point we can measure off of.\n    var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function(s) {\n        s.attr('d', 'M0,0H1V1H0Z')\n            .style({\n                'stroke-width': 0,\n                fill: 'black'\n            });\n    });\n\n    drawing.tester = tester;\n    drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\n\ndrawing.bBox = function(node, inTester, hash) {\n    /*\n     * Cache elements we've already measured so we don't have to\n     * remeasure the same thing many times\n     * We have a few bBox callers though who pass a node larger than\n     * a <text> or a MathJax <g>, such as an axis group containing many labels.\n     * These will not generate a hash (unless we figure out an appropriate\n     * hash key for them) and thus we will not hash them.\n     */\n    if(!hash) hash = nodeHash(node);\n    var out;\n    if(hash) {\n        out = drawing.savedBBoxes[hash];\n        if(out) return Lib.extendFlat({}, out);\n    } else if(node.childNodes.length === 1) {\n        /*\n         * If we have only one child element, which is itself hashable, make\n         * a new hash from this element plus its x,y,transform\n         * These bounding boxes *include* x,y,transform - mostly for use by\n         * callers trying to avoid overlaps (ie titles)\n         */\n        var innerNode = node.childNodes[0];\n\n        hash = nodeHash(innerNode);\n        if(hash) {\n            var x = +innerNode.getAttribute('x') || 0;\n            var y = +innerNode.getAttribute('y') || 0;\n            var transform = innerNode.getAttribute('transform');\n\n            if(!transform) {\n                // in this case, just varying x and y, don't bother caching\n                // the final bBox because the alteration is quick.\n                var innerBB = drawing.bBox(innerNode, false, hash);\n                if(x) {\n                    innerBB.left += x;\n                    innerBB.right += x;\n                }\n                if(y) {\n                    innerBB.top += y;\n                    innerBB.bottom += y;\n                }\n                return innerBB;\n            }\n            /*\n             * else we have a transform - rather than make a complicated\n             * (and error-prone and probably slow) transform parser/calculator,\n             * just continue on calculating the boundingClientRect of the group\n             * and use the new composite hash to cache it.\n             * That said, `innerNode.transform.baseVal` is an array of\n             * `SVGTransform` objects, that *do* seem to have a nice matrix\n             * multiplication interface that we could use to avoid making\n             * another getBoundingClientRect call...\n             */\n            hash += '~' + x + '~' + y + '~' + transform;\n\n            out = drawing.savedBBoxes[hash];\n            if(out) return Lib.extendFlat({}, out);\n        }\n    }\n    var testNode, tester;\n    if(inTester) {\n        testNode = node;\n    } else {\n        tester = drawing.tester.node();\n\n        // copy the node to test into the tester\n        testNode = node.cloneNode(true);\n        tester.appendChild(testNode);\n    }\n\n    // standardize its position (and newline tspans if any)\n    d3.select(testNode)\n        .attr('transform', null)\n        .call(svgTextUtils.positionText, 0, 0);\n\n    var testRect = testNode.getBoundingClientRect();\n    var refRect = drawing.testref\n        .node()\n        .getBoundingClientRect();\n\n    if(!inTester) tester.removeChild(testNode);\n\n    var bb = {\n        height: testRect.height,\n        width: testRect.width,\n        left: testRect.left - refRect.left,\n        top: testRect.top - refRect.top,\n        right: testRect.right - refRect.left,\n        bottom: testRect.bottom - refRect.top\n    };\n\n    // make sure we don't have too many saved boxes,\n    // or a long session could overload on memory\n    // by saving boxes for long-gone elements\n    if(savedBBoxesCount >= maxSavedBBoxes) {\n        drawing.savedBBoxes = {};\n        savedBBoxesCount = 0;\n    }\n\n    // cache this bbox\n    if(hash) drawing.savedBBoxes[hash] = bb;\n    savedBBoxesCount++;\n\n    return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n    var inputText = node.getAttribute('data-unformatted');\n    if(inputText === null) return;\n    return inputText +\n        node.getAttribute('data-math') +\n        node.getAttribute('text-anchor') +\n        node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function(s, localId, gd) {\n    s.attr('clip-path', getFullUrl(localId, gd));\n};\n\nfunction getFullUrl(localId, gd) {\n    if(!localId) return null;\n\n    var context = gd._context;\n    var baseUrl = context._exportedPlot ? '' : (context._baseUrl || '');\n    return baseUrl ?\n        'url(\\'' + baseUrl + '#' + localId + '\\')' :\n        'url(#' + localId + ')';\n}\n\ndrawing.getTranslate = function(element) {\n    // Note the separator [^\\d] between x and y in this regex\n    // We generally use ',' but IE will convert it to ' '\n    var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 0,\n        y: +translate[1] || 0\n    };\n};\n\ndrawing.setTranslate = function(element, x, y) {\n    var re = /(\\btranslate\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 0;\n    y = y || 0;\n\n    transform = transform.replace(re, '').trim();\n    transform += strTranslate(x, y);\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\ndrawing.getScale = function(element) {\n    var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 1,\n        y: +translate[1] || 1\n    };\n};\n\ndrawing.setScale = function(element, x, y) {\n    var re = /(\\bscale\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 1;\n    y = y || 1;\n\n    transform = transform.replace(re, '').trim();\n    transform += 'scale(' + x + ',' + y + ')';\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\nvar SCALE_RE = /\\s*sc.*/;\n\ndrawing.setPointGroupScale = function(selection, xScale, yScale) {\n    xScale = xScale || 1;\n    yScale = yScale || 1;\n\n    if(!selection) return;\n\n    // The same scale transform for every point:\n    var scale = (xScale === 1 && yScale === 1) ?\n        '' :\n        'scale(' + xScale + ',' + yScale + ')';\n\n    selection.each(function() {\n        var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n        t += scale;\n        t = t.trim();\n        this.setAttribute('transform', t);\n    });\n};\n\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\n\ndrawing.setTextPointsScale = function(selection, xScale, yScale) {\n    if(!selection) return;\n\n    selection.each(function() {\n        var transforms;\n        var el = d3.select(this);\n        var text = el.select('text');\n\n        if(!text.node()) return;\n\n        var x = parseFloat(text.attr('x') || 0);\n        var y = parseFloat(text.attr('y') || 0);\n\n        var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n\n        if(xScale === 1 && yScale === 1) {\n            transforms = [];\n        } else {\n            transforms = [\n                strTranslate(x, y),\n                'scale(' + xScale + ',' + yScale + ')',\n                strTranslate(-x, -y),\n            ];\n        }\n\n        if(existingTransform) {\n            transforms.push(existingTransform);\n        }\n\n        el.attr('transform', transforms.join(''));\n    });\n};\n\nfunction getMarkerStandoff(d, trace) {\n    var standoff;\n\n    if(d) standoff = d.mf;\n\n    if(standoff === undefined) {\n        standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n    }\n\n    if(!trace._geo && !trace._xA) {\n        // case of legends\n        return -standoff;\n    }\n\n    return standoff;\n}\n\ndrawing.getMarkerStandoff = getMarkerStandoff;\n\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nfunction rotate(t, xy) {\n    var x = xy[0];\n    var y = xy[1];\n    return [\n        x * cos(t) - y * sin(t),\n        x * sin(t) + y * cos(t)\n    ];\n}\n\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\n\nfunction getMarkerAngle(d, trace) {\n    var angle = d.ma;\n\n    if(angle === undefined) {\n        angle = trace.marker.angle;\n        if(!angle || Lib.isArrayOrTypedArray(angle)) {\n            angle = 0;\n        }\n    }\n\n    var x, y;\n    var ref = trace.marker.angleref;\n    if(ref === 'previous' || ref === 'north') {\n        if(trace._geo) {\n            var p = trace._geo.project(d.lonlat);\n            x = p[0];\n            y = p[1];\n        } else {\n            var xa = trace._xA;\n            var ya = trace._yA;\n            if(xa && ya) {\n                x = xa.c2p(d.x);\n                y = ya.c2p(d.y);\n            } else {\n                // case of legends\n                return 90;\n            }\n        }\n\n        if(trace._geo) {\n            var lon = d.lonlat[0];\n            var lat = d.lonlat[1];\n\n            var north = trace._geo.project([\n                lon,\n                lat + 1e-5 // epsilon\n            ]);\n\n            var east = trace._geo.project([\n                lon + 1e-5, // epsilon\n                lat\n            ]);\n\n            var u = atan2(\n                east[1] - y,\n                east[0] - x\n            );\n\n            var v = atan2(\n                north[1] - y,\n                north[0] - x\n            );\n\n            var t;\n            if(ref === 'north') {\n                t = angle / 180 * Math.PI;\n                // To use counter-clockwise angles i.e.\n                // East: 90, West: -90\n                // to facilitate wind visualisations\n                // in future we should use t = -t here.\n            } else if(ref === 'previous') {\n                var lon1 = lon / 180 * Math.PI;\n                var lat1 = lat / 180 * Math.PI;\n                var lon2 = previousLon / 180 * Math.PI;\n                var lat2 = previousLat / 180 * Math.PI;\n\n                var dLon = lon2 - lon1;\n\n                var deltaY = cos(lat2) * sin(dLon);\n                var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n\n                t = -atan2(\n                    deltaY,\n                    deltaX\n                ) - Math.PI;\n\n                previousLon = lon;\n                previousLat = lat;\n            }\n\n            var A = rotate(u, [cos(t), 0]);\n            var B = rotate(v, [sin(t), 0]);\n\n            angle = atan2(\n                A[1] + B[1],\n                A[0] + B[0]\n            ) / Math.PI * 180;\n\n            if(ref === 'previous' && !(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1\n            )) {\n                angle = null;\n            }\n        }\n\n        if(ref === 'previous' && !trace._geo) {\n            if(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1 &&\n                isNumeric(x) &&\n                isNumeric(y)\n            ) {\n                var dX = x - previousX;\n                var dY = y - previousY;\n\n                var shape = trace.line ? trace.line.shape || '' : '';\n\n                var lastShapeChar = shape.slice(shape.length - 1);\n                if(lastShapeChar === 'h') dY = 0;\n                if(lastShapeChar === 'v') dX = 0;\n\n                angle += atan2(dY, dX) / Math.PI * 180 + 90;\n            } else {\n                angle = null;\n            }\n        }\n    }\n\n    previousX = x;\n    previousY = y;\n    previousI = d.i;\n    previousTraceUid = trace.uid;\n\n    return angle;\n}\n\ndrawing.getMarkerAngle = getMarkerAngle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}