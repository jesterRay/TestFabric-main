{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nmodule.exports = function makeBoundArray(trace, arrayIn, v0In, dvIn, numbricks, ax) {\n  var arrayOut = [];\n  var isContour = Registry.traceIs(trace, 'contour');\n  var isHist = Registry.traceIs(trace, 'histogram');\n  var isGL2D = Registry.traceIs(trace, 'gl2d');\n  var v0;\n  var dv;\n  var i;\n  var isArrayOfTwoItemsOrMore = isArrayOrTypedArray(arrayIn) && arrayIn.length > 1;\n  if (isArrayOfTwoItemsOrMore && !isHist && ax.type !== 'category') {\n    var len = arrayIn.length;\n\n    // given vals are brick centers\n    // hopefully length === numbricks, but use this method even if too few are supplied\n    // and extend it linearly based on the last two points\n    if (len <= numbricks) {\n      // contour plots only want the centers\n      if (isContour || isGL2D) arrayOut = Array.from(arrayIn).slice(0, numbricks);else if (numbricks === 1) {\n        if (ax.type === 'log') {\n          arrayOut = [0.5 * arrayIn[0], 2 * arrayIn[0]];\n        } else {\n          arrayOut = [arrayIn[0] - 0.5, arrayIn[0] + 0.5];\n        }\n      } else if (ax.type === 'log') {\n        arrayOut = [Math.pow(arrayIn[0], 1.5) / Math.pow(arrayIn[1], 0.5)];\n        for (i = 1; i < len; i++) {\n          // Geomean\n          arrayOut.push(Math.sqrt(arrayIn[i - 1] * arrayIn[i]));\n        }\n        arrayOut.push(Math.pow(arrayIn[len - 1], 1.5) / Math.pow(arrayIn[len - 2], 0.5));\n      } else {\n        arrayOut = [1.5 * arrayIn[0] - 0.5 * arrayIn[1]];\n        for (i = 1; i < len; i++) {\n          // Arithmetic mean\n          arrayOut.push((arrayIn[i - 1] + arrayIn[i]) * 0.5);\n        }\n        arrayOut.push(1.5 * arrayIn[len - 1] - 0.5 * arrayIn[len - 2]);\n      }\n      if (len < numbricks) {\n        var lastPt = arrayOut[arrayOut.length - 1];\n        var delta; // either multiplicative delta (log axis type) or arithmetic delta (all other axis types)\n        if (ax.type === 'log') {\n          delta = lastPt / arrayOut[arrayOut.length - 2];\n          for (i = len; i < numbricks; i++) {\n            lastPt *= delta;\n            arrayOut.push(lastPt);\n          }\n        } else {\n          delta = lastPt - arrayOut[arrayOut.length - 2];\n          for (i = len; i < numbricks; i++) {\n            lastPt += delta;\n            arrayOut.push(lastPt);\n          }\n        }\n      }\n    } else {\n      // hopefully length === numbricks+1, but do something regardless:\n      // given vals are brick boundaries\n      return isContour ? arrayIn.slice(0, numbricks) :\n      // we must be strict for contours\n      arrayIn.slice(0, numbricks + 1);\n    }\n  } else {\n    var calendar = trace[ax._id.charAt(0) + 'calendar'];\n    if (isHist) {\n      v0 = ax.r2c(v0In, 0, calendar);\n    } else {\n      if (isArrayOrTypedArray(arrayIn) && arrayIn.length === 1) {\n        v0 = arrayIn[0];\n      } else if (v0In === undefined) {\n        v0 = 0;\n      } else {\n        var fn = ax.type === 'log' ? ax.d2c : ax.r2c;\n        v0 = fn(v0In, 0, calendar);\n      }\n    }\n    dv = dvIn || 1;\n    for (i = isContour || isGL2D ? 0 : -0.5; i < numbricks; i++) {\n      arrayOut.push(v0 + dv * i);\n    }\n  }\n  return arrayOut;\n};","map":{"version":3,"names":["Registry","require","isArrayOrTypedArray","module","exports","makeBoundArray","trace","arrayIn","v0In","dvIn","numbricks","ax","arrayOut","isContour","traceIs","isHist","isGL2D","v0","dv","i","isArrayOfTwoItemsOrMore","length","type","len","Array","from","slice","Math","pow","push","sqrt","lastPt","delta","calendar","_id","charAt","r2c","undefined","fn","d2c"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/heatmap/make_bound_array.js"],"sourcesContent":["'use strict';\n\nvar Registry = require('../../registry');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nmodule.exports = function makeBoundArray(trace, arrayIn, v0In, dvIn, numbricks, ax) {\n    var arrayOut = [];\n    var isContour = Registry.traceIs(trace, 'contour');\n    var isHist = Registry.traceIs(trace, 'histogram');\n    var isGL2D = Registry.traceIs(trace, 'gl2d');\n    var v0;\n    var dv;\n    var i;\n\n    var isArrayOfTwoItemsOrMore = isArrayOrTypedArray(arrayIn) && arrayIn.length > 1;\n\n    if(isArrayOfTwoItemsOrMore && !isHist && (ax.type !== 'category')) {\n        var len = arrayIn.length;\n\n        // given vals are brick centers\n        // hopefully length === numbricks, but use this method even if too few are supplied\n        // and extend it linearly based on the last two points\n        if(len <= numbricks) {\n            // contour plots only want the centers\n            if(isContour || isGL2D) arrayOut = Array.from(arrayIn).slice(0, numbricks);\n            else if(numbricks === 1) {\n                if(ax.type === 'log') {\n                    arrayOut = [0.5 * arrayIn[0], 2 * arrayIn[0]];\n                } else {\n                    arrayOut = [arrayIn[0] - 0.5, arrayIn[0] + 0.5];\n                }\n            } else if(ax.type === 'log') {\n                arrayOut = [Math.pow(arrayIn[0], 1.5) / Math.pow(arrayIn[1], 0.5)];\n\n                for(i = 1; i < len; i++) {\n                    // Geomean\n                    arrayOut.push(Math.sqrt(arrayIn[i - 1] * arrayIn[i]));\n                }\n\n                arrayOut.push(Math.pow(arrayIn[len - 1], 1.5) / Math.pow(arrayIn[len - 2], 0.5));\n            } else {\n                arrayOut = [1.5 * arrayIn[0] - 0.5 * arrayIn[1]];\n\n                for(i = 1; i < len; i++) {\n                    // Arithmetic mean\n                    arrayOut.push((arrayIn[i - 1] + arrayIn[i]) * 0.5);\n                }\n\n                arrayOut.push(1.5 * arrayIn[len - 1] - 0.5 * arrayIn[len - 2]);\n            }\n\n            if(len < numbricks) {\n                var lastPt = arrayOut[arrayOut.length - 1];\n                var delta; // either multiplicative delta (log axis type) or arithmetic delta (all other axis types)\n                if(ax.type === 'log') {\n                    delta = lastPt / arrayOut[arrayOut.length - 2];\n\n                    for(i = len; i < numbricks; i++) {\n                        lastPt *= delta;\n                        arrayOut.push(lastPt);\n                    }\n                } else {\n                    delta = lastPt - arrayOut[arrayOut.length - 2];\n\n                    for(i = len; i < numbricks; i++) {\n                        lastPt += delta;\n                        arrayOut.push(lastPt);\n                    }\n                }\n            }\n        } else {\n            // hopefully length === numbricks+1, but do something regardless:\n            // given vals are brick boundaries\n            return isContour ?\n                arrayIn.slice(0, numbricks) :  // we must be strict for contours\n                arrayIn.slice(0, numbricks + 1);\n        }\n    } else {\n        var calendar = trace[ax._id.charAt(0) + 'calendar'];\n\n        if(isHist) {\n            v0 = ax.r2c(v0In, 0, calendar);\n        } else {\n            if(isArrayOrTypedArray(arrayIn) && arrayIn.length === 1) {\n                v0 = arrayIn[0];\n            } else if(v0In === undefined) {\n                v0 = 0;\n            } else {\n                var fn = ax.type === 'log' ? ax.d2c : ax.r2c;\n                v0 = fn(v0In, 0, calendar);\n            }\n        }\n\n        dv = dvIn || 1;\n\n        for(i = (isContour || isGL2D) ? 0 : -0.5; i < numbricks; i++) {\n            arrayOut.push(v0 + dv * i);\n        }\n    }\n\n    return arrayOut;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}