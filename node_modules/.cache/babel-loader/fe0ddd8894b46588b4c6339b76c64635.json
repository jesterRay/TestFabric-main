{"ast":null,"code":"/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\n'use strict';\n\n//////////////////////////////////////////////////////////////////////////\n// Helpers\n//\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input = jpeg_bin.subarray(exif_start, exif_end);\n\n  // offset correction for `on_entry` callback\n  this.start = exif_start;\n\n  // Check TIFF header (includes byte alignment and first IFD offset)\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  }\n\n  // true if motorola (big endian) byte alignment, false if intel\n  this.big_endian = sig[0] === 'M';\n}\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n  var offset = this.read_uint32(4);\n  this.ifds_to_read = [{\n    id: 0,\n    offset: offset\n  }];\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n  return this.big_endian ? d[offset] * 0x100 + d[offset + 1] : d[offset] + d[offset + 1] * 0x100;\n};\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n  return this.big_endian ? d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] : d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return ifd === 0 && tag === 0x8769 ||\n  // SubIFD\n  ifd === 0 && tag === 0x8825 ||\n  // GPS Info\n  ifd === 0x8769 && tag === 0xA005; // Interop IFD\n};\n\n// Returns byte length of a single component of a given format\n//\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n    case 6: // sbyte\n    case 7:\n      // undefined\n      return 1;\n    case 3: // short\n    case 8:\n      // sshort\n      return 2;\n    case 4: // long\n    case 9: // slong\n    case 11:\n      // float\n      return 4;\n    case 5: // rational\n    case 10: // srational\n    case 12:\n      // double\n      return 8;\n    default:\n      // unknown type\n      return 0;\n  }\n};\n\n// Reads Exif data\n//\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n  switch (format) {\n    case 1: // byte\n    case 2:\n      // ascii\n      v = this.input[offset];\n      return v;\n    case 6:\n      // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n    case 3:\n      // short\n      v = this.read_uint16(offset);\n      return v;\n    case 8:\n      // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n    case 4:\n      // long\n      v = this.read_uint32(offset);\n      return v;\n    case 9:\n      // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n    case 5: // rational\n    case 10: // srational\n    case 11: // float\n    case 12:\n      // double\n      return null;\n    // not implemented\n\n    case 7:\n      // undefined\n      return null;\n    // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n  offset += 2;\n  for (var i = 0; i < entry_count; i++) {\n    var tag = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count = this.read_uint32(offset + 4);\n    var comp_length = this.exif_format_length(format);\n    var data_length = count * comp_length;\n    var data_offset = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n    var value = [];\n    var comp_offset = data_offset;\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n      if (item === null) {\n        value = null;\n        break;\n      }\n      value.push(item);\n    }\n    if (Array.isArray(value) && format === 2) {\n      value = utf8_decode(String.fromCharCode.apply(null, value));\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id: tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n    var entry = {\n      is_big_endian: this.big_endian,\n      ifd: ifd_no,\n      tag: tag,\n      format: format,\n      count: count,\n      entry_offset: offset + this.start,\n      data_length: data_length,\n      data_offset: data_offset + this.start,\n      value: value,\n      is_subifd_link: is_subifd_link\n    };\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n    offset += 12;\n  }\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id: 1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\nmodule.exports.ExifParser = ExifParser;\n\n// returns orientation stored in Exif (1-8), 0 if none was found, -1 if error\nmodule.exports.get_orientation = function (data) {\n  var orientation = 0;\n  try {\n    new ExifParser(data, 0, data.length).each(function (entry) {\n      if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n        orientation = entry.value[0];\n        return false;\n      }\n    });\n    return orientation;\n  } catch (err) {\n    return -1;\n  }\n};","map":{"version":3,"names":["error","message","code","err","Error","utf8_decode","str","decodeURIComponent","escape","_","ExifParser","jpeg_bin","exif_start","exif_end","input","subarray","start","sig","String","fromCharCode","apply","big_endian","prototype","each","on_entry","aborted","offset","read_uint32","ifds_to_read","id","length","i","shift","scan_ifd","read_uint16","d","is_subifd_link","ifd","tag","exif_format_length","format","exif_format_read","v","ifd_no","entry_count","count","comp_length","data_length","data_offset","value","comp_offset","j","item","push","Array","isArray","slice","Number","isInteger","entry","is_big_endian","entry_offset","module","exports","get_orientation","data","orientation"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/probe-image-size/lib/exif_utils.js"],"sourcesContent":["\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\n'use strict';\n\n//////////////////////////////////////////////////////////////////////////\n// Helpers\n//\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\n\n\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input      = jpeg_bin.subarray(exif_start, exif_end);\n\n  // offset correction for `on_entry` callback\n  this.start      = exif_start;\n\n  // Check TIFF header (includes byte alignment and first IFD offset)\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  }\n\n  // true if motorola (big endian) byte alignment, false if intel\n  this.big_endian = sig[0] === 'M';\n}\n\n\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n\n  var offset = this.read_uint32(4);\n\n  this.ifds_to_read = [ {\n    id:     0,\n    offset: offset\n  } ];\n\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\n\n\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x100 + d[offset + 1] :\n    d[offset] + d[offset + 1] * 0x100;\n};\n\n\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] :\n    d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\n\n\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return (ifd === 0 && tag === 0x8769) || // SubIFD\n         (ifd === 0 && tag === 0x8825) || // GPS Info\n         (ifd === 0x8769 && tag === 0xA005); // Interop IFD\n};\n\n\n// Returns byte length of a single component of a given format\n//\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n    case 6: // sbyte\n    case 7: // undefined\n      return 1;\n\n    case 3: // short\n    case 8: // sshort\n      return 2;\n\n    case 4:  // long\n    case 9:  // slong\n    case 11: // float\n      return 4;\n\n    case 5:  // rational\n    case 10: // srational\n    case 12: // double\n      return 8;\n\n    default:\n      // unknown type\n      return 0;\n  }\n};\n\n\n// Reads Exif data\n//\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n      v = this.input[offset];\n      return v;\n\n    case 6: // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n\n    case 3: // short\n      v = this.read_uint16(offset);\n      return v;\n\n    case 8: // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n\n    case 4: // long\n      v = this.read_uint32(offset);\n      return v;\n\n    case 9: // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n\n    case 5:  // rational\n    case 10: // srational\n    case 11: // float\n    case 12: // double\n      return null; // not implemented\n\n    case 7: // undefined\n      return null; // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\n\n\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n\n  offset += 2;\n\n  for (var i = 0; i < entry_count; i++) {\n    var tag    = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count  = this.read_uint32(offset + 4);\n\n    var comp_length    = this.exif_format_length(format);\n    var data_length    = count * comp_length;\n    var data_offset    = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n\n    var value = [];\n    var comp_offset = data_offset;\n\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n      if (item === null) {\n        value = null;\n        break;\n      }\n      value.push(item);\n    }\n\n    if (Array.isArray(value) && format === 2) {\n      value = utf8_decode(String.fromCharCode.apply(null, value));\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id:     tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n\n    var entry = {\n      is_big_endian:  this.big_endian,\n      ifd:            ifd_no,\n      tag:            tag,\n      format:         format,\n      count:          count,\n      entry_offset:   offset + this.start,\n      data_length:    data_length,\n      data_offset:    data_offset + this.start,\n      value:          value,\n      is_subifd_link: is_subifd_link\n    };\n\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n\n    offset += 12;\n  }\n\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id:     1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\n\n\nmodule.exports.ExifParser = ExifParser;\n\n// returns orientation stored in Exif (1-8), 0 if none was found, -1 if error\nmodule.exports.get_orientation = function (data) {\n  var orientation = 0;\n  try {\n    new ExifParser(data, 0, data.length).each(function (entry) {\n      if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n        orientation = entry.value[0];\n        return false;\n      }\n    });\n    return orientation;\n  } catch (err) {\n    return -1;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}