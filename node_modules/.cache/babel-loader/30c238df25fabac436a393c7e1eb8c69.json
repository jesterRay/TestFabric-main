{"ast":null,"code":"'use strict';\n\nconst createScatter = require('regl-scatter2d');\nconst pick = require('pick-by-alias');\nconst getBounds = require('array-bounds');\nconst raf = require('raf');\nconst arrRange = require('array-range');\nconst rect = require('parse-rect');\nconst flatten = require('flatten-vertex-data');\nmodule.exports = SPLOM;\n\n// @constructor\nfunction SPLOM(regl, options) {\n  if (!(this instanceof SPLOM)) return new SPLOM(regl, options);\n\n  // render passes\n  this.traces = [];\n\n  // passes for scatter, combined across traces\n  this.passes = {};\n  this.regl = regl;\n\n  // main scatter drawing instance\n  this.scatter = createScatter(regl);\n  this.canvas = this.scatter.canvas;\n}\n\n// update & draw passes once per frame\nSPLOM.prototype.render = function (...args) {\n  if (args.length) {\n    this.update(...args);\n  }\n  if (this.regl.attributes.preserveDrawingBuffer) return this.draw();\n\n  // make sure draw is not called more often than once a frame\n  if (this.dirty) {\n    if (this.planned == null) {\n      this.planned = raf(() => {\n        this.draw();\n        this.dirty = true;\n        this.planned = null;\n      });\n    }\n  } else {\n    this.draw();\n    this.dirty = true;\n    raf(() => {\n      this.dirty = false;\n    });\n  }\n  return this;\n};\n\n// update passes\nSPLOM.prototype.update = function (...args) {\n  if (!args.length) return;\n  for (let i = 0; i < args.length; i++) {\n    this.updateItem(i, args[i]);\n  }\n\n  // remove nulled passes\n  this.traces = this.traces.filter(Boolean);\n\n  // FIXME: update passes independently\n  let passes = [];\n  let offset = 0;\n  for (let i = 0; i < this.traces.length; i++) {\n    let trace = this.traces[i];\n    let tracePasses = this.traces[i].passes;\n    for (let j = 0; j < tracePasses.length; j++) {\n      passes.push(this.passes[tracePasses[j]]);\n    }\n    // save offset of passes\n    trace.passOffset = offset;\n    offset += trace.passes.length;\n  }\n  this.scatter.update(...passes);\n  return this;\n};\n\n// update trace by index, not supposed to be called directly\nSPLOM.prototype.updateItem = function (i, options) {\n  let {\n    regl\n  } = this;\n\n  // remove pass if null\n  if (options === null) {\n    this.traces[i] = null;\n    return this;\n  }\n  if (!options) return this;\n  let o = pick(options, {\n    data: 'data items columns rows values dimensions samples x',\n    snap: 'snap cluster',\n    size: 'sizes size radius',\n    color: 'colors color fill fill-color fillColor',\n    opacity: 'opacity alpha transparency opaque',\n    borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n    borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n    marker: 'markers marker shape',\n    range: 'range ranges databox dataBox',\n    viewport: 'viewport viewBox viewbox',\n    domain: 'domain domains area areas',\n    padding: 'pad padding paddings pads margin margins',\n    transpose: 'transpose transposed',\n    diagonal: 'diagonal diag showDiagonal',\n    upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n    lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n  });\n\n  // we provide regl buffer per-trace, since trace data can be changed\n  let trace = this.traces[i] || (this.traces[i] = {\n    id: i,\n    buffer: regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array()\n    }),\n    color: 'black',\n    marker: null,\n    size: 12,\n    borderColor: 'transparent',\n    borderSize: 1,\n    viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n    padding: [0, 0, 0, 0],\n    opacity: 1,\n    diagonal: true,\n    upper: true,\n    lower: true\n  });\n\n  // save styles\n  if (o.color != null) {\n    trace.color = o.color;\n  }\n  if (o.size != null) {\n    trace.size = o.size;\n  }\n  if (o.marker != null) {\n    trace.marker = o.marker;\n  }\n  if (o.borderColor != null) {\n    trace.borderColor = o.borderColor;\n  }\n  if (o.borderSize != null) {\n    trace.borderSize = o.borderSize;\n  }\n  if (o.opacity != null) {\n    trace.opacity = o.opacity;\n  }\n  if (o.viewport) {\n    trace.viewport = rect(o.viewport);\n  }\n  if (o.diagonal != null) trace.diagonal = o.diagonal;\n  if (o.upper != null) trace.upper = o.upper;\n  if (o.lower != null) trace.lower = o.lower;\n\n  // put flattened data into buffer\n  if (o.data) {\n    trace.buffer(flatten(o.data));\n    trace.columns = o.data.length;\n    trace.count = o.data[0].length;\n\n    // detect bounds per-column\n    trace.bounds = [];\n    for (let i = 0; i < trace.columns; i++) {\n      trace.bounds[i] = getBounds(o.data[i], 1);\n    }\n  }\n\n  // add proper range updating markers\n  let multirange;\n  if (o.range) {\n    trace.range = o.range;\n    multirange = trace.range && typeof trace.range[0] !== 'number';\n  }\n  if (o.domain) {\n    trace.domain = o.domain;\n  }\n  let multipadding = false;\n  if (o.padding != null) {\n    // multiple paddings\n    if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n      trace.padding = o.padding.map(getPad);\n      multipadding = true;\n    }\n    // single padding\n    else {\n      trace.padding = getPad(o.padding);\n    }\n  }\n\n  // create passes\n  let m = trace.columns;\n  let n = trace.count;\n  let w = trace.viewport.width;\n  let h = trace.viewport.height;\n  let left = trace.viewport.x;\n  let top = trace.viewport.y;\n  let iw = w / m;\n  let ih = h / m;\n  trace.passes = [];\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < m; j++) {\n      if (!trace.diagonal && j === i) continue;\n      if (!trace.upper && i > j) continue;\n      if (!trace.lower && i < j) continue;\n      let key = passId(trace.id, i, j);\n      let pass = this.passes[key] || (this.passes[key] = {});\n      if (o.data) {\n        if (o.transpose) {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j,\n              count: n,\n              stride: m\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: i,\n              count: n,\n              stride: m\n            }\n          };\n        } else {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j * n,\n              count: n\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: i * n,\n              count: n\n            }\n          };\n        }\n        pass.bounds = getBox(trace.bounds, i, j);\n      }\n      if (o.domain || o.viewport || o.data) {\n        let pad = multipadding ? getBox(trace.padding, i, j) : trace.padding;\n        if (trace.domain) {\n          let [lox, loy, hix, hiy] = getBox(trace.domain, i, j);\n          pass.viewport = [left + lox * w + pad[0], top + loy * h + pad[1], left + hix * w - pad[2], top + hiy * h - pad[3]];\n        }\n        // consider auto-domain equipartial\n        else {\n          pass.viewport = [left + j * iw + iw * pad[0], top + i * ih + ih * pad[1], left + (j + 1) * iw - iw * pad[2], top + (i + 1) * ih - ih * pad[3]];\n        }\n      }\n      if (o.color) pass.color = trace.color;\n      if (o.size) pass.size = trace.size;\n      if (o.marker) pass.marker = trace.marker;\n      if (o.borderSize) pass.borderSize = trace.borderSize;\n      if (o.borderColor) pass.borderColor = trace.borderColor;\n      if (o.opacity) pass.opacity = trace.opacity;\n      if (o.range) {\n        pass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds;\n      }\n      trace.passes.push(key);\n    }\n  }\n  return this;\n};\n\n// draw all or passed passes\nSPLOM.prototype.draw = function (...args) {\n  if (!args.length) {\n    this.scatter.draw();\n  } else {\n    let idx = [];\n    for (let i = 0; i < args.length; i++) {\n      // draw(0, 2, 5) - draw traces\n      if (typeof args[i] === 'number') {\n        let {\n          passes,\n          passOffset\n        } = this.traces[args[i]];\n        idx.push(...arrRange(passOffset, passOffset + passes.length));\n      }\n      // draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n      else if (args[i].length) {\n        let els = args[i];\n        let {\n          passes,\n          passOffset\n        } = this.traces[i];\n        passes = passes.map((passId, i) => {\n          idx[passOffset + i] = els;\n        });\n      }\n    }\n    this.scatter.draw(...idx);\n  }\n  return this;\n};\n\n// dispose resources\nSPLOM.prototype.destroy = function () {\n  this.traces.forEach(trace => {\n    if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();\n  });\n  this.traces = null;\n  this.passes = null;\n  this.scatter.destroy();\n  return this;\n};\n\n// return pass corresponding to trace i- j- square\nfunction passId(trace, i, j) {\n  let id = trace.id != null ? trace.id : trace;\n  let n = i;\n  let m = j;\n  let key = id << 16 | (n & 0xff) << 8 | m & 0xff;\n  return key;\n}\n\n// return bounding box corresponding to a pass\nfunction getBox(items, i, j) {\n  let ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;\n  let iitem = items[i],\n    jitem = items[j];\n  if (iitem.length > 2) {\n    ilox = iitem[0];\n    ihix = iitem[2];\n    iloy = iitem[1];\n    ihiy = iitem[3];\n  } else if (iitem.length) {\n    ilox = iloy = iitem[0];\n    ihix = ihiy = iitem[1];\n  } else {\n    ilox = iitem.x;\n    iloy = iitem.y;\n    ihix = iitem.x + iitem.width;\n    ihiy = iitem.y + iitem.height;\n  }\n  if (jitem.length > 2) {\n    jlox = jitem[0];\n    jhix = jitem[2];\n    jloy = jitem[1];\n    jhiy = jitem[3];\n  } else if (jitem.length) {\n    jlox = jloy = jitem[0];\n    jhix = jhiy = jitem[1];\n  } else {\n    jlox = jitem.x;\n    jloy = jitem.y;\n    jhix = jitem.x + jitem.width;\n    jhiy = jitem.y + jitem.height;\n  }\n  return [jlox, iloy, jhix, ihiy];\n}\nfunction getPad(arg) {\n  if (typeof arg === 'number') return [arg, arg, arg, arg];else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];else {\n    let box = rect(arg);\n    return [box.x, box.y, box.x + box.width, box.y + box.height];\n  }\n}","map":{"version":3,"names":["createScatter","require","pick","getBounds","raf","arrRange","rect","flatten","module","exports","SPLOM","regl","options","traces","passes","scatter","canvas","prototype","render","args","length","update","attributes","preserveDrawingBuffer","draw","dirty","planned","i","updateItem","filter","Boolean","offset","trace","tracePasses","j","push","passOffset","o","data","snap","size","color","opacity","borderSize","borderColor","marker","range","viewport","domain","padding","transpose","diagonal","upper","lower","id","buffer","usage","type","Uint8Array","_gl","drawingBufferWidth","drawingBufferHeight","columns","count","bounds","multirange","multipadding","Array","isArray","map","getPad","m","n","w","width","h","height","left","x","top","y","iw","ih","key","passId","pass","positions","stride","getBox","pad","lox","loy","hix","hiy","idx","els","destroy","forEach","items","ilox","iloy","ihix","ihiy","jlox","jloy","jhix","jhiy","iitem","jitem","arg","box"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/regl-splom/index.js"],"sourcesContent":["'use strict'\n\n\nconst createScatter = require('regl-scatter2d')\nconst pick = require('pick-by-alias')\nconst getBounds = require('array-bounds')\nconst raf = require('raf')\nconst arrRange = require('array-range')\nconst rect = require('parse-rect')\nconst flatten = require('flatten-vertex-data')\n\n\nmodule.exports = SPLOM\n\n\n// @constructor\nfunction SPLOM (regl, options) {\n\tif (!(this instanceof SPLOM)) return new SPLOM(regl, options)\n\n\t// render passes\n\tthis.traces = []\n\n\t// passes for scatter, combined across traces\n\tthis.passes = {}\n\n\tthis.regl = regl\n\n\t// main scatter drawing instance\n\tthis.scatter = createScatter(regl)\n\n\tthis.canvas = this.scatter.canvas\n}\n\n\n// update & draw passes once per frame\nSPLOM.prototype.render = function (...args) {\n\tif (args.length) {\n\t\tthis.update(...args)\n\t}\n\n\tif (this.regl.attributes.preserveDrawingBuffer) return this.draw()\n\n\t// make sure draw is not called more often than once a frame\n\tif (this.dirty) {\n\t\tif (this.planned == null) {\n\t\t\tthis.planned = raf(() => {\n\t\t\t\tthis.draw()\n\t\t\t\tthis.dirty = true\n\t\t\t\tthis.planned = null\n\t\t\t})\n\t\t}\n\t}\n\telse {\n\t\tthis.draw()\n\t\tthis.dirty = true\n\t\traf(() => {\n\t\t\tthis.dirty = false\n\t\t})\n\t}\n\n\treturn this\n}\n\n\n// update passes\nSPLOM.prototype.update = function (...args) {\n\tif (!args.length) return\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tthis.updateItem(i, args[i])\n\t}\n\n\t// remove nulled passes\n\tthis.traces = this.traces.filter(Boolean)\n\n\t// FIXME: update passes independently\n\tlet passes = []\n\tlet offset = 0\n\tfor (let i = 0; i < this.traces.length; i++) {\n\t\tlet trace = this.traces[i]\n\t\tlet tracePasses = this.traces[i].passes\n\t\tfor (let j = 0; j < tracePasses.length; j++) {\n\t\t\tpasses.push(this.passes[tracePasses[j]])\n\t\t}\n\t\t// save offset of passes\n\t\ttrace.passOffset = offset\n\t\toffset += trace.passes.length\n\t}\n\n\tthis.scatter.update(...passes)\n\n\treturn this\n}\n\n\n// update trace by index, not supposed to be called directly\nSPLOM.prototype.updateItem = function (i, options) {\n\tlet { regl } = this\n\n\t// remove pass if null\n\tif (options === null) {\n\t\tthis.traces[i] = null\n\t\treturn this\n\t}\n\n\tif (!options) return this\n\n\tlet o = pick(options, {\n\t\tdata: 'data items columns rows values dimensions samples x',\n\t\tsnap: 'snap cluster',\n\t\tsize: 'sizes size radius',\n\t\tcolor: 'colors color fill fill-color fillColor',\n\t\topacity: 'opacity alpha transparency opaque',\n\t\tborderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n\t\tborderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n\t\tmarker: 'markers marker shape',\n\t\trange: 'range ranges databox dataBox',\n\t\tviewport: 'viewport viewBox viewbox',\n\t\tdomain: 'domain domains area areas',\n\t\tpadding: 'pad padding paddings pads margin margins',\n\t\ttranspose: 'transpose transposed',\n\t\tdiagonal: 'diagonal diag showDiagonal',\n\t\tupper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n\t\tlower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n\t})\n\n\t// we provide regl buffer per-trace, since trace data can be changed\n\tlet trace = (this.traces[i] || (this.traces[i] = {\n\t\tid: i,\n\t\tbuffer: regl.buffer({\n\t\t\tusage: 'dynamic',\n\t\t\ttype: 'float',\n\t\t\tdata: new Uint8Array()\n\t\t}),\n\t\tcolor: 'black',\n\t\tmarker: null,\n\t\tsize: 12,\n\t\tborderColor: 'transparent',\n\t\tborderSize: 1,\n\t\tviewport:  rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n\t\tpadding: [0, 0, 0, 0],\n\t\topacity: 1,\n\t\tdiagonal: true,\n\t\tupper: true,\n\t\tlower: true\n\t}))\n\n\n\t// save styles\n\tif (o.color != null) {\n\t\ttrace.color = o.color\n\t}\n\tif (o.size != null) {\n\t\ttrace.size = o.size\n\t}\n\tif (o.marker != null) {\n\t\ttrace.marker = o.marker\n\t}\n\tif (o.borderColor != null) {\n\t\ttrace.borderColor = o.borderColor\n\t}\n\tif (o.borderSize != null) {\n\t\ttrace.borderSize = o.borderSize\n\t}\n\tif (o.opacity != null) {\n\t\ttrace.opacity = o.opacity\n\t}\n\tif (o.viewport) {\n\t\ttrace.viewport = rect(o.viewport)\n\t}\n\tif (o.diagonal != null) trace.diagonal = o.diagonal\n\tif (o.upper != null) trace.upper = o.upper\n\tif (o.lower != null) trace.lower = o.lower\n\n\t// put flattened data into buffer\n\tif (o.data) {\n\t\ttrace.buffer(flatten(o.data))\n\t\ttrace.columns = o.data.length\n\t\ttrace.count = o.data[0].length\n\n\t\t// detect bounds per-column\n\t\ttrace.bounds = []\n\n\t\tfor (let i = 0; i < trace.columns; i++) {\n\t\t\ttrace.bounds[i] = getBounds(o.data[i], 1)\n\t\t}\n\t}\n\n\t// add proper range updating markers\n\tlet multirange\n\tif (o.range) {\n\t\ttrace.range = o.range\n\t\tmultirange = trace.range && typeof trace.range[0] !== 'number'\n\t}\n\n\tif (o.domain) {\n\t\ttrace.domain = o.domain\n\t}\n\tlet multipadding = false\n\tif (o.padding != null) {\n\t\t// multiple paddings\n\t\tif (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n\t\t\ttrace.padding = o.padding.map(getPad)\n\t\t\tmultipadding = true\n\t\t}\n\t\t// single padding\n\t\telse {\n\t\t\ttrace.padding = getPad(o.padding)\n\t\t}\n\t}\n\n\t// create passes\n\tlet m = trace.columns\n\tlet n = trace.count\n\n\tlet w = trace.viewport.width\n\tlet h = trace.viewport.height\n\tlet left = trace.viewport.x\n\tlet top = trace.viewport.y\n\tlet iw = w / m\n\tlet ih = h / m\n\n\ttrace.passes = []\n\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < m; j++) {\n\t\t\tif (!trace.diagonal && j === i) continue\n\t\t\tif (!trace.upper && i > j) continue\n\t\t\tif (!trace.lower && i < j) continue\n\n\t\t\tlet key = passId(trace.id, i, j)\n\n\t\t\tlet pass = this.passes[key] || (this.passes[key] = {})\n\n\t\t\tif (o.data) {\n\t\t\t\tif (o.transpose) {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j, count: n, stride: m},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i, count: n, stride: m}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j * n, count: n},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i * n, count: n}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpass.bounds = getBox(trace.bounds, i, j)\n\t\t\t}\n\n\t\t\tif (o.domain || o.viewport || o.data) {\n\t\t\t\tlet pad = multipadding ? getBox(trace.padding, i, j) : trace.padding\n\t\t\t\tif (trace.domain) {\n\t\t\t\t\tlet [lox, loy, hix, hiy] = getBox(trace.domain, i, j)\n\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + lox * w + pad[0],\n\t\t\t\t\t\ttop + loy * h + pad[1],\n\t\t\t\t\t\tleft + hix * w - pad[2],\n\t\t\t\t\t\ttop + hiy * h - pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t// consider auto-domain equipartial\n\t\t\t\telse {\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + j * iw + iw * pad[0],\n\t\t\t\t\t\ttop + i * ih + ih * pad[1],\n\t\t\t\t\t\tleft + (j + 1) * iw - iw * pad[2],\n\t\t\t\t\t\ttop + (i + 1) * ih - ih * pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (o.color) pass.color = trace.color\n\t\t\tif (o.size) pass.size = trace.size\n\t\t\tif (o.marker) pass.marker = trace.marker\n\t\t\tif (o.borderSize) pass.borderSize = trace.borderSize\n\t\t\tif (o.borderColor) pass.borderColor = trace.borderColor\n\t\t\tif (o.opacity) pass.opacity = trace.opacity\n\n\t\t\tif (o.range) {\n\t\t\t\tpass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds\n\t\t\t}\n\n\t\t\ttrace.passes.push(key)\n\t\t}\n\t}\n\n\treturn this\n}\n\n\n// draw all or passed passes\nSPLOM.prototype.draw = function (...args) {\n\tif (!args.length) {\n\t\tthis.scatter.draw()\n\t}\n\telse {\n\t\tlet idx = []\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t// draw(0, 2, 5) - draw traces\n\t\t\tif (typeof args[i] === 'number' ) {\n\t\t\t\tlet { passes, passOffset } = this.traces[args[i]]\n\t\t\t\tidx.push(...arrRange(passOffset, passOffset + passes.length))\n\t\t\t}\n\t\t\t// draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n\t\t\telse if (args[i].length) {\n\t\t\t\tlet els = args[i]\n\t\t\t\tlet { passes, passOffset } = this.traces[i]\n\t\t\t\tpasses = passes.map((passId, i) => {\n\t\t\t\t\tidx[passOffset + i] = els\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tthis.scatter.draw(...idx)\n\t}\n\n\treturn this\n}\n\n\n// dispose resources\nSPLOM.prototype.destroy = function () {\n\tthis.traces.forEach(trace => {\n\t\tif (trace.buffer && trace.buffer.destroy) trace.buffer.destroy()\n\t})\n\tthis.traces = null\n\tthis.passes = null\n\n\tthis.scatter.destroy()\n\n\treturn this\n}\n\n\n// return pass corresponding to trace i- j- square\nfunction passId (trace, i, j) {\n\tlet id = (trace.id != null ? trace.id : trace)\n\tlet n = i\n\tlet m = j\n\tlet key = id << 16 | (n & 0xff) << 8 | m & 0xff\n\n\treturn key\n}\n\n\n// return bounding box corresponding to a pass\nfunction getBox (items, i, j) {\n\tlet ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy\n\tlet iitem = items[i], jitem = items[j]\n\n\tif (iitem.length > 2) {\n\t\tilox = iitem[0]\n\t\tihix = iitem[2]\n\t\tiloy = iitem[1]\n\t\tihiy = iitem[3]\n\t}\n\telse if (iitem.length) {\n\t\tilox = iloy = iitem[0]\n\t\tihix = ihiy = iitem[1]\n\t}\n\telse {\n\t\tilox = iitem.x\n\t\tiloy = iitem.y\n\t\tihix = iitem.x + iitem.width\n\t\tihiy = iitem.y + iitem.height\n\t}\n\n\tif (jitem.length > 2) {\n\t\tjlox = jitem[0]\n\t\tjhix = jitem[2]\n\t\tjloy = jitem[1]\n\t\tjhiy = jitem[3]\n\t}\n\telse if (jitem.length) {\n\t\tjlox = jloy = jitem[0]\n\t\tjhix = jhiy = jitem[1]\n\t}\n\telse {\n\t\tjlox = jitem.x\n\t\tjloy = jitem.y\n\t\tjhix = jitem.x + jitem.width\n\t\tjhiy = jitem.y + jitem.height\n\t}\n\n\treturn [ jlox, iloy, jhix, ihiy ]\n}\n\n\nfunction getPad (arg) {\n\tif (typeof arg === 'number') return [arg, arg, arg, arg]\n\telse if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]]\n\telse {\n\t\tlet box = rect(arg)\n\t\treturn [box.x, box.y, box.x + box.width, box.y + box.height]\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}