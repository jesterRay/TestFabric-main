{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar Colorscale = require('../../components/colorscale');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvert = require('../../plots/cartesian/set_convert');\nvar heatmapPlot = require('../heatmap/plot');\nvar makeCrossings = require('./make_crossings');\nvar findAllPaths = require('./find_all_paths');\nvar emptyPathinfo = require('./empty_pathinfo');\nvar convertToConstraints = require('./convert_to_constraints');\nvar closeBoundaries = require('./close_boundaries');\nvar constants = require('./constants');\nvar costConstants = constants.LABELOPTIMIZER;\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var x = cd0.x;\n    var y = cd0.y;\n    var contours = trace.contours;\n    var pathinfo = emptyPathinfo(contours, plotinfo, cd0);\n\n    // use a heatmap to fill - draw it behind the lines\n    var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n    var cdheatmaps = [];\n    if (contours.coloring === 'heatmap') {\n      cdheatmaps = [cd];\n    }\n    heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n    makeCrossings(pathinfo);\n    findAllPaths(pathinfo);\n    var leftedge = xa.c2p(x[0], true);\n    var rightedge = xa.c2p(x[x.length - 1], true);\n    var bottomedge = ya.c2p(y[0], true);\n    var topedge = ya.c2p(y[y.length - 1], true);\n    var perimeter = [[leftedge, topedge], [rightedge, topedge], [rightedge, bottomedge], [leftedge, bottomedge]];\n    var fillPathinfo = pathinfo;\n    if (contours.type === 'constraint') {\n      // N.B. this also mutates pathinfo\n      fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n    }\n\n    // draw everything\n    makeBackground(plotGroup, perimeter, contours);\n    makeFills(plotGroup, fillPathinfo, perimeter, contours);\n    makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours);\n    clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n  });\n};\nfunction makeBackground(plotgroup, perimeter, contours) {\n  var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n  var bgfill = bggroup.selectAll('path').data(contours.coloring === 'fill' ? [0] : []);\n  bgfill.enter().append('path');\n  bgfill.exit().remove();\n  bgfill.attr('d', 'M' + perimeter.join('L') + 'Z').style('stroke', 'none');\n}\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n  var hasFills = contours.coloring === 'fill' || contours.type === 'constraint' && contours._operation !== '=';\n  var boundaryPath = 'M' + perimeter.join('L') + 'Z';\n\n  // fills prefixBoundary in pathinfo items\n  if (hasFills) {\n    closeBoundaries(pathinfo, contours);\n  }\n  var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n  var fillitems = fillgroup.selectAll('path').data(hasFills ? pathinfo : []);\n  fillitems.enter().append('path');\n  fillitems.exit().remove();\n  fillitems.each(function (pi) {\n    // join all paths for this level together into a single path\n    // first follow clockwise around the perimeter to close any open paths\n    // if the whole perimeter is above this level, start with a path\n    // enclosing the whole thing. With all that, the parity should mean\n    // that we always fill everything above the contour, nothing below\n    var fullpath = (pi.prefixBoundary ? boundaryPath : '') + joinAllPaths(pi, perimeter);\n    if (!fullpath) {\n      d3.select(this).remove();\n    } else {\n      d3.select(this).attr('d', fullpath).style('stroke', 'none');\n    }\n  });\n}\nfunction joinAllPaths(pi, perimeter) {\n  var fullpath = '';\n  var i = 0;\n  var startsleft = pi.edgepaths.map(function (v, i) {\n    return i;\n  });\n  var newloop = true;\n  var endpt;\n  var newendpt;\n  var cnt;\n  var nexti;\n  var possiblei;\n  var addpath;\n  function istop(pt) {\n    return Math.abs(pt[1] - perimeter[0][1]) < 0.01;\n  }\n  function isbottom(pt) {\n    return Math.abs(pt[1] - perimeter[2][1]) < 0.01;\n  }\n  function isleft(pt) {\n    return Math.abs(pt[0] - perimeter[0][0]) < 0.01;\n  }\n  function isright(pt) {\n    return Math.abs(pt[0] - perimeter[2][0]) < 0.01;\n  }\n  while (startsleft.length) {\n    addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n    fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n    startsleft.splice(startsleft.indexOf(i), 1);\n    endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n    nexti = -1;\n\n    // now loop through sides, moving our endpoint until we find a new start\n    for (cnt = 0; cnt < 4; cnt++) {\n      // just to prevent infinite loops\n      if (!endpt) {\n        Lib.log('Missing end?', i, pi);\n        break;\n      }\n      if (istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n      else if (isleft(endpt)) newendpt = perimeter[0]; // left top\n      else if (isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n      else if (isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n      for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n        var ptNew = pi.edgepaths[possiblei][0];\n        // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n        if (Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n          if (Math.abs(endpt[0] - ptNew[0]) < 0.01 && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else if (Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n          if (Math.abs(endpt[1] - ptNew[1]) < 0.01 && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else {\n          Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n        }\n      }\n      endpt = newendpt;\n      if (nexti >= 0) break;\n      fullpath += 'L' + newendpt;\n    }\n    if (nexti === pi.edgepaths.length) {\n      Lib.log('unclosed perimeter path');\n      break;\n    }\n    i = nexti;\n\n    // if we closed back on a loop we already included,\n    // close it and start a new loop\n    newloop = startsleft.indexOf(i) === -1;\n    if (newloop) {\n      i = startsleft[0];\n      fullpath += 'Z';\n    }\n  }\n\n  // finally add the interior paths\n  for (i = 0; i < pi.paths.length; i++) {\n    fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n  }\n  return fullpath;\n}\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours) {\n  var isStatic = gd._context.staticPlot;\n  var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n  var showLines = contours.showlines !== false;\n  var showLabels = contours.showlabels;\n  var clipLinesForLabels = showLines && showLabels;\n\n  // Even if we're not going to show lines, we need to create them\n  // if we're showing labels, because the fill paths include the perimeter\n  // so can't be used to position the labels correctly.\n  // In this case we'll remove the lines after making the labels.\n  var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo, isStatic);\n  var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n  var labelGroup = plotgroup.selectAll('g.contourlabels').data(showLabels ? [0] : []);\n  labelGroup.exit().remove();\n  labelGroup.enter().append('g').classed('contourlabels', true);\n  if (showLabels) {\n    var labelClipPathData = [];\n    var labelData = [];\n\n    // invalidate the getTextLocation cache in case paths changed\n    Lib.clearLocationCache();\n    var contourFormat = exports.labelFormatter(gd, cd0);\n    var dummyText = Drawing.tester.append('text').attr('data-notex', 1).call(Drawing.font, contours.labelfont);\n    var xa = pathinfo[0].xaxis;\n    var ya = pathinfo[0].yaxis;\n    var xLen = xa._length;\n    var yLen = ya._length;\n    var xRng = xa.range;\n    var yRng = ya.range;\n    var xMin = Lib.aggNums(Math.min, null, cd0.x);\n    var xMax = Lib.aggNums(Math.max, null, cd0.x);\n    var yMin = Lib.aggNums(Math.min, null, cd0.y);\n    var yMax = Lib.aggNums(Math.max, null, cd0.y);\n    var x0 = Math.max(xa.c2p(xMin, true), 0);\n    var x1 = Math.min(xa.c2p(xMax, true), xLen);\n    var y0 = Math.max(ya.c2p(yMax, true), 0);\n    var y1 = Math.min(ya.c2p(yMin, true), yLen);\n\n    // visible bounds of the contour trace (and the midpoints, to\n    // help with cost calculations)\n    var bounds = {};\n    if (xRng[0] < xRng[1]) {\n      bounds.left = x0;\n      bounds.right = x1;\n    } else {\n      bounds.left = x1;\n      bounds.right = x0;\n    }\n    if (yRng[0] < yRng[1]) {\n      bounds.top = y0;\n      bounds.bottom = y1;\n    } else {\n      bounds.top = y1;\n      bounds.bottom = y0;\n    }\n    bounds.middle = (bounds.top + bounds.bottom) / 2;\n    bounds.center = (bounds.left + bounds.right) / 2;\n    labelClipPathData.push([[bounds.left, bounds.top], [bounds.right, bounds.top], [bounds.right, bounds.bottom], [bounds.left, bounds.bottom]]);\n    var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);\n\n    // the path length to use to scale the number of labels to draw:\n    var normLength = constants.LABELDISTANCE * plotDiagonal / Math.max(1, pathinfo.length / constants.LABELINCREASE);\n    linegroup.each(function (d) {\n      var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n      d3.select(this).selectAll('path').each(function () {\n        var path = this;\n        var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n        if (!pathBounds) return;\n        if (pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n        var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength), constants.LABELMAX);\n        for (var i = 0; i < maxLabels; i++) {\n          var loc = exports.findBestTextLocation(path, pathBounds, textOpts, labelData, bounds);\n          if (!loc) break;\n          exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n        }\n      });\n    });\n    dummyText.remove();\n    exports.drawLabels(labelGroup, labelData, gd, lineClip, clipLinesForLabels ? labelClipPathData : null);\n  }\n  if (showLabels && !showLines) linegroup.remove();\n}\nexports.createLines = function (lineContainer, makeLines, pathinfo, isStatic) {\n  var smoothing = pathinfo[0].smoothing;\n  var linegroup = lineContainer.selectAll('g.contourlevel').data(makeLines ? pathinfo : []);\n  linegroup.exit().remove();\n  linegroup.enter().append('g').classed('contourlevel', true);\n  if (makeLines) {\n    // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n    // edgepaths / paths are used by contour since it's in x/y from the start\n    var opencontourlines = linegroup.selectAll('path.openline').data(function (d) {\n      return d.pedgepaths || d.edgepaths;\n    });\n    opencontourlines.exit().remove();\n    opencontourlines.enter().append('path').classed('openline', true);\n    opencontourlines.attr('d', function (d) {\n      return Drawing.smoothopen(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke');\n    var closedcontourlines = linegroup.selectAll('path.closedline').data(function (d) {\n      return d.ppaths || d.paths;\n    });\n    closedcontourlines.exit().remove();\n    closedcontourlines.enter().append('path').classed('closedline', true);\n    closedcontourlines.attr('d', function (d) {\n      return Drawing.smoothclosed(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke');\n  }\n  return linegroup;\n};\nexports.createLineClip = function (lineContainer, clipLinesForLabels, gd, uid) {\n  var clips = gd._fullLayout._clips;\n  var clipId = clipLinesForLabels ? 'clipline' + uid : null;\n  var lineClip = clips.selectAll('#' + clipId).data(clipLinesForLabels ? [0] : []);\n  lineClip.exit().remove();\n  lineClip.enter().append('clipPath').classed('contourlineclip', true).attr('id', clipId);\n  Drawing.setClipUrl(lineContainer, clipId, gd);\n  return lineClip;\n};\nexports.labelFormatter = function (gd, cd0) {\n  var fullLayout = gd._fullLayout;\n  var trace = cd0.trace;\n  var contours = trace.contours;\n  var formatAxis = {\n    type: 'linear',\n    _id: 'ycontour',\n    showexponent: 'all',\n    exponentformat: 'B'\n  };\n  if (contours.labelformat) {\n    formatAxis.tickformat = contours.labelformat;\n    setConvert(formatAxis, fullLayout);\n  } else {\n    var cOpts = Colorscale.extractOpts(trace);\n    if (cOpts && cOpts.colorbar && cOpts.colorbar._axis) {\n      formatAxis = cOpts.colorbar._axis;\n    } else {\n      if (contours.type === 'constraint') {\n        var value = contours.value;\n        if (Lib.isArrayOrTypedArray(value)) {\n          formatAxis.range = [value[0], value[value.length - 1]];\n        } else formatAxis.range = [value, value];\n      } else {\n        formatAxis.range = [contours.start, contours.end];\n        formatAxis.nticks = (contours.end - contours.start) / contours.size;\n      }\n      if (formatAxis.range[0] === formatAxis.range[1]) {\n        formatAxis.range[1] += formatAxis.range[0] || 1;\n      }\n      if (!formatAxis.nticks) formatAxis.nticks = 1000;\n      setConvert(formatAxis, fullLayout);\n      Axes.prepTicks(formatAxis);\n      formatAxis._tmin = null;\n      formatAxis._tmax = null;\n    }\n  }\n  return function (v) {\n    return Axes.tickText(formatAxis, v).text;\n  };\n};\nexports.calcTextOpts = function (level, contourFormat, dummyText, gd) {\n  var text = contourFormat(level);\n  dummyText.text(text).call(svgTextUtils.convertToTspans, gd);\n  var el = dummyText.node();\n  var bBox = Drawing.bBox(el, true);\n  return {\n    text: text,\n    width: bBox.width,\n    height: bBox.height,\n    fontSize: +el.style['font-size'].replace('px', ''),\n    level: level,\n    dy: (bBox.top + bBox.bottom) / 2\n  };\n};\nexports.findBestTextLocation = function (path, pathBounds, textOpts, labelData, plotBounds) {\n  var textWidth = textOpts.width;\n  var p0, dp, pMax, pMin, loc;\n  if (pathBounds.isClosed) {\n    dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n    p0 = pathBounds.min + dp / 2;\n    pMax = pathBounds.max;\n  } else {\n    dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n    p0 = pathBounds.min + dp + textWidth / 2;\n    pMax = pathBounds.max - (dp + textWidth) / 2;\n  }\n  var cost = Infinity;\n  for (var j = 0; j < costConstants.ITERATIONS; j++) {\n    for (var p = p0; p < pMax; p += dp) {\n      var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n      var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n      if (newCost < cost) {\n        cost = newCost;\n        loc = newLocation;\n        pMin = p;\n      }\n    }\n    if (cost > costConstants.MAXCOST * 2) break;\n\n    // subsequent iterations just look half steps away from the\n    // best we found in the previous iteration\n    if (j) dp /= 2;\n    p0 = pMin - dp / 2;\n    pMax = p0 + dp * 1.5;\n  }\n  if (cost <= costConstants.MAXCOST) return loc;\n};\n\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\nfunction locationCost(loc, textOpts, labelData, bounds) {\n  var halfWidth = textOpts.width / 2;\n  var halfHeight = textOpts.height / 2;\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var dx = Math.cos(theta) * halfWidth;\n  var dy = Math.sin(theta) * halfWidth;\n\n  // cost for being near an edge\n  var normX = (x > bounds.center ? bounds.right - x : x - bounds.left) / (dx + Math.abs(Math.sin(theta) * halfHeight));\n  var normY = (y > bounds.middle ? bounds.bottom - y : y - bounds.top) / (Math.abs(dy) + Math.cos(theta) * halfHeight);\n  if (normX < 1 || normY < 1) return Infinity;\n  var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));\n\n  // cost for not being horizontal\n  cost += costConstants.ANGLECOST * theta * theta;\n\n  // cost for being close to other labels\n  var x1 = x - dx;\n  var y1 = y - dy;\n  var x2 = x + dx;\n  var y2 = y + dy;\n  for (var i = 0; i < labelData.length; i++) {\n    var labeli = labelData[i];\n    var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n    var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n    var dist = Lib.segmentDistance(x1, y1, x2, y2, labeli.x - dxd, labeli.y - dyd, labeli.x + dxd, labeli.y + dyd) * 2 / (textOpts.height + labeli.height);\n    var sameLevel = labeli.level === textOpts.level;\n    var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n    if (dist <= distOffset) return Infinity;\n    var distFactor = costConstants.NEIGHBORCOST * (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n    cost += distFactor / (dist - distOffset);\n  }\n  return cost;\n}\nexports.addLabelData = function (loc, textOpts, labelData, labelClipPathData) {\n  var fontSize = textOpts.fontSize;\n  var w = textOpts.width + fontSize / 3;\n  var h = Math.max(0, textOpts.height - fontSize / 3);\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var sin = Math.sin(theta);\n  var cos = Math.cos(theta);\n  var rotateXY = function (dx, dy) {\n    return [x + dx * cos - dy * sin, y + dx * sin + dy * cos];\n  };\n  var bBoxPts = [rotateXY(-w / 2, -h / 2), rotateXY(-w / 2, h / 2), rotateXY(w / 2, h / 2), rotateXY(w / 2, -h / 2)];\n  labelData.push({\n    text: textOpts.text,\n    x: x,\n    y: y,\n    dy: textOpts.dy,\n    theta: theta,\n    level: textOpts.level,\n    width: w,\n    height: h\n  });\n  labelClipPathData.push(bBoxPts);\n};\nexports.drawLabels = function (labelGroup, labelData, gd, lineClip, labelClipPathData) {\n  var labels = labelGroup.selectAll('text').data(labelData, function (d) {\n    return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n  });\n  labels.exit().remove();\n  labels.enter().append('text').attr({\n    'data-notex': 1,\n    'text-anchor': 'middle'\n  }).each(function (d) {\n    var x = d.x + Math.sin(d.theta) * d.dy;\n    var y = d.y - Math.cos(d.theta) * d.dy;\n    d3.select(this).text(d.text).attr({\n      x: x,\n      y: y,\n      transform: 'rotate(' + 180 * d.theta / Math.PI + ' ' + x + ' ' + y + ')'\n    }).call(svgTextUtils.convertToTspans, gd);\n  });\n  if (labelClipPathData) {\n    var clipPath = '';\n    for (var i = 0; i < labelClipPathData.length; i++) {\n      clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n    }\n    var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n    lineClipPath.attr('d', clipPath);\n  }\n};\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n  var trace = cd0.trace;\n  var clips = gd._fullLayout._clips;\n  var clipId = 'clip' + trace.uid;\n  var clipPath = clips.selectAll('#' + clipId).data(trace.connectgaps ? [] : [0]);\n  clipPath.enter().append('clipPath').classed('contourclip', true).attr('id', clipId);\n  clipPath.exit().remove();\n  if (trace.connectgaps === false) {\n    var clipPathInfo = {\n      // fraction of the way from missing to present point\n      // to draw the boundary.\n      // if you make this 1 (or 1-epsilon) then a point in\n      // a sea of missing data will disappear entirely.\n      level: 0.9,\n      crossings: {},\n      starts: [],\n      edgepaths: [],\n      paths: [],\n      xaxis: plotinfo.xaxis,\n      yaxis: plotinfo.yaxis,\n      x: cd0.x,\n      y: cd0.y,\n      // 0 = no data, 1 = data\n      z: makeClipMask(cd0),\n      smoothing: 0\n    };\n    makeCrossings([clipPathInfo]);\n    findAllPaths([clipPathInfo]);\n    closeBoundaries([clipPathInfo], {\n      type: 'levels'\n    });\n    var path = Lib.ensureSingle(clipPath, 'path', '');\n    path.attr('d', (clipPathInfo.prefixBoundary ? 'M' + perimeter.join('L') + 'Z' : '') + joinAllPaths(clipPathInfo, perimeter));\n  } else clipId = null;\n  Drawing.setClipUrl(plotGroup, clipId, gd);\n}\nfunction makeClipMask(cd0) {\n  var empties = cd0.trace._emptypoints;\n  var z = [];\n  var m = cd0.z.length;\n  var n = cd0.z[0].length;\n  var i;\n  var row = [];\n  var emptyPoint;\n  for (i = 0; i < n; i++) row.push(1);\n  for (i = 0; i < m; i++) z.push(row.slice());\n  for (i = 0; i < empties.length; i++) {\n    emptyPoint = empties[i];\n    z[emptyPoint[0]][emptyPoint[1]] = 0;\n  }\n  // save this mask to determine whether to show this data in hover\n  cd0.zmask = z;\n  return z;\n}","map":{"version":3,"names":["d3","require","Lib","Drawing","Colorscale","svgTextUtils","Axes","setConvert","heatmapPlot","makeCrossings","findAllPaths","emptyPathinfo","convertToConstraints","closeBoundaries","constants","costConstants","LABELOPTIMIZER","exports","plot","gd","plotinfo","cdcontours","contourLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","trace","x","y","contours","pathinfo","heatmapColoringLayer","ensureSingle","cdheatmaps","coloring","leftedge","c2p","rightedge","length","bottomedge","topedge","perimeter","fillPathinfo","type","_operation","makeBackground","makeFills","makeLinesAndLabels","clipGaps","plotgroup","bggroup","bgfill","selectAll","data","enter","append","exit","remove","attr","join","style","hasFills","boundaryPath","fillgroup","fillitems","pi","fullpath","prefixBoundary","joinAllPaths","i","startsleft","edgepaths","map","v","newloop","endpt","newendpt","cnt","nexti","possiblei","addpath","istop","pt","Math","abs","isbottom","isleft","isright","smoothopen","smoothing","replace","splice","indexOf","log","ptNew","paths","smoothclosed","isStatic","_context","staticPlot","lineContainer","showLines","showlines","showLabels","showlabels","clipLinesForLabels","linegroup","createLines","lineClip","createLineClip","uid","labelGroup","classed","labelClipPathData","labelData","clearLocationCache","contourFormat","labelFormatter","dummyText","tester","call","font","labelfont","xLen","_length","yLen","xRng","range","yRng","xMin","aggNums","min","xMax","max","yMin","yMax","x0","x1","y0","y1","bounds","left","right","top","bottom","middle","center","push","plotDiagonal","sqrt","normLength","LABELDISTANCE","LABELINCREASE","d","textOpts","calcTextOpts","level","path","pathBounds","getVisibleSegment","height","len","width","LABELMIN","maxLabels","ceil","LABELMAX","loc","findBestTextLocation","addLabelData","drawLabels","makeLines","opencontourlines","pedgepaths","closedcontourlines","ppaths","clips","_fullLayout","_clips","clipId","setClipUrl","fullLayout","formatAxis","_id","showexponent","exponentformat","labelformat","tickformat","cOpts","extractOpts","colorbar","_axis","value","isArrayOrTypedArray","start","end","nticks","size","prepTicks","_tmin","_tmax","tickText","text","convertToTspans","el","node","bBox","fontSize","dy","plotBounds","textWidth","p0","dp","pMax","pMin","isClosed","INITIALSEARCHPOINTS","cost","Infinity","j","ITERATIONS","p","newLocation","getTextLocation","total","newCost","locationCost","MAXCOST","halfWidth","halfHeight","theta","dx","cos","sin","normX","normY","EDGECOST","ANGLECOST","x2","y2","labeli","dxd","dyd","dist","segmentDistance","sameLevel","distOffset","SAMELEVELDISTANCE","distFactor","NEIGHBORCOST","SAMELEVELFACTOR","w","h","rotateXY","bBoxPts","labels","transform","PI","clipPath","lineClipPath","connectgaps","clipPathInfo","crossings","starts","z","makeClipMask","empties","_emptypoints","m","n","row","emptyPoint","slice","zmask"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/contour/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar Colorscale = require('../../components/colorscale');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvert = require('../../plots/cartesian/set_convert');\n\nvar heatmapPlot = require('../heatmap/plot');\nvar makeCrossings = require('./make_crossings');\nvar findAllPaths = require('./find_all_paths');\nvar emptyPathinfo = require('./empty_pathinfo');\nvar convertToConstraints = require('./convert_to_constraints');\nvar closeBoundaries = require('./close_boundaries');\nvar constants = require('./constants');\nvar costConstants = constants.LABELOPTIMIZER;\n\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var x = cd0.x;\n        var y = cd0.y;\n        var contours = trace.contours;\n        var pathinfo = emptyPathinfo(contours, plotinfo, cd0);\n\n        // use a heatmap to fill - draw it behind the lines\n        var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n        var cdheatmaps = [];\n        if(contours.coloring === 'heatmap') {\n            cdheatmaps = [cd];\n        }\n        heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n\n        makeCrossings(pathinfo);\n        findAllPaths(pathinfo);\n\n        var leftedge = xa.c2p(x[0], true);\n        var rightedge = xa.c2p(x[x.length - 1], true);\n        var bottomedge = ya.c2p(y[0], true);\n        var topedge = ya.c2p(y[y.length - 1], true);\n        var perimeter = [\n            [leftedge, topedge],\n            [rightedge, topedge],\n            [rightedge, bottomedge],\n            [leftedge, bottomedge]\n        ];\n\n        var fillPathinfo = pathinfo;\n        if(contours.type === 'constraint') {\n            // N.B. this also mutates pathinfo\n            fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n        }\n\n        // draw everything\n        makeBackground(plotGroup, perimeter, contours);\n        makeFills(plotGroup, fillPathinfo, perimeter, contours);\n        makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours);\n        clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n    });\n};\n\nfunction makeBackground(plotgroup, perimeter, contours) {\n    var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n\n    var bgfill = bggroup.selectAll('path')\n        .data(contours.coloring === 'fill' ? [0] : []);\n    bgfill.enter().append('path');\n    bgfill.exit().remove();\n    bgfill\n        .attr('d', 'M' + perimeter.join('L') + 'Z')\n        .style('stroke', 'none');\n}\n\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n    var hasFills = contours.coloring === 'fill' || (contours.type === 'constraint' && contours._operation !== '=');\n    var boundaryPath = 'M' + perimeter.join('L') + 'Z';\n\n    // fills prefixBoundary in pathinfo items\n    if(hasFills) {\n        closeBoundaries(pathinfo, contours);\n    }\n\n    var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n\n    var fillitems = fillgroup.selectAll('path').data(hasFills ? pathinfo : []);\n    fillitems.enter().append('path');\n    fillitems.exit().remove();\n    fillitems.each(function(pi) {\n        // join all paths for this level together into a single path\n        // first follow clockwise around the perimeter to close any open paths\n        // if the whole perimeter is above this level, start with a path\n        // enclosing the whole thing. With all that, the parity should mean\n        // that we always fill everything above the contour, nothing below\n        var fullpath = (pi.prefixBoundary ? boundaryPath : '') +\n            joinAllPaths(pi, perimeter);\n\n        if(!fullpath) {\n            d3.select(this).remove();\n        } else {\n            d3.select(this)\n                .attr('d', fullpath)\n                .style('stroke', 'none');\n        }\n    });\n}\n\nfunction joinAllPaths(pi, perimeter) {\n    var fullpath = '';\n    var i = 0;\n    var startsleft = pi.edgepaths.map(function(v, i) { return i; });\n    var newloop = true;\n    var endpt;\n    var newendpt;\n    var cnt;\n    var nexti;\n    var possiblei;\n    var addpath;\n\n    function istop(pt) { return Math.abs(pt[1] - perimeter[0][1]) < 0.01; }\n    function isbottom(pt) { return Math.abs(pt[1] - perimeter[2][1]) < 0.01; }\n    function isleft(pt) { return Math.abs(pt[0] - perimeter[0][0]) < 0.01; }\n    function isright(pt) { return Math.abs(pt[0] - perimeter[2][0]) < 0.01; }\n\n    while(startsleft.length) {\n        addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n        fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n        startsleft.splice(startsleft.indexOf(i), 1);\n        endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n        nexti = -1;\n\n        // now loop through sides, moving our endpoint until we find a new start\n        for(cnt = 0; cnt < 4; cnt++) { // just to prevent infinite loops\n            if(!endpt) {\n                Lib.log('Missing end?', i, pi);\n                break;\n            }\n\n            if(istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n            else if(isleft(endpt)) newendpt = perimeter[0]; // left top\n            else if(isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n            else if(isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n            for(possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n                var ptNew = pi.edgepaths[possiblei][0];\n                // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n                if(Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n                    if(Math.abs(endpt[0] - ptNew[0]) < 0.01 &&\n                            (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else if(Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n                    if(Math.abs(endpt[1] - ptNew[1]) < 0.01 &&\n                            (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else {\n                    Lib.log('endpt to newendpt is not vert. or horz.',\n                        endpt, newendpt, ptNew);\n                }\n            }\n\n            endpt = newendpt;\n\n            if(nexti >= 0) break;\n            fullpath += 'L' + newendpt;\n        }\n\n        if(nexti === pi.edgepaths.length) {\n            Lib.log('unclosed perimeter path');\n            break;\n        }\n\n        i = nexti;\n\n        // if we closed back on a loop we already included,\n        // close it and start a new loop\n        newloop = (startsleft.indexOf(i) === -1);\n        if(newloop) {\n            i = startsleft[0];\n            fullpath += 'Z';\n        }\n    }\n\n    // finally add the interior paths\n    for(i = 0; i < pi.paths.length; i++) {\n        fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n    }\n\n    return fullpath;\n}\n\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours) {\n    var isStatic = gd._context.staticPlot;\n    var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n    var showLines = contours.showlines !== false;\n    var showLabels = contours.showlabels;\n    var clipLinesForLabels = showLines && showLabels;\n\n    // Even if we're not going to show lines, we need to create them\n    // if we're showing labels, because the fill paths include the perimeter\n    // so can't be used to position the labels correctly.\n    // In this case we'll remove the lines after making the labels.\n    var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo, isStatic);\n\n    var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n\n    var labelGroup = plotgroup.selectAll('g.contourlabels')\n        .data(showLabels ? [0] : []);\n\n    labelGroup.exit().remove();\n\n    labelGroup.enter().append('g')\n        .classed('contourlabels', true);\n\n    if(showLabels) {\n        var labelClipPathData = [];\n        var labelData = [];\n\n        // invalidate the getTextLocation cache in case paths changed\n        Lib.clearLocationCache();\n\n        var contourFormat = exports.labelFormatter(gd, cd0);\n\n        var dummyText = Drawing.tester.append('text')\n            .attr('data-notex', 1)\n            .call(Drawing.font, contours.labelfont);\n\n        var xa = pathinfo[0].xaxis;\n        var ya = pathinfo[0].yaxis;\n        var xLen = xa._length;\n        var yLen = ya._length;\n        var xRng = xa.range;\n        var yRng = ya.range;\n        var xMin = Lib.aggNums(Math.min, null, cd0.x);\n        var xMax = Lib.aggNums(Math.max, null, cd0.x);\n        var yMin = Lib.aggNums(Math.min, null, cd0.y);\n        var yMax = Lib.aggNums(Math.max, null, cd0.y);\n        var x0 = Math.max(xa.c2p(xMin, true), 0);\n        var x1 = Math.min(xa.c2p(xMax, true), xLen);\n        var y0 = Math.max(ya.c2p(yMax, true), 0);\n        var y1 = Math.min(ya.c2p(yMin, true), yLen);\n\n        // visible bounds of the contour trace (and the midpoints, to\n        // help with cost calculations)\n        var bounds = {};\n\n        if(xRng[0] < xRng[1]) {\n            bounds.left = x0;\n            bounds.right = x1;\n        } else {\n            bounds.left = x1;\n            bounds.right = x0;\n        }\n\n        if(yRng[0] < yRng[1]) {\n            bounds.top = y0;\n            bounds.bottom = y1;\n        } else {\n            bounds.top = y1;\n            bounds.bottom = y0;\n        }\n\n        bounds.middle = (bounds.top + bounds.bottom) / 2;\n        bounds.center = (bounds.left + bounds.right) / 2;\n\n        labelClipPathData.push([\n            [bounds.left, bounds.top],\n            [bounds.right, bounds.top],\n            [bounds.right, bounds.bottom],\n            [bounds.left, bounds.bottom]\n        ]);\n\n        var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);\n\n        // the path length to use to scale the number of labels to draw:\n        var normLength = constants.LABELDISTANCE * plotDiagonal /\n            Math.max(1, pathinfo.length / constants.LABELINCREASE);\n\n        linegroup.each(function(d) {\n            var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n\n            d3.select(this).selectAll('path').each(function() {\n                var path = this;\n                var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n                if(!pathBounds) return;\n\n                if(pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n\n                var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength),\n                    constants.LABELMAX);\n\n                for(var i = 0; i < maxLabels; i++) {\n                    var loc = exports.findBestTextLocation(path, pathBounds, textOpts,\n                        labelData, bounds);\n\n                    if(!loc) break;\n\n                    exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n                }\n            });\n        });\n\n        dummyText.remove();\n\n        exports.drawLabels(labelGroup, labelData, gd, lineClip,\n            clipLinesForLabels ? labelClipPathData : null);\n    }\n\n    if(showLabels && !showLines) linegroup.remove();\n}\n\nexports.createLines = function(lineContainer, makeLines, pathinfo, isStatic) {\n    var smoothing = pathinfo[0].smoothing;\n\n    var linegroup = lineContainer.selectAll('g.contourlevel')\n        .data(makeLines ? pathinfo : []);\n\n    linegroup.exit().remove();\n    linegroup.enter().append('g')\n        .classed('contourlevel', true);\n\n    if(makeLines) {\n        // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n        // edgepaths / paths are used by contour since it's in x/y from the start\n        var opencontourlines = linegroup.selectAll('path.openline')\n            .data(function(d) { return d.pedgepaths || d.edgepaths; });\n\n        opencontourlines.exit().remove();\n        opencontourlines.enter().append('path')\n            .classed('openline', true);\n\n        opencontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothopen(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke');\n\n        var closedcontourlines = linegroup.selectAll('path.closedline')\n            .data(function(d) { return d.ppaths || d.paths; });\n\n        closedcontourlines.exit().remove();\n        closedcontourlines.enter().append('path')\n            .classed('closedline', true);\n\n        closedcontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothclosed(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke');\n    }\n\n    return linegroup;\n};\n\nexports.createLineClip = function(lineContainer, clipLinesForLabels, gd, uid) {\n    var clips = gd._fullLayout._clips;\n    var clipId = clipLinesForLabels ? ('clipline' + uid) : null;\n\n    var lineClip = clips.selectAll('#' + clipId)\n        .data(clipLinesForLabels ? [0] : []);\n    lineClip.exit().remove();\n\n    lineClip.enter().append('clipPath')\n        .classed('contourlineclip', true)\n        .attr('id', clipId);\n\n    Drawing.setClipUrl(lineContainer, clipId, gd);\n\n    return lineClip;\n};\n\nexports.labelFormatter = function(gd, cd0) {\n    var fullLayout = gd._fullLayout;\n    var trace = cd0.trace;\n    var contours = trace.contours;\n\n    var formatAxis = {\n        type: 'linear',\n        _id: 'ycontour',\n        showexponent: 'all',\n        exponentformat: 'B'\n    };\n\n    if(contours.labelformat) {\n        formatAxis.tickformat = contours.labelformat;\n        setConvert(formatAxis, fullLayout);\n    } else {\n        var cOpts = Colorscale.extractOpts(trace);\n        if(cOpts && cOpts.colorbar && cOpts.colorbar._axis) {\n            formatAxis = cOpts.colorbar._axis;\n        } else {\n            if(contours.type === 'constraint') {\n                var value = contours.value;\n                if(Lib.isArrayOrTypedArray(value)) {\n                    formatAxis.range = [value[0], value[value.length - 1]];\n                } else formatAxis.range = [value, value];\n            } else {\n                formatAxis.range = [contours.start, contours.end];\n                formatAxis.nticks = (contours.end - contours.start) / contours.size;\n            }\n\n            if(formatAxis.range[0] === formatAxis.range[1]) {\n                formatAxis.range[1] += formatAxis.range[0] || 1;\n            }\n            if(!formatAxis.nticks) formatAxis.nticks = 1000;\n\n            setConvert(formatAxis, fullLayout);\n            Axes.prepTicks(formatAxis);\n            formatAxis._tmin = null;\n            formatAxis._tmax = null;\n        }\n    }\n\n    return function(v) { return Axes.tickText(formatAxis, v).text; };\n};\n\nexports.calcTextOpts = function(level, contourFormat, dummyText, gd) {\n    var text = contourFormat(level);\n    dummyText.text(text)\n        .call(svgTextUtils.convertToTspans, gd);\n\n    var el = dummyText.node();\n    var bBox = Drawing.bBox(el, true);\n\n    return {\n        text: text,\n        width: bBox.width,\n        height: bBox.height,\n        fontSize: +(el.style['font-size'].replace('px', '')),\n        level: level,\n        dy: (bBox.top + bBox.bottom) / 2\n    };\n};\n\nexports.findBestTextLocation = function(path, pathBounds, textOpts, labelData, plotBounds) {\n    var textWidth = textOpts.width;\n\n    var p0, dp, pMax, pMin, loc;\n    if(pathBounds.isClosed) {\n        dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n        p0 = pathBounds.min + dp / 2;\n        pMax = pathBounds.max;\n    } else {\n        dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n        p0 = pathBounds.min + dp + textWidth / 2;\n        pMax = pathBounds.max - (dp + textWidth) / 2;\n    }\n\n    var cost = Infinity;\n    for(var j = 0; j < costConstants.ITERATIONS; j++) {\n        for(var p = p0; p < pMax; p += dp) {\n            var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n            var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n            if(newCost < cost) {\n                cost = newCost;\n                loc = newLocation;\n                pMin = p;\n            }\n        }\n        if(cost > costConstants.MAXCOST * 2) break;\n\n        // subsequent iterations just look half steps away from the\n        // best we found in the previous iteration\n        if(j) dp /= 2;\n        p0 = pMin - dp / 2;\n        pMax = p0 + dp * 1.5;\n    }\n    if(cost <= costConstants.MAXCOST) return loc;\n};\n\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\nfunction locationCost(loc, textOpts, labelData, bounds) {\n    var halfWidth = textOpts.width / 2;\n    var halfHeight = textOpts.height / 2;\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n    var dx = Math.cos(theta) * halfWidth;\n    var dy = Math.sin(theta) * halfWidth;\n\n    // cost for being near an edge\n    var normX = ((x > bounds.center) ? (bounds.right - x) : (x - bounds.left)) /\n        (dx + Math.abs(Math.sin(theta) * halfHeight));\n    var normY = ((y > bounds.middle) ? (bounds.bottom - y) : (y - bounds.top)) /\n        (Math.abs(dy) + Math.cos(theta) * halfHeight);\n    if(normX < 1 || normY < 1) return Infinity;\n    var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));\n\n    // cost for not being horizontal\n    cost += costConstants.ANGLECOST * theta * theta;\n\n    // cost for being close to other labels\n    var x1 = x - dx;\n    var y1 = y - dy;\n    var x2 = x + dx;\n    var y2 = y + dy;\n    for(var i = 0; i < labelData.length; i++) {\n        var labeli = labelData[i];\n        var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n        var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n        var dist = Lib.segmentDistance(\n            x1, y1,\n            x2, y2,\n            labeli.x - dxd, labeli.y - dyd,\n            labeli.x + dxd, labeli.y + dyd\n        ) * 2 / (textOpts.height + labeli.height);\n\n        var sameLevel = labeli.level === textOpts.level;\n        var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n\n        if(dist <= distOffset) return Infinity;\n\n        var distFactor = costConstants.NEIGHBORCOST *\n            (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n\n        cost += distFactor / (dist - distOffset);\n    }\n\n    return cost;\n}\n\nexports.addLabelData = function(loc, textOpts, labelData, labelClipPathData) {\n    var fontSize = textOpts.fontSize;\n    var w = textOpts.width + fontSize / 3;\n    var h = Math.max(0, textOpts.height - fontSize / 3);\n\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n\n    var sin = Math.sin(theta);\n    var cos = Math.cos(theta);\n\n    var rotateXY = function(dx, dy) {\n        return [\n            x + dx * cos - dy * sin,\n            y + dx * sin + dy * cos\n        ];\n    };\n\n    var bBoxPts = [\n        rotateXY(-w / 2, -h / 2),\n        rotateXY(-w / 2, h / 2),\n        rotateXY(w / 2, h / 2),\n        rotateXY(w / 2, -h / 2)\n    ];\n\n    labelData.push({\n        text: textOpts.text,\n        x: x,\n        y: y,\n        dy: textOpts.dy,\n        theta: theta,\n        level: textOpts.level,\n        width: w,\n        height: h\n    });\n\n    labelClipPathData.push(bBoxPts);\n};\n\nexports.drawLabels = function(labelGroup, labelData, gd, lineClip, labelClipPathData) {\n    var labels = labelGroup.selectAll('text')\n        .data(labelData, function(d) {\n            return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n        });\n\n    labels.exit().remove();\n\n    labels.enter().append('text')\n        .attr({\n            'data-notex': 1,\n            'text-anchor': 'middle'\n        })\n        .each(function(d) {\n            var x = d.x + Math.sin(d.theta) * d.dy;\n            var y = d.y - Math.cos(d.theta) * d.dy;\n            d3.select(this)\n                .text(d.text)\n                .attr({\n                    x: x,\n                    y: y,\n                    transform: 'rotate(' + (180 * d.theta / Math.PI) + ' ' + x + ' ' + y + ')'\n                })\n                .call(svgTextUtils.convertToTspans, gd);\n        });\n\n    if(labelClipPathData) {\n        var clipPath = '';\n        for(var i = 0; i < labelClipPathData.length; i++) {\n            clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n        }\n\n        var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n        lineClipPath.attr('d', clipPath);\n    }\n};\n\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n    var trace = cd0.trace;\n    var clips = gd._fullLayout._clips;\n    var clipId = 'clip' + trace.uid;\n\n    var clipPath = clips.selectAll('#' + clipId)\n        .data(trace.connectgaps ? [] : [0]);\n    clipPath.enter().append('clipPath')\n        .classed('contourclip', true)\n        .attr('id', clipId);\n    clipPath.exit().remove();\n\n    if(trace.connectgaps === false) {\n        var clipPathInfo = {\n            // fraction of the way from missing to present point\n            // to draw the boundary.\n            // if you make this 1 (or 1-epsilon) then a point in\n            // a sea of missing data will disappear entirely.\n            level: 0.9,\n            crossings: {},\n            starts: [],\n            edgepaths: [],\n            paths: [],\n            xaxis: plotinfo.xaxis,\n            yaxis: plotinfo.yaxis,\n            x: cd0.x,\n            y: cd0.y,\n            // 0 = no data, 1 = data\n            z: makeClipMask(cd0),\n            smoothing: 0\n        };\n\n        makeCrossings([clipPathInfo]);\n        findAllPaths([clipPathInfo]);\n        closeBoundaries([clipPathInfo], {type: 'levels'});\n\n        var path = Lib.ensureSingle(clipPath, 'path', '');\n        path.attr('d',\n            (clipPathInfo.prefixBoundary ? 'M' + perimeter.join('L') + 'Z' : '') +\n            joinAllPaths(clipPathInfo, perimeter)\n        );\n    } else clipId = null;\n\n    Drawing.setClipUrl(plotGroup, clipId, gd);\n}\n\nfunction makeClipMask(cd0) {\n    var empties = cd0.trace._emptypoints;\n    var z = [];\n    var m = cd0.z.length;\n    var n = cd0.z[0].length;\n    var i;\n    var row = [];\n    var emptyPoint;\n\n    for(i = 0; i < n; i++) row.push(1);\n    for(i = 0; i < m; i++) z.push(row.slice());\n    for(i = 0; i < empties.length; i++) {\n        emptyPoint = empties[i];\n        z[emptyPoint[0]][emptyPoint[1]] = 0;\n    }\n    // save this mask to determine whether to show this data in hover\n    cd0.zmask = z;\n    return z;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}