{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Template = require('../../plot_api/plot_template');\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\nvar handlePrefixSuffixDefaults = require('../cartesian/prefix_suffix_defaults');\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\nvar handleAutorangeOptionsDefaults = require('../cartesian/autorange_options_defaults');\nvar autoType = require('../cartesian/axis_autotype');\nvar layoutAttributes = require('./layout_attributes');\nvar setConvert = require('./set_convert');\nvar constants = require('./constants');\nvar axisNames = constants.axisNames;\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n  var bgColor = coerce('bgcolor');\n  opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n  var sector = coerce('sector');\n  coerce('hole');\n\n  // could optimize, subplotData is not always needed!\n  var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n  var layoutOut = opts.layoutOut;\n  var axName;\n  function coerceAxis(attr, dflt) {\n    return coerce(axName + '.' + attr, dflt);\n  }\n  for (var i = 0; i < axisNames.length; i++) {\n    axName = axisNames[i];\n    if (!Lib.isPlainObject(contIn[axName])) {\n      contIn[axName] = {};\n    }\n    var axIn = contIn[axName];\n    var axOut = Template.newContainer(contOut, axName);\n    axOut._id = axOut._name = axName;\n    axOut._attr = opts.id + '.' + axName;\n    axOut._traceIndices = subplotData.map(function (t) {\n      return t._expandedIndex;\n    });\n    var dataAttr = constants.axisName2dataArray[axName];\n    var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr, opts);\n    handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n      axData: subplotData,\n      dataAttr: dataAttr\n    });\n    var visible = coerceAxis('visible');\n    setConvert(axOut, contOut, layoutOut);\n    coerceAxis('uirevision', contOut.uirevision);\n\n    // We don't want to make downstream code call ax.setScale,\n    // as both radial and angular axes don't have a set domain.\n    // Furthermore, angular axes don't have a set range.\n    //\n    // Mocked domains and ranges are set by the polar subplot instances,\n    // but Axes.findExtremes uses the sign of _m to determine which padding value\n    // to use.\n    //\n    // By setting, _m to 1 here, we make Axes.findExtremes think that\n    // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n    axOut._m = 1;\n    switch (axName) {\n      case 'radialaxis':\n        coerceAxis('minallowed');\n        coerceAxis('maxallowed');\n        var range = coerceAxis('range');\n        var autorangeDflt = axOut.getAutorangeDflt(range);\n        var autorange = coerceAxis('autorange', autorangeDflt);\n        var shouldAutorange;\n\n        // validate range and set autorange true for invalid partial ranges\n        if (range && (range[0] === null && range[1] === null || (range[0] === null || range[1] === null) && (autorange === 'reversed' || autorange === true) || range[0] !== null && (autorange === 'min' || autorange === 'max reversed') || range[1] !== null && (autorange === 'max' || autorange === 'min reversed'))) {\n          range = undefined;\n          delete axOut.range;\n          axOut.autorange = true;\n          shouldAutorange = true;\n        }\n        if (!shouldAutorange) {\n          autorangeDflt = axOut.getAutorangeDflt(range);\n          autorange = coerceAxis('autorange', autorangeDflt);\n        }\n        axIn.autorange = autorange;\n        if (autorange) {\n          handleAutorangeOptionsDefaults(coerceAxis, autorange, range);\n          if (axType === 'linear' || axType === '-') coerceAxis('rangemode');\n          if (axOut.isReversed()) axOut._m = -1;\n        }\n        axOut.cleanRange('range', {\n          dfltRange: [0, 1]\n        });\n        break;\n      case 'angularaxis':\n        // We do not support 'true' date angular axes yet,\n        // users can still plot dates on angular axes by setting\n        // `angularaxis.type: 'category'`.\n        //\n        // Here, if a date angular axes is detected, we make\n        // all its corresponding traces invisible, so that\n        // when we do add support for data angular axes, the new\n        // behavior won't conflict with existing behavior\n        if (axType === 'date') {\n          Lib.log('Polar plots do not support date angular axes yet.');\n          for (var j = 0; j < subplotData.length; j++) {\n            subplotData[j].visible = false;\n          }\n\n          // turn this into a 'dummy' linear axis so that\n          // the subplot still renders ok\n          axType = axIn.type = axOut.type = 'linear';\n        }\n        if (axType === 'linear') {\n          coerceAxis('thetaunit');\n        } else {\n          coerceAxis('period');\n        }\n        var direction = coerceAxis('direction');\n        coerceAxis('rotation', {\n          counterclockwise: 0,\n          clockwise: 90\n        }[direction]);\n        break;\n    }\n    handlePrefixSuffixDefaults(axIn, axOut, coerceAxis, axOut.type, {\n      tickSuffixDflt: axOut.thetaunit === 'degrees' ? 'Â°' : undefined\n    });\n    if (visible) {\n      var dfltColor;\n      var dfltFontColor;\n      var dfltFontSize;\n      var dfltFontFamily;\n      var dfltFontWeight;\n      var dfltFontStyle;\n      var dfltFontVariant;\n      var dfltFontTextcase;\n      var dfltFontLineposition;\n      var dfltFontShadow;\n      var font = opts.font || {};\n      dfltColor = coerceAxis('color');\n      dfltFontColor = dfltColor === axIn.color ? dfltColor : font.color;\n      dfltFontSize = font.size;\n      dfltFontFamily = font.family;\n      dfltFontWeight = font.weight;\n      dfltFontStyle = font.style;\n      dfltFontVariant = font.variant;\n      dfltFontTextcase = font.textcase;\n      dfltFontLineposition = font.lineposition;\n      dfltFontShadow = font.shadow;\n      handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n      handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n        font: {\n          weight: dfltFontWeight,\n          style: dfltFontStyle,\n          variant: dfltFontVariant,\n          textcase: dfltFontTextcase,\n          lineposition: dfltFontLineposition,\n          shadow: dfltFontShadow,\n          color: dfltFontColor,\n          size: dfltFontSize,\n          family: dfltFontFamily\n        },\n        noAutotickangles: axName === 'angularaxis',\n        noTicklabelshift: true,\n        noTicklabelstandoff: true\n      });\n      handleTickMarkDefaults(axIn, axOut, coerceAxis, {\n        outerTicks: true\n      });\n      handleLineGridDefaults(axIn, axOut, coerceAxis, {\n        dfltColor: dfltColor,\n        bgColor: opts.bgColor,\n        // default grid color is darker here (60%, vs cartesian default ~91%)\n        // because the grid is not square so the eye needs heavier cues to follow\n        blend: 60,\n        showLine: true,\n        showGrid: true,\n        noZeroLine: true,\n        attributes: layoutAttributes[axName]\n      });\n      coerceAxis('layer');\n      if (axName === 'radialaxis') {\n        coerceAxis('side');\n        coerceAxis('angle', sector[0]);\n        coerceAxis('title.text');\n        Lib.coerceFont(coerceAxis, 'title.font', {\n          weight: dfltFontWeight,\n          style: dfltFontStyle,\n          variant: dfltFontVariant,\n          textcase: dfltFontTextcase,\n          lineposition: dfltFontLineposition,\n          shadow: dfltFontShadow,\n          color: dfltFontColor,\n          size: Lib.bigFont(dfltFontSize),\n          family: dfltFontFamily\n        });\n      }\n    }\n    if (axType !== 'category') coerceAxis('hoverformat');\n    axOut._input = axIn;\n  }\n  if (contOut.angularaxis.type === 'category') {\n    coerce('gridshape');\n  }\n}\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr, options) {\n  var autotypenumbers = coerce('autotypenumbers', options.autotypenumbersDflt);\n  var axType = coerce('type');\n  if (axType === '-') {\n    var trace;\n    for (var i = 0; i < subplotData.length; i++) {\n      if (subplotData[i].visible) {\n        trace = subplotData[i];\n        break;\n      }\n    }\n    if (trace && trace[dataAttr]) {\n      axOut.type = autoType(trace[dataAttr], 'gregorian', {\n        noMultiCategory: true,\n        autotypenumbers: autotypenumbers\n      });\n    }\n    if (axOut.type === '-') {\n      axOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      axIn.type = axOut.type;\n    }\n  }\n  return axOut.type;\n}\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: constants.name,\n    attributes: layoutAttributes,\n    handleDefaults: handleDefaults,\n    font: layoutOut.font,\n    autotypenumbersDflt: layoutOut.autotypenumbers,\n    paper_bgcolor: layoutOut.paper_bgcolor,\n    fullData: fullData,\n    layoutOut: layoutOut\n  });\n};","map":{"version":3,"names":["Lib","require","Color","Template","handleSubplotDefaults","getSubplotData","handleTickValueDefaults","handleTickMarkDefaults","handleTickLabelDefaults","handlePrefixSuffixDefaults","handleCategoryOrderDefaults","handleLineGridDefaults","handleAutorangeOptionsDefaults","autoType","layoutAttributes","setConvert","constants","axisNames","handleDefaults","contIn","contOut","coerce","opts","bgColor","combine","paper_bgcolor","sector","subplotData","fullData","name","id","layoutOut","axName","coerceAxis","attr","dflt","i","length","isPlainObject","axIn","axOut","newContainer","_id","_name","_attr","_traceIndices","map","t","_expandedIndex","dataAttr","axisName2dataArray","axType","handleAxisTypeDefaults","axData","visible","uirevision","_m","range","autorangeDflt","getAutorangeDflt","autorange","shouldAutorange","undefined","isReversed","cleanRange","dfltRange","log","j","type","direction","counterclockwise","clockwise","tickSuffixDflt","thetaunit","dfltColor","dfltFontColor","dfltFontSize","dfltFontFamily","dfltFontWeight","dfltFontStyle","dfltFontVariant","dfltFontTextcase","dfltFontLineposition","dfltFontShadow","font","color","size","family","weight","style","variant","textcase","lineposition","shadow","noAutotickangles","noTicklabelshift","noTicklabelstandoff","outerTicks","blend","showLine","showGrid","noZeroLine","attributes","coerceFont","bigFont","_input","angularaxis","options","autotypenumbers","autotypenumbersDflt","trace","noMultiCategory","module","exports","supplyLayoutDefaults","layoutIn"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/polar/layout_defaults.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Template = require('../../plot_api/plot_template');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\nvar handlePrefixSuffixDefaults = require('../cartesian/prefix_suffix_defaults');\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\nvar handleAutorangeOptionsDefaults = require('../cartesian/autorange_options_defaults');\nvar autoType = require('../cartesian/axis_autotype');\n\nvar layoutAttributes = require('./layout_attributes');\nvar setConvert = require('./set_convert');\nvar constants = require('./constants');\nvar axisNames = constants.axisNames;\n\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n    var bgColor = coerce('bgcolor');\n    opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n\n    var sector = coerce('sector');\n    coerce('hole');\n\n    // could optimize, subplotData is not always needed!\n    var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n    var layoutOut = opts.layoutOut;\n    var axName;\n\n    function coerceAxis(attr, dflt) {\n        return coerce(axName + '.' + attr, dflt);\n    }\n\n    for(var i = 0; i < axisNames.length; i++) {\n        axName = axisNames[i];\n\n        if(!Lib.isPlainObject(contIn[axName])) {\n            contIn[axName] = {};\n        }\n\n        var axIn = contIn[axName];\n        var axOut = Template.newContainer(contOut, axName);\n        axOut._id = axOut._name = axName;\n        axOut._attr = opts.id + '.' + axName;\n        axOut._traceIndices = subplotData.map(function(t) { return t._expandedIndex; });\n\n        var dataAttr = constants.axisName2dataArray[axName];\n        var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr, opts);\n\n        handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n            axData: subplotData,\n            dataAttr: dataAttr\n        });\n\n        var visible = coerceAxis('visible');\n        setConvert(axOut, contOut, layoutOut);\n\n        coerceAxis('uirevision', contOut.uirevision);\n\n        // We don't want to make downstream code call ax.setScale,\n        // as both radial and angular axes don't have a set domain.\n        // Furthermore, angular axes don't have a set range.\n        //\n        // Mocked domains and ranges are set by the polar subplot instances,\n        // but Axes.findExtremes uses the sign of _m to determine which padding value\n        // to use.\n        //\n        // By setting, _m to 1 here, we make Axes.findExtremes think that\n        // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n        axOut._m = 1;\n\n        switch(axName) {\n            case 'radialaxis':\n                coerceAxis('minallowed');\n                coerceAxis('maxallowed');\n                var range = coerceAxis('range');\n                var autorangeDflt = axOut.getAutorangeDflt(range);\n                var autorange = coerceAxis('autorange', autorangeDflt);\n                var shouldAutorange;\n\n                // validate range and set autorange true for invalid partial ranges\n                if(range && (\n                    (range[0] === null && range[1] === null) ||\n                    ((range[0] === null || range[1] === null) && (autorange === 'reversed' || autorange === true)) ||\n                    (range[0] !== null && (autorange === 'min' || autorange === 'max reversed')) ||\n                    (range[1] !== null && (autorange === 'max' || autorange === 'min reversed'))\n                )) {\n                    range = undefined;\n                    delete axOut.range;\n                    axOut.autorange = true;\n                    shouldAutorange = true;\n                }\n\n                if(!shouldAutorange) {\n                    autorangeDflt = axOut.getAutorangeDflt(range);\n                    autorange = coerceAxis('autorange', autorangeDflt);\n                }\n\n                axIn.autorange = autorange;\n                if(autorange) {\n                    handleAutorangeOptionsDefaults(coerceAxis, autorange, range);\n\n                    if(axType === 'linear' || axType === '-') coerceAxis('rangemode');\n                    if(axOut.isReversed()) axOut._m = -1;\n                }\n\n                axOut.cleanRange('range', {dfltRange: [0, 1]});\n                break;\n\n            case 'angularaxis':\n                // We do not support 'true' date angular axes yet,\n                // users can still plot dates on angular axes by setting\n                // `angularaxis.type: 'category'`.\n                //\n                // Here, if a date angular axes is detected, we make\n                // all its corresponding traces invisible, so that\n                // when we do add support for data angular axes, the new\n                // behavior won't conflict with existing behavior\n                if(axType === 'date') {\n                    Lib.log('Polar plots do not support date angular axes yet.');\n\n                    for(var j = 0; j < subplotData.length; j++) {\n                        subplotData[j].visible = false;\n                    }\n\n                    // turn this into a 'dummy' linear axis so that\n                    // the subplot still renders ok\n                    axType = axIn.type = axOut.type = 'linear';\n                }\n\n                if(axType === 'linear') {\n                    coerceAxis('thetaunit');\n                } else {\n                    coerceAxis('period');\n                }\n\n                var direction = coerceAxis('direction');\n                coerceAxis('rotation', {counterclockwise: 0, clockwise: 90}[direction]);\n                break;\n        }\n\n        handlePrefixSuffixDefaults(axIn, axOut, coerceAxis, axOut.type, {\n            tickSuffixDflt: axOut.thetaunit === 'degrees' ? 'Â°' : undefined\n        });\n\n        if(visible) {\n            var dfltColor;\n            var dfltFontColor;\n            var dfltFontSize;\n            var dfltFontFamily;\n            var dfltFontWeight;\n            var dfltFontStyle;\n            var dfltFontVariant;\n            var dfltFontTextcase;\n            var dfltFontLineposition;\n            var dfltFontShadow;\n            var font = opts.font || {};\n\n            dfltColor = coerceAxis('color');\n            dfltFontColor = (dfltColor === axIn.color) ? dfltColor : font.color;\n            dfltFontSize = font.size;\n            dfltFontFamily = font.family;\n            dfltFontWeight = font.weight;\n            dfltFontStyle = font.style;\n            dfltFontVariant = font.variant;\n            dfltFontTextcase = font.textcase;\n            dfltFontLineposition = font.lineposition;\n            dfltFontShadow = font.shadow;\n\n            handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n            handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n                font: {\n                    weight: dfltFontWeight,\n                    style: dfltFontStyle,\n                    variant: dfltFontVariant,\n                    textcase: dfltFontTextcase,\n                    lineposition: dfltFontLineposition,\n                    shadow: dfltFontShadow,\n                    color: dfltFontColor,\n                    size: dfltFontSize,\n                    family: dfltFontFamily\n                },\n                noAutotickangles: axName === 'angularaxis',\n                noTicklabelshift: true,\n                noTicklabelstandoff: true\n            });\n\n            handleTickMarkDefaults(axIn, axOut, coerceAxis, {outerTicks: true});\n\n            handleLineGridDefaults(axIn, axOut, coerceAxis, {\n                dfltColor: dfltColor,\n                bgColor: opts.bgColor,\n                // default grid color is darker here (60%, vs cartesian default ~91%)\n                // because the grid is not square so the eye needs heavier cues to follow\n                blend: 60,\n                showLine: true,\n                showGrid: true,\n                noZeroLine: true,\n                attributes: layoutAttributes[axName]\n            });\n\n            coerceAxis('layer');\n\n            if(axName === 'radialaxis') {\n                coerceAxis('side');\n                coerceAxis('angle', sector[0]);\n\n                coerceAxis('title.text');\n                Lib.coerceFont(coerceAxis, 'title.font', {\n                    weight: dfltFontWeight,\n                    style: dfltFontStyle,\n                    variant: dfltFontVariant,\n                    textcase: dfltFontTextcase,\n                    lineposition: dfltFontLineposition,\n                    shadow: dfltFontShadow,\n                    color: dfltFontColor,\n                    size: Lib.bigFont(dfltFontSize),\n                    family: dfltFontFamily\n                });\n            }\n        }\n\n        if(axType !== 'category') coerceAxis('hoverformat');\n\n        axOut._input = axIn;\n    }\n\n    if(contOut.angularaxis.type === 'category') {\n        coerce('gridshape');\n    }\n}\n\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr, options) {\n    var autotypenumbers = coerce('autotypenumbers', options.autotypenumbersDflt);\n    var axType = coerce('type');\n\n    if(axType === '-') {\n        var trace;\n\n        for(var i = 0; i < subplotData.length; i++) {\n            if(subplotData[i].visible) {\n                trace = subplotData[i];\n                break;\n            }\n        }\n\n        if(trace && trace[dataAttr]) {\n            axOut.type = autoType(trace[dataAttr], 'gregorian', {\n                noMultiCategory: true,\n                autotypenumbers: autotypenumbers\n            });\n        }\n\n        if(axOut.type === '-') {\n            axOut.type = 'linear';\n        } else {\n            // copy autoType back to input axis\n            // note that if this object didn't exist\n            // in the input layout, we have to put it in\n            // this happens in the main supplyDefaults function\n            axIn.type = axOut.type;\n        }\n    }\n\n    return axOut.type;\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n        type: constants.name,\n        attributes: layoutAttributes,\n        handleDefaults: handleDefaults,\n        font: layoutOut.font,\n        autotypenumbersDflt: layoutOut.autotypenumbers,\n        paper_bgcolor: layoutOut.paper_bgcolor,\n        fullData: fullData,\n        layoutOut: layoutOut\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}