{"ast":null,"code":"'use strict';\n\nvar createScatter = require('regl-scatter2d');\nvar createLine = require('regl-line2d');\nvar createError = require('regl-error2d');\nvar Text = require('gl-text');\nvar Lib = require('../../lib');\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\nvar prepareRegl = require('../../lib/prepare_regl');\nvar subTypes = require('../scatter/subtypes');\nvar linkTraces = require('../scatter/link_traces');\nvar styleTextSelection = require('./edit_style').styleTextSelection;\nvar reglPrecompiled = {};\nfunction getViewport(fullLayout, xaxis, yaxis, plotGlPixelRatio) {\n  var gs = fullLayout._size;\n  var width = fullLayout.width * plotGlPixelRatio;\n  var height = fullLayout.height * plotGlPixelRatio;\n  var l = gs.l * plotGlPixelRatio;\n  var b = gs.b * plotGlPixelRatio;\n  var r = gs.r * plotGlPixelRatio;\n  var t = gs.t * plotGlPixelRatio;\n  var w = gs.w * plotGlPixelRatio;\n  var h = gs.h * plotGlPixelRatio;\n  return [l + xaxis.domain[0] * w, b + yaxis.domain[0] * h, width - r - (1 - xaxis.domain[1]) * w, height - t - (1 - yaxis.domain[1]) * h];\n}\nvar exports = module.exports = function plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var fullLayout = gd._fullLayout;\n  var scene = subplot._scene;\n  var xaxis = subplot.xaxis;\n  var yaxis = subplot.yaxis;\n  var i, j;\n\n  // we may have more subplots than initialized data due to Axes.getSubplots method\n  if (!scene) return;\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint'], reglPrecompiled);\n  if (!success) {\n    scene.init();\n    return;\n  }\n  var count = scene.count;\n  var regl = fullLayout._glcanvas.data()[0].regl;\n\n  // that is needed for fills\n  linkTraces(gd, subplot, cdata);\n  if (scene.dirty) {\n    if ((scene.line2d || scene.error2d) && !(scene.scatter2d || scene.fill2d || scene.glText)) {\n      // Fixes shared WebGL context drawing lines only case\n      regl.clear({});\n    }\n\n    // make sure scenes are created\n    if (scene.error2d === true) {\n      scene.error2d = createError(regl);\n    }\n    if (scene.line2d === true) {\n      scene.line2d = createLine(regl);\n    }\n    if (scene.scatter2d === true) {\n      scene.scatter2d = createScatter(regl);\n    }\n    if (scene.fill2d === true) {\n      scene.fill2d = createLine(regl);\n    }\n    if (scene.glText === true) {\n      scene.glText = new Array(count);\n      for (i = 0; i < count; i++) {\n        scene.glText[i] = new Text(regl);\n      }\n    }\n\n    // update main marker options\n    if (scene.glText) {\n      if (count > scene.glText.length) {\n        // add gl text marker\n        var textsToAdd = count - scene.glText.length;\n        for (i = 0; i < textsToAdd; i++) {\n          scene.glText.push(new Text(regl));\n        }\n      } else if (count < scene.glText.length) {\n        // remove gl text marker\n        var textsToRemove = scene.glText.length - count;\n        var removedTexts = scene.glText.splice(count, textsToRemove);\n        removedTexts.forEach(function (text) {\n          text.destroy();\n        });\n      }\n      for (i = 0; i < count; i++) {\n        scene.glText[i].update(scene.textOptions[i]);\n      }\n    }\n    if (scene.line2d) {\n      scene.line2d.update(scene.lineOptions);\n      scene.lineOptions = scene.lineOptions.map(function (lineOptions) {\n        if (lineOptions && lineOptions.positions) {\n          var srcPos = lineOptions.positions;\n          var firstptdef = 0;\n          while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n            firstptdef += 2;\n          }\n          var lastptdef = srcPos.length - 2;\n          while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n            lastptdef -= 2;\n          }\n          lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n        }\n        return lineOptions;\n      });\n      scene.line2d.update(scene.lineOptions);\n    }\n    if (scene.error2d) {\n      var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n      scene.error2d.update(errorBatch);\n    }\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n\n    // fill requires linked traces, so we generate it's positions here\n    scene.fillOrder = Lib.repeat(null, count);\n    if (scene.fill2d) {\n      scene.fillOptions = scene.fillOptions.map(function (fillOptions, i) {\n        var cdscatter = cdata[i];\n        if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var lineOptions = scene.lineOptions[i];\n        var last, j;\n        var fillData = [];\n        if (trace._ownfill) fillData.push(i);\n        if (trace._nexttrace) fillData.push(i + 1);\n        if (fillData.length) scene.fillOrder[i] = fillData;\n        var pos = [];\n        var srcPos = lineOptions && lineOptions.positions || stash.positions;\n        var firstptdef, lastptdef;\n        if (trace.fill === 'tozeroy') {\n          firstptdef = 0;\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n            firstptdef += 2;\n          }\n          lastptdef = srcPos.length - 2;\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n            lastptdef -= 2;\n          }\n          if (srcPos[firstptdef + 1] !== 0) {\n            pos = [srcPos[firstptdef], 0];\n          }\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n          if (srcPos[lastptdef + 1] !== 0) {\n            pos = pos.concat([srcPos[lastptdef], 0]);\n          }\n        } else if (trace.fill === 'tozerox') {\n          firstptdef = 0;\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n            firstptdef += 2;\n          }\n          lastptdef = srcPos.length - 2;\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n            lastptdef -= 2;\n          }\n          if (srcPos[firstptdef] !== 0) {\n            pos = [0, srcPos[firstptdef + 1]];\n          }\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n          if (srcPos[lastptdef] !== 0) {\n            pos = pos.concat([0, srcPos[lastptdef + 1]]);\n          }\n        } else if (trace.fill === 'toself' || trace.fill === 'tonext') {\n          pos = [];\n          last = 0;\n          fillOptions.splitNull = true;\n          for (j = 0; j < srcPos.length; j += 2) {\n            if (isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n              pos = pos.concat(srcPos.slice(last, j));\n              pos.push(srcPos[last], srcPos[last + 1]);\n              pos.push(null, null); // keep null to mark end of polygon\n              last = j + 2;\n            }\n          }\n          pos = pos.concat(srcPos.slice(last));\n          if (last) {\n            pos.push(srcPos[last], srcPos[last + 1]);\n          }\n        } else {\n          var nextTrace = trace._nexttrace;\n          if (nextTrace) {\n            var nextOptions = scene.lineOptions[i + 1];\n            if (nextOptions) {\n              var nextPos = nextOptions.positions;\n              if (trace.fill === 'tonexty') {\n                pos = srcPos.slice();\n                for (i = Math.floor(nextPos.length / 2); i--;) {\n                  var xx = nextPos[i * 2];\n                  var yy = nextPos[i * 2 + 1];\n                  if (isNaN(xx) || isNaN(yy)) continue;\n                  pos.push(xx, yy);\n                }\n                fillOptions.fill = nextTrace.fillcolor;\n              }\n            }\n          }\n        }\n\n        // detect prev trace positions to exclude from current fill\n        if (trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n          var prevLinePos = scene.lineOptions[i - 1].positions;\n\n          // FIXME: likely this logic should be tested better\n          var offset = pos.length / 2;\n          last = offset;\n          var hole = [last];\n          for (j = 0; j < prevLinePos.length; j += 2) {\n            if (isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n              hole.push(j / 2 + offset + 1);\n              last = j + 2;\n            }\n          }\n          pos = pos.concat(prevLinePos);\n          fillOptions.hole = hole;\n        }\n        fillOptions.fillmode = trace.fill;\n        fillOptions.opacity = trace.opacity;\n        fillOptions.positions = pos;\n        return fillOptions;\n      });\n      scene.fill2d.update(scene.fillOptions);\n    }\n  }\n\n  // form batch arrays, and check for selected points\n  var dragmode = fullLayout.dragmode;\n  var isSelectMode = selectMode(dragmode);\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n  for (i = 0; i < count; i++) {\n    var cd0 = cdata[i][0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var index = stash.index;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n    if (trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n      if (!isSelectMode) isSelectMode = true;\n\n      // regenerate scene batch, if traces number changed during selection\n      if (trace.selectedpoints) {\n        var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n        var selDict = {};\n        for (j = 0; j < selPts.length; j++) {\n          selDict[selPts[j]] = 1;\n        }\n        var unselPts = [];\n        for (j = 0; j < len; j++) {\n          if (!selDict[j]) unselPts.push(j);\n        }\n        scene.unselectBatch[index] = unselPts;\n      }\n\n      // precalculate px coords since we are not going to pan during select\n      // TODO, could do better here e.g.\n      // - spin that in a webworker\n      // - compute selection from polygons in data coordinates\n      //   (maybe just for linear axes)\n      var xpx = stash.xpx = new Array(len);\n      var ypx = stash.ypx = new Array(len);\n      for (j = 0; j < len; j++) {\n        xpx[j] = xaxis.c2p(x[j]);\n        ypx[j] = yaxis.c2p(y[j]);\n      }\n    } else {\n      stash.xpx = stash.ypx = null;\n    }\n  }\n  if (isSelectMode) {\n    // create scatter instance by cloning scatter2d\n    if (!scene.select2d) {\n      scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n    }\n\n    // use unselected styles on 'context' canvas\n    if (scene.scatter2d) {\n      var unselOpts = new Array(count);\n      for (i = 0; i < count; i++) {\n        unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ? scene.markerUnselectedOptions[i] : {};\n      }\n      scene.scatter2d.update(unselOpts);\n    }\n\n    // use selected style on 'focus' canvas\n    if (scene.select2d) {\n      scene.select2d.update(scene.markerOptions);\n      scene.select2d.update(scene.markerSelectedOptions);\n    }\n    if (scene.glText) {\n      cdata.forEach(function (cdscatter) {\n        var trace = ((cdscatter || [])[0] || {}).trace || {};\n        if (subTypes.hasText(trace)) {\n          styleTextSelection(cdscatter);\n        }\n      });\n    }\n  } else {\n    // reset 'context' scatter2d opts to base opts,\n    // thus unsetting markerUnselectedOptions from selection\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n  }\n\n  // provide viewport and range\n  var vpRange0 = {\n    viewport: getViewport(fullLayout, xaxis, yaxis, gd._context.plotGlPixelRatio),\n    // TODO do we need those fallbacks?\n    range: [(xaxis._rl || xaxis.range)[0], (yaxis._rl || yaxis.range)[0], (xaxis._rl || xaxis.range)[1], (yaxis._rl || yaxis.range)[1]]\n  };\n  var vpRange = Lib.repeat(vpRange0, scene.count);\n\n  // upload viewport/range data to GPU\n  if (scene.fill2d) {\n    scene.fill2d.update(vpRange);\n  }\n  if (scene.line2d) {\n    scene.line2d.update(vpRange);\n  }\n  if (scene.error2d) {\n    scene.error2d.update(vpRange.concat(vpRange));\n  }\n  if (scene.scatter2d) {\n    scene.scatter2d.update(vpRange);\n  }\n  if (scene.select2d) {\n    scene.select2d.update(vpRange);\n  }\n  if (scene.glText) {\n    scene.glText.forEach(function (text) {\n      text.update(vpRange0);\n    });\n  }\n};\nexports.reglPrecompiled = reglPrecompiled;","map":{"version":3,"names":["createScatter","require","createLine","createError","Text","Lib","selectMode","prepareRegl","subTypes","linkTraces","styleTextSelection","reglPrecompiled","getViewport","fullLayout","xaxis","yaxis","plotGlPixelRatio","gs","_size","width","height","l","b","r","t","w","h","domain","exports","module","plot","gd","subplot","cdata","length","_fullLayout","scene","_scene","i","j","success","init","count","regl","_glcanvas","data","dirty","line2d","error2d","scatter2d","fill2d","glText","clear","Array","textsToAdd","push","textsToRemove","removedTexts","splice","forEach","text","destroy","update","textOptions","lineOptions","map","positions","srcPos","firstptdef","isNaN","lastptdef","slice","errorBatch","errorXOptions","concat","errorYOptions","markerOptions","fillOrder","repeat","fillOptions","cdscatter","trace","cd","stash","last","fillData","_ownfill","_nexttrace","pos","fill","splitNull","nextTrace","nextOptions","nextPos","Math","floor","xx","yy","fillcolor","_prevtrace","prevLinePos","offset","hole","fillmode","opacity","dragmode","isSelectMode","clickSelectEnabled","clickmode","indexOf","cd0","index","len","_length","x","y","selectedpoints","selPts","selectBatch","selIndices2selPoints","selDict","unselPts","unselectBatch","xpx","ypx","c2p","select2d","unselOpts","markerUnselectedOptions","markerSelectedOptions","hasText","vpRange0","viewport","_context","range","_rl","vpRange"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scattergl/plot.js"],"sourcesContent":["'use strict';\n\nvar createScatter = require('regl-scatter2d');\nvar createLine = require('regl-line2d');\nvar createError = require('regl-error2d');\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\nvar reglPrecompiled = {};\n\nfunction getViewport(fullLayout, xaxis, yaxis, plotGlPixelRatio) {\n    var gs = fullLayout._size;\n    var width = fullLayout.width * plotGlPixelRatio;\n    var height = fullLayout.height * plotGlPixelRatio;\n\n    var l = gs.l * plotGlPixelRatio;\n    var b = gs.b * plotGlPixelRatio;\n    var r = gs.r * plotGlPixelRatio;\n    var t = gs.t * plotGlPixelRatio;\n    var w = gs.w * plotGlPixelRatio;\n    var h = gs.h * plotGlPixelRatio;\n    return [\n        l + xaxis.domain[0] * w,\n        b + yaxis.domain[0] * h,\n        (width - r) - (1 - xaxis.domain[1]) * w,\n        (height - t) - (1 - yaxis.domain[1]) * h\n    ];\n}\n\nvar exports = module.exports = function plot(gd, subplot, cdata) {\n    if(!cdata.length) return;\n\n    var fullLayout = gd._fullLayout;\n    var scene = subplot._scene;\n    var xaxis = subplot.xaxis;\n    var yaxis = subplot.yaxis;\n    var i, j;\n\n    // we may have more subplots than initialized data due to Axes.getSubplots method\n    if(!scene) return;\n\n    var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint'], reglPrecompiled);\n    if(!success) {\n        scene.init();\n        return;\n    }\n\n    var count = scene.count;\n    var regl = fullLayout._glcanvas.data()[0].regl;\n\n    // that is needed for fills\n    linkTraces(gd, subplot, cdata);\n\n    if(scene.dirty) {\n        if(\n            (scene.line2d || scene.error2d) &&\n            !(scene.scatter2d || scene.fill2d || scene.glText)\n        ) {\n            // Fixes shared WebGL context drawing lines only case\n            regl.clear({});\n        }\n\n        // make sure scenes are created\n        if(scene.error2d === true) {\n            scene.error2d = createError(regl);\n        }\n        if(scene.line2d === true) {\n            scene.line2d = createLine(regl);\n        }\n        if(scene.scatter2d === true) {\n            scene.scatter2d = createScatter(regl);\n        }\n        if(scene.fill2d === true) {\n            scene.fill2d = createLine(regl);\n        }\n        if(scene.glText === true) {\n            scene.glText = new Array(count);\n            for(i = 0; i < count; i++) {\n                scene.glText[i] = new Text(regl);\n            }\n        }\n\n        // update main marker options\n        if(scene.glText) {\n            if(count > scene.glText.length) {\n                // add gl text marker\n                var textsToAdd = count - scene.glText.length;\n                for(i = 0; i < textsToAdd; i++) {\n                    scene.glText.push(new Text(regl));\n                }\n            } else if(count < scene.glText.length) {\n                // remove gl text marker\n                var textsToRemove = scene.glText.length - count;\n                var removedTexts = scene.glText.splice(count, textsToRemove);\n                removedTexts.forEach(function(text) { text.destroy(); });\n            }\n\n            for(i = 0; i < count; i++) {\n                scene.glText[i].update(scene.textOptions[i]);\n            }\n        }\n        if(scene.line2d) {\n            scene.line2d.update(scene.lineOptions);\n            scene.lineOptions = scene.lineOptions.map(function(lineOptions) {\n                if(lineOptions && lineOptions.positions) {\n                    var srcPos = lineOptions.positions;\n\n                    var firstptdef = 0;\n                    while(firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n                        firstptdef += 2;\n                    }\n                    var lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n                        lastptdef -= 2;\n                    }\n                    lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n                }\n                return lineOptions;\n            });\n            scene.line2d.update(scene.lineOptions);\n        }\n        if(scene.error2d) {\n            var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n            scene.error2d.update(errorBatch);\n        }\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n\n        // fill requires linked traces, so we generate it's positions here\n        scene.fillOrder = Lib.repeat(null, count);\n        if(scene.fill2d) {\n            scene.fillOptions = scene.fillOptions.map(function(fillOptions, i) {\n                var cdscatter = cdata[i];\n                if(!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n                var cd = cdscatter[0];\n                var trace = cd.trace;\n                var stash = cd.t;\n                var lineOptions = scene.lineOptions[i];\n                var last, j;\n\n                var fillData = [];\n                if(trace._ownfill) fillData.push(i);\n                if(trace._nexttrace) fillData.push(i + 1);\n                if(fillData.length) scene.fillOrder[i] = fillData;\n\n                var pos = [];\n                var srcPos = (lineOptions && lineOptions.positions) || stash.positions;\n                var firstptdef, lastptdef;\n\n                if(trace.fill === 'tozeroy') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef + 1] !== 0) {\n                        pos = [srcPos[firstptdef], 0];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef + 1] !== 0) {\n                        pos = pos.concat([srcPos[lastptdef], 0]);\n                    }\n                } else if(trace.fill === 'tozerox') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef] !== 0) {\n                        pos = [0, srcPos[firstptdef + 1]];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef] !== 0) {\n                        pos = pos.concat([ 0, srcPos[lastptdef + 1]]);\n                    }\n                } else if(trace.fill === 'toself' || trace.fill === 'tonext') {\n                    pos = [];\n                    last = 0;\n\n                    fillOptions.splitNull = true;\n\n                    for(j = 0; j < srcPos.length; j += 2) {\n                        if(isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n                            pos = pos.concat(srcPos.slice(last, j));\n                            pos.push(srcPos[last], srcPos[last + 1]);\n                            pos.push(null, null); // keep null to mark end of polygon\n                            last = j + 2;\n                        }\n                    }\n                    pos = pos.concat(srcPos.slice(last));\n                    if(last) {\n                        pos.push(srcPos[last], srcPos[last + 1]);\n                    }\n                } else {\n                    var nextTrace = trace._nexttrace;\n\n                    if(nextTrace) {\n                        var nextOptions = scene.lineOptions[i + 1];\n\n                        if(nextOptions) {\n                            var nextPos = nextOptions.positions;\n                            if(trace.fill === 'tonexty') {\n                                pos = srcPos.slice();\n\n                                for(i = Math.floor(nextPos.length / 2); i--;) {\n                                    var xx = nextPos[i * 2];\n                                    var yy = nextPos[i * 2 + 1];\n                                    if(isNaN(xx) || isNaN(yy)) continue;\n                                    pos.push(xx, yy);\n                                }\n                                fillOptions.fill = nextTrace.fillcolor;\n                            }\n                        }\n                    }\n                }\n\n                // detect prev trace positions to exclude from current fill\n                if(trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n                    var prevLinePos = scene.lineOptions[i - 1].positions;\n\n                    // FIXME: likely this logic should be tested better\n                    var offset = pos.length / 2;\n                    last = offset;\n                    var hole = [last];\n                    for(j = 0; j < prevLinePos.length; j += 2) {\n                        if(isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n                            hole.push(j / 2 + offset + 1);\n                            last = j + 2;\n                        }\n                    }\n\n                    pos = pos.concat(prevLinePos);\n                    fillOptions.hole = hole;\n                }\n                fillOptions.fillmode = trace.fill;\n                fillOptions.opacity = trace.opacity;\n                fillOptions.positions = pos;\n\n                return fillOptions;\n            });\n\n            scene.fill2d.update(scene.fillOptions);\n        }\n    }\n\n    // form batch arrays, and check for selected points\n    var dragmode = fullLayout.dragmode;\n    var isSelectMode = selectMode(dragmode);\n    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n    for(i = 0; i < count; i++) {\n        var cd0 = cdata[i][0];\n        var trace = cd0.trace;\n        var stash = cd0.t;\n        var index = stash.index;\n        var len = trace._length;\n        var x = stash.x;\n        var y = stash.y;\n\n        if(trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n            if(!isSelectMode) isSelectMode = true;\n\n            // regenerate scene batch, if traces number changed during selection\n            if(trace.selectedpoints) {\n                var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n\n                var selDict = {};\n                for(j = 0; j < selPts.length; j++) {\n                    selDict[selPts[j]] = 1;\n                }\n                var unselPts = [];\n                for(j = 0; j < len; j++) {\n                    if(!selDict[j]) unselPts.push(j);\n                }\n                scene.unselectBatch[index] = unselPts;\n            }\n\n            // precalculate px coords since we are not going to pan during select\n            // TODO, could do better here e.g.\n            // - spin that in a webworker\n            // - compute selection from polygons in data coordinates\n            //   (maybe just for linear axes)\n            var xpx = stash.xpx = new Array(len);\n            var ypx = stash.ypx = new Array(len);\n            for(j = 0; j < len; j++) {\n                xpx[j] = xaxis.c2p(x[j]);\n                ypx[j] = yaxis.c2p(y[j]);\n            }\n        } else {\n            stash.xpx = stash.ypx = null;\n        }\n    }\n\n    if(isSelectMode) {\n        // create scatter instance by cloning scatter2d\n        if(!scene.select2d) {\n            scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n        }\n\n        // use unselected styles on 'context' canvas\n        if(scene.scatter2d) {\n            var unselOpts = new Array(count);\n            for(i = 0; i < count; i++) {\n                unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ?\n                    scene.markerUnselectedOptions[i] :\n                    {};\n            }\n            scene.scatter2d.update(unselOpts);\n        }\n\n        // use selected style on 'focus' canvas\n        if(scene.select2d) {\n            scene.select2d.update(scene.markerOptions);\n            scene.select2d.update(scene.markerSelectedOptions);\n        }\n\n        if(scene.glText) {\n            cdata.forEach(function(cdscatter) {\n                var trace = ((cdscatter || [])[0] || {}).trace || {};\n                if(subTypes.hasText(trace)) {\n                    styleTextSelection(cdscatter);\n                }\n            });\n        }\n    } else {\n        // reset 'context' scatter2d opts to base opts,\n        // thus unsetting markerUnselectedOptions from selection\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n    }\n\n    // provide viewport and range\n    var vpRange0 = {\n        viewport: getViewport(fullLayout, xaxis, yaxis, gd._context.plotGlPixelRatio),\n        // TODO do we need those fallbacks?\n        range: [\n            (xaxis._rl || xaxis.range)[0],\n            (yaxis._rl || yaxis.range)[0],\n            (xaxis._rl || xaxis.range)[1],\n            (yaxis._rl || yaxis.range)[1]\n        ]\n    };\n    var vpRange = Lib.repeat(vpRange0, scene.count);\n\n    // upload viewport/range data to GPU\n    if(scene.fill2d) {\n        scene.fill2d.update(vpRange);\n    }\n    if(scene.line2d) {\n        scene.line2d.update(vpRange);\n    }\n    if(scene.error2d) {\n        scene.error2d.update(vpRange.concat(vpRange));\n    }\n    if(scene.scatter2d) {\n        scene.scatter2d.update(vpRange);\n    }\n    if(scene.select2d) {\n        scene.select2d.update(vpRange);\n    }\n    if(scene.glText) {\n        scene.glText.forEach(function(text) { text.update(vpRange0); });\n    }\n};\n\nexports.reglPrecompiled = reglPrecompiled;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}