{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\n// The contour extraction is great, except it totally fails for constraints because we\n// need weird range loops and flipped contours instead of the usual format. This function\n// does some weird manipulation of the extracted pathinfo data such that it magically\n// draws contours correctly *as* constraints.\n//\n// ** I do not know which \"weird range loops\" the comment above is referring to.\nmodule.exports = function (pathinfo, operation) {\n  var i, pi0, pi1;\n  var op0 = function (arr) {\n    return arr.reverse();\n  };\n  var op1 = function (arr) {\n    return arr;\n  };\n  switch (operation) {\n    case '=':\n    case '<':\n      return pathinfo;\n    case '>':\n      if (pathinfo.length !== 1) {\n        Lib.warn('Contour data invalid for the specified inequality operation.');\n      }\n\n      // In this case there should be exactly one contour levels in pathinfo.\n      // We flip all of the data. This will draw the contour as closed.\n      pi0 = pathinfo[0];\n      for (i = 0; i < pi0.edgepaths.length; i++) {\n        pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n      }\n      for (i = 0; i < pi0.paths.length; i++) {\n        pi0.paths[i] = op0(pi0.paths[i]);\n      }\n      for (i = 0; i < pi0.starts.length; i++) {\n        pi0.starts[i] = op0(pi0.starts[i]);\n      }\n      return pathinfo;\n    case '][':\n      var tmp = op0;\n      op0 = op1;\n      op1 = tmp;\n    // It's a nice rule, except this definitely *is* what's intended here.\n    /* eslint-disable: no-fallthrough */\n    case '[]':\n      /* eslint-enable: no-fallthrough */\n      if (pathinfo.length !== 2) {\n        Lib.warn('Contour data invalid for the specified inequality range operation.');\n      }\n\n      // In this case there should be exactly two contour levels in pathinfo.\n      // - We concatenate the info into one pathinfo.\n      // - We must also flip all of the data in the `[]` case.\n      // This will draw the contours as closed.\n      pi0 = copyPathinfo(pathinfo[0]);\n      pi1 = copyPathinfo(pathinfo[1]);\n      for (i = 0; i < pi0.edgepaths.length; i++) {\n        pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n      }\n      for (i = 0; i < pi0.paths.length; i++) {\n        pi0.paths[i] = op0(pi0.paths[i]);\n      }\n      for (i = 0; i < pi0.starts.length; i++) {\n        pi0.starts[i] = op0(pi0.starts[i]);\n      }\n      while (pi1.edgepaths.length) {\n        pi0.edgepaths.push(op1(pi1.edgepaths.shift()));\n      }\n      while (pi1.paths.length) {\n        pi0.paths.push(op1(pi1.paths.shift()));\n      }\n      while (pi1.starts.length) {\n        pi0.starts.push(op1(pi1.starts.shift()));\n      }\n      return [pi0];\n  }\n};\nfunction copyPathinfo(pi) {\n  return Lib.extendFlat({}, pi, {\n    edgepaths: Lib.extendDeep([], pi.edgepaths),\n    paths: Lib.extendDeep([], pi.paths),\n    starts: Lib.extendDeep([], pi.starts)\n  });\n}","map":{"version":3,"names":["Lib","require","module","exports","pathinfo","operation","i","pi0","pi1","op0","arr","reverse","op1","length","warn","edgepaths","paths","starts","tmp","copyPathinfo","push","shift","pi","extendFlat","extendDeep"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/contour/convert_to_constraints.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\n// The contour extraction is great, except it totally fails for constraints because we\n// need weird range loops and flipped contours instead of the usual format. This function\n// does some weird manipulation of the extracted pathinfo data such that it magically\n// draws contours correctly *as* constraints.\n//\n// ** I do not know which \"weird range loops\" the comment above is referring to.\nmodule.exports = function(pathinfo, operation) {\n    var i, pi0, pi1;\n\n    var op0 = function(arr) { return arr.reverse(); };\n    var op1 = function(arr) { return arr; };\n\n    switch(operation) {\n        case '=':\n        case '<':\n            return pathinfo;\n        case '>':\n            if(pathinfo.length !== 1) {\n                Lib.warn('Contour data invalid for the specified inequality operation.');\n            }\n\n            // In this case there should be exactly one contour levels in pathinfo.\n            // We flip all of the data. This will draw the contour as closed.\n            pi0 = pathinfo[0];\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n            for(i = 0; i < pi0.starts.length; i++) {\n                pi0.starts[i] = op0(pi0.starts[i]);\n            }\n\n            return pathinfo;\n        case '][':\n            var tmp = op0;\n            op0 = op1;\n            op1 = tmp;\n            // It's a nice rule, except this definitely *is* what's intended here.\n            /* eslint-disable: no-fallthrough */\n        case '[]':\n            /* eslint-enable: no-fallthrough */\n            if(pathinfo.length !== 2) {\n                Lib.warn('Contour data invalid for the specified inequality range operation.');\n            }\n\n            // In this case there should be exactly two contour levels in pathinfo.\n            // - We concatenate the info into one pathinfo.\n            // - We must also flip all of the data in the `[]` case.\n            // This will draw the contours as closed.\n            pi0 = copyPathinfo(pathinfo[0]);\n            pi1 = copyPathinfo(pathinfo[1]);\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n            for(i = 0; i < pi0.starts.length; i++) {\n                pi0.starts[i] = op0(pi0.starts[i]);\n            }\n\n            while(pi1.edgepaths.length) {\n                pi0.edgepaths.push(op1(pi1.edgepaths.shift()));\n            }\n            while(pi1.paths.length) {\n                pi0.paths.push(op1(pi1.paths.shift()));\n            }\n            while(pi1.starts.length) {\n                pi0.starts.push(op1(pi1.starts.shift()));\n            }\n\n            return [pi0];\n    }\n};\n\nfunction copyPathinfo(pi) {\n    return Lib.extendFlat({}, pi, {\n        edgepaths: Lib.extendDeep([], pi.edgepaths),\n        paths: Lib.extendDeep([], pi.paths),\n        starts: Lib.extendDeep([], pi.starts)\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}