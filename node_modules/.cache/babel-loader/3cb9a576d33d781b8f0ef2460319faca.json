{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar constants = require('../../constants/numerical');\nvar ONEDAY = constants.ONEDAY;\nvar ONEWEEK = constants.ONEWEEK;\n\n/**\n * Return a validated dtick value for this axis\n *\n * @param {any} dtick: the candidate dtick. valid values are numbers and strings,\n *     and further constrained depending on the axis type.\n * @param {string} axType: the axis type\n */\nexports.dtick = function (dtick, axType) {\n  var isLog = axType === 'log';\n  var isDate = axType === 'date';\n  var isCat = axType === 'category';\n  var dtickDflt = isDate ? ONEDAY : 1;\n  if (!dtick) return dtickDflt;\n  if (isNumeric(dtick)) {\n    dtick = Number(dtick);\n    if (dtick <= 0) return dtickDflt;\n    if (isCat) {\n      // category dtick must be positive integers\n      return Math.max(1, Math.round(dtick));\n    }\n    if (isDate) {\n      // date dtick must be at least 0.1ms (our current precision)\n      return Math.max(0.1, dtick);\n    }\n    return dtick;\n  }\n  if (typeof dtick !== 'string' || !(isDate || isLog)) {\n    return dtickDflt;\n  }\n  var prefix = dtick.charAt(0);\n  var dtickNum = dtick.substr(1);\n  dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;\n  if (dtickNum <= 0 || !(\n  // \"M<n>\" gives ticks every (integer) n months\n  isDate && prefix === 'M' && dtickNum === Math.round(dtickNum) ||\n  // \"L<f>\" gives ticks linearly spaced in data (not in position) every (float) f\n  isLog && prefix === 'L' ||\n  // \"D1\" gives powers of 10 with all small digits between, \"D2\" gives only 2 and 5\n  isLog && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))) {\n    return dtickDflt;\n  }\n  return dtick;\n};\n\n/**\n * Return a validated tick0 for this axis\n *\n * @param {any} tick0: the candidate tick0. Valid values are numbers and strings,\n *     further constrained depending on the axis type\n * @param {string} axType: the axis type\n * @param {string} calendar: for date axes, the calendar to validate/convert with\n * @param {any} dtick: an already valid dtick. Only used for D1 and D2 log dticks,\n *     which do not support tick0 at all.\n */\nexports.tick0 = function (tick0, axType, calendar, dtick) {\n  if (axType === 'date') {\n    return Lib.cleanDate(tick0, Lib.dateTick0(calendar, dtick % ONEWEEK === 0 ? 1 : 0));\n  }\n  if (dtick === 'D1' || dtick === 'D2') {\n    // D1 and D2 modes ignore tick0 entirely\n    return undefined;\n  }\n  // Aside from date axes, tick0 must be numeric\n  return isNumeric(tick0) ? Number(tick0) : 0;\n};","map":{"version":3,"names":["isNumeric","require","Lib","constants","ONEDAY","ONEWEEK","exports","dtick","axType","isLog","isDate","isCat","dtickDflt","Number","Math","max","round","prefix","charAt","dtickNum","substr","tick0","calendar","cleanDate","dateTick0","undefined"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/cartesian/clean_ticks.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar constants = require('../../constants/numerical');\nvar ONEDAY = constants.ONEDAY;\nvar ONEWEEK = constants.ONEWEEK;\n\n/**\n * Return a validated dtick value for this axis\n *\n * @param {any} dtick: the candidate dtick. valid values are numbers and strings,\n *     and further constrained depending on the axis type.\n * @param {string} axType: the axis type\n */\nexports.dtick = function(dtick, axType) {\n    var isLog = axType === 'log';\n    var isDate = axType === 'date';\n    var isCat = axType === 'category';\n    var dtickDflt = isDate ? ONEDAY : 1;\n\n    if(!dtick) return dtickDflt;\n\n    if(isNumeric(dtick)) {\n        dtick = Number(dtick);\n        if(dtick <= 0) return dtickDflt;\n        if(isCat) {\n            // category dtick must be positive integers\n            return Math.max(1, Math.round(dtick));\n        }\n        if(isDate) {\n            // date dtick must be at least 0.1ms (our current precision)\n            return Math.max(0.1, dtick);\n        }\n        return dtick;\n    }\n\n    if(typeof dtick !== 'string' || !(isDate || isLog)) {\n        return dtickDflt;\n    }\n\n    var prefix = dtick.charAt(0);\n    var dtickNum = dtick.substr(1);\n    dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;\n\n    if((dtickNum <= 0) || !(\n            // \"M<n>\" gives ticks every (integer) n months\n            (isDate && prefix === 'M' && dtickNum === Math.round(dtickNum)) ||\n            // \"L<f>\" gives ticks linearly spaced in data (not in position) every (float) f\n            (isLog && prefix === 'L') ||\n            // \"D1\" gives powers of 10 with all small digits between, \"D2\" gives only 2 and 5\n            (isLog && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))\n        )) {\n        return dtickDflt;\n    }\n\n    return dtick;\n};\n\n/**\n * Return a validated tick0 for this axis\n *\n * @param {any} tick0: the candidate tick0. Valid values are numbers and strings,\n *     further constrained depending on the axis type\n * @param {string} axType: the axis type\n * @param {string} calendar: for date axes, the calendar to validate/convert with\n * @param {any} dtick: an already valid dtick. Only used for D1 and D2 log dticks,\n *     which do not support tick0 at all.\n */\nexports.tick0 = function(tick0, axType, calendar, dtick) {\n    if(axType === 'date') {\n        return Lib.cleanDate(tick0,\n            Lib.dateTick0(calendar, (dtick % ONEWEEK === 0) ? 1 : 0)\n        );\n    }\n    if(dtick === 'D1' || dtick === 'D2') {\n        // D1 and D2 modes ignore tick0 entirely\n        return undefined;\n    }\n    // Aside from date axes, tick0 must be numeric\n    return isNumeric(tick0) ? Number(tick0) : 0;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AACzC,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIE,SAAS,GAAGF,OAAO,CAAC,2BAA2B,CAAC;AACpD,IAAIG,MAAM,GAAGD,SAAS,CAACC,MAAM;AAC7B,IAAIC,OAAO,GAAGF,SAAS,CAACE,OAAO;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,OAAO,CAACC,KAAK,GAAG,UAASA,KAAK,EAAEC,MAAM,EAAE;EACpC,IAAIC,KAAK,GAAGD,MAAM,KAAK,KAAK;EAC5B,IAAIE,MAAM,GAAGF,MAAM,KAAK,MAAM;EAC9B,IAAIG,KAAK,GAAGH,MAAM,KAAK,UAAU;EACjC,IAAII,SAAS,GAAGF,MAAM,GAAGN,MAAM,GAAG,CAAC;EAEnC,IAAG,CAACG,KAAK,EAAE,OAAOK,SAAS;EAE3B,IAAGZ,SAAS,CAACO,KAAK,CAAC,EAAE;IACjBA,KAAK,GAAGM,MAAM,CAACN,KAAK,CAAC;IACrB,IAAGA,KAAK,IAAI,CAAC,EAAE,OAAOK,SAAS;IAC/B,IAAGD,KAAK,EAAE;MACN;MACA,OAAOG,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,KAAK,CAACT,KAAK,CAAC,CAAC;IACzC;IACA,IAAGG,MAAM,EAAE;MACP;MACA,OAAOI,IAAI,CAACC,GAAG,CAAC,GAAG,EAAER,KAAK,CAAC;IAC/B;IACA,OAAOA,KAAK;EAChB;EAEA,IAAG,OAAOA,KAAK,KAAK,QAAQ,IAAI,EAAEG,MAAM,IAAID,KAAK,CAAC,EAAE;IAChD,OAAOG,SAAS;EACpB;EAEA,IAAIK,MAAM,GAAGV,KAAK,CAACW,MAAM,CAAC,CAAC,CAAC;EAC5B,IAAIC,QAAQ,GAAGZ,KAAK,CAACa,MAAM,CAAC,CAAC,CAAC;EAC9BD,QAAQ,GAAGnB,SAAS,CAACmB,QAAQ,CAAC,GAAGN,MAAM,CAACM,QAAQ,CAAC,GAAG,CAAC;EAErD,IAAIA,QAAQ,IAAI,CAAC,IAAK;EACd;EACCT,MAAM,IAAIO,MAAM,KAAK,GAAG,IAAIE,QAAQ,KAAKL,IAAI,CAACE,KAAK,CAACG,QAAQ,CAAC;EAC9D;EACCV,KAAK,IAAIQ,MAAM,KAAK,GAAI;EACzB;EACCR,KAAK,IAAIQ,MAAM,KAAK,GAAG,KAAKE,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,CAAE,CAClE,EAAE;IACH,OAAOP,SAAS;EACpB;EAEA,OAAOL,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,OAAO,CAACe,KAAK,GAAG,UAASA,KAAK,EAAEb,MAAM,EAAEc,QAAQ,EAAEf,KAAK,EAAE;EACrD,IAAGC,MAAM,KAAK,MAAM,EAAE;IAClB,OAAON,GAAG,CAACqB,SAAS,CAACF,KAAK,EACtBnB,GAAG,CAACsB,SAAS,CAACF,QAAQ,EAAGf,KAAK,GAAGF,OAAO,KAAK,CAAC,GAAI,CAAC,GAAG,CAAC,CAC3D,CAAC;EACL;EACA,IAAGE,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,IAAI,EAAE;IACjC;IACA,OAAOkB,SAAS;EACpB;EACA;EACA,OAAOzB,SAAS,CAACqB,KAAK,CAAC,GAAGR,MAAM,CAACQ,KAAK,CAAC,GAAG,CAAC;AAC/C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}