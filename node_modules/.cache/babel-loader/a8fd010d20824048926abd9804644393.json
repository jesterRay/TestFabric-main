{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\nvar Registry = require('../registry');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\nvar filterOps = require('../constants/filter_ops');\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\nexports.moduleType = 'transform';\nexports.name = 'filter';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    editType: 'calc',\n    description: ['Determines whether this filter transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    editType: 'calc',\n    description: ['Sets the filter target by which the filter is applied.', 'If a string, `target` is assumed to be a reference to a data array', 'in the parent trace object.', 'To filter about nested variables, use *.* to access them.', 'For example, set `target` to *marker.color* to filter', 'about the marker color array.', 'If an array, `target` is then the data array by which the filter is applied.'].join(' ')\n  },\n  operation: {\n    valType: 'enumerated',\n    values: [].concat(COMPARISON_OPS).concat(INTERVAL_OPS).concat(SET_OPS),\n    dflt: '=',\n    editType: 'calc',\n    description: ['Sets the filter operation.', '*=* keeps items equal to `value`', '*!=* keeps items not equal to `value`', '*<* keeps items less than `value`', '*<=* keeps items less than or equal to `value`', '*>* keeps items greater than `value`', '*>=* keeps items greater than or equal to `value`', '*[]* keeps items inside `value[0]` to `value[1]` including both bounds', '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds', '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]', '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]', '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds', '*)(* keeps items outside `value[0]` to `value[1]`', '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`', '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`', '*{}* keeps items present in a set of values', '*}{* keeps items not present in a set of values'].join(' ')\n  },\n  value: {\n    valType: 'any',\n    dflt: 0,\n    editType: 'calc',\n    description: ['Sets the value or values by which to filter.', 'Values are expected to be in the same type as the data linked', 'to `target`.', 'When `operation` is set to one of', 'the comparison values (' + COMPARISON_OPS + ')', '`value` is expected to be a number or a string.', 'When `operation` is set to one of the interval values', '(' + INTERVAL_OPS + ')', '`value` is expected to be 2-item array where the first item', 'is the lower bound and the second item is the upper bound.', 'When `operation`, is set to one of the set values', '(' + SET_OPS + ')', '`value` is expected to be an array with as many items as', 'the desired set elements.'].join(' ')\n  },\n  preservegaps: {\n    valType: 'boolean',\n    dflt: false,\n    editType: 'calc',\n    description: ['Determines whether or not gaps in data arrays produced by the filter operation', 'are preserved.', 'Setting this to *true* might be useful when plotting a line chart', 'with `connectgaps` set to *false*.'].join(' ')\n  },\n  editType: 'calc'\n};\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n  var enabled = coerce('enabled');\n  if (enabled) {\n    var target = coerce('target');\n    if (Lib.isArrayOrTypedArray(target) && target.length === 0) {\n      transformOut.enabled = false;\n      return transformOut;\n    }\n    coerce('preservegaps');\n    coerce('operation');\n    coerce('value');\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n    handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n  }\n  return transformOut;\n};\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var targetCalendar = opts.targetcalendar;\n  var arrayAttrs = trace._arrayAttrs;\n  var preservegaps = opts.preservegaps;\n\n  // even if you provide targetcalendar, if target is a string and there\n  // is a calendar attribute matching target it will get used instead.\n  if (typeof target === 'string') {\n    var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n    if (attrTargetCalendar) targetCalendar = attrTargetCalendar;\n  }\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n  var originalArrays = {};\n  var indexToPoints = {};\n  var index = 0;\n  function forAllAttrs(fn, index) {\n    for (var j = 0; j < arrayAttrs.length; j++) {\n      var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n      fn(np, index);\n    }\n  }\n  var initFn;\n  var fillFn;\n  if (preservegaps) {\n    initFn = function (np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set(new Array(len));\n    };\n    fillFn = function (np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get()[index] = val;\n    };\n  } else {\n    initFn = function (np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set([]);\n    };\n    fillFn = function (np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get().push(val);\n    };\n  }\n\n  // copy all original array attribute values, and clear arrays in trace\n  forAllAttrs(initFn);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n  // loop through filter array, fill trace arrays if passed\n  for (var i = 0; i < len; i++) {\n    var passed = filterFunc(targetArray[i]);\n    if (passed) {\n      forAllAttrs(fillFn, i);\n      indexToPoints[index++] = originalPointsAccessor(i);\n    } else if (preservegaps) index++;\n  }\n  opts._indexToPoints = indexToPoints;\n  trace._length = index;\n};\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n  var operation = opts.operation;\n  var value = opts.value;\n  var hasArrayValue = Lib.isArrayOrTypedArray(value);\n  function isOperationIn(array) {\n    return array.indexOf(operation) !== -1;\n  }\n  var d2cValue = function (v) {\n    return d2c(v, 0, opts.valuecalendar);\n  };\n  var d2cTarget = function (v) {\n    return d2c(v, 0, targetCalendar);\n  };\n  var coercedValue;\n  if (isOperationIn(COMPARISON_OPS)) {\n    coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n  } else if (isOperationIn(INTERVAL_OPS)) {\n    coercedValue = hasArrayValue ? [d2cValue(value[0]), d2cValue(value[1])] : [d2cValue(value), d2cValue(value)];\n  } else if (isOperationIn(SET_OPS)) {\n    coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n  }\n  switch (operation) {\n    case '=':\n      return function (v) {\n        return d2cTarget(v) === coercedValue;\n      };\n    case '!=':\n      return function (v) {\n        return d2cTarget(v) !== coercedValue;\n      };\n    case '<':\n      return function (v) {\n        return d2cTarget(v) < coercedValue;\n      };\n    case '<=':\n      return function (v) {\n        return d2cTarget(v) <= coercedValue;\n      };\n    case '>':\n      return function (v) {\n        return d2cTarget(v) > coercedValue;\n      };\n    case '>=':\n      return function (v) {\n        return d2cTarget(v) >= coercedValue;\n      };\n    case '[]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv <= coercedValue[1];\n      };\n    case '()':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv < coercedValue[1];\n      };\n    case '[)':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv < coercedValue[1];\n      };\n    case '(]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv <= coercedValue[1];\n      };\n    case '][':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv >= coercedValue[1];\n      };\n    case ')(':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv > coercedValue[1];\n      };\n    case '](':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv > coercedValue[1];\n      };\n    case ')[':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv >= coercedValue[1];\n      };\n    case '{}':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) !== -1;\n      };\n    case '}{':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) === -1;\n      };\n  }\n}","map":{"version":3,"names":["Lib","require","Registry","Axes","pointsAccessorFunction","filterOps","COMPARISON_OPS","INTERVAL_OPS","SET_OPS","exports","moduleType","name","attributes","enabled","valType","dflt","editType","description","join","target","strict","noBlank","arrayOk","operation","values","concat","value","preservegaps","supplyDefaults","transformIn","transformOut","coerce","attr","isArrayOrTypedArray","length","handleCalendarDefaults","getComponentMethod","calcTransform","gd","trace","opts","targetArray","getTargetArray","len","_length","Math","min","targetCalendar","targetcalendar","arrayAttrs","_arrayAttrs","attrTargetCalendar","nestedProperty","get","d2c","getDataToCoordFunc","filterFunc","getFilterFunc","originalArrays","indexToPoints","index","forAllAttrs","fn","j","np","initFn","fillFn","astr","extendDeep","set","Array","val","push","originalPointsAccessor","transforms","i","passed","_indexToPoints","hasArrayValue","isOperationIn","array","indexOf","d2cValue","v","valuecalendar","d2cTarget","coercedValue","map","cv"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/transforms/filter.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../lib');\nvar Registry = require('../registry');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar filterOps = require('../constants/filter_ops');\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\n\nexports.moduleType = 'transform';\n\nexports.name = 'filter';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        editType: 'calc',\n        description: [\n            'Determines whether this filter transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        editType: 'calc',\n        description: [\n            'Sets the filter target by which the filter is applied.',\n\n            'If a string, `target` is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To filter about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.color* to filter',\n            'about the marker color array.',\n\n            'If an array, `target` is then the data array by which the filter is applied.'\n        ].join(' ')\n    },\n    operation: {\n        valType: 'enumerated',\n        values: []\n            .concat(COMPARISON_OPS)\n            .concat(INTERVAL_OPS)\n            .concat(SET_OPS),\n        dflt: '=',\n        editType: 'calc',\n        description: [\n            'Sets the filter operation.',\n\n            '*=* keeps items equal to `value`',\n            '*!=* keeps items not equal to `value`',\n\n            '*<* keeps items less than `value`',\n            '*<=* keeps items less than or equal to `value`',\n\n            '*>* keeps items greater than `value`',\n            '*>=* keeps items greater than or equal to `value`',\n\n            '*[]* keeps items inside `value[0]` to `value[1]` including both bounds',\n            '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds',\n            '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]',\n            '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]',\n\n            '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds',\n            '*)(* keeps items outside `value[0]` to `value[1]`',\n            '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`',\n            '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`',\n\n            '*{}* keeps items present in a set of values',\n            '*}{* keeps items not present in a set of values'\n        ].join(' ')\n    },\n    value: {\n        valType: 'any',\n        dflt: 0,\n        editType: 'calc',\n        description: [\n            'Sets the value or values by which to filter.',\n\n            'Values are expected to be in the same type as the data linked',\n            'to `target`.',\n\n            'When `operation` is set to one of',\n            'the comparison values (' + COMPARISON_OPS + ')',\n            '`value` is expected to be a number or a string.',\n\n            'When `operation` is set to one of the interval values',\n            '(' + INTERVAL_OPS + ')',\n            '`value` is expected to be 2-item array where the first item',\n            'is the lower bound and the second item is the upper bound.',\n\n            'When `operation`, is set to one of the set values',\n            '(' + SET_OPS + ')',\n            '`value` is expected to be an array with as many items as',\n            'the desired set elements.'\n        ].join(' ')\n    },\n    preservegaps: {\n        valType: 'boolean',\n        dflt: false,\n        editType: 'calc',\n        description: [\n            'Determines whether or not gaps in data arrays produced by the filter operation',\n            'are preserved.',\n            'Setting this to *true* might be useful when plotting a line chart',\n            'with `connectgaps` set to *false*.'\n        ].join(' ')\n    },\n    editType: 'calc'\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        var target = coerce('target');\n\n        if(Lib.isArrayOrTypedArray(target) && target.length === 0) {\n            transformOut.enabled = false;\n            return transformOut;\n        }\n\n        coerce('preservegaps');\n        coerce('operation');\n        coerce('value');\n\n        var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n        handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n        handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var targetArray = Lib.getTargetArray(trace, opts);\n    if(!targetArray) return;\n\n    var target = opts.target;\n\n    var len = targetArray.length;\n    if(trace._length) len = Math.min(len, trace._length);\n\n    var targetCalendar = opts.targetcalendar;\n    var arrayAttrs = trace._arrayAttrs;\n    var preservegaps = opts.preservegaps;\n\n    // even if you provide targetcalendar, if target is a string and there\n    // is a calendar attribute matching target it will get used instead.\n    if(typeof target === 'string') {\n        var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n        if(attrTargetCalendar) targetCalendar = attrTargetCalendar;\n    }\n\n    var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n    var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n    var originalArrays = {};\n    var indexToPoints = {};\n    var index = 0;\n\n    function forAllAttrs(fn, index) {\n        for(var j = 0; j < arrayAttrs.length; j++) {\n            var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n            fn(np, index);\n        }\n    }\n\n    var initFn;\n    var fillFn;\n    if(preservegaps) {\n        initFn = function(np) {\n            originalArrays[np.astr] = Lib.extendDeep([], np.get());\n            np.set(new Array(len));\n        };\n        fillFn = function(np, index) {\n            var val = originalArrays[np.astr][index];\n            np.get()[index] = val;\n        };\n    } else {\n        initFn = function(np) {\n            originalArrays[np.astr] = Lib.extendDeep([], np.get());\n            np.set([]);\n        };\n        fillFn = function(np, index) {\n            var val = originalArrays[np.astr][index];\n            np.get().push(val);\n        };\n    }\n\n    // copy all original array attribute values, and clear arrays in trace\n    forAllAttrs(initFn);\n\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n    // loop through filter array, fill trace arrays if passed\n    for(var i = 0; i < len; i++) {\n        var passed = filterFunc(targetArray[i]);\n        if(passed) {\n            forAllAttrs(fillFn, i);\n            indexToPoints[index++] = originalPointsAccessor(i);\n        } else if(preservegaps) index++;\n    }\n\n    opts._indexToPoints = indexToPoints;\n    trace._length = index;\n};\n\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n    var operation = opts.operation;\n    var value = opts.value;\n    var hasArrayValue = Lib.isArrayOrTypedArray(value);\n\n    function isOperationIn(array) {\n        return array.indexOf(operation) !== -1;\n    }\n\n    var d2cValue = function(v) { return d2c(v, 0, opts.valuecalendar); };\n    var d2cTarget = function(v) { return d2c(v, 0, targetCalendar); };\n\n    var coercedValue;\n\n    if(isOperationIn(COMPARISON_OPS)) {\n        coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n    } else if(isOperationIn(INTERVAL_OPS)) {\n        coercedValue = hasArrayValue ?\n            [d2cValue(value[0]), d2cValue(value[1])] :\n            [d2cValue(value), d2cValue(value)];\n    } else if(isOperationIn(SET_OPS)) {\n        coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n    }\n\n    switch(operation) {\n        case '=':\n            return function(v) { return d2cTarget(v) === coercedValue; };\n\n        case '!=':\n            return function(v) { return d2cTarget(v) !== coercedValue; };\n\n        case '<':\n            return function(v) { return d2cTarget(v) < coercedValue; };\n\n        case '<=':\n            return function(v) { return d2cTarget(v) <= coercedValue; };\n\n        case '>':\n            return function(v) { return d2cTarget(v) > coercedValue; };\n\n        case '>=':\n            return function(v) { return d2cTarget(v) >= coercedValue; };\n\n        case '[]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '()':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '[)':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '(]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '][':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case ')(':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case '](':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case ')[':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case '{}':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) !== -1;\n            };\n\n        case '}{':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) === -1;\n            };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}