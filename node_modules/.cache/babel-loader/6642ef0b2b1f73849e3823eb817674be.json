{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Color = require('../../components/color');\nvar extendedColorWayList = {};\nfunction calc(gd, trace) {\n  var cd = [];\n  var fullLayout = gd._fullLayout;\n  var hiddenLabels = fullLayout.hiddenlabels || [];\n  var labels = trace.labels;\n  var colors = trace.marker.colors || [];\n  var vals = trace.values;\n  var len = trace._length;\n  var hasValues = trace._hasValues && len;\n  var i, pt;\n  if (trace.dlabel) {\n    labels = new Array(len);\n    for (i = 0; i < len; i++) {\n      labels[i] = String(trace.label0 + i * trace.dlabel);\n    }\n  }\n  var allThisTraceLabels = {};\n  var pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n  var vTotal = 0;\n  var isAggregated = false;\n  for (i = 0; i < len; i++) {\n    var v, label, hidden;\n    if (hasValues) {\n      v = vals[i];\n      if (!isNumeric(v)) continue;\n      v = +v;\n    } else v = 1;\n    label = labels[i];\n    if (label === undefined || label === '') label = i;\n    label = String(label);\n    var thisLabelIndex = allThisTraceLabels[label];\n    if (thisLabelIndex === undefined) {\n      allThisTraceLabels[label] = cd.length;\n      hidden = hiddenLabels.indexOf(label) !== -1;\n      if (!hidden) vTotal += v;\n      cd.push({\n        v: v,\n        label: label,\n        color: pullColor(colors[i], label),\n        i: i,\n        pts: [i],\n        hidden: hidden\n      });\n    } else {\n      isAggregated = true;\n      pt = cd[thisLabelIndex];\n      pt.v += v;\n      pt.pts.push(i);\n      if (!pt.hidden) vTotal += v;\n      if (pt.color === false && colors[i]) {\n        pt.color = pullColor(colors[i], label);\n      }\n    }\n  }\n\n  // Drop aggregate sums of value 0 or less\n  cd = cd.filter(function (elem) {\n    return elem.v >= 0;\n  });\n  var shouldSort = trace.type === 'funnelarea' ? isAggregated : trace.sort;\n  if (shouldSort) cd.sort(function (a, b) {\n    return b.v - a.v;\n  });\n\n  // include the sum of all values in the first point\n  if (cd[0]) cd[0].vTotal = vTotal;\n  return cd;\n}\nfunction makePullColorFn(colorMap) {\n  return function pullColor(color, id) {\n    if (!color) return false;\n    color = tinycolor(color);\n    if (!color.isValid()) return false;\n    color = Color.addOpacity(color, color.getAlpha());\n    if (!colorMap[id]) colorMap[id] = color;\n    return color;\n  };\n}\n\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\nfunction crossTraceCalc(gd, plotinfo) {\n  // TODO: should we name the second argument opts?\n  var desiredType = (plotinfo || {}).type;\n  if (!desiredType) desiredType = 'pie';\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var colorWay = fullLayout[desiredType + 'colorway'];\n  var colorMap = fullLayout['_' + desiredType + 'colormap'];\n  if (fullLayout['extend' + desiredType + 'colors']) {\n    colorWay = generateExtendedColors(colorWay, extendedColorWayList);\n  }\n  var dfltColorCount = 0;\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var traceType = cd[0].trace.type;\n    if (traceType !== desiredType) continue;\n    for (var j = 0; j < cd.length; j++) {\n      var pt = cd[j];\n      if (pt.color === false) {\n        // have we seen this label and assigned a color to it in a previous trace?\n        if (colorMap[pt.label]) {\n          pt.color = colorMap[pt.label];\n        } else {\n          colorMap[pt.label] = pt.color = colorWay[dfltColorCount % colorWay.length];\n          dfltColorCount++;\n        }\n      }\n    }\n  }\n}\n\n/**\n * pick a default color from the main default set, augmented by\n * itself lighter then darker before repeating\n */\nfunction generateExtendedColors(colorList, extendedColorWays) {\n  var i;\n  var colorString = JSON.stringify(colorList);\n  var colors = extendedColorWays[colorString];\n  if (!colors) {\n    colors = colorList.slice();\n    for (i = 0; i < colorList.length; i++) {\n      colors.push(tinycolor(colorList[i]).lighten(20).toHexString());\n    }\n    for (i = 0; i < colorList.length; i++) {\n      colors.push(tinycolor(colorList[i]).darken(20).toHexString());\n    }\n    extendedColorWays[colorString] = colors;\n  }\n  return colors;\n}\nmodule.exports = {\n  calc: calc,\n  crossTraceCalc: crossTraceCalc,\n  makePullColorFn: makePullColorFn,\n  generateExtendedColors: generateExtendedColors\n};","map":{"version":3,"names":["isNumeric","require","tinycolor","Color","extendedColorWayList","calc","gd","trace","cd","fullLayout","_fullLayout","hiddenLabels","hiddenlabels","labels","colors","marker","vals","values","len","_length","hasValues","_hasValues","i","pt","dlabel","Array","String","label0","allThisTraceLabels","pullColor","makePullColorFn","type","vTotal","isAggregated","v","label","hidden","undefined","thisLabelIndex","length","indexOf","push","color","pts","filter","elem","shouldSort","sort","a","b","colorMap","id","isValid","addOpacity","getAlpha","crossTraceCalc","plotinfo","desiredType","calcdata","colorWay","generateExtendedColors","dfltColorCount","traceType","j","colorList","extendedColorWays","colorString","JSON","stringify","slice","lighten","toHexString","darken","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/pie/calc.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Color = require('../../components/color');\n\nvar extendedColorWayList = {};\n\nfunction calc(gd, trace) {\n    var cd = [];\n\n    var fullLayout = gd._fullLayout;\n    var hiddenLabels = fullLayout.hiddenlabels || [];\n\n    var labels = trace.labels;\n    var colors = trace.marker.colors || [];\n    var vals = trace.values;\n    var len = trace._length;\n    var hasValues = trace._hasValues && len;\n\n    var i, pt;\n\n    if(trace.dlabel) {\n        labels = new Array(len);\n        for(i = 0; i < len; i++) {\n            labels[i] = String(trace.label0 + i * trace.dlabel);\n        }\n    }\n\n    var allThisTraceLabels = {};\n    var pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n    var vTotal = 0;\n    var isAggregated = false;\n\n    for(i = 0; i < len; i++) {\n        var v, label, hidden;\n        if(hasValues) {\n            v = vals[i];\n            if(!isNumeric(v)) continue;\n            v = +v;\n        } else v = 1;\n\n        label = labels[i];\n        if(label === undefined || label === '') label = i;\n        label = String(label);\n\n        var thisLabelIndex = allThisTraceLabels[label];\n        if(thisLabelIndex === undefined) {\n            allThisTraceLabels[label] = cd.length;\n\n            hidden = hiddenLabels.indexOf(label) !== -1;\n\n            if(!hidden) vTotal += v;\n\n            cd.push({\n                v: v,\n                label: label,\n                color: pullColor(colors[i], label),\n                i: i,\n                pts: [i],\n                hidden: hidden\n            });\n        } else {\n            isAggregated = true;\n\n            pt = cd[thisLabelIndex];\n            pt.v += v;\n            pt.pts.push(i);\n            if(!pt.hidden) vTotal += v;\n\n            if(pt.color === false && colors[i]) {\n                pt.color = pullColor(colors[i], label);\n            }\n        }\n    }\n\n    // Drop aggregate sums of value 0 or less\n    cd = cd.filter(function(elem) { return elem.v >= 0; });\n\n    var shouldSort = (trace.type === 'funnelarea') ? isAggregated : trace.sort;\n    if(shouldSort) cd.sort(function(a, b) { return b.v - a.v; });\n\n    // include the sum of all values in the first point\n    if(cd[0]) cd[0].vTotal = vTotal;\n\n    return cd;\n}\n\nfunction makePullColorFn(colorMap) {\n    return function pullColor(color, id) {\n        if(!color) return false;\n\n        color = tinycolor(color);\n        if(!color.isValid()) return false;\n\n        color = Color.addOpacity(color, color.getAlpha());\n        if(!colorMap[id]) colorMap[id] = color;\n\n        return color;\n    };\n}\n\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\nfunction crossTraceCalc(gd, plotinfo) { // TODO: should we name the second argument opts?\n    var desiredType = (plotinfo || {}).type;\n    if(!desiredType) desiredType = 'pie';\n\n    var fullLayout = gd._fullLayout;\n    var calcdata = gd.calcdata;\n    var colorWay = fullLayout[desiredType + 'colorway'];\n    var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n    if(fullLayout['extend' + desiredType + 'colors']) {\n        colorWay = generateExtendedColors(colorWay, extendedColorWayList);\n    }\n    var dfltColorCount = 0;\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var traceType = cd[0].trace.type;\n        if(traceType !== desiredType) continue;\n\n        for(var j = 0; j < cd.length; j++) {\n            var pt = cd[j];\n            if(pt.color === false) {\n                // have we seen this label and assigned a color to it in a previous trace?\n                if(colorMap[pt.label]) {\n                    pt.color = colorMap[pt.label];\n                } else {\n                    colorMap[pt.label] = pt.color = colorWay[dfltColorCount % colorWay.length];\n                    dfltColorCount++;\n                }\n            }\n        }\n    }\n}\n\n/**\n * pick a default color from the main default set, augmented by\n * itself lighter then darker before repeating\n */\nfunction generateExtendedColors(colorList, extendedColorWays) {\n    var i;\n    var colorString = JSON.stringify(colorList);\n    var colors = extendedColorWays[colorString];\n    if(!colors) {\n        colors = colorList.slice();\n\n        for(i = 0; i < colorList.length; i++) {\n            colors.push(tinycolor(colorList[i]).lighten(20).toHexString());\n        }\n\n        for(i = 0; i < colorList.length; i++) {\n            colors.push(tinycolor(colorList[i]).darken(20).toHexString());\n        }\n        extendedColorWays[colorString] = colors;\n    }\n\n    return colors;\n}\n\nmodule.exports = {\n    calc: calc,\n    crossTraceCalc: crossTraceCalc,\n\n    makePullColorFn: makePullColorFn,\n    generateExtendedColors: generateExtendedColors\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AACzC,IAAIC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AAErC,IAAIE,KAAK,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AAE7C,IAAIG,oBAAoB,GAAG,CAAC,CAAC;AAE7B,SAASC,IAAIA,CAACC,EAAE,EAAEC,KAAK,EAAE;EACrB,IAAIC,EAAE,GAAG,EAAE;EAEX,IAAIC,UAAU,GAAGH,EAAE,CAACI,WAAW;EAC/B,IAAIC,YAAY,GAAGF,UAAU,CAACG,YAAY,IAAI,EAAE;EAEhD,IAAIC,MAAM,GAAGN,KAAK,CAACM,MAAM;EACzB,IAAIC,MAAM,GAAGP,KAAK,CAACQ,MAAM,CAACD,MAAM,IAAI,EAAE;EACtC,IAAIE,IAAI,GAAGT,KAAK,CAACU,MAAM;EACvB,IAAIC,GAAG,GAAGX,KAAK,CAACY,OAAO;EACvB,IAAIC,SAAS,GAAGb,KAAK,CAACc,UAAU,IAAIH,GAAG;EAEvC,IAAII,CAAC,EAAEC,EAAE;EAET,IAAGhB,KAAK,CAACiB,MAAM,EAAE;IACbX,MAAM,GAAG,IAAIY,KAAK,CAACP,GAAG,CAAC;IACvB,KAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,EAAEI,CAAC,EAAE,EAAE;MACrBT,MAAM,CAACS,CAAC,CAAC,GAAGI,MAAM,CAACnB,KAAK,CAACoB,MAAM,GAAGL,CAAC,GAAGf,KAAK,CAACiB,MAAM,CAAC;IACvD;EACJ;EAEA,IAAII,kBAAkB,GAAG,CAAC,CAAC;EAC3B,IAAIC,SAAS,GAAGC,eAAe,CAACrB,UAAU,CAAC,GAAG,GAAGF,KAAK,CAACwB,IAAI,GAAG,UAAU,CAAC,CAAC;EAC1E,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,YAAY,GAAG,KAAK;EAExB,KAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,EAAEI,CAAC,EAAE,EAAE;IACrB,IAAIY,CAAC,EAAEC,KAAK,EAAEC,MAAM;IACpB,IAAGhB,SAAS,EAAE;MACVc,CAAC,GAAGlB,IAAI,CAACM,CAAC,CAAC;MACX,IAAG,CAACtB,SAAS,CAACkC,CAAC,CAAC,EAAE;MAClBA,CAAC,GAAG,CAACA,CAAC;IACV,CAAC,MAAMA,CAAC,GAAG,CAAC;IAEZC,KAAK,GAAGtB,MAAM,CAACS,CAAC,CAAC;IACjB,IAAGa,KAAK,KAAKE,SAAS,IAAIF,KAAK,KAAK,EAAE,EAAEA,KAAK,GAAGb,CAAC;IACjDa,KAAK,GAAGT,MAAM,CAACS,KAAK,CAAC;IAErB,IAAIG,cAAc,GAAGV,kBAAkB,CAACO,KAAK,CAAC;IAC9C,IAAGG,cAAc,KAAKD,SAAS,EAAE;MAC7BT,kBAAkB,CAACO,KAAK,CAAC,GAAG3B,EAAE,CAAC+B,MAAM;MAErCH,MAAM,GAAGzB,YAAY,CAAC6B,OAAO,CAACL,KAAK,CAAC,KAAK,CAAC,CAAC;MAE3C,IAAG,CAACC,MAAM,EAAEJ,MAAM,IAAIE,CAAC;MAEvB1B,EAAE,CAACiC,IAAI,CAAC;QACJP,CAAC,EAAEA,CAAC;QACJC,KAAK,EAAEA,KAAK;QACZO,KAAK,EAAEb,SAAS,CAACf,MAAM,CAACQ,CAAC,CAAC,EAAEa,KAAK,CAAC;QAClCb,CAAC,EAAEA,CAAC;QACJqB,GAAG,EAAE,CAACrB,CAAC,CAAC;QACRc,MAAM,EAAEA;MACZ,CAAC,CAAC;IACN,CAAC,MAAM;MACHH,YAAY,GAAG,IAAI;MAEnBV,EAAE,GAAGf,EAAE,CAAC8B,cAAc,CAAC;MACvBf,EAAE,CAACW,CAAC,IAAIA,CAAC;MACTX,EAAE,CAACoB,GAAG,CAACF,IAAI,CAACnB,CAAC,CAAC;MACd,IAAG,CAACC,EAAE,CAACa,MAAM,EAAEJ,MAAM,IAAIE,CAAC;MAE1B,IAAGX,EAAE,CAACmB,KAAK,KAAK,KAAK,IAAI5B,MAAM,CAACQ,CAAC,CAAC,EAAE;QAChCC,EAAE,CAACmB,KAAK,GAAGb,SAAS,CAACf,MAAM,CAACQ,CAAC,CAAC,EAAEa,KAAK,CAAC;MAC1C;IACJ;EACJ;;EAEA;EACA3B,EAAE,GAAGA,EAAE,CAACoC,MAAM,CAAC,UAASC,IAAI,EAAE;IAAE,OAAOA,IAAI,CAACX,CAAC,IAAI,CAAC;EAAE,CAAC,CAAC;EAEtD,IAAIY,UAAU,GAAIvC,KAAK,CAACwB,IAAI,KAAK,YAAY,GAAIE,YAAY,GAAG1B,KAAK,CAACwC,IAAI;EAC1E,IAAGD,UAAU,EAAEtC,EAAE,CAACuC,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOA,CAAC,CAACf,CAAC,GAAGc,CAAC,CAACd,CAAC;EAAE,CAAC,CAAC;;EAE5D;EACA,IAAG1B,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAACwB,MAAM,GAAGA,MAAM;EAE/B,OAAOxB,EAAE;AACb;AAEA,SAASsB,eAAeA,CAACoB,QAAQ,EAAE;EAC/B,OAAO,SAASrB,SAASA,CAACa,KAAK,EAAES,EAAE,EAAE;IACjC,IAAG,CAACT,KAAK,EAAE,OAAO,KAAK;IAEvBA,KAAK,GAAGxC,SAAS,CAACwC,KAAK,CAAC;IACxB,IAAG,CAACA,KAAK,CAACU,OAAO,CAAC,CAAC,EAAE,OAAO,KAAK;IAEjCV,KAAK,GAAGvC,KAAK,CAACkD,UAAU,CAACX,KAAK,EAAEA,KAAK,CAACY,QAAQ,CAAC,CAAC,CAAC;IACjD,IAAG,CAACJ,QAAQ,CAACC,EAAE,CAAC,EAAED,QAAQ,CAACC,EAAE,CAAC,GAAGT,KAAK;IAEtC,OAAOA,KAAK;EAChB,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,cAAcA,CAACjD,EAAE,EAAEkD,QAAQ,EAAE;EAAE;EACpC,IAAIC,WAAW,GAAG,CAACD,QAAQ,IAAI,CAAC,CAAC,EAAEzB,IAAI;EACvC,IAAG,CAAC0B,WAAW,EAAEA,WAAW,GAAG,KAAK;EAEpC,IAAIhD,UAAU,GAAGH,EAAE,CAACI,WAAW;EAC/B,IAAIgD,QAAQ,GAAGpD,EAAE,CAACoD,QAAQ;EAC1B,IAAIC,QAAQ,GAAGlD,UAAU,CAACgD,WAAW,GAAG,UAAU,CAAC;EACnD,IAAIP,QAAQ,GAAGzC,UAAU,CAAC,GAAG,GAAGgD,WAAW,GAAG,UAAU,CAAC;EAEzD,IAAGhD,UAAU,CAAC,QAAQ,GAAGgD,WAAW,GAAG,QAAQ,CAAC,EAAE;IAC9CE,QAAQ,GAAGC,sBAAsB,CAACD,QAAQ,EAAEvD,oBAAoB,CAAC;EACrE;EACA,IAAIyD,cAAc,GAAG,CAAC;EAEtB,KAAI,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAACnB,MAAM,EAAEjB,CAAC,EAAE,EAAE;IACrC,IAAId,EAAE,GAAGkD,QAAQ,CAACpC,CAAC,CAAC;IACpB,IAAIwC,SAAS,GAAGtD,EAAE,CAAC,CAAC,CAAC,CAACD,KAAK,CAACwB,IAAI;IAChC,IAAG+B,SAAS,KAAKL,WAAW,EAAE;IAE9B,KAAI,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvD,EAAE,CAAC+B,MAAM,EAAEwB,CAAC,EAAE,EAAE;MAC/B,IAAIxC,EAAE,GAAGf,EAAE,CAACuD,CAAC,CAAC;MACd,IAAGxC,EAAE,CAACmB,KAAK,KAAK,KAAK,EAAE;QACnB;QACA,IAAGQ,QAAQ,CAAC3B,EAAE,CAACY,KAAK,CAAC,EAAE;UACnBZ,EAAE,CAACmB,KAAK,GAAGQ,QAAQ,CAAC3B,EAAE,CAACY,KAAK,CAAC;QACjC,CAAC,MAAM;UACHe,QAAQ,CAAC3B,EAAE,CAACY,KAAK,CAAC,GAAGZ,EAAE,CAACmB,KAAK,GAAGiB,QAAQ,CAACE,cAAc,GAAGF,QAAQ,CAACpB,MAAM,CAAC;UAC1EsB,cAAc,EAAE;QACpB;MACJ;IACJ;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA,SAASD,sBAAsBA,CAACI,SAAS,EAAEC,iBAAiB,EAAE;EAC1D,IAAI3C,CAAC;EACL,IAAI4C,WAAW,GAAGC,IAAI,CAACC,SAAS,CAACJ,SAAS,CAAC;EAC3C,IAAIlD,MAAM,GAAGmD,iBAAiB,CAACC,WAAW,CAAC;EAC3C,IAAG,CAACpD,MAAM,EAAE;IACRA,MAAM,GAAGkD,SAAS,CAACK,KAAK,CAAC,CAAC;IAE1B,KAAI/C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0C,SAAS,CAACzB,MAAM,EAAEjB,CAAC,EAAE,EAAE;MAClCR,MAAM,CAAC2B,IAAI,CAACvC,SAAS,CAAC8D,SAAS,CAAC1C,CAAC,CAAC,CAAC,CAACgD,OAAO,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;IAClE;IAEA,KAAIjD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0C,SAAS,CAACzB,MAAM,EAAEjB,CAAC,EAAE,EAAE;MAClCR,MAAM,CAAC2B,IAAI,CAACvC,SAAS,CAAC8D,SAAS,CAAC1C,CAAC,CAAC,CAAC,CAACkD,MAAM,CAAC,EAAE,CAAC,CAACD,WAAW,CAAC,CAAC,CAAC;IACjE;IACAN,iBAAiB,CAACC,WAAW,CAAC,GAAGpD,MAAM;EAC3C;EAEA,OAAOA,MAAM;AACjB;AAEA2D,MAAM,CAACC,OAAO,GAAG;EACbrE,IAAI,EAAEA,IAAI;EACVkD,cAAc,EAAEA,cAAc;EAE9BzB,eAAe,EAAEA,eAAe;EAChC8B,sBAAsB,EAAEA;AAC5B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}