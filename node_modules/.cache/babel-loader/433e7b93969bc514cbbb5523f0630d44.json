{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\nvar tickText = require('../../plots/cartesian/axes').tickText;\nvar uniformText = require('./uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar style = require('./style');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar attributes = require('./attributes');\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nvar TEXTPAD = constants.TEXTPAD;\nfunction keyFunc(d) {\n  return d.id;\n}\nfunction getKeyFunc(trace) {\n  if (trace.ids) {\n    return keyFunc;\n  }\n}\n\n// Returns -1 if v < 0, 1 if v > 0, and 0 if v == 0\nfunction sign(v) {\n  return (v > 0) - (v < 0);\n}\n\n// Returns 1 if a < b and -1 otherwise\n// (For the purposes of this module we don't care about the case where a == b)\nfunction dirSign(a, b) {\n  return a < b ? 1 : -1;\n}\nfunction getXY(di, xa, ya, isHorizontal) {\n  var s = [];\n  var p = [];\n  var sAxis = isHorizontal ? xa : ya;\n  var pAxis = isHorizontal ? ya : xa;\n  s[0] = sAxis.c2p(di.s0, true);\n  p[0] = pAxis.c2p(di.p0, true);\n  s[1] = sAxis.c2p(di.s1, true);\n  p[1] = pAxis.c2p(di.p1, true);\n  return isHorizontal ? [s, p] : [p, s];\n}\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n  if (!fullLayout.uniformtext.mode && hasTransition(opts)) {\n    var onComplete;\n    if (makeOnCompleteCallback) {\n      onComplete = makeOnCompleteCallback();\n    }\n    return selection.transition().duration(opts.duration).ease(opts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n  } else {\n    return selection;\n  }\n}\nfunction hasTransition(transitionOpts) {\n  return transitionOpts && transitionOpts.duration > 0;\n}\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var isStatic = gd._context.staticPlot;\n  if (!opts) {\n    opts = {\n      mode: fullLayout.barmode,\n      norm: fullLayout.barmode,\n      gap: fullLayout.bargap,\n      groupgap: fullLayout.bargroupgap\n    };\n\n    // don't clear bar when this is called from waterfall or funnel\n    clearMinTextSize('bar', fullLayout);\n  }\n  var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isWaterfall = trace.type === 'waterfall';\n    var isFunnel = trace.type === 'funnel';\n    var isHistogram = trace.type === 'histogram';\n    var isBar = trace.type === 'bar';\n    var shouldDisplayZeros = isBar || isFunnel;\n    var adjustPixel = 0;\n    if (isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n      adjustPixel = trace.connector.line.width / 2;\n    }\n    var isHorizontal = trace.orientation === 'h';\n    var withTransition = hasTransition(opts);\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var keyFunc = getKeyFunc(trace);\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n    bars.enter().append('g').classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di, i) {\n      var bar = d3.select(this);\n\n      // now display the bar\n      // clipped xf/yf (2nd arg true): non-positive\n      // log values go off-screen by plotwidth\n      // so you see them continue if you drag the plot\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x0 = xy[0][0];\n      var x1 = xy[0][1];\n      var y0 = xy[1][0];\n      var y1 = xy[1][1];\n\n      // empty bars\n      var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0;\n\n      // display zeros if line.width > 0\n      if (isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n        isBlank = false;\n      }\n\n      // skip nulls\n      if (!isBlank) {\n        isBlank = !isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1);\n      }\n\n      // record isBlank\n      di.isBlank = isBlank;\n\n      // for blank bars, ensure start and end positions are equal - important for smooth transitions\n      if (isBlank) {\n        if (isHorizontal) {\n          x1 = x0;\n        } else {\n          y1 = y0;\n        }\n      }\n\n      // in waterfall mode `between` we need to adjust bar end points to match the connector width\n      if (adjustPixel && !isBlank) {\n        if (isHorizontal) {\n          x0 -= dirSign(x0, x1) * adjustPixel;\n          x1 += dirSign(x0, x1) * adjustPixel;\n        } else {\n          y0 -= dirSign(y0, y1) * adjustPixel;\n          y1 += dirSign(y0, y1) * adjustPixel;\n        }\n      }\n      var lw;\n      var mc;\n      if (trace.type === 'waterfall') {\n        if (!isBlank) {\n          var cont = trace[di.dir].marker;\n          lw = cont.line.width;\n          mc = cont.color;\n        }\n      } else {\n        lw = helpers.getLineWidth(trace, di);\n        mc = di.mc || trace.marker.color;\n      }\n      function roundWithLine(v) {\n        var offset = d3.round(lw / 2 % 1, 2);\n\n        // if there are explicit gaps, don't round,\n        // it can make the gaps look crappy\n        return opts.gap === 0 && opts.groupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;\n      }\n      function expandToVisible(v, vc, hideZeroSpan) {\n        if (hideZeroSpan && v === vc) {\n          // should not expand zero span bars\n          // when start and end positions are identical\n          // i.e. for vertical when y0 === y1\n          // and for horizontal when x0 === x1\n          return v;\n        }\n\n        // if it's not in danger of disappearing entirely,\n        // round more precisely\n        return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n        // but if it's very thin, expand it so it's\n        // necessarily visible, even if it might overlap\n        // its neighbor\n        v > vc ? Math.ceil(v) : Math.floor(v);\n      }\n      var op = Color.opacity(mc);\n      var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;\n      if (!gd._context.staticPlot) {\n        // if bars are not fully opaque or they have a line\n        // around them, round to integer pixels, mainly for\n        // safari so we prevent overlaps from its expansive\n        // pixelation. if the bars ARE fully opaque and have\n        // no line, expand to a full pixel to make sure we\n        // can see them\n        x0 = fixpx(x0, x1, isHorizontal);\n        x1 = fixpx(x1, x0, isHorizontal);\n        y0 = fixpx(y0, y1, !isHorizontal);\n        y1 = fixpx(y1, y0, !isHorizontal);\n      }\n\n      // Function to convert from size axis values to pixels\n      var c2p = isHorizontal ? xa.c2p : ya.c2p;\n\n      // Decide whether to use upper or lower bound of current bar stack\n      // as reference point for rounding\n      var outerBound;\n      if (di.s0 > 0) {\n        outerBound = di._sMax;\n      } else if (di.s0 < 0) {\n        outerBound = di._sMin;\n      } else {\n        outerBound = di.s1 > 0 ? di._sMax : di._sMin;\n      }\n\n      // Calculate corner radius of bar in pixels\n      function calcCornerRadius(crValue, crForm) {\n        if (!crValue) return 0;\n        var barWidth = isHorizontal ? Math.abs(y1 - y0) : Math.abs(x1 - x0);\n        var barLength = isHorizontal ? Math.abs(x1 - x0) : Math.abs(y1 - y0);\n        var stackedBarTotalLength = fixpx(Math.abs(c2p(outerBound, true) - c2p(0, true)));\n        var maxRadius = di.hasB ? Math.min(barWidth / 2, barLength / 2) : Math.min(barWidth / 2, stackedBarTotalLength);\n        var crPx;\n        if (crForm === '%') {\n          // If radius is given as a % string, convert to number of pixels\n          var crPercent = Math.min(50, crValue);\n          crPx = barWidth * (crPercent / 100);\n        } else {\n          // Otherwise, it's already a number of pixels, use the given value\n          crPx = crValue;\n        }\n        return fixpx(Math.max(Math.min(crPx, maxRadius), 0));\n      }\n      // Exclude anything which is not explicitly a bar or histogram chart from rounding\n      var r = isBar || isHistogram ? calcCornerRadius(t.cornerradiusvalue, t.cornerradiusform) : 0;\n      // Construct path string for bar\n      var path, h;\n      // Default rectangular path (used if no rounding)\n      var rectanglePath = 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z';\n      var overhead = 0;\n      if (r && di.s) {\n        // Bar has cornerradius, and nonzero size\n        // Check amount of 'overhead' (bars stacked above this one)\n        // to see whether we need to round or not\n        var refPoint = sign(di.s0) === 0 || sign(di.s) === sign(di.s0) ? di.s1 : di.s0;\n        overhead = fixpx(!di.hasB ? Math.abs(c2p(outerBound, true) - c2p(refPoint, true)) : 0);\n        if (overhead < r) {\n          // Calculate parameters for rounded corners\n          var xdir = dirSign(x0, x1);\n          var ydir = dirSign(y0, y1);\n          // Sweep direction for rounded corner arcs\n          var cornersweep = xdir === -ydir ? 1 : 0;\n          if (isHorizontal) {\n            // Horizontal bars\n            if (di.hasB) {\n              // Floating base: Round 1st & 2nd, and 3rd & 4th corners\n              path = 'M' + (x0 + r * xdir) + ',' + y0 + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x0 + ',' + (y0 + r * ydir) + 'V' + (y1 - r * ydir) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x0 + r * xdir) + ',' + y1 + 'H' + (x1 - r * xdir) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x1 + ',' + (y1 - r * ydir) + 'V' + (y0 + r * ydir) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x1 - r * xdir) + ',' + y0 + 'Z';\n            } else {\n              // Base on axis: Round 3rd and 4th corners\n\n              // Helper variables to help with extending rounding down to lower bars\n              h = Math.abs(x1 - x0) + overhead;\n              var dy1 = h < r ? r - Math.sqrt(h * (2 * r - h)) : 0;\n              var dy2 = overhead > 0 ? Math.sqrt(overhead * (2 * r - overhead)) : 0;\n              var xminfunc = xdir > 0 ? Math.max : Math.min;\n              path = 'M' + x0 + ',' + y0 + 'V' + (y1 - dy1 * ydir) + 'H' + xminfunc(x1 - (r - overhead) * xdir, x0) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x1 + ',' + (y1 - r * ydir - dy2) + 'V' + (y0 + r * ydir + dy2) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + xminfunc(x1 - (r - overhead) * xdir, x0) + ',' + (y0 + dy1 * ydir) + 'Z';\n            }\n          } else {\n            // Vertical bars\n            if (di.hasB) {\n              // Floating base: Round 1st & 4th, and 2nd & 3rd corners\n              path = 'M' + (x0 + r * xdir) + ',' + y0 + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x0 + ',' + (y0 + r * ydir) + 'V' + (y1 - r * ydir) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x0 + r * xdir) + ',' + y1 + 'H' + (x1 - r * xdir) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x1 + ',' + (y1 - r * ydir) + 'V' + (y0 + r * ydir) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x1 - r * xdir) + ',' + y0 + 'Z';\n            } else {\n              // Base on axis: Round 2nd and 3rd corners\n\n              // Helper variables to help with extending rounding down to lower bars\n              h = Math.abs(y1 - y0) + overhead;\n              var dx1 = h < r ? r - Math.sqrt(h * (2 * r - h)) : 0;\n              var dx2 = overhead > 0 ? Math.sqrt(overhead * (2 * r - overhead)) : 0;\n              var yminfunc = ydir > 0 ? Math.max : Math.min;\n              path = 'M' + (x0 + dx1 * xdir) + ',' + y0 + 'V' + yminfunc(y1 - (r - overhead) * ydir, y0) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x0 + r * xdir - dx2) + ',' + y1 + 'H' + (x1 - r * xdir + dx2) + 'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x1 - dx1 * xdir) + ',' + yminfunc(y1 - (r - overhead) * ydir, y0) + 'V' + y0 + 'Z';\n            }\n          }\n        } else {\n          // There is a cornerradius, but bar is too far down the stack to be rounded; just draw a rectangle\n          path = rectanglePath;\n        }\n      } else {\n        // No cornerradius, just draw a rectangle\n        path = rectanglePath;\n      }\n      var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n      sel.style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').attr('d', isNaN((x1 - x0) * (y1 - y0)) || isBlank && gd._context.staticPlot ? 'M0,0Z' : path).call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n      if (!fullLayout.uniformtext.mode && withTransition) {\n        var styleFns = Drawing.makePointStyleFns(trace);\n        Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n      }\n      appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, r, overhead, opts, makeOnCompleteCallback);\n      if (plotinfo.layerClipId) {\n        Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n      }\n    });\n\n    // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n  });\n\n  // error bars are on the top\n  Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, r, overhead, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var textPosition;\n  function appendTextNode(bar, text, font) {\n    var textSelection = Lib.ensureSingle(bar, 'text').text(text).attr({\n      class: 'bartext bartext-' + textPosition,\n      'text-anchor': 'middle',\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      'data-notex': 1\n    }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    return textSelection;\n  }\n\n  // get trace attributes\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var text = getText(fullLayout, cd, i, xa, ya);\n  textPosition = getTextPosition(trace, i);\n\n  // compute text position\n  var inStackOrRelativeMode = opts.mode === 'stack' || opts.mode === 'relative';\n  var calcBar = cd[i];\n  var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n  var hasB = calcBar.hasB;\n  var barIsRounded = r && r - overhead > TEXTPAD;\n  if (!text || textPosition === 'none' || (calcBar.isBlank || x0 === x1 || y0 === y1) && (textPosition === 'auto' || textPosition === 'inside')) {\n    bar.select('text').remove();\n    return;\n  }\n  var layoutFont = fullLayout.font;\n  var barColor = style.getBarColor(cd[i], trace);\n  var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n  var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n  var insidetextanchor = trace.insidetextanchor || 'end';\n\n  // Special case: don't use the c2p(v, true) value on log size axes,\n  // so that we can get correctly inside text scaling\n  var di = bar.datum();\n  if (isHorizontal) {\n    if (xa.type === 'log' && di.s0 <= 0) {\n      if (xa.range[0] < xa.range[1]) {\n        x0 = 0;\n      } else {\n        x0 = xa._length;\n      }\n    }\n  } else {\n    if (ya.type === 'log' && di.s0 <= 0) {\n      if (ya.range[0] < ya.range[1]) {\n        y0 = ya._length;\n      } else {\n        y0 = 0;\n      }\n    }\n  }\n\n  // Compute width and height of bar\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n\n  // padding excluded\n  var barWidth = lx - 2 * TEXTPAD;\n  var barHeight = ly - 2 * TEXTPAD;\n  var textSelection;\n  var textBB;\n  var textWidth;\n  var textHeight;\n  var font;\n  if (textPosition === 'outside') {\n    if (!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n  }\n  if (textPosition === 'auto') {\n    if (isOutmostBar) {\n      // draw text using insideTextFont and check if it fits inside bar\n      textPosition = 'inside';\n      font = Lib.ensureUniformFontSize(gd, insideTextFont);\n      textSelection = appendTextNode(bar, text, font);\n      textBB = Drawing.bBox(textSelection.node());\n      textWidth = textBB.width;\n      textHeight = textBB.height;\n      var textHasSize = textWidth > 0 && textHeight > 0;\n      var fitsInside;\n      if (barIsRounded) {\n        // If bar is rounded, check if text fits between rounded corners\n        if (hasB) {\n          fitsInside = textfitsInsideBar(barWidth - 2 * r, barHeight, textWidth, textHeight, isHorizontal) || textfitsInsideBar(barWidth, barHeight - 2 * r, textWidth, textHeight, isHorizontal);\n        } else if (isHorizontal) {\n          fitsInside = textfitsInsideBar(barWidth - (r - overhead), barHeight, textWidth, textHeight, isHorizontal) || textfitsInsideBar(barWidth, barHeight - 2 * (r - overhead), textWidth, textHeight, isHorizontal);\n        } else {\n          fitsInside = textfitsInsideBar(barWidth, barHeight - (r - overhead), textWidth, textHeight, isHorizontal) || textfitsInsideBar(barWidth - 2 * (r - overhead), barHeight, textWidth, textHeight, isHorizontal);\n        }\n      } else {\n        fitsInside = textfitsInsideBar(barWidth, barHeight, textWidth, textHeight, isHorizontal);\n      }\n      if (textHasSize && fitsInside) {\n        textPosition = 'inside';\n      } else {\n        textPosition = 'outside';\n        textSelection.remove();\n        textSelection = null;\n      }\n    } else {\n      textPosition = 'inside';\n    }\n  }\n  if (!textSelection) {\n    font = Lib.ensureUniformFontSize(gd, textPosition === 'outside' ? outsideTextFont : insideTextFont);\n    textSelection = appendTextNode(bar, text, font);\n    var currentTransform = textSelection.attr('transform');\n    textSelection.attr('transform', '');\n    textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n    textSelection.attr('transform', currentTransform);\n    if (textWidth <= 0 || textHeight <= 0) {\n      textSelection.remove();\n      return;\n    }\n  }\n  var angle = trace.textangle;\n\n  // compute text transform\n  var transform, constrained;\n  if (textPosition === 'outside') {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n    transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle\n    });\n  } else {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n    transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle,\n      anchor: insidetextanchor,\n      hasB: hasB,\n      r: r,\n      overhead: overhead\n    });\n  }\n  transform.fontSize = font.size;\n  recordMinTextSize(trace.type === 'histogram' ? 'bar' : trace.type, transform, fullLayout);\n  calcBar.transform = transform;\n  var s = transition(textSelection, fullLayout, opts, makeOnCompleteCallback);\n  Lib.setTransormAndDisplay(s, transform);\n}\nfunction textfitsInsideBar(barWidth, barHeight, textWidth, textHeight, isHorizontal) {\n  if (barWidth < 0 || barHeight < 0) return false;\n  var fitsInside = textWidth <= barWidth && textHeight <= barHeight;\n  var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;\n  var fitsInsideIfShrunk = isHorizontal ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);\n  return fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk;\n}\nfunction getRotateFromAngle(angle) {\n  return angle === 'auto' ? 0 : angle;\n}\nfunction getRotatedTextSize(textBB, rotate) {\n  var a = Math.PI / 180 * rotate;\n  var absSin = Math.abs(Math.sin(a));\n  var absCos = Math.abs(Math.cos(a));\n  return {\n    x: textBB.width * absCos + textBB.height * absSin,\n    y: textBB.width * absSin + textBB.height * absCos\n  };\n}\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var anchor = opts.anchor;\n  var isEnd = anchor === 'end';\n  var isStart = anchor === 'start';\n  var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n  var toRight = (leftToRight + 1) / 2;\n  var toLeft = 1 - toRight;\n  var hasB = opts.hasB;\n  var r = opts.r;\n  var overhead = opts.overhead;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n\n  // compute remaining space\n  var textpad = lx > 2 * TEXTPAD && ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  lx -= 2 * textpad;\n  ly -= 2 * textpad;\n  var rotate = getRotateFromAngle(angle);\n  if (angle === 'auto' && !(textWidth <= lx && textHeight <= ly) && (textWidth > lx || textHeight > ly) && (!(textWidth > ly || textHeight > lx) || textWidth < textHeight !== lx < ly)) {\n    rotate += 90;\n  }\n  var t = getRotatedTextSize(textBB, rotate);\n  var scale, padForRounding;\n  // Scale text for rounded bars\n  if (r && r - overhead > TEXTPAD) {\n    var scaleAndPad = scaleTextForRoundedBar(x0, x1, y0, y1, t, r, overhead, isHorizontal, hasB);\n    scale = scaleAndPad.scale;\n    padForRounding = scaleAndPad.pad;\n    // Scale text for non-rounded bars\n  } else {\n    scale = 1;\n    if (constrained) {\n      scale = Math.min(1, lx / t.x, ly / t.y);\n    }\n    padForRounding = 0;\n  }\n\n  // compute text and target positions\n  var textX = textBB.left * toLeft + textBB.right * toRight;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + TEXTPAD) * toLeft + (x1 - TEXTPAD) * toRight;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n  if (isStart || isEnd) {\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    if (r && (isEnd || hasB)) {\n      textpad += padForRounding;\n    }\n    var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n    if (isHorizontal) {\n      if (isStart) {\n        targetX = x0 + dir * textpad;\n        anchorX = -dir * extrapad;\n      } else {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n      }\n    } else {\n      if (isStart) {\n        targetY = y0 + dir * textpad;\n        anchorY = -dir * extrapad;\n      } else {\n        targetY = y1 - dir * textpad;\n        anchorY = dir * extrapad;\n      }\n    }\n  }\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\nfunction scaleTextForRoundedBar(x0, x1, y0, y1, t, r, overhead, isHorizontal, hasB) {\n  var barWidth = Math.max(0, Math.abs(x1 - x0) - 2 * TEXTPAD);\n  var barHeight = Math.max(0, Math.abs(y1 - y0) - 2 * TEXTPAD);\n  var R = r - TEXTPAD;\n  var clippedR = overhead ? R - Math.sqrt(R * R - (R - overhead) * (R - overhead)) : R;\n  var rX = hasB ? R * 2 : isHorizontal ? R - overhead : 2 * clippedR;\n  var rY = hasB ? R * 2 : isHorizontal ? 2 * clippedR : R - overhead;\n  var a, b, c;\n  var scale, pad;\n  if (t.y / t.x >= barHeight / (barWidth - rX)) {\n    // Case 1 (Tall text)\n    scale = barHeight / t.y;\n  } else if (t.y / t.x <= (barHeight - rY) / barWidth) {\n    // Case 2 (Wide text)\n    scale = barWidth / t.x;\n  } else if (!hasB && isHorizontal) {\n    // Case 3a (Quadratic case, two side corners are rounded)\n    a = t.x * t.x + t.y * t.y / 4;\n    b = -2 * t.x * (barWidth - R) - t.y * (barHeight / 2 - R);\n    c = (barWidth - R) * (barWidth - R) + (barHeight / 2 - R) * (barHeight / 2 - R) - R * R;\n    scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n  } else if (!hasB) {\n    // Case 3b (Quadratic case, two top/bottom corners are rounded)\n    a = t.x * t.x / 4 + t.y * t.y;\n    b = -t.x * (barWidth / 2 - R) - 2 * t.y * (barHeight - R);\n    c = (barWidth / 2 - R) * (barWidth / 2 - R) + (barHeight - R) * (barHeight - R) - R * R;\n    scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n  } else {\n    // Case 4 (Quadratic case, all four corners are rounded)\n    a = (t.x * t.x + t.y * t.y) / 4;\n    b = -t.x * (barWidth / 2 - R) - t.y * (barHeight / 2 - R);\n    c = (barWidth / 2 - R) * (barWidth / 2 - R) + (barHeight / 2 - R) * (barHeight / 2 - R) - R * R;\n    scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n  }\n\n  // Scale should not be larger than 1\n  scale = Math.min(1, scale);\n  if (isHorizontal) {\n    pad = Math.max(0, R - Math.sqrt(Math.max(0, R * R - (R - (barHeight - t.y * scale) / 2) * (R - (barHeight - t.y * scale) / 2))) - overhead);\n  } else {\n    pad = Math.max(0, R - Math.sqrt(Math.max(0, R * R - (R - (barWidth - t.x * scale) / 2) * (R - (barWidth - t.x * scale) / 2))) - overhead);\n  }\n  return {\n    scale: scale,\n    pad: pad\n  };\n}\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n  var textpad;\n  // Keep the padding so the text doesn't sit right against\n  // the bars, but don't factor it into barWidth\n  if (isHorizontal) {\n    textpad = ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  } else {\n    textpad = lx > 2 * TEXTPAD ? TEXTPAD : 0;\n  }\n\n  // compute rotate and scale\n  var scale = 1;\n  if (constrained) {\n    scale = isHorizontal ? Math.min(1, ly / textHeight) : Math.min(1, lx / textWidth);\n  }\n  var rotate = getRotateFromAngle(angle);\n  var t = getRotatedTextSize(textBB, rotate);\n\n  // compute text and target positions\n  var extrapad = (isHorizontal ? t.x : t.y) / 2;\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + x1) / 2;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n  var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n  if (isHorizontal) {\n    targetX = x1 - dir * textpad;\n    anchorX = dir * extrapad;\n  } else {\n    targetY = y1 + dir * textpad;\n    anchorY = -dir * extrapad;\n  }\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\nfunction getText(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = trace.texttemplate;\n  var value;\n  if (texttemplate) {\n    value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n  } else if (trace.textinfo) {\n    value = calcTextinfo(cd, index, xa, ya);\n  } else {\n    value = helpers.getValue(trace.text, index);\n  }\n  return helpers.coerceString(attributeText, value);\n}\nfunction getTextPosition(trace, index) {\n  var value = helpers.getValue(trace.textposition, index);\n  return helpers.coerceEnumerated(attributeTextPosition, value);\n}\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n  if (!texttemplate) return '';\n  var isHistogram = trace.type === 'histogram';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n  var isHorizontal = trace.orientation === 'h';\n  var pLetter, pAxis;\n  var vLetter, vAxis;\n  if (isHorizontal) {\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  }\n  function formatLabel(u) {\n    return tickText(pAxis, pAxis.c2l(u), true).text;\n  }\n  function formatNumber(v) {\n    return tickText(vAxis, vAxis.c2l(v), true).text;\n  }\n  var cdi = cd[index];\n  var obj = {};\n  obj.label = cdi.p;\n  obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n  var tx = Lib.castOption(trace, cdi.i, 'text');\n  if (tx === 0 || tx) obj.text = tx;\n  obj.value = cdi.s;\n  obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n  var pt = {};\n  appendArrayPointValue(pt, trace, cdi.i);\n  if (isHistogram || pt.x === undefined) pt.x = isHorizontal ? obj.value : obj.label;\n  if (isHistogram || pt.y === undefined) pt.y = isHorizontal ? obj.label : obj.value;\n  if (isHistogram || pt.xLabel === undefined) pt.xLabel = isHorizontal ? obj.valueLabel : obj.labelLabel;\n  if (isHistogram || pt.yLabel === undefined) pt.yLabel = isHorizontal ? obj.labelLabel : obj.valueLabel;\n  if (isWaterfall) {\n    obj.delta = +cdi.rawS || cdi.s;\n    obj.deltaLabel = formatNumber(obj.delta);\n    obj.final = cdi.v;\n    obj.finalLabel = formatNumber(obj.final);\n    obj.initial = obj.final - obj.delta;\n    obj.initialLabel = formatNumber(obj.initial);\n  }\n  if (isFunnel) {\n    obj.value = cdi.s;\n    obj.valueLabel = formatNumber(obj.value);\n    obj.percentInitial = cdi.begR;\n    obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n    obj.percentPrevious = cdi.difR;\n    obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n    obj.percentTotal = cdi.sumR;\n    obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n  }\n  var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  if (customdata) obj.customdata = customdata;\n  return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\nfunction calcTextinfo(cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n  function formatLabel(u) {\n    var pAxis = isHorizontal ? ya : xa;\n    return tickText(pAxis, u, true).text;\n  }\n  function formatNumber(v) {\n    var sAxis = isHorizontal ? xa : ya;\n    return tickText(sAxis, +v, true).text;\n  }\n  var textinfo = trace.textinfo;\n  var cdi = cd[index];\n  var parts = textinfo.split('+');\n  var text = [];\n  var tx;\n  var hasFlag = function (flag) {\n    return parts.indexOf(flag) !== -1;\n  };\n  if (hasFlag('label')) {\n    text.push(formatLabel(cd[index].p));\n  }\n  if (hasFlag('text')) {\n    tx = Lib.castOption(trace, cdi.i, 'text');\n    if (tx === 0 || tx) text.push(tx);\n  }\n  if (isWaterfall) {\n    var delta = +cdi.rawS || cdi.s;\n    var final = cdi.v;\n    var initial = final - delta;\n    if (hasFlag('initial')) text.push(formatNumber(initial));\n    if (hasFlag('delta')) text.push(formatNumber(delta));\n    if (hasFlag('final')) text.push(formatNumber(final));\n  }\n  if (isFunnel) {\n    if (hasFlag('value')) text.push(formatNumber(cdi.s));\n    var nPercent = 0;\n    if (hasFlag('percent initial')) nPercent++;\n    if (hasFlag('percent previous')) nPercent++;\n    if (hasFlag('percent total')) nPercent++;\n    var hasMultiplePercents = nPercent > 1;\n    if (hasFlag('percent initial')) {\n      tx = Lib.formatPercent(cdi.begR);\n      if (hasMultiplePercents) tx += ' of initial';\n      text.push(tx);\n    }\n    if (hasFlag('percent previous')) {\n      tx = Lib.formatPercent(cdi.difR);\n      if (hasMultiplePercents) tx += ' of previous';\n      text.push(tx);\n    }\n    if (hasFlag('percent total')) {\n      tx = Lib.formatPercent(cdi.sumR);\n      if (hasMultiplePercents) tx += ' of total';\n      text.push(tx);\n    }\n  }\n  return text.join('<br>');\n}\nmodule.exports = {\n  plot: plot,\n  toMoveInsideBar: toMoveInsideBar\n};","map":{"version":3,"names":["d3","require","isNumeric","Lib","svgTextUtils","Color","Drawing","Registry","tickText","uniformText","recordMinTextSize","clearMinTextSize","style","helpers","constants","attributes","attributeText","text","attributeTextPosition","textposition","appendArrayPointValue","TEXTPAD","keyFunc","d","id","getKeyFunc","trace","ids","sign","v","dirSign","a","b","getXY","di","xa","ya","isHorizontal","s","p","sAxis","pAxis","c2p","s0","p0","s1","p1","transition","selection","fullLayout","opts","makeOnCompleteCallback","uniformtext","mode","hasTransition","onComplete","duration","ease","easing","each","transitionOpts","plot","gd","plotinfo","cdModule","traceLayer","xaxis","yaxis","_fullLayout","isStatic","_context","staticPlot","barmode","norm","gap","bargap","groupgap","bargroupgap","bartraces","makeTraceGroups","cd","plotGroup","select","t","isWaterfall","type","isFunnel","isHistogram","isBar","shouldDisplayZeros","adjustPixel","connector","visible","line","width","orientation","withTransition","pointGroup","ensureSingle","bars","selectAll","data","identity","enter","append","classed","exit","remove","i","bar","xy","x0","x1","y0","y1","isBlank","getLineWidth","lw","mc","cont","dir","marker","color","roundWithLine","offset","round","Math","expandToVisible","vc","hideZeroSpan","abs","ceil","floor","op","opacity","fixpx","outerBound","_sMax","_sMin","calcCornerRadius","crValue","crForm","barWidth","barLength","stackedBarTotalLength","maxRadius","hasB","min","crPx","crPercent","max","r","cornerradiusvalue","cornerradiusform","path","h","rectanglePath","overhead","refPoint","xdir","ydir","cornersweep","dy1","sqrt","dy2","xminfunc","dx1","dx2","yminfunc","sel","attr","isNaN","call","setClipUrl","layerClipId","styleFns","makePointStyleFns","singlePointStyle","appendBarText","hideOutsideRangePoint","xcalendar","ycalendar","hasClipOnAxisFalse","cliponaxis","getComponentMethod","textPosition","appendTextNode","font","textSelection","class","convertToTspans","getText","getTextPosition","inStackOrRelativeMode","calcBar","isOutmostBar","_outmost","barIsRounded","layoutFont","barColor","getBarColor","insideTextFont","getInsideTextFont","outsideTextFont","getOutsideTextFont","insidetextanchor","datum","range","_length","lx","ly","barHeight","textBB","textWidth","textHeight","ensureUniformFontSize","bBox","node","height","textHasSize","fitsInside","textfitsInsideBar","currentTransform","angle","textangle","transform","constrained","constraintext","toMoveOutsideBar","toMoveInsideBar","anchor","fontSize","size","setTransormAndDisplay","fitsInsideIfRotated","fitsInsideIfShrunk","getRotateFromAngle","getRotatedTextSize","rotate","PI","absSin","sin","absCos","cos","x","y","isEnd","isStart","leftToRight","toRight","toLeft","textpad","scale","padForRounding","scaleAndPad","scaleTextForRoundedBar","pad","textX","left","right","textY","top","bottom","targetX","targetY","anchorX","anchorY","extrapad","R","clippedR","rX","rY","c","index","texttemplate","value","calcTexttemplate","textinfo","calcTextinfo","getValue","coerceString","coerceEnumerated","castOption","pLetter","vLetter","vAxis","formatLabel","u","c2l","formatNumber","cdi","obj","label","labelLabel","tx","valueLabel","pt","undefined","xLabel","yLabel","delta","rawS","deltaLabel","final","finalLabel","initial","initialLabel","percentInitial","begR","percentInitialLabel","formatPercent","percentPrevious","difR","percentPreviousLabel","percentTotal","sumR","percenTotalLabel","customdata","texttemplateString","_d3locale","_meta","parts","split","hasFlag","flag","indexOf","push","nPercent","hasMultiplePercents","join","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/bar/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\nvar tickText = require('../../plots/cartesian/axes').tickText;\n\nvar uniformText = require('./uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar style = require('./style');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar attributes = require('./attributes');\n\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar TEXTPAD = constants.TEXTPAD;\n\nfunction keyFunc(d) {return d.id;}\nfunction getKeyFunc(trace) {\n    if(trace.ids) {\n        return keyFunc;\n    }\n}\n\n// Returns -1 if v < 0, 1 if v > 0, and 0 if v == 0\nfunction sign(v) {\n    return (v > 0) - (v < 0);\n}\n\n// Returns 1 if a < b and -1 otherwise\n// (For the purposes of this module we don't care about the case where a == b)\nfunction dirSign(a, b) {\n    return (a < b) ? 1 : -1;\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n    var s = [];\n    var p = [];\n\n    var sAxis = isHorizontal ? xa : ya;\n    var pAxis = isHorizontal ? ya : xa;\n\n    s[0] = sAxis.c2p(di.s0, true);\n    p[0] = pAxis.c2p(di.p0, true);\n\n    s[1] = sAxis.c2p(di.s1, true);\n    p[1] = pAxis.c2p(di.p1, true);\n\n    return isHorizontal ? [s, p] : [p, s];\n}\n\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n    if(!fullLayout.uniformtext.mode && hasTransition(opts)) {\n        var onComplete;\n        if(makeOnCompleteCallback) {\n            onComplete = makeOnCompleteCallback();\n        }\n        return selection\n          .transition()\n          .duration(opts.duration)\n          .ease(opts.easing)\n          .each('end', function() { onComplete && onComplete(); })\n          .each('interrupt', function() { onComplete && onComplete(); });\n    } else {\n        return selection;\n    }\n}\n\nfunction hasTransition(transitionOpts) {\n    return transitionOpts && transitionOpts.duration > 0;\n}\n\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var fullLayout = gd._fullLayout;\n    var isStatic = gd._context.staticPlot;\n\n    if(!opts) {\n        opts = {\n            mode: fullLayout.barmode,\n            norm: fullLayout.barmode,\n            gap: fullLayout.bargap,\n            groupgap: fullLayout.bargroupgap\n        };\n\n        // don't clear bar when this is called from waterfall or funnel\n        clearMinTextSize('bar', fullLayout);\n    }\n\n    var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var trace = cd[0].trace;\n        var t = cd[0].t;\n        var isWaterfall = (trace.type === 'waterfall');\n        var isFunnel = (trace.type === 'funnel');\n        var isHistogram = (trace.type === 'histogram');\n        var isBar = (trace.type === 'bar');\n        var shouldDisplayZeros = (isBar || isFunnel);\n        var adjustPixel = 0;\n        if(isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n            adjustPixel = trace.connector.line.width / 2;\n        }\n\n        var isHorizontal = (trace.orientation === 'h');\n        var withTransition = hasTransition(opts);\n\n        var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n\n        var keyFunc = getKeyFunc(trace);\n        var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n\n        bars.enter().append('g')\n            .classed('point', true);\n\n        bars.exit().remove();\n\n        bars.each(function(di, i) {\n            var bar = d3.select(this);\n\n            // now display the bar\n            // clipped xf/yf (2nd arg true): non-positive\n            // log values go off-screen by plotwidth\n            // so you see them continue if you drag the plot\n            var xy = getXY(di, xa, ya, isHorizontal);\n\n            var x0 = xy[0][0];\n            var x1 = xy[0][1];\n            var y0 = xy[1][0];\n            var y1 = xy[1][1];\n\n            // empty bars\n            var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0;\n\n            // display zeros if line.width > 0\n            if(isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n                isBlank = false;\n            }\n\n            // skip nulls\n            if(!isBlank) {\n                isBlank = (\n                    !isNumeric(x0) ||\n                    !isNumeric(x1) ||\n                    !isNumeric(y0) ||\n                    !isNumeric(y1)\n                );\n            }\n\n            // record isBlank\n            di.isBlank = isBlank;\n\n            // for blank bars, ensure start and end positions are equal - important for smooth transitions\n            if(isBlank) {\n                if(isHorizontal) {\n                    x1 = x0;\n                } else {\n                    y1 = y0;\n                }\n            }\n\n            // in waterfall mode `between` we need to adjust bar end points to match the connector width\n            if(adjustPixel && !isBlank) {\n                if(isHorizontal) {\n                    x0 -= dirSign(x0, x1) * adjustPixel;\n                    x1 += dirSign(x0, x1) * adjustPixel;\n                } else {\n                    y0 -= dirSign(y0, y1) * adjustPixel;\n                    y1 += dirSign(y0, y1) * adjustPixel;\n                }\n            }\n\n            var lw;\n            var mc;\n\n            if(trace.type === 'waterfall') {\n                if(!isBlank) {\n                    var cont = trace[di.dir].marker;\n                    lw = cont.line.width;\n                    mc = cont.color;\n                }\n            } else {\n                lw = helpers.getLineWidth(trace, di);\n                mc = di.mc || trace.marker.color;\n            }\n\n            function roundWithLine(v) {\n                var offset = d3.round((lw / 2) % 1, 2);\n\n                // if there are explicit gaps, don't round,\n                // it can make the gaps look crappy\n                return (opts.gap === 0 && opts.groupgap === 0) ?\n                    d3.round(Math.round(v) - offset, 2) : v;\n            }\n\n            function expandToVisible(v, vc, hideZeroSpan) {\n                if(hideZeroSpan && v === vc) {\n                    // should not expand zero span bars\n                    // when start and end positions are identical\n                    // i.e. for vertical when y0 === y1\n                    // and for horizontal when x0 === x1\n                    return v;\n                }\n\n                // if it's not in danger of disappearing entirely,\n                // round more precisely\n                return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n                // but if it's very thin, expand it so it's\n                // necessarily visible, even if it might overlap\n                // its neighbor\n                (v > vc ? Math.ceil(v) : Math.floor(v));\n            }\n\n            var op = Color.opacity(mc);\n            var fixpx = (op < 1 || lw > 0.01) ? roundWithLine : expandToVisible;\n            if(!gd._context.staticPlot) {\n                // if bars are not fully opaque or they have a line\n                // around them, round to integer pixels, mainly for\n                // safari so we prevent overlaps from its expansive\n                // pixelation. if the bars ARE fully opaque and have\n                // no line, expand to a full pixel to make sure we\n                // can see them\n                x0 = fixpx(x0, x1, isHorizontal);\n                x1 = fixpx(x1, x0, isHorizontal);\n                y0 = fixpx(y0, y1, !isHorizontal);\n                y1 = fixpx(y1, y0, !isHorizontal);\n            }\n\n            // Function to convert from size axis values to pixels\n            var c2p = isHorizontal ? xa.c2p : ya.c2p;\n\n            // Decide whether to use upper or lower bound of current bar stack\n            // as reference point for rounding\n            var outerBound;\n            if(di.s0 > 0) {\n                outerBound = di._sMax;\n            } else if(di.s0 < 0) {\n                outerBound = di._sMin;\n            } else {\n                outerBound = di.s1 > 0 ? di._sMax : di._sMin;\n            }\n\n            // Calculate corner radius of bar in pixels\n            function calcCornerRadius(crValue, crForm) {\n                if(!crValue) return 0;\n\n                var barWidth = isHorizontal ? Math.abs(y1 - y0) : Math.abs(x1 - x0);\n                var barLength = isHorizontal ? Math.abs(x1 - x0) : Math.abs(y1 - y0);\n                var stackedBarTotalLength = fixpx(Math.abs(c2p(outerBound, true) - c2p(0, true)));\n                var maxRadius = di.hasB ? Math.min(barWidth / 2, barLength / 2) : Math.min(barWidth / 2, stackedBarTotalLength);\n                var crPx;\n\n                if(crForm === '%') {\n                    // If radius is given as a % string, convert to number of pixels\n                    var crPercent = Math.min(50, crValue);\n                    crPx = barWidth * (crPercent / 100);\n                } else {\n                    // Otherwise, it's already a number of pixels, use the given value\n                    crPx = crValue;\n                }\n                return fixpx(Math.max(Math.min(crPx, maxRadius), 0));\n            }\n            // Exclude anything which is not explicitly a bar or histogram chart from rounding\n            var r = (isBar || isHistogram) ? calcCornerRadius(t.cornerradiusvalue, t.cornerradiusform) : 0;\n            // Construct path string for bar\n            var path, h;\n            // Default rectangular path (used if no rounding)\n            var rectanglePath = 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z';\n            var overhead = 0;\n            if(r && di.s) {\n                // Bar has cornerradius, and nonzero size\n                // Check amount of 'overhead' (bars stacked above this one)\n                // to see whether we need to round or not\n                var refPoint = sign(di.s0) === 0 || sign(di.s) === sign(di.s0) ? di.s1 : di.s0;\n                overhead = fixpx(!di.hasB ? Math.abs(c2p(outerBound, true) - c2p(refPoint, true)) : 0);\n                if(overhead < r) {\n                    // Calculate parameters for rounded corners\n                    var xdir = dirSign(x0, x1);\n                    var ydir = dirSign(y0, y1);\n                    // Sweep direction for rounded corner arcs\n                    var cornersweep = (xdir === -ydir) ? 1 : 0;\n                    if(isHorizontal) {\n                        // Horizontal bars\n                        if(di.hasB) {\n                            // Floating base: Round 1st & 2nd, and 3rd & 4th corners\n                            path = 'M' + (x0 + r * xdir) + ',' + y0 +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x0 + ',' + (y0 + r * ydir) +\n                                'V' + (y1 - r * ydir) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x0 + r * xdir) + ',' + y1 +\n                                'H' + (x1 - r * xdir) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x1 + ',' + (y1 - r * ydir) +\n                                'V' + (y0 + r * ydir) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x1 - r * xdir) + ',' + y0 +\n                                'Z';\n                        } else {\n                            // Base on axis: Round 3rd and 4th corners\n\n                            // Helper variables to help with extending rounding down to lower bars\n                            h = Math.abs(x1 - x0) + overhead;\n                            var dy1 = (h < r) ? r - Math.sqrt(h * (2 * r - h)) : 0;\n                            var dy2 = (overhead > 0) ? Math.sqrt(overhead * (2 * r - overhead)) : 0;\n                            var xminfunc = xdir > 0 ? Math.max : Math.min;\n\n                            path = 'M' + x0 + ',' + y0 +\n                                'V' + (y1 - dy1 * ydir) +\n                                'H' + xminfunc(x1 - (r - overhead) * xdir, x0) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x1 + ',' + (y1 - r * ydir - dy2) +\n                                'V' + (y0 + r * ydir + dy2) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + xminfunc(x1 - (r - overhead) * xdir, x0) + ',' + (y0 + dy1 * ydir) +\n                                'Z';\n                        }\n                    } else {\n                        // Vertical bars\n                        if(di.hasB) {\n                            // Floating base: Round 1st & 4th, and 2nd & 3rd corners\n                            path = 'M' + (x0 + r * xdir) + ',' + y0 +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x0 + ',' + (y0 + r * ydir) +\n                                'V' + (y1 - r * ydir) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x0 + r * xdir) + ',' + y1 +\n                                'H' + (x1 - r * xdir) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + x1 + ',' + (y1 - r * ydir) +\n                                'V' + (y0 + r * ydir) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x1 - r * xdir) + ',' + y0 +\n                                'Z';\n                        } else {\n                            // Base on axis: Round 2nd and 3rd corners\n\n                            // Helper variables to help with extending rounding down to lower bars\n                            h = Math.abs(y1 - y0) + overhead;\n                            var dx1 = (h < r) ? r - Math.sqrt(h * (2 * r - h)) : 0;\n                            var dx2 = (overhead > 0) ? Math.sqrt(overhead * (2 * r - overhead)) : 0;\n                            var yminfunc = ydir > 0 ? Math.max : Math.min;\n\n                            path = 'M' + (x0 + dx1 * xdir) + ',' + y0 +\n                                'V' + yminfunc(y1 - (r - overhead) * ydir, y0) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x0 + r * xdir - dx2) + ',' + y1 +\n                                'H' + (x1 - r * xdir + dx2) +\n                                'A ' + r + ',' + r + ' 0 0 ' + cornersweep + ' ' + (x1 - dx1 * xdir) + ',' + yminfunc(y1 - (r - overhead) * ydir, y0) +\n                                'V' + y0 + 'Z';\n                        }\n                    }\n                } else {\n                    // There is a cornerradius, but bar is too far down the stack to be rounded; just draw a rectangle\n                    path = rectanglePath;\n                }\n            } else {\n                // No cornerradius, just draw a rectangle\n                path = rectanglePath;\n            }\n\n            var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n            sel\n                .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke')\n                .attr('d', (isNaN((x1 - x0) * (y1 - y0)) || (isBlank && gd._context.staticPlot)) ? 'M0,0Z' : path)\n                .call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n            if(!fullLayout.uniformtext.mode && withTransition) {\n                var styleFns = Drawing.makePointStyleFns(trace);\n                Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n            }\n\n            appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, r, overhead, opts, makeOnCompleteCallback);\n\n            if(plotinfo.layerClipId) {\n                Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n            }\n        });\n\n        // lastly, clip points groups of `cliponaxis !== false` traces\n        // on `plotinfo._hasClipOnAxisFalse === true` subplots\n        var hasClipOnAxisFalse = trace.cliponaxis === false;\n        Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n    });\n\n    // error bars are on the top\n    Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\n\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, r, overhead, opts, makeOnCompleteCallback) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var textPosition;\n\n    function appendTextNode(bar, text, font) {\n        var textSelection = Lib.ensureSingle(bar, 'text')\n            .text(text)\n            .attr({\n                class: 'bartext bartext-' + textPosition,\n                'text-anchor': 'middle',\n                // prohibit tex interpretation until we can handle\n                // tex and regular text together\n                'data-notex': 1\n            })\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        return textSelection;\n    }\n\n    // get trace attributes\n    var trace = cd[0].trace;\n    var isHorizontal = (trace.orientation === 'h');\n\n    var text = getText(fullLayout, cd, i, xa, ya);\n\n    textPosition = getTextPosition(trace, i);\n\n    // compute text position\n    var inStackOrRelativeMode =\n        opts.mode === 'stack' ||\n        opts.mode === 'relative';\n\n    var calcBar = cd[i];\n    var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n    var hasB = calcBar.hasB;\n    var barIsRounded = r && (r - overhead) > TEXTPAD;\n\n    if(!text ||\n        textPosition === 'none' ||\n        ((calcBar.isBlank || x0 === x1 || y0 === y1) && (\n            textPosition === 'auto' ||\n            textPosition === 'inside'))) {\n        bar.select('text').remove();\n        return;\n    }\n\n    var layoutFont = fullLayout.font;\n    var barColor = style.getBarColor(cd[i], trace);\n    var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n    var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n    var insidetextanchor = trace.insidetextanchor || 'end';\n\n    // Special case: don't use the c2p(v, true) value on log size axes,\n    // so that we can get correctly inside text scaling\n    var di = bar.datum();\n    if(isHorizontal) {\n        if(xa.type === 'log' && di.s0 <= 0) {\n            if(xa.range[0] < xa.range[1]) {\n                x0 = 0;\n            } else {\n                x0 = xa._length;\n            }\n        }\n    } else {\n        if(ya.type === 'log' && di.s0 <= 0) {\n            if(ya.range[0] < ya.range[1]) {\n                y0 = ya._length;\n            } else {\n                y0 = 0;\n            }\n        }\n    }\n\n    // Compute width and height of bar\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    // padding excluded\n    var barWidth = lx - 2 * TEXTPAD;\n    var barHeight = ly - 2 * TEXTPAD;\n\n    var textSelection;\n\n    var textBB;\n    var textWidth;\n    var textHeight;\n    var font;\n\n    if(textPosition === 'outside') {\n        if(!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n    }\n\n    if(textPosition === 'auto') {\n        if(isOutmostBar) {\n            // draw text using insideTextFont and check if it fits inside bar\n            textPosition = 'inside';\n\n            font = Lib.ensureUniformFontSize(gd, insideTextFont);\n\n            textSelection = appendTextNode(bar, text, font);\n\n            textBB = Drawing.bBox(textSelection.node());\n            textWidth = textBB.width;\n            textHeight = textBB.height;\n\n            var textHasSize = (textWidth > 0 && textHeight > 0);\n\n            var fitsInside;\n            if(barIsRounded) {\n                // If bar is rounded, check if text fits between rounded corners\n                if(hasB) {\n                    fitsInside = (\n                        textfitsInsideBar(barWidth - 2 * r, barHeight, textWidth, textHeight, isHorizontal) ||\n                        textfitsInsideBar(barWidth, barHeight - 2 * r, textWidth, textHeight, isHorizontal)\n                    );\n                } else if(isHorizontal) {\n                    fitsInside = (\n                        textfitsInsideBar(barWidth - (r - overhead), barHeight, textWidth, textHeight, isHorizontal) ||\n                        textfitsInsideBar(barWidth, barHeight - 2 * (r - overhead), textWidth, textHeight, isHorizontal)\n                    );\n                } else {\n                    fitsInside = (\n                        textfitsInsideBar(barWidth, barHeight - (r - overhead), textWidth, textHeight, isHorizontal) ||\n                        textfitsInsideBar(barWidth - 2 * (r - overhead), barHeight, textWidth, textHeight, isHorizontal)\n                    );\n                }\n            } else {\n                fitsInside = textfitsInsideBar(barWidth, barHeight, textWidth, textHeight, isHorizontal);\n            }\n\n            if(textHasSize && fitsInside) {\n                textPosition = 'inside';\n            } else {\n                textPosition = 'outside';\n                textSelection.remove();\n                textSelection = null;\n            }\n        } else {\n            textPosition = 'inside';\n        }\n    }\n\n    if(!textSelection) {\n        font = Lib.ensureUniformFontSize(gd, (textPosition === 'outside') ? outsideTextFont : insideTextFont);\n\n        textSelection = appendTextNode(bar, text, font);\n\n        var currentTransform = textSelection.attr('transform');\n        textSelection.attr('transform', '');\n        textBB = Drawing.bBox(textSelection.node()),\n        textWidth = textBB.width,\n        textHeight = textBB.height;\n        textSelection.attr('transform', currentTransform);\n\n        if(textWidth <= 0 || textHeight <= 0) {\n            textSelection.remove();\n            return;\n        }\n    }\n\n    var angle = trace.textangle;\n\n    // compute text transform\n    var transform, constrained;\n    if(textPosition === 'outside') {\n        constrained =\n            trace.constraintext === 'both' ||\n            trace.constraintext === 'outside';\n\n        transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: isHorizontal,\n            constrained: constrained,\n            angle: angle\n        });\n    } else {\n        constrained =\n            trace.constraintext === 'both' ||\n            trace.constraintext === 'inside';\n\n        transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: isHorizontal,\n            constrained: constrained,\n            angle: angle,\n            anchor: insidetextanchor,\n            hasB: hasB,\n            r: r,\n            overhead: overhead,\n        });\n    }\n\n    transform.fontSize = font.size;\n    recordMinTextSize(trace.type === 'histogram' ? 'bar' : trace.type, transform, fullLayout);\n    calcBar.transform = transform;\n\n    var s = transition(textSelection, fullLayout, opts, makeOnCompleteCallback);\n    Lib.setTransormAndDisplay(s, transform);\n}\n\nfunction textfitsInsideBar(barWidth, barHeight, textWidth, textHeight, isHorizontal) {\n    if(barWidth < 0 || barHeight < 0) return false;\n    var fitsInside = (textWidth <= barWidth && textHeight <= barHeight);\n    var fitsInsideIfRotated = (textWidth <= barHeight && textHeight <= barWidth);\n    var fitsInsideIfShrunk = (isHorizontal) ?\n        (barWidth >= textWidth * (barHeight / textHeight)) :\n        (barHeight >= textHeight * (barWidth / textWidth));\n    return fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk;\n}\n\nfunction getRotateFromAngle(angle) {\n    return (angle === 'auto') ? 0 : angle;\n}\n\nfunction getRotatedTextSize(textBB, rotate) {\n    var a = Math.PI / 180 * rotate;\n    var absSin = Math.abs(Math.sin(a));\n    var absCos = Math.abs(Math.cos(a));\n\n    return {\n        x: textBB.width * absCos + textBB.height * absSin,\n        y: textBB.width * absSin + textBB.height * absCos\n    };\n}\n\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n    var isHorizontal = !!opts.isHorizontal;\n    var constrained = !!opts.constrained;\n    var angle = opts.angle || 0;\n    var anchor = opts.anchor;\n    var isEnd = anchor === 'end';\n    var isStart = anchor === 'start';\n    var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n    var toRight = (leftToRight + 1) / 2;\n    var toLeft = 1 - toRight;\n    var hasB = opts.hasB;\n    var r = opts.r;\n    var overhead = opts.overhead;\n\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    // compute remaining space\n    var textpad = (\n        lx > (2 * TEXTPAD) &&\n        ly > (2 * TEXTPAD)\n    ) ? TEXTPAD : 0;\n\n    lx -= 2 * textpad;\n    ly -= 2 * textpad;\n\n    var rotate = getRotateFromAngle(angle);\n    if((angle === 'auto') &&\n        !(textWidth <= lx && textHeight <= ly) &&\n        (textWidth > lx || textHeight > ly) && (\n            !(textWidth > ly || textHeight > lx) ||\n            ((textWidth < textHeight) !== (lx < ly))\n        )) {\n        rotate += 90;\n    }\n\n    var t = getRotatedTextSize(textBB, rotate);\n\n    var scale, padForRounding;\n    // Scale text for rounded bars\n    if(r && (r - overhead) > TEXTPAD) {\n        var scaleAndPad = scaleTextForRoundedBar(x0, x1, y0, y1, t, r, overhead, isHorizontal, hasB);\n        scale = scaleAndPad.scale;\n        padForRounding = scaleAndPad.pad;\n    // Scale text for non-rounded bars\n    } else {\n        scale = 1;\n        if(constrained) {\n            scale = Math.min(\n                1,\n                lx / t.x,\n                ly / t.y\n            );\n        }\n        padForRounding = 0;\n    }\n\n    // compute text and target positions\n    var textX = (\n        textBB.left * toLeft +\n        textBB.right * toRight\n    );\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetX = (\n        (x0 + TEXTPAD) * toLeft +\n        (x1 - TEXTPAD) * toRight\n    );\n    var targetY = (y0 + y1) / 2;\n    var anchorX = 0;\n    var anchorY = 0;\n    if(isStart || isEnd) {\n        var extrapad = (isHorizontal ? t.x : t.y) / 2;\n\n        if(r && (isEnd || hasB)) {\n            textpad += padForRounding;\n        }\n\n        var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n\n        if(isHorizontal) {\n            if(isStart) {\n                targetX = x0 + dir * textpad;\n                anchorX = -dir * extrapad;\n            } else {\n                targetX = x1 - dir * textpad;\n                anchorX = dir * extrapad;\n            }\n        } else {\n            if(isStart) {\n                targetY = y0 + dir * textpad;\n                anchorY = -dir * extrapad;\n            } else {\n                targetY = y1 - dir * textpad;\n                anchorY = dir * extrapad;\n            }\n        }\n    }\n\n    return {\n        textX: textX,\n        textY: textY,\n        targetX: targetX,\n        targetY: targetY,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        scale: scale,\n        rotate: rotate\n    };\n}\n\nfunction scaleTextForRoundedBar(x0, x1, y0, y1, t, r, overhead, isHorizontal, hasB) {\n    var barWidth = Math.max(0, Math.abs(x1 - x0) - 2 * TEXTPAD);\n    var barHeight = Math.max(0, Math.abs(y1 - y0) - 2 * TEXTPAD);\n    var R = r - TEXTPAD;\n    var clippedR = overhead ? R - Math.sqrt(R * R - (R - overhead) * (R - overhead)) : R;\n    var rX = hasB ? R * 2 : (isHorizontal ? R - overhead : 2 * clippedR);\n    var rY = hasB ? R * 2 : (isHorizontal ? 2 * clippedR : R - overhead);\n    var a, b, c;\n    var scale, pad;\n\n\n    if(t.y / t.x >= barHeight / (barWidth - rX)) {\n        // Case 1 (Tall text)\n        scale = barHeight / t.y;\n    } else if(t.y / t.x <= (barHeight - rY) / barWidth) {\n        // Case 2 (Wide text)\n        scale = barWidth / t.x;\n    } else if(!hasB && isHorizontal) {\n        // Case 3a (Quadratic case, two side corners are rounded)\n        a = t.x * t.x + t.y * t.y / 4;\n        b = -2 * t.x * (barWidth - R) - t.y * (barHeight / 2 - R);\n        c = (barWidth - R) * (barWidth - R) + (barHeight / 2 - R) * (barHeight / 2 - R) - R * R;\n\n        scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    } else if(!hasB) {\n        // Case 3b (Quadratic case, two top/bottom corners are rounded)\n        a = t.x * t.x / 4 + t.y * t.y;\n        b = -t.x * (barWidth / 2 - R) - 2 * t.y * (barHeight - R);\n        c = (barWidth / 2 - R) * (barWidth / 2 - R) + (barHeight - R) * (barHeight - R) - R * R;\n\n        scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    } else {\n        // Case 4 (Quadratic case, all four corners are rounded)\n        a = (t.x * t.x + t.y * t.y) / 4;\n        b = -t.x * (barWidth / 2 - R) - t.y * (barHeight / 2 - R);\n        c = (barWidth / 2 - R) * (barWidth / 2 - R) + (barHeight / 2 - R) * (barHeight / 2 - R) - R * R;\n        scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    }\n\n    // Scale should not be larger than 1\n    scale = Math.min(1, scale);\n\n    if(isHorizontal) {\n        pad = Math.max(0, R - Math.sqrt(Math.max(0, R * R - (R - (barHeight - t.y * scale) / 2) * (R - (barHeight - t.y * scale) / 2))) - overhead);\n    } else {\n        pad = Math.max(0, R - Math.sqrt(Math.max(0, R * R - (R - (barWidth - t.x * scale) / 2) * (R - (barWidth - t.x * scale) / 2))) - overhead);\n    }\n\n    return { scale: scale, pad: pad };\n}\n\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n    var isHorizontal = !!opts.isHorizontal;\n    var constrained = !!opts.constrained;\n    var angle = opts.angle || 0;\n\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    var textpad;\n    // Keep the padding so the text doesn't sit right against\n    // the bars, but don't factor it into barWidth\n    if(isHorizontal) {\n        textpad = (ly > 2 * TEXTPAD) ? TEXTPAD : 0;\n    } else {\n        textpad = (lx > 2 * TEXTPAD) ? TEXTPAD : 0;\n    }\n\n    // compute rotate and scale\n    var scale = 1;\n    if(constrained) {\n        scale = (isHorizontal) ?\n            Math.min(1, ly / textHeight) :\n            Math.min(1, lx / textWidth);\n    }\n\n    var rotate = getRotateFromAngle(angle);\n    var t = getRotatedTextSize(textBB, rotate);\n\n    // compute text and target positions\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    var textX = (textBB.left + textBB.right) / 2;\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetX = (x0 + x1) / 2;\n    var targetY = (y0 + y1) / 2;\n    var anchorX = 0;\n    var anchorY = 0;\n\n    var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n    if(isHorizontal) {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n    } else {\n        targetY = y1 + dir * textpad;\n        anchorY = -dir * extrapad;\n    }\n\n    return {\n        textX: textX,\n        textY: textY,\n        targetX: targetX,\n        targetY: targetY,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        scale: scale,\n        rotate: rotate\n    };\n}\n\nfunction getText(fullLayout, cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var texttemplate = trace.texttemplate;\n\n    var value;\n    if(texttemplate) {\n        value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n    } else if(trace.textinfo) {\n        value = calcTextinfo(cd, index, xa, ya);\n    } else {\n        value = helpers.getValue(trace.text, index);\n    }\n\n    return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n    var value = helpers.getValue(trace.textposition, index);\n    return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n    if(!texttemplate) return '';\n    var isHistogram = (trace.type === 'histogram');\n    var isWaterfall = (trace.type === 'waterfall');\n    var isFunnel = (trace.type === 'funnel');\n    var isHorizontal = trace.orientation === 'h';\n\n    var pLetter, pAxis;\n    var vLetter, vAxis;\n    if(isHorizontal) {\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n    } else {\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n    }\n\n    function formatLabel(u) {\n        return tickText(pAxis, pAxis.c2l(u), true).text;\n    }\n\n    function formatNumber(v) {\n        return tickText(vAxis, vAxis.c2l(v), true).text;\n    }\n\n    var cdi = cd[index];\n    var obj = {};\n\n    obj.label = cdi.p;\n    obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n\n    var tx = Lib.castOption(trace, cdi.i, 'text');\n    if(tx === 0 || tx) obj.text = tx;\n\n    obj.value = cdi.s;\n    obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n\n    var pt = {};\n    appendArrayPointValue(pt, trace, cdi.i);\n\n    if(isHistogram || pt.x === undefined) pt.x = isHorizontal ? obj.value : obj.label;\n    if(isHistogram || pt.y === undefined) pt.y = isHorizontal ? obj.label : obj.value;\n    if(isHistogram || pt.xLabel === undefined) pt.xLabel = isHorizontal ? obj.valueLabel : obj.labelLabel;\n    if(isHistogram || pt.yLabel === undefined) pt.yLabel = isHorizontal ? obj.labelLabel : obj.valueLabel;\n\n    if(isWaterfall) {\n        obj.delta = +cdi.rawS || cdi.s;\n        obj.deltaLabel = formatNumber(obj.delta);\n        obj.final = cdi.v;\n        obj.finalLabel = formatNumber(obj.final);\n        obj.initial = obj.final - obj.delta;\n        obj.initialLabel = formatNumber(obj.initial);\n    }\n\n    if(isFunnel) {\n        obj.value = cdi.s;\n        obj.valueLabel = formatNumber(obj.value);\n\n        obj.percentInitial = cdi.begR;\n        obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n        obj.percentPrevious = cdi.difR;\n        obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n        obj.percentTotal = cdi.sumR;\n        obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n    }\n\n    var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n    if(customdata) obj.customdata = customdata;\n    return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\n\nfunction calcTextinfo(cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var isHorizontal = (trace.orientation === 'h');\n    var isWaterfall = (trace.type === 'waterfall');\n    var isFunnel = (trace.type === 'funnel');\n\n    function formatLabel(u) {\n        var pAxis = isHorizontal ? ya : xa;\n        return tickText(pAxis, u, true).text;\n    }\n\n    function formatNumber(v) {\n        var sAxis = isHorizontal ? xa : ya;\n        return tickText(sAxis, +v, true).text;\n    }\n\n    var textinfo = trace.textinfo;\n    var cdi = cd[index];\n\n    var parts = textinfo.split('+');\n    var text = [];\n    var tx;\n\n    var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n\n    if(hasFlag('label')) {\n        text.push(formatLabel(cd[index].p));\n    }\n\n    if(hasFlag('text')) {\n        tx = Lib.castOption(trace, cdi.i, 'text');\n        if(tx === 0 || tx) text.push(tx);\n    }\n\n    if(isWaterfall) {\n        var delta = +cdi.rawS || cdi.s;\n        var final = cdi.v;\n        var initial = final - delta;\n\n        if(hasFlag('initial')) text.push(formatNumber(initial));\n        if(hasFlag('delta')) text.push(formatNumber(delta));\n        if(hasFlag('final')) text.push(formatNumber(final));\n    }\n\n    if(isFunnel) {\n        if(hasFlag('value')) text.push(formatNumber(cdi.s));\n\n        var nPercent = 0;\n        if(hasFlag('percent initial')) nPercent++;\n        if(hasFlag('percent previous')) nPercent++;\n        if(hasFlag('percent total')) nPercent++;\n\n        var hasMultiplePercents = nPercent > 1;\n\n        if(hasFlag('percent initial')) {\n            tx = Lib.formatPercent(cdi.begR);\n            if(hasMultiplePercents) tx += ' of initial';\n            text.push(tx);\n        }\n        if(hasFlag('percent previous')) {\n            tx = Lib.formatPercent(cdi.difR);\n            if(hasMultiplePercents) tx += ' of previous';\n            text.push(tx);\n        }\n        if(hasFlag('percent total')) {\n            tx = Lib.formatPercent(cdi.sumR);\n            if(hasMultiplePercents) tx += ' of total';\n            text.push(tx);\n        }\n    }\n\n    return text.join('<br>');\n}\n\nmodule.exports = {\n    plot: plot,\n    toMoveInsideBar: toMoveInsideBar\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}