{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useMemo, useRef } from \"react\";\nimport axios from \"axios\";\nimport { useHistory } from \"react-router-dom\";\nexport function useApi(baseUrl, params) {\n  _s();\n  const history = useHistory();\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // ðŸ”¥ Memoize params to prevent unnecessary re-fetching\n  const memoizedParams = useMemo(() => params, [JSON.stringify(params)]);\n\n  // âœ… Track component mount state to prevent state updates on unmounted component\n  const isMounted = useRef(true);\n  useEffect(() => {\n    isMounted.current = true; // Component is mounted\n\n    if (!baseUrl) return;\n    setIsLoading(true);\n    axios.get(`${process.env.REACT_APP_API_URL}${baseUrl}`, {\n      params: memoizedParams\n    }).then(response => {\n      if (isMounted.current) {\n        var _response$data;\n        setData((response === null || response === void 0 ? void 0 : (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.data) || null);\n      }\n    }).catch(error => {\n      if (isMounted.current) {\n        var _error$response;\n        setError(error);\n        console.error(`API Error (${baseUrl}):`, error);\n        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 404) {\n          history.push(\"/\"); // Redirect if 404\n        }\n      }\n    }).finally(() => {\n      if (isMounted.current) {\n        setIsLoading(false);\n      }\n    });\n    return () => {\n      isMounted.current = false; // Cleanup on unmount\n    };\n  }, [baseUrl, memoizedParams]);\n  return {\n    data,\n    error,\n    isLoading\n  };\n}\n_s(useApi, \"fblFmEC8vaDeIlOrcX3eA6/dRnQ=\", false, function () {\n  return [useHistory];\n});","map":{"version":3,"names":["useState","useEffect","useMemo","useRef","axios","useHistory","useApi","baseUrl","params","_s","history","data","setData","error","setError","isLoading","setIsLoading","memoizedParams","JSON","stringify","isMounted","current","get","process","env","REACT_APP_API_URL","then","response","_response$data","catch","_error$response","console","status","push","finally"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/src/middleware/middleware.js"],"sourcesContent":["import { useState, useEffect, useMemo, useRef } from \"react\";\nimport axios from \"axios\";\nimport { useHistory } from \"react-router-dom\";\n\nexport function useApi(baseUrl, params) {\n    const history = useHistory();\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n    const [isLoading, setIsLoading] = useState(false);\n\n    // ðŸ”¥ Memoize params to prevent unnecessary re-fetching\n    const memoizedParams = useMemo(() => params, [JSON.stringify(params)]);\n    \n    // âœ… Track component mount state to prevent state updates on unmounted component\n    const isMounted = useRef(true);\n\n    useEffect(() => {\n        isMounted.current = true; // Component is mounted\n\n        if (!baseUrl) return;\n\n        setIsLoading(true);\n\n        axios\n            .get(`${process.env.REACT_APP_API_URL}${baseUrl}`, { params: memoizedParams })\n            .then(response => {\n                if (isMounted.current) {\n                    setData(response?.data?.data || null);\n                }\n            })\n            .catch(error => {\n                if (isMounted.current) {\n                    setError(error);\n                    console.error(`API Error (${baseUrl}):`, error);\n\n                    if (error.response?.status === 404) {\n                        history.push(\"/\"); // Redirect if 404\n                    }\n                }\n            })\n            .finally(() => {\n                if (isMounted.current) {\n                    setIsLoading(false);\n                }\n            });\n\n        return () => {\n            isMounted.current = false; // Cleanup on unmount\n        };\n    }, [baseUrl, memoizedParams]);\n\n    return { data, error, isLoading };\n}\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AAC5D,OAAOC,KAAK,MAAM,OAAO;AACzB,SAASC,UAAU,QAAQ,kBAAkB;AAE7C,OAAO,SAASC,MAAMA,CAACC,OAAO,EAAEC,MAAM,EAAE;EAAAC,EAAA;EACpC,MAAMC,OAAO,GAAGL,UAAU,CAAC,CAAC;EAC5B,MAAM,CAACM,IAAI,EAAEC,OAAO,CAAC,GAAGZ,QAAQ,CAAC,IAAI,CAAC;EACtC,MAAM,CAACa,KAAK,EAAEC,QAAQ,CAAC,GAAGd,QAAQ,CAAC,IAAI,CAAC;EACxC,MAAM,CAACe,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAC,KAAK,CAAC;;EAEjD;EACA,MAAMiB,cAAc,GAAGf,OAAO,CAAC,MAAMM,MAAM,EAAE,CAACU,IAAI,CAACC,SAAS,CAACX,MAAM,CAAC,CAAC,CAAC;;EAEtE;EACA,MAAMY,SAAS,GAAGjB,MAAM,CAAC,IAAI,CAAC;EAE9BF,SAAS,CAAC,MAAM;IACZmB,SAAS,CAACC,OAAO,GAAG,IAAI,CAAC,CAAC;;IAE1B,IAAI,CAACd,OAAO,EAAE;IAEdS,YAAY,CAAC,IAAI,CAAC;IAElBZ,KAAK,CACAkB,GAAG,CAAC,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,GAAGlB,OAAO,EAAE,EAAE;MAAEC,MAAM,EAAES;IAAe,CAAC,CAAC,CAC7ES,IAAI,CAACC,QAAQ,IAAI;MACd,IAAIP,SAAS,CAACC,OAAO,EAAE;QAAA,IAAAO,cAAA;QACnBhB,OAAO,CAAC,CAAAe,QAAQ,aAARA,QAAQ,wBAAAC,cAAA,GAARD,QAAQ,CAAEhB,IAAI,cAAAiB,cAAA,uBAAdA,cAAA,CAAgBjB,IAAI,KAAI,IAAI,CAAC;MACzC;IACJ,CAAC,CAAC,CACDkB,KAAK,CAAChB,KAAK,IAAI;MACZ,IAAIO,SAAS,CAACC,OAAO,EAAE;QAAA,IAAAS,eAAA;QACnBhB,QAAQ,CAACD,KAAK,CAAC;QACfkB,OAAO,CAAClB,KAAK,CAAC,cAAcN,OAAO,IAAI,EAAEM,KAAK,CAAC;QAE/C,IAAI,EAAAiB,eAAA,GAAAjB,KAAK,CAACc,QAAQ,cAAAG,eAAA,uBAAdA,eAAA,CAAgBE,MAAM,MAAK,GAAG,EAAE;UAChCtB,OAAO,CAACuB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACvB;MACJ;IACJ,CAAC,CAAC,CACDC,OAAO,CAAC,MAAM;MACX,IAAId,SAAS,CAACC,OAAO,EAAE;QACnBL,YAAY,CAAC,KAAK,CAAC;MACvB;IACJ,CAAC,CAAC;IAEN,OAAO,MAAM;MACTI,SAAS,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;IAC/B,CAAC;EACL,CAAC,EAAE,CAACd,OAAO,EAAEU,cAAc,CAAC,CAAC;EAE7B,OAAO;IAAEN,IAAI;IAAEE,KAAK;IAAEE;EAAU,CAAC;AACrC;AAACN,EAAA,CAhDeH,MAAM;EAAA,QACFD,UAAU;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}