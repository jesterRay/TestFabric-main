{"ast":null,"code":"'use strict';\n\nvar parseSvgPath = require('parse-svg-path');\nvar constants = require('./constants');\nvar CIRCLE_SIDES = constants.CIRCLE_SIDES;\nvar SQRT2 = constants.SQRT2;\nvar cartesianHelpers = require('../../selections/helpers');\nvar p2r = cartesianHelpers.p2r;\nvar r2p = cartesianHelpers.r2p;\nvar iC = [0, 3, 4, 5, 6, 1, 2];\nvar iQS = [0, 3, 4, 1, 2];\nexports.writePaths = function (polygons) {\n  var nI = polygons.length;\n  if (!nI) return 'M0,0Z';\n  var str = '';\n  for (var i = 0; i < nI; i++) {\n    var nJ = polygons[i].length;\n    for (var j = 0; j < nJ; j++) {\n      var w = polygons[i][j][0];\n      if (w === 'Z') {\n        str += 'Z';\n      } else {\n        var nK = polygons[i][j].length;\n        for (var k = 0; k < nK; k++) {\n          var realK = k;\n          if (w === 'Q' || w === 'S') {\n            realK = iQS[k];\n          } else if (w === 'C') {\n            realK = iC[k];\n          }\n          str += polygons[i][j][realK];\n          if (k > 0 && k < nK - 1) {\n            str += ',';\n          }\n        }\n      }\n    }\n  }\n  return str;\n};\nexports.readPaths = function (str, gd, plotinfo, isActiveShape) {\n  var cmd = parseSvgPath(str);\n  var polys = [];\n  var n = -1;\n  var newPoly = function () {\n    n++;\n    polys[n] = [];\n  };\n  var k;\n  var x = 0;\n  var y = 0;\n  var initX;\n  var initY;\n  var recStart = function () {\n    initX = x;\n    initY = y;\n  };\n  recStart();\n  for (var i = 0; i < cmd.length; i++) {\n    var newPos = [];\n    var x1, x2, y1, y2; // i.e. extra params for curves\n\n    var c = cmd[i][0];\n    var w = c;\n    switch (c) {\n      case 'M':\n        newPoly();\n        x = +cmd[i][1];\n        y = +cmd[i][2];\n        newPos.push([w, x, y]);\n        recStart();\n        break;\n      case 'Q':\n      case 'S':\n        x1 = +cmd[i][1];\n        y1 = +cmd[i][2];\n        x = +cmd[i][3];\n        y = +cmd[i][4];\n        newPos.push([w, x, y, x1, y1]); // -> iQS order\n        break;\n      case 'C':\n        x1 = +cmd[i][1];\n        y1 = +cmd[i][2];\n        x2 = +cmd[i][3];\n        y2 = +cmd[i][4];\n        x = +cmd[i][5];\n        y = +cmd[i][6];\n        newPos.push([w, x, y, x1, y1, x2, y2]); // -> iC order\n        break;\n      case 'T':\n      case 'L':\n        x = +cmd[i][1];\n        y = +cmd[i][2];\n        newPos.push([w, x, y]);\n        break;\n      case 'H':\n        w = 'L'; // convert to line (for now)\n        x = +cmd[i][1];\n        newPos.push([w, x, y]);\n        break;\n      case 'V':\n        w = 'L'; // convert to line (for now)\n        y = +cmd[i][1];\n        newPos.push([w, x, y]);\n        break;\n      case 'A':\n        w = 'L'; // convert to line to handle circle\n        var rx = +cmd[i][1];\n        var ry = +cmd[i][2];\n        if (!+cmd[i][4]) {\n          rx = -rx;\n          ry = -ry;\n        }\n        var cenX = x - rx;\n        var cenY = y;\n        for (k = 1; k <= CIRCLE_SIDES / 2; k++) {\n          var t = 2 * Math.PI * k / CIRCLE_SIDES;\n          newPos.push([w, cenX + rx * Math.cos(t), cenY + ry * Math.sin(t)]);\n        }\n        break;\n      case 'Z':\n        if (x !== initX || y !== initY) {\n          x = initX;\n          y = initY;\n          newPos.push([w, x, y]);\n        }\n        break;\n    }\n    var domain = (plotinfo || {}).domain;\n    var size = gd._fullLayout._size;\n    var xPixelSized = plotinfo && plotinfo.xsizemode === 'pixel';\n    var yPixelSized = plotinfo && plotinfo.ysizemode === 'pixel';\n    var noOffset = isActiveShape === false;\n    for (var j = 0; j < newPos.length; j++) {\n      for (k = 0; k + 2 < 7; k += 2) {\n        var _x = newPos[j][k + 1];\n        var _y = newPos[j][k + 2];\n        if (_x === undefined || _y === undefined) continue;\n        // keep track of end point for Z\n        x = _x;\n        y = _y;\n        if (plotinfo) {\n          if (plotinfo.xaxis && plotinfo.xaxis.p2r) {\n            if (noOffset) _x -= plotinfo.xaxis._offset;\n            if (xPixelSized) {\n              _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;\n            } else {\n              _x = p2r(plotinfo.xaxis, _x);\n            }\n          } else {\n            if (noOffset) _x -= size.l;\n            if (domain) _x = domain.x[0] + _x / size.w;else _x = _x / size.w;\n          }\n          if (plotinfo.yaxis && plotinfo.yaxis.p2r) {\n            if (noOffset) _y -= plotinfo.yaxis._offset;\n            if (yPixelSized) {\n              _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;\n            } else {\n              _y = p2r(plotinfo.yaxis, _y);\n            }\n          } else {\n            if (noOffset) _y -= size.t;\n            if (domain) _y = domain.y[1] - _y / size.h;else _y = 1 - _y / size.h;\n          }\n        }\n        newPos[j][k + 1] = _x;\n        newPos[j][k + 2] = _y;\n      }\n      polys[n].push(newPos[j].slice());\n    }\n  }\n  return polys;\n};\nfunction almostEq(a, b) {\n  return Math.abs(a - b) <= 1e-6;\n}\nfunction dist(a, b) {\n  var dx = b[1] - a[1];\n  var dy = b[2] - a[2];\n  return Math.sqrt(dx * dx + dy * dy);\n}\nexports.pointsOnRectangle = function (cell) {\n  var len = cell.length;\n  if (len !== 5) return false;\n  for (var j = 1; j < 3; j++) {\n    var e01 = cell[0][j] - cell[1][j];\n    var e32 = cell[3][j] - cell[2][j];\n    if (!almostEq(e01, e32)) return false;\n    var e03 = cell[0][j] - cell[3][j];\n    var e12 = cell[1][j] - cell[2][j];\n    if (!almostEq(e03, e12)) return false;\n  }\n\n  // N.B. rotated rectangles are not valid rects since rotation is not supported in shapes for now.\n  if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false;\n\n  // reject cases with zero area\n  return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));\n};\nexports.pointsOnEllipse = function (cell) {\n  var len = cell.length;\n  if (len !== CIRCLE_SIDES + 1) return false;\n\n  // opposite diagonals should be the same\n  len = CIRCLE_SIDES;\n  for (var i = 0; i < len; i++) {\n    var k = (len * 2 - i) % len;\n    var k2 = (len / 2 + k) % len;\n    var i2 = (len / 2 + i) % len;\n    if (!almostEq(dist(cell[i], cell[i2]), dist(cell[k], cell[k2]))) return false;\n  }\n  return true;\n};\nexports.handleEllipse = function (isEllipse, start, end) {\n  if (!isEllipse) return [start, end]; // i.e. case of line\n\n  var pos = exports.ellipseOver({\n    x0: start[0],\n    y0: start[1],\n    x1: end[0],\n    y1: end[1]\n  });\n  var cx = (pos.x1 + pos.x0) / 2;\n  var cy = (pos.y1 + pos.y0) / 2;\n  var rx = (pos.x1 - pos.x0) / 2;\n  var ry = (pos.y1 - pos.y0) / 2;\n\n  // make a circle when one dimension is zero\n  if (!rx) rx = ry = ry / SQRT2;\n  if (!ry) ry = rx = rx / SQRT2;\n  var cell = [];\n  for (var i = 0; i < CIRCLE_SIDES; i++) {\n    var t = i * 2 * Math.PI / CIRCLE_SIDES;\n    cell.push([cx + rx * Math.cos(t), cy + ry * Math.sin(t)]);\n  }\n  return cell;\n};\nexports.ellipseOver = function (pos) {\n  var x0 = pos.x0;\n  var y0 = pos.y0;\n  var x1 = pos.x1;\n  var y1 = pos.y1;\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n  x0 -= dx;\n  y0 -= dy;\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var scale = SQRT2;\n  dx *= scale;\n  dy *= scale;\n  return {\n    x0: cx - dx,\n    y0: cy - dy,\n    x1: cx + dx,\n    y1: cy + dy\n  };\n};\nexports.fixDatesForPaths = function (polygons, xaxis, yaxis) {\n  var xIsDate = xaxis.type === 'date';\n  var yIsDate = yaxis.type === 'date';\n  if (!xIsDate && !yIsDate) return polygons;\n  for (var i = 0; i < polygons.length; i++) {\n    for (var j = 0; j < polygons[i].length; j++) {\n      for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {\n        if (xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(' ', '_');\n        if (yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(' ', '_');\n      }\n    }\n  }\n  return polygons;\n};","map":{"version":3,"names":["parseSvgPath","require","constants","CIRCLE_SIDES","SQRT2","cartesianHelpers","p2r","r2p","iC","iQS","exports","writePaths","polygons","nI","length","str","i","nJ","j","w","nK","k","realK","readPaths","gd","plotinfo","isActiveShape","cmd","polys","n","newPoly","x","y","initX","initY","recStart","newPos","x1","x2","y1","y2","c","push","rx","ry","cenX","cenY","t","Math","PI","cos","sin","domain","size","_fullLayout","_size","xPixelSized","xsizemode","yPixelSized","ysizemode","noOffset","_x","_y","undefined","xaxis","_offset","xanchor","l","yaxis","yanchor","h","slice","almostEq","a","b","abs","dist","dx","dy","sqrt","pointsOnRectangle","cell","len","e01","e32","e03","e12","pointsOnEllipse","k2","i2","handleEllipse","isEllipse","start","end","pos","ellipseOver","x0","y0","cx","cy","scale","fixDatesForPaths","xIsDate","type","yIsDate","replace"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/shapes/draw_newshape/helpers.js"],"sourcesContent":["'use strict';\n\nvar parseSvgPath = require('parse-svg-path');\n\nvar constants = require('./constants');\nvar CIRCLE_SIDES = constants.CIRCLE_SIDES;\nvar SQRT2 = constants.SQRT2;\n\nvar cartesianHelpers = require('../../selections/helpers');\nvar p2r = cartesianHelpers.p2r;\nvar r2p = cartesianHelpers.r2p;\n\nvar iC = [0, 3, 4, 5, 6, 1, 2];\nvar iQS = [0, 3, 4, 1, 2];\n\nexports.writePaths = function(polygons) {\n    var nI = polygons.length;\n    if(!nI) return 'M0,0Z';\n\n    var str = '';\n    for(var i = 0; i < nI; i++) {\n        var nJ = polygons[i].length;\n        for(var j = 0; j < nJ; j++) {\n            var w = polygons[i][j][0];\n            if(w === 'Z') {\n                str += 'Z';\n            } else {\n                var nK = polygons[i][j].length;\n                for(var k = 0; k < nK; k++) {\n                    var realK = k;\n                    if(w === 'Q' || w === 'S') {\n                        realK = iQS[k];\n                    } else if(w === 'C') {\n                        realK = iC[k];\n                    }\n\n                    str += polygons[i][j][realK];\n                    if(k > 0 && k < nK - 1) {\n                        str += ',';\n                    }\n                }\n            }\n        }\n    }\n\n    return str;\n};\n\nexports.readPaths = function(str, gd, plotinfo, isActiveShape) {\n    var cmd = parseSvgPath(str);\n\n    var polys = [];\n    var n = -1;\n    var newPoly = function() {\n        n++;\n        polys[n] = [];\n    };\n\n    var k;\n    var x = 0;\n    var y = 0;\n    var initX;\n    var initY;\n    var recStart = function() {\n        initX = x;\n        initY = y;\n    };\n\n    recStart();\n    for(var i = 0; i < cmd.length; i++) {\n        var newPos = [];\n\n        var x1, x2, y1, y2; // i.e. extra params for curves\n\n        var c = cmd[i][0];\n        var w = c;\n        switch(c) {\n            case 'M':\n                newPoly();\n                x = +cmd[i][1];\n                y = +cmd[i][2];\n                newPos.push([w, x, y]);\n\n                recStart();\n                break;\n\n            case 'Q':\n            case 'S':\n                x1 = +cmd[i][1];\n                y1 = +cmd[i][2];\n                x = +cmd[i][3];\n                y = +cmd[i][4];\n                newPos.push([w, x, y, x1, y1]); // -> iQS order\n                break;\n\n            case 'C':\n                x1 = +cmd[i][1];\n                y1 = +cmd[i][2];\n                x2 = +cmd[i][3];\n                y2 = +cmd[i][4];\n                x = +cmd[i][5];\n                y = +cmd[i][6];\n                newPos.push([w, x, y, x1, y1, x2, y2]); // -> iC order\n                break;\n\n            case 'T':\n            case 'L':\n                x = +cmd[i][1];\n                y = +cmd[i][2];\n                newPos.push([w, x, y]);\n                break;\n\n            case 'H':\n                w = 'L'; // convert to line (for now)\n                x = +cmd[i][1];\n                newPos.push([w, x, y]);\n                break;\n\n            case 'V':\n                w = 'L'; // convert to line (for now)\n                y = +cmd[i][1];\n                newPos.push([w, x, y]);\n                break;\n\n            case 'A':\n                w = 'L'; // convert to line to handle circle\n                var rx = +cmd[i][1];\n                var ry = +cmd[i][2];\n                if(!+cmd[i][4]) {\n                    rx = -rx;\n                    ry = -ry;\n                }\n\n                var cenX = x - rx;\n                var cenY = y;\n                for(k = 1; k <= CIRCLE_SIDES / 2; k++) {\n                    var t = 2 * Math.PI * k / CIRCLE_SIDES;\n                    newPos.push([\n                        w,\n                        cenX + rx * Math.cos(t),\n                        cenY + ry * Math.sin(t)\n                    ]);\n                }\n                break;\n\n            case 'Z':\n                if(x !== initX || y !== initY) {\n                    x = initX;\n                    y = initY;\n                    newPos.push([w, x, y]);\n                }\n                break;\n        }\n\n        var domain = (plotinfo || {}).domain;\n        var size = gd._fullLayout._size;\n        var xPixelSized = plotinfo && plotinfo.xsizemode === 'pixel';\n        var yPixelSized = plotinfo && plotinfo.ysizemode === 'pixel';\n        var noOffset = isActiveShape === false;\n\n        for(var j = 0; j < newPos.length; j++) {\n            for(k = 0; k + 2 < 7; k += 2) {\n                var _x = newPos[j][k + 1];\n                var _y = newPos[j][k + 2];\n\n                if(_x === undefined || _y === undefined) continue;\n                // keep track of end point for Z\n                x = _x;\n                y = _y;\n\n                if(plotinfo) {\n                    if(plotinfo.xaxis && plotinfo.xaxis.p2r) {\n                        if(noOffset) _x -= plotinfo.xaxis._offset;\n                        if(xPixelSized) {\n                            _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;\n                        } else {\n                            _x = p2r(plotinfo.xaxis, _x);\n                        }\n                    } else {\n                        if(noOffset) _x -= size.l;\n                        if(domain) _x = domain.x[0] + _x / size.w;\n                        else _x = _x / size.w;\n                    }\n\n                    if(plotinfo.yaxis && plotinfo.yaxis.p2r) {\n                        if(noOffset) _y -= plotinfo.yaxis._offset;\n                        if(yPixelSized) {\n                            _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;\n                        } else {\n                            _y = p2r(plotinfo.yaxis, _y);\n                        }\n                    } else {\n                        if(noOffset) _y -= size.t;\n                        if(domain) _y = domain.y[1] - _y / size.h;\n                        else _y = 1 - _y / size.h;\n                    }\n                }\n\n                newPos[j][k + 1] = _x;\n                newPos[j][k + 2] = _y;\n            }\n            polys[n].push(\n                newPos[j].slice()\n            );\n        }\n    }\n\n    return polys;\n};\n\nfunction almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n}\n\nfunction dist(a, b) {\n    var dx = b[1] - a[1];\n    var dy = b[2] - a[2];\n    return Math.sqrt(\n        dx * dx +\n        dy * dy\n    );\n}\n\nexports.pointsOnRectangle = function(cell) {\n    var len = cell.length;\n    if(len !== 5) return false;\n\n    for(var j = 1; j < 3; j++) {\n        var e01 = cell[0][j] - cell[1][j];\n        var e32 = cell[3][j] - cell[2][j];\n\n        if(!almostEq(e01, e32)) return false;\n\n        var e03 = cell[0][j] - cell[3][j];\n        var e12 = cell[1][j] - cell[2][j];\n        if(!almostEq(e03, e12)) return false;\n    }\n\n    // N.B. rotated rectangles are not valid rects since rotation is not supported in shapes for now.\n    if(\n        !almostEq(cell[0][1], cell[1][1]) &&\n        !almostEq(cell[0][1], cell[3][1])\n    ) return false;\n\n    // reject cases with zero area\n    return !!(\n        dist(cell[0], cell[1]) *\n        dist(cell[0], cell[3])\n    );\n};\n\nexports.pointsOnEllipse = function(cell) {\n    var len = cell.length;\n    if(len !== CIRCLE_SIDES + 1) return false;\n\n    // opposite diagonals should be the same\n    len = CIRCLE_SIDES;\n    for(var i = 0; i < len; i++) {\n        var k = (len * 2 - i) % len;\n\n        var k2 = (len / 2 + k) % len;\n        var i2 = (len / 2 + i) % len;\n\n        if(!almostEq(\n            dist(cell[i], cell[i2]),\n            dist(cell[k], cell[k2])\n        )) return false;\n    }\n    return true;\n};\n\nexports.handleEllipse = function(isEllipse, start, end) {\n    if(!isEllipse) return [start, end]; // i.e. case of line\n\n    var pos = exports.ellipseOver({\n        x0: start[0],\n        y0: start[1],\n        x1: end[0],\n        y1: end[1]\n    });\n\n    var cx = (pos.x1 + pos.x0) / 2;\n    var cy = (pos.y1 + pos.y0) / 2;\n    var rx = (pos.x1 - pos.x0) / 2;\n    var ry = (pos.y1 - pos.y0) / 2;\n\n    // make a circle when one dimension is zero\n    if(!rx) rx = ry = ry / SQRT2;\n    if(!ry) ry = rx = rx / SQRT2;\n\n    var cell = [];\n    for(var i = 0; i < CIRCLE_SIDES; i++) {\n        var t = i * 2 * Math.PI / CIRCLE_SIDES;\n        cell.push([\n            cx + rx * Math.cos(t),\n            cy + ry * Math.sin(t),\n        ]);\n    }\n    return cell;\n};\n\nexports.ellipseOver = function(pos) {\n    var x0 = pos.x0;\n    var y0 = pos.y0;\n    var x1 = pos.x1;\n    var y1 = pos.y1;\n\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n\n    x0 -= dx;\n    y0 -= dy;\n\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n\n    var scale = SQRT2;\n    dx *= scale;\n    dy *= scale;\n\n    return {\n        x0: cx - dx,\n        y0: cy - dy,\n        x1: cx + dx,\n        y1: cy + dy\n    };\n};\n\nexports.fixDatesForPaths = function(polygons, xaxis, yaxis) {\n    var xIsDate = xaxis.type === 'date';\n    var yIsDate = yaxis.type === 'date';\n    if(!xIsDate && !yIsDate) return polygons;\n\n    for(var i = 0; i < polygons.length; i++) {\n        for(var j = 0; j < polygons[i].length; j++) {\n            for(var k = 0; k + 2 < polygons[i][j].length; k += 2) {\n                if(xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(' ', '_');\n                if(yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(' ', '_');\n            }\n        }\n    }\n\n    return polygons;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}