{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\nvar Template = require('../../plot_api/plot_template');\nvar basePlotLayoutAttributes = require('../layout_attributes');\nvar layoutAttributes = require('./layout_attributes');\nvar handleTypeDefaults = require('./type_defaults');\nvar handleAxisDefaults = require('./axis_defaults');\nvar constraints = require('./constraints');\nvar handlePositionDefaults = require('./position_defaults');\nvar axisIds = require('./axis_ids');\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\nvar Registry = require('../../registry');\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\nfunction appendList(cont, k, item) {\n  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];\n}\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var autotypenumbersDflt = layoutOut.autotypenumbers;\n  var ax2traces = {};\n  var xaMayHide = {};\n  var yaMayHide = {};\n  var xaMustDisplay = {};\n  var yaMustDisplay = {};\n  var yaMustNotReverse = {};\n  var yaMayReverse = {};\n  var axHasImage = {};\n  var outerTicks = {};\n  var noGrids = {};\n  var i, j;\n\n  // look for axes in the data\n  for (i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n    var xaName;\n    if (trace.xaxis) {\n      xaName = id2name(trace.xaxis);\n      appendList(ax2traces, xaName, trace);\n    } else if (trace.xaxes) {\n      for (j = 0; j < trace.xaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n      }\n    }\n    var yaName;\n    if (trace.yaxis) {\n      yaName = id2name(trace.yaxis);\n      appendList(ax2traces, yaName, trace);\n    } else if (trace.yaxes) {\n      for (j = 0; j < trace.yaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n      }\n    }\n\n    // logic for funnels\n    if (trace.type === 'funnel') {\n      if (trace.orientation === 'h') {\n        if (xaName) xaMayHide[xaName] = true;\n        if (yaName) yaMayReverse[yaName] = true;\n      } else {\n        if (yaName) yaMayHide[yaName] = true;\n      }\n    } else if (trace.type === 'image') {\n      if (yaName) axHasImage[yaName] = true;\n      if (xaName) axHasImage[xaName] = true;\n    } else {\n      if (yaName) {\n        yaMustDisplay[yaName] = true;\n        yaMustNotReverse[yaName] = true;\n      }\n      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {\n        if (xaName) xaMustDisplay[xaName] = true;\n      }\n    }\n\n    // Two things trigger axis visibility:\n    // 1. is not carpet\n    // 2. carpet that's not cheater\n\n    // The above check for definitely-not-cheater is not adequate. This\n    // second list tracks which axes *could* be a cheater so that the\n    // full condition triggering hiding is:\n    //   *could* be a cheater and *is not definitely visible*\n    if (trace.type === 'carpet' && trace._cheater) {\n      if (xaName) xaMayHide[xaName] = true;\n    }\n\n    // check for default formatting tweaks\n    if (traceIs(trace, '2dMap')) {\n      outerTicks[xaName] = true;\n      outerTicks[yaName] = true;\n    }\n    if (traceIs(trace, 'oriented')) {\n      var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n      noGrids[positionAxis] = true;\n    }\n  }\n  var subplots = layoutOut._subplots;\n  var xIds = subplots.xaxis;\n  var yIds = subplots.yaxis;\n  var xNames = Lib.simpleMap(xIds, id2name);\n  var yNames = Lib.simpleMap(yIds, id2name);\n  var axNames = xNames.concat(yNames);\n\n  // plot_bgcolor only makes sense if there's a (2D) plot!\n  // TODO: bgcolor for each subplot, to inherit from the main one\n  var plotBgColor = Color.background;\n  if (xIds.length && yIds.length) {\n    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n  }\n  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n\n  // name of single axis (e.g. 'xaxis', 'yaxis2')\n  var axName;\n  // id of single axis (e.g. 'y', 'x5')\n  var axId;\n  // 'x' or 'y'\n  var axLetter;\n  // input layout axis container\n  var axLayoutIn;\n  // full layout axis container\n  var axLayoutOut;\n  function newAxLayoutOut() {\n    var traces = ax2traces[axName] || [];\n    axLayoutOut._traceIndices = traces.map(function (t) {\n      return t._expandedIndex;\n    });\n    axLayoutOut._annIndices = [];\n    axLayoutOut._shapeIndices = [];\n    axLayoutOut._selectionIndices = [];\n    axLayoutOut._imgIndices = [];\n    axLayoutOut._subplotsWith = [];\n    axLayoutOut._counterAxes = [];\n    axLayoutOut._name = axLayoutOut._attr = axName;\n    axLayoutOut._id = axId;\n  }\n  function coerce(attr, dflt) {\n    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n  function getCounterAxes(axLetter) {\n    return axLetter === 'x' ? yIds : xIds;\n  }\n  function getOverlayableAxes(axLetter, axName) {\n    var list = axLetter === 'x' ? xNames : yNames;\n    var out = [];\n    for (var j = 0; j < list.length; j++) {\n      var axName2 = list[j];\n      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n        out.push(name2id(axName2));\n      }\n    }\n    return out;\n  }\n\n  // list of available counter axis names\n  var counterAxes = {\n    x: getCounterAxes('x'),\n    y: getCounterAxes('y')\n  };\n  // list of all x AND y axis ids\n  var allAxisIds = counterAxes.x.concat(counterAxes.y);\n  // lookup and list of axis ids that axes in axNames have a reference to,\n  // even though they are missing from allAxisIds\n  var missingMatchedAxisIdsLookup = {};\n  var missingMatchedAxisIds = [];\n\n  // fill in 'missing' axis lookup when an axis is set to match an axis\n  // not part of the allAxisIds list, save axis type so that we can propagate\n  // it to the missing axes\n  function addMissingMatchedAxis() {\n    var matchesIn = axLayoutIn.matches;\n    if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n      missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n      missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n    }\n  }\n  var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);\n  var unifiedHover = isUnifiedHover(hovermode);\n\n  // first pass creates the containers, determines types, and handles most of the settings\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axId = name2id(axName);\n    axLetter = axName.charAt(0);\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];\n    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);\n    var defaultOptions = {\n      hasMinor: true,\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: ax2traces[axName] || [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: visibleDflt,\n      reverseDflt: reverseDflt,\n      autotypenumbersDflt: autotypenumbersDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId],\n      noAutotickangles: axLetter === 'y'\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n    var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n    var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n    var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n    var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n    var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n    var spikesnap = coerce2('spikesnap');\n    var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n    if (!showSpikes) {\n      delete axLayoutOut.spikecolor;\n      delete axLayoutOut.spikethickness;\n      delete axLayoutOut.spikedash;\n      delete axLayoutOut.spikemode;\n      delete axLayoutOut.spikesnap;\n    }\n\n    // If it exists, the the domain of the axis for the anchor of the overlaying axis\n    var overlayingAxis = id2name(axLayoutIn.overlaying);\n    var overlayingAnchorDomain = [0, 1];\n    if (layoutOut[overlayingAxis] !== undefined) {\n      var overlayingAnchor = id2name(layoutOut[overlayingAxis].anchor);\n      if (layoutOut[overlayingAnchor] !== undefined) {\n        overlayingAnchorDomain = layoutOut[overlayingAnchor].domain;\n      }\n    }\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid,\n      overlayingDomain: overlayingAnchorDomain\n    });\n    coerce('title.standoff');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  }\n\n  // coerce the 'missing' axes\n  i = 0;\n  while (i < missingMatchedAxisIds.length) {\n    axId = missingMatchedAxisIds[i++];\n    axName = id2name(axId);\n    axLetter = axName.charAt(0);\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var defaultOptions2 = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: false,\n      reverseDflt: false,\n      autotypenumbersDflt: autotypenumbersDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('fixedrange');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  }\n\n  // quick second pass for range slider and selector defaults\n  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n  for (i = 0; i < xNames.length; i++) {\n    axName = xNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    rangeSliderDefaults(layoutIn, layoutOut, axName);\n    if (axLayoutOut.type === 'date') {\n      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);\n    }\n    coerce('fixedrange');\n  }\n  for (i = 0; i < yNames.length; i++) {\n    axName = yNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n    coerce('fixedrange', fixedRangeDflt);\n  }\n\n  // Finally, handle scale constraints and matching axes.\n  //\n  // We need to do this after all axes have coerced both `type`\n  // (so we link only axes of the same type) and\n  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n  constraints.handleDefaults(layoutIn, layoutOut, {\n    axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),\n    axHasImage: axHasImage\n  });\n};","map":{"version":3,"names":["Lib","require","Color","isUnifiedHover","handleHoverModeDefaults","Template","basePlotLayoutAttributes","layoutAttributes","handleTypeDefaults","handleAxisDefaults","constraints","handlePositionDefaults","axisIds","id2name","name2id","AX_ID_PATTERN","Registry","traceIs","getComponentMethod","appendList","cont","k","item","Array","isArray","push","module","exports","supplyLayoutDefaults","layoutIn","layoutOut","fullData","autotypenumbersDflt","autotypenumbers","ax2traces","xaMayHide","yaMayHide","xaMustDisplay","yaMustDisplay","yaMustNotReverse","yaMayReverse","axHasImage","outerTicks","noGrids","i","j","length","trace","xaName","xaxis","xaxes","yaName","yaxis","yaxes","type","orientation","_cheater","positionAxis","subplots","_subplots","xIds","yIds","xNames","simpleMap","yNames","axNames","concat","plotBgColor","background","coerce","bgColor","combine","paper_bgcolor","axName","axId","axLetter","axLayoutIn","axLayoutOut","newAxLayoutOut","traces","_traceIndices","map","t","_expandedIndex","_annIndices","_shapeIndices","_selectionIndices","_imgIndices","_subplotsWith","_counterAxes","_name","_attr","_id","attr","dflt","coerce2","getCounterAxes","getOverlayableAxes","list","out","axName2","overlaying","counterAxes","x","y","allAxisIds","missingMatchedAxisIdsLookup","missingMatchedAxisIds","addMissingMatchedAxis","matchesIn","matches","test","indexOf","Object","keys","hovermode","unifiedHover","charAt","isPlainObject","newContainer","visibleDflt","reverseDflt","defaultOptions","hasMinor","letter","font","showGrid","data","calendar","automargin","splomStash","_splomAxes","noAutotickangles","uirevision","unifiedSpike","spikecolor","color","undefined","spikethickness","spikedash","spikemode","spikesnap","showSpikes","overlayingAxis","overlayingAnchorDomain","overlayingAnchor","anchor","domain","overlayableAxes","grid","overlayingDomain","_input","defaultOptions2","rangeSliderDefaults","rangeSelectorDefaults","anchoredAxis","fixedRangeDflt","handleDefaults","axIds","sort","idSort"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/cartesian/layout_defaults.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\nvar Template = require('../../plot_api/plot_template');\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\nvar handleTypeDefaults = require('./type_defaults');\nvar handleAxisDefaults = require('./axis_defaults');\nvar constraints = require('./constraints');\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\n\nvar Registry = require('../../registry');\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n    if(Array.isArray(cont[k])) cont[k].push(item);\n    else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    var autotypenumbersDflt = layoutOut.autotypenumbers;\n\n    var ax2traces = {};\n    var xaMayHide = {};\n    var yaMayHide = {};\n    var xaMustDisplay = {};\n    var yaMustDisplay = {};\n    var yaMustNotReverse = {};\n    var yaMayReverse = {};\n    var axHasImage = {};\n    var outerTicks = {};\n    var noGrids = {};\n    var i, j;\n\n    // look for axes in the data\n    for(i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n        if(!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n\n        var xaName;\n        if(trace.xaxis) {\n            xaName = id2name(trace.xaxis);\n            appendList(ax2traces, xaName, trace);\n        } else if(trace.xaxes) {\n            for(j = 0; j < trace.xaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n            }\n        }\n\n        var yaName;\n        if(trace.yaxis) {\n            yaName = id2name(trace.yaxis);\n            appendList(ax2traces, yaName, trace);\n        } else if(trace.yaxes) {\n            for(j = 0; j < trace.yaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n            }\n        }\n\n        // logic for funnels\n        if(trace.type === 'funnel') {\n            if(trace.orientation === 'h') {\n                if(xaName) xaMayHide[xaName] = true;\n                if(yaName) yaMayReverse[yaName] = true;\n            } else {\n                if(yaName) yaMayHide[yaName] = true;\n            }\n        } else if(trace.type === 'image') {\n            if(yaName) axHasImage[yaName] = true;\n            if(xaName) axHasImage[xaName] = true;\n        } else {\n            if(yaName) {\n                yaMustDisplay[yaName] = true;\n                yaMustNotReverse[yaName] = true;\n            }\n\n            if(!traceIs(trace, 'carpet') || (trace.type === 'carpet' && !trace._cheater)) {\n                if(xaName) xaMustDisplay[xaName] = true;\n            }\n        }\n\n        // Two things trigger axis visibility:\n        // 1. is not carpet\n        // 2. carpet that's not cheater\n\n        // The above check for definitely-not-cheater is not adequate. This\n        // second list tracks which axes *could* be a cheater so that the\n        // full condition triggering hiding is:\n        //   *could* be a cheater and *is not definitely visible*\n        if(trace.type === 'carpet' && trace._cheater) {\n            if(xaName) xaMayHide[xaName] = true;\n        }\n\n        // check for default formatting tweaks\n        if(traceIs(trace, '2dMap')) {\n            outerTicks[xaName] = true;\n            outerTicks[yaName] = true;\n        }\n\n        if(traceIs(trace, 'oriented')) {\n            var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n            noGrids[positionAxis] = true;\n        }\n    }\n\n    var subplots = layoutOut._subplots;\n    var xIds = subplots.xaxis;\n    var yIds = subplots.yaxis;\n    var xNames = Lib.simpleMap(xIds, id2name);\n    var yNames = Lib.simpleMap(yIds, id2name);\n    var axNames = xNames.concat(yNames);\n\n    // plot_bgcolor only makes sense if there's a (2D) plot!\n    // TODO: bgcolor for each subplot, to inherit from the main one\n    var plotBgColor = Color.background;\n    if(xIds.length && yIds.length) {\n        plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n    }\n\n    var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n\n    // name of single axis (e.g. 'xaxis', 'yaxis2')\n    var axName;\n    // id of single axis (e.g. 'y', 'x5')\n    var axId;\n    // 'x' or 'y'\n    var axLetter;\n    // input layout axis container\n    var axLayoutIn;\n    // full layout axis container\n    var axLayoutOut;\n\n    function newAxLayoutOut() {\n        var traces = ax2traces[axName] || [];\n        axLayoutOut._traceIndices = traces.map(function(t) { return t._expandedIndex; });\n        axLayoutOut._annIndices = [];\n        axLayoutOut._shapeIndices = [];\n        axLayoutOut._selectionIndices = [];\n        axLayoutOut._imgIndices = [];\n        axLayoutOut._subplotsWith = [];\n        axLayoutOut._counterAxes = [];\n        axLayoutOut._name = axLayoutOut._attr = axName;\n        axLayoutOut._id = axId;\n    }\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function coerce2(attr, dflt) {\n        return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function getCounterAxes(axLetter) {\n        return (axLetter === 'x') ? yIds : xIds;\n    }\n\n    function getOverlayableAxes(axLetter, axName) {\n        var list = (axLetter === 'x') ? xNames : yNames;\n        var out = [];\n\n        for(var j = 0; j < list.length; j++) {\n            var axName2 = list[j];\n\n            if(axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n                out.push(name2id(axName2));\n            }\n        }\n\n        return out;\n    }\n\n    // list of available counter axis names\n    var counterAxes = {x: getCounterAxes('x'), y: getCounterAxes('y')};\n    // list of all x AND y axis ids\n    var allAxisIds = counterAxes.x.concat(counterAxes.y);\n    // lookup and list of axis ids that axes in axNames have a reference to,\n    // even though they are missing from allAxisIds\n    var missingMatchedAxisIdsLookup = {};\n    var missingMatchedAxisIds = [];\n\n    // fill in 'missing' axis lookup when an axis is set to match an axis\n    // not part of the allAxisIds list, save axis type so that we can propagate\n    // it to the missing axes\n    function addMissingMatchedAxis() {\n        var matchesIn = axLayoutIn.matches;\n        if(AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n            missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n            missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n        }\n    }\n\n    var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);\n    var unifiedHover = isUnifiedHover(hovermode);\n\n    // first pass creates the containers, determines types, and handles most of the settings\n    for(i = 0; i < axNames.length; i++) {\n        axName = axNames[i];\n        axId = name2id(axName);\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n        newAxLayoutOut();\n\n        var visibleDflt =\n            (axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName]) ||\n            (axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName]);\n\n        var reverseDflt =\n            (axLetter === 'y' &&\n              (\n                (!yaMustNotReverse[axName] && yaMayReverse[axName]) ||\n                axHasImage[axName]\n              ));\n\n        var defaultOptions = {\n            hasMinor: true,\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: ax2traces[axName] || [],\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: visibleDflt,\n            reverseDflt: reverseDflt,\n            autotypenumbersDflt: autotypenumbersDflt,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId],\n            noAutotickangles: axLetter === 'y'\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n\n        var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n        var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n        var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n        var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n        var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n        var spikesnap = coerce2('spikesnap');\n        var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n        if(!showSpikes) {\n            delete axLayoutOut.spikecolor;\n            delete axLayoutOut.spikethickness;\n            delete axLayoutOut.spikedash;\n            delete axLayoutOut.spikemode;\n            delete axLayoutOut.spikesnap;\n        }\n\n        // If it exists, the the domain of the axis for the anchor of the overlaying axis\n        var overlayingAxis = id2name(axLayoutIn.overlaying);\n        var overlayingAnchorDomain = [0, 1];\n\n        if(layoutOut[overlayingAxis] !== undefined) {\n            var overlayingAnchor = id2name(layoutOut[overlayingAxis].anchor);\n            if(layoutOut[overlayingAnchor] !== undefined) {\n                overlayingAnchorDomain = layoutOut[overlayingAnchor].domain;\n            }\n        }\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: getOverlayableAxes(axLetter, axName),\n            grid: layoutOut.grid,\n            overlayingDomain: overlayingAnchorDomain\n\n        });\n\n        coerce('title.standoff');\n\n        addMissingMatchedAxis();\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // coerce the 'missing' axes\n    i = 0;\n    while(i < missingMatchedAxisIds.length) {\n        axId = missingMatchedAxisIds[i++];\n        axName = id2name(axId);\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n        newAxLayoutOut();\n\n        var defaultOptions2 = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: [],\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: false,\n            reverseDflt: false,\n            autotypenumbersDflt: autotypenumbersDflt,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: getOverlayableAxes(axLetter, axName),\n            grid: layoutOut.grid\n        });\n\n        coerce('fixedrange');\n\n        addMissingMatchedAxis();\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // quick second pass for range slider and selector defaults\n    var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n    var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n    for(i = 0; i < xNames.length; i++) {\n        axName = xNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n        if(axLayoutOut.type === 'date') {\n            rangeSelectorDefaults(\n                axLayoutIn,\n                axLayoutOut,\n                layoutOut,\n                yNames,\n                axLayoutOut.calendar\n            );\n        }\n\n        coerce('fixedrange');\n    }\n\n    for(i = 0; i < yNames.length; i++) {\n        axName = yNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n\n        var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n\n        coerce('fixedrange', fixedRangeDflt);\n    }\n\n    // Finally, handle scale constraints and matching axes.\n    //\n    // We need to do this after all axes have coerced both `type`\n    // (so we link only axes of the same type) and\n    // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n    constraints.handleDefaults(layoutIn, layoutOut, {\n        axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),\n        axHasImage: axHasImage\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}