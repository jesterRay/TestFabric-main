{"ast":null,"code":"'use strict';\n\nvar Registry = require('../registry');\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\nexports.getSubplotCalcData = function (calcData, type, subplotId) {\n  var basePlotModule = Registry.subplotsRegistry[type];\n  if (!basePlotModule) return [];\n  var attr = basePlotModule.attr;\n  var subplotCalcData = [];\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n    if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n  }\n  return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n * @param {int} arg2: (optional) zorder to filter on\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\nexports.getModuleCalcData = function (calcdata, arg1, arg2) {\n  var moduleCalcData = [];\n  var remainingCalcData = [];\n  var plotMethod;\n  if (typeof arg1 === 'string') {\n    plotMethod = Registry.getModule(arg1).plot;\n  } else if (typeof arg1 === 'function') {\n    plotMethod = arg1;\n  } else {\n    plotMethod = arg1.plot;\n  }\n  if (!plotMethod) {\n    return [moduleCalcData, calcdata];\n  }\n  var zorder = arg2;\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var trace = cd[0].trace;\n    var filterByZ = trace.zorder !== undefined;\n    // N.B.\n    // - 'legendonly' traces do not make it past here\n    // - skip over 'visible' traces that got trimmed completely during calc transforms\n    if (trace.visible !== true || trace._length === 0) continue;\n\n    // group calcdata trace not by 'module' (as the name of this function\n    // would suggest), but by 'module plot method' so that if some traces\n    // share the same module plot method (e.g. bar and histogram), we\n    // only call it one!\n    if (trace._module && trace._module.plot === plotMethod && (!filterByZ || trace.zorder === zorder)) {\n      moduleCalcData.push(cd);\n    } else {\n      remainingCalcData.push(cd);\n    }\n  }\n  return [moduleCalcData, remainingCalcData];\n};\n\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n  if (!Registry.subplotsRegistry[type]) return [];\n  var attr = Registry.subplotsRegistry[type].attr;\n  var subplotData = [];\n  var trace, subplotX, subplotY;\n  if (type === 'gl2d') {\n    var spmatch = subplotId.match(SUBPLOT_PATTERN);\n    subplotX = 'x' + spmatch[1];\n    subplotY = 'y' + spmatch[2];\n  }\n  for (var i = 0; i < data.length; i++) {\n    trace = data[i];\n    if (type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n      if (trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n        subplotData.push(trace);\n      }\n    } else {\n      if (trace[attr] === subplotId) subplotData.push(trace);\n    }\n  }\n  return subplotData;\n};","map":{"version":3,"names":["Registry","require","SUBPLOT_PATTERN","exports","getSubplotCalcData","calcData","type","subplotId","basePlotModule","subplotsRegistry","attr","subplotCalcData","i","length","calcTrace","trace","push","getModuleCalcData","calcdata","arg1","arg2","moduleCalcData","remainingCalcData","plotMethod","getModule","plot","zorder","cd","filterByZ","undefined","visible","_length","_module","getSubplotData","data","subplotData","subplotX","subplotY","spmatch","match","traceIs"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/get_data.js"],"sourcesContent":["'use strict';\n\nvar Registry = require('../registry');\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\nexports.getSubplotCalcData = function(calcData, type, subplotId) {\n    var basePlotModule = Registry.subplotsRegistry[type];\n    if(!basePlotModule) return [];\n\n    var attr = basePlotModule.attr;\n    var subplotCalcData = [];\n\n    for(var i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i];\n        var trace = calcTrace[0].trace;\n\n        if(trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n    }\n\n    return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n * @param {int} arg2: (optional) zorder to filter on\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\nexports.getModuleCalcData = function(calcdata, arg1, arg2) {\n    var moduleCalcData = [];\n    var remainingCalcData = [];\n\n    var plotMethod;\n    if(typeof arg1 === 'string') {\n        plotMethod = Registry.getModule(arg1).plot;\n    } else if(typeof arg1 === 'function') {\n        plotMethod = arg1;\n    } else {\n        plotMethod = arg1.plot;\n    }\n    if(!plotMethod) {\n        return [moduleCalcData, calcdata];\n    }\n    var zorder = arg2;\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var trace = cd[0].trace;\n        var filterByZ = (trace.zorder !== undefined);\n        // N.B.\n        // - 'legendonly' traces do not make it past here\n        // - skip over 'visible' traces that got trimmed completely during calc transforms\n        if(trace.visible !== true || trace._length === 0) continue;\n\n        // group calcdata trace not by 'module' (as the name of this function\n        // would suggest), but by 'module plot method' so that if some traces\n        // share the same module plot method (e.g. bar and histogram), we\n        // only call it one!\n        if(trace._module && trace._module.plot === plotMethod && (!filterByZ || trace.zorder === zorder)) {\n            moduleCalcData.push(cd);\n        } else {\n            remainingCalcData.push(cd);\n        }\n    }\n\n    return [moduleCalcData, remainingCalcData];\n};\n\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n    if(!Registry.subplotsRegistry[type]) return [];\n\n    var attr = Registry.subplotsRegistry[type].attr;\n    var subplotData = [];\n    var trace, subplotX, subplotY;\n\n    if(type === 'gl2d') {\n        var spmatch = subplotId.match(SUBPLOT_PATTERN);\n        subplotX = 'x' + spmatch[1];\n        subplotY = 'y' + spmatch[2];\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        trace = data[i];\n\n        if(type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n            if(trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n                subplotData.push(trace);\n            }\n        } else {\n            if(trace[attr] === subplotId) subplotData.push(trace);\n        }\n    }\n\n    return subplotData;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}