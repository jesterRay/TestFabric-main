{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar orientations = ['v', 'h'];\nfunction crossTraceCalc(gd, plotinfo) {\n  var calcdata = gd.calcdata;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  for (var i = 0; i < orientations.length; i++) {\n    var orientation = orientations[i];\n    var posAxis = orientation === 'h' ? ya : xa;\n    var boxList = [];\n\n    // make list of boxes / candlesticks\n    // For backward compatibility, candlesticks are treated as if they *are* box traces here\n    for (var j = 0; j < calcdata.length; j++) {\n      var cd = calcdata[j];\n      var t = cd[0].t;\n      var trace = cd[0].trace;\n      if (trace.visible === true && (trace.type === 'box' || trace.type === 'candlestick') && !t.empty && (trace.orientation || 'v') === orientation && trace.xaxis === xa._id && trace.yaxis === ya._id) {\n        boxList.push(j);\n      }\n    }\n    setPositionOffset('box', gd, boxList, posAxis);\n  }\n}\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n  var calcdata = gd.calcdata;\n  var fullLayout = gd._fullLayout;\n  var axId = posAxis._id;\n  var axLetter = axId.charAt(0);\n  var i, j, calcTrace;\n  var pointList = [];\n  var shownPts = 0;\n\n  // make list of box points\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n    for (j = 0; j < calcTrace.length; j++) {\n      pointList.push(posAxis.c2l(calcTrace[j].pos, true));\n      shownPts += (calcTrace[j].pts2 || []).length;\n    }\n  }\n  if (!pointList.length) return;\n\n  // box plots - update dPos based on multiple traces\n  var boxdv = Lib.distinctVals(pointList);\n  if (posAxis.type === 'category' || posAxis.type === 'multicategory') {\n    boxdv.minDiff = 1;\n  }\n  var dPos0 = boxdv.minDiff / 2;\n\n  // check for forced minimum dtick\n  Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n  var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n  var numTotal = fullLayout[numKey];\n  var group = fullLayout[traceType + 'mode'] === 'group' && numTotal > 1;\n  var groupFraction = 1 - fullLayout[traceType + 'gap'];\n  var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n    var trace = calcTrace[0].trace;\n    var t = calcTrace[0].t;\n    var width = trace.width;\n    var side = trace.side;\n\n    // position coordinate delta\n    var dPos;\n    // box half width;\n    var bdPos;\n    // box center offset\n    var bPos;\n    // half-width within which to accept hover for this box/violin\n    // always split the distance to the closest box/violin\n    var wHover;\n    if (width) {\n      dPos = bdPos = wHover = width / 2;\n      bPos = 0;\n    } else {\n      dPos = dPos0;\n      if (group) {\n        var groupId = getAxisGroup(fullLayout, posAxis._id) + trace.orientation;\n        var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n        var num = nOffsetGroups || numTotal;\n        var shift = nOffsetGroups ? trace._offsetIndex : t.num;\n        bdPos = dPos * groupFraction * groupGapFraction / num;\n        bPos = 2 * dPos * (-0.5 + (shift + 0.5) / num) * groupFraction;\n        wHover = dPos * groupFraction / num;\n      } else {\n        bdPos = dPos * groupFraction * groupGapFraction;\n        bPos = 0;\n        wHover = dPos;\n      }\n    }\n    t.dPos = dPos;\n    t.bPos = bPos;\n    t.bdPos = bdPos;\n    t.wHover = wHover;\n\n    // box/violin-only value-space push value\n    var pushplus;\n    var pushminus;\n    // edge of box/violin\n    var edge = bPos + bdPos;\n    var edgeplus;\n    var edgeminus;\n    // value-space padding\n    var vpadplus;\n    var vpadminus;\n    // pixel-space padding\n    var ppadplus;\n    var ppadminus;\n    // do we add 5% of both sides (more logic for points beyond box/violin below)\n    var padded = Boolean(width);\n    // does this trace show points?\n    var hasPts = (trace.boxpoints || trace.points) && shownPts > 0;\n    if (side === 'positive') {\n      pushplus = dPos * (width ? 1 : 0.5);\n      edgeplus = edge;\n      pushminus = edgeplus = bPos;\n    } else if (side === 'negative') {\n      pushplus = edgeplus = bPos;\n      pushminus = dPos * (width ? 1 : 0.5);\n      edgeminus = edge;\n    } else {\n      pushplus = pushminus = dPos;\n      edgeplus = edgeminus = edge;\n    }\n    if (hasPts) {\n      var pointpos = trace.pointpos;\n      var jitter = trace.jitter;\n      var ms = trace.marker.size / 2;\n      var pp = 0;\n      if (pointpos + jitter >= 0) {\n        pp = edge * (pointpos + jitter);\n        if (pp > pushplus) {\n          // (++) beyond plus-value, use pp\n          padded = true;\n          ppadplus = ms;\n          vpadplus = pp;\n        } else if (pp > edgeplus) {\n          // (+), use push-value (it's bigger), but add px-pad\n          ppadplus = ms;\n          vpadplus = pushplus;\n        }\n      }\n      if (pp <= pushplus) {\n        // (->) fallback to push value\n        vpadplus = pushplus;\n      }\n      var pm = 0;\n      if (pointpos - jitter <= 0) {\n        pm = -edge * (pointpos - jitter);\n        if (pm > pushminus) {\n          // (--) beyond plus-value, use pp\n          padded = true;\n          ppadminus = ms;\n          vpadminus = pm;\n        } else if (pm > edgeminus) {\n          // (-), use push-value (it's bigger), but add px-pad\n          ppadminus = ms;\n          vpadminus = pushminus;\n        }\n      }\n      if (pm <= pushminus) {\n        // (<-) fallback to push value\n        vpadminus = pushminus;\n      }\n    } else {\n      vpadplus = pushplus;\n      vpadminus = pushminus;\n    }\n    var pos = new Array(calcTrace.length);\n    for (j = 0; j < calcTrace.length; j++) {\n      pos[j] = calcTrace[j].pos;\n    }\n    trace._extremes[axId] = Axes.findExtremes(posAxis, pos, {\n      padded: padded,\n      vpadminus: vpadminus,\n      vpadplus: vpadplus,\n      vpadLinearized: true,\n      // N.B. SVG px-space positive/negative\n      ppadminus: {\n        x: ppadminus,\n        y: ppadplus\n      }[axLetter],\n      ppadplus: {\n        x: ppadplus,\n        y: ppadminus\n      }[axLetter]\n    });\n  }\n}\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setPositionOffset: setPositionOffset\n};","map":{"version":3,"names":["Axes","require","Lib","getAxisGroup","orientations","crossTraceCalc","gd","plotinfo","calcdata","xa","xaxis","ya","yaxis","i","length","orientation","posAxis","boxList","j","cd","t","trace","visible","type","empty","_id","push","setPositionOffset","traceType","fullLayout","_fullLayout","axId","axLetter","charAt","calcTrace","pointList","shownPts","c2l","pos","pts2","boxdv","distinctVals","minDiff","dPos0","minDtick","vals","numKey","numTotal","group","groupFraction","groupGapFraction","width","side","dPos","bdPos","bPos","wHover","groupId","alignmentGroups","_alignmentOpts","alignmentGroupOpts","alignmentgroup","nOffsetGroups","Object","keys","offsetGroups","num","shift","_offsetIndex","pushplus","pushminus","edge","edgeplus","edgeminus","vpadplus","vpadminus","ppadplus","ppadminus","padded","Boolean","hasPts","boxpoints","points","pointpos","jitter","ms","marker","size","pp","pm","Array","_extremes","findExtremes","vpadLinearized","x","y","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/box/cross_trace_calc.js"],"sourcesContent":["'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar orientations = ['v', 'h'];\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var calcdata = gd.calcdata;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    for(var i = 0; i < orientations.length; i++) {\n        var orientation = orientations[i];\n        var posAxis = orientation === 'h' ? ya : xa;\n        var boxList = [];\n\n        // make list of boxes / candlesticks\n        // For backward compatibility, candlesticks are treated as if they *are* box traces here\n        for(var j = 0; j < calcdata.length; j++) {\n            var cd = calcdata[j];\n            var t = cd[0].t;\n            var trace = cd[0].trace;\n\n            if(trace.visible === true &&\n                    (trace.type === 'box' || trace.type === 'candlestick') &&\n                    !t.empty &&\n                    (trace.orientation || 'v') === orientation &&\n                    trace.xaxis === xa._id &&\n                    trace.yaxis === ya._id\n              ) {\n                boxList.push(j);\n            }\n        }\n\n        setPositionOffset('box', gd, boxList, posAxis);\n    }\n}\n\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n    var calcdata = gd.calcdata;\n    var fullLayout = gd._fullLayout;\n    var axId = posAxis._id;\n    var axLetter = axId.charAt(0);\n\n    var i, j, calcTrace;\n    var pointList = [];\n    var shownPts = 0;\n\n    // make list of box points\n    for(i = 0; i < boxList.length; i++) {\n        calcTrace = calcdata[boxList[i]];\n        for(j = 0; j < calcTrace.length; j++) {\n            pointList.push(posAxis.c2l(calcTrace[j].pos, true));\n            shownPts += (calcTrace[j].pts2 || []).length;\n        }\n    }\n\n    if(!pointList.length) return;\n\n    // box plots - update dPos based on multiple traces\n    var boxdv = Lib.distinctVals(pointList);\n    if(posAxis.type === 'category' || posAxis.type === 'multicategory') {\n        boxdv.minDiff = 1;\n    }\n\n    var dPos0 = boxdv.minDiff / 2;\n\n    // check for forced minimum dtick\n    Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n\n    var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n    var numTotal = fullLayout[numKey];\n    var group = fullLayout[traceType + 'mode'] === 'group' && numTotal > 1;\n    var groupFraction = 1 - fullLayout[traceType + 'gap'];\n    var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n\n    for(i = 0; i < boxList.length; i++) {\n        calcTrace = calcdata[boxList[i]];\n\n        var trace = calcTrace[0].trace;\n        var t = calcTrace[0].t;\n        var width = trace.width;\n        var side = trace.side;\n\n        // position coordinate delta\n        var dPos;\n        // box half width;\n        var bdPos;\n        // box center offset\n        var bPos;\n        // half-width within which to accept hover for this box/violin\n        // always split the distance to the closest box/violin\n        var wHover;\n\n        if(width) {\n            dPos = bdPos = wHover = width / 2;\n            bPos = 0;\n        } else {\n            dPos = dPos0;\n\n            if(group) {\n                var groupId = getAxisGroup(fullLayout, posAxis._id) + trace.orientation;\n                var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n                var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n                var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n                var num = nOffsetGroups || numTotal;\n                var shift = nOffsetGroups ? trace._offsetIndex : t.num;\n\n                bdPos = dPos * groupFraction * groupGapFraction / num;\n                bPos = 2 * dPos * (-0.5 + (shift + 0.5) / num) * groupFraction;\n                wHover = dPos * groupFraction / num;\n            } else {\n                bdPos = dPos * groupFraction * groupGapFraction;\n                bPos = 0;\n                wHover = dPos;\n            }\n        }\n        t.dPos = dPos;\n        t.bPos = bPos;\n        t.bdPos = bdPos;\n        t.wHover = wHover;\n\n        // box/violin-only value-space push value\n        var pushplus;\n        var pushminus;\n        // edge of box/violin\n        var edge = bPos + bdPos;\n        var edgeplus;\n        var edgeminus;\n        // value-space padding\n        var vpadplus;\n        var vpadminus;\n        // pixel-space padding\n        var ppadplus;\n        var ppadminus;\n        // do we add 5% of both sides (more logic for points beyond box/violin below)\n        var padded = Boolean(width);\n        // does this trace show points?\n        var hasPts = (trace.boxpoints || trace.points) && (shownPts > 0);\n\n        if(side === 'positive') {\n            pushplus = dPos * (width ? 1 : 0.5);\n            edgeplus = edge;\n            pushminus = edgeplus = bPos;\n        } else if(side === 'negative') {\n            pushplus = edgeplus = bPos;\n            pushminus = dPos * (width ? 1 : 0.5);\n            edgeminus = edge;\n        } else {\n            pushplus = pushminus = dPos;\n            edgeplus = edgeminus = edge;\n        }\n\n        if(hasPts) {\n            var pointpos = trace.pointpos;\n            var jitter = trace.jitter;\n            var ms = trace.marker.size / 2;\n\n            var pp = 0;\n            if((pointpos + jitter) >= 0) {\n                pp = edge * (pointpos + jitter);\n                if(pp > pushplus) {\n                    // (++) beyond plus-value, use pp\n                    padded = true;\n                    ppadplus = ms;\n                    vpadplus = pp;\n                } else if(pp > edgeplus) {\n                    // (+), use push-value (it's bigger), but add px-pad\n                    ppadplus = ms;\n                    vpadplus = pushplus;\n                }\n            }\n            if(pp <= pushplus) {\n                // (->) fallback to push value\n                vpadplus = pushplus;\n            }\n\n            var pm = 0;\n            if((pointpos - jitter) <= 0) {\n                pm = -edge * (pointpos - jitter);\n                if(pm > pushminus) {\n                    // (--) beyond plus-value, use pp\n                    padded = true;\n                    ppadminus = ms;\n                    vpadminus = pm;\n                } else if(pm > edgeminus) {\n                    // (-), use push-value (it's bigger), but add px-pad\n                    ppadminus = ms;\n                    vpadminus = pushminus;\n                }\n            }\n            if(pm <= pushminus) {\n                // (<-) fallback to push value\n                vpadminus = pushminus;\n            }\n        } else {\n            vpadplus = pushplus;\n            vpadminus = pushminus;\n        }\n\n        var pos = new Array(calcTrace.length);\n        for(j = 0; j < calcTrace.length; j++) {\n            pos[j] = calcTrace[j].pos;\n        }\n\n        trace._extremes[axId] = Axes.findExtremes(posAxis, pos, {\n            padded: padded,\n            vpadminus: vpadminus,\n            vpadplus: vpadplus,\n            vpadLinearized: true,\n            // N.B. SVG px-space positive/negative\n            ppadminus: {x: ppadminus, y: ppadplus}[axLetter],\n            ppadplus: {x: ppadplus, y: ppadminus}[axLetter],\n        });\n    }\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setPositionOffset: setPositionOffset\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}