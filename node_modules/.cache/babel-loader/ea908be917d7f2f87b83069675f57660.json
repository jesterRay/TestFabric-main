{"ast":null,"code":"'use strict';\n\nvar constants = require('./constants');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\nexports.extractPathCoords = function (path, paramsToUse, isRaw) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    var str = params[relevantParamIdx];\n    var pos = isRaw ? str : Lib.cleanNumber(str);\n    extractedCoordinates.push(pos);\n  });\n  return extractedCoordinates;\n};\nexports.getDataToPixel = function (gd, axis, shift, isVertical, refType) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n  if (axis) {\n    if (refType === 'domain') {\n      dataToPixel = function (v) {\n        return axis._length * (isVertical ? 1 - v : v) + axis._offset;\n      };\n    } else {\n      var d2r = exports.shapePositionToRange(axis);\n      dataToPixel = function (v) {\n        var shiftPixels = getPixelShift(axis, shift);\n        return axis._offset + axis.r2p(d2r(v, true)) + shiftPixels;\n      };\n      if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    }\n  } else if (isVertical) {\n    dataToPixel = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n  return dataToPixel;\n};\nexports.getPixelToData = function (gd, axis, isVertical, opt) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n  if (axis) {\n    if (opt === 'domain') {\n      pixelToData = function (p) {\n        var q = (p - axis._offset) / axis._length;\n        return isVertical ? 1 - q : q;\n      };\n    } else {\n      var r2d = exports.rangeToShapePosition(axis);\n      pixelToData = function (p) {\n        return r2d(axis.p2r(p - axis._offset));\n      };\n    }\n  } else if (isVertical) {\n    pixelToData = function (p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function (p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n  return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\nexports.makeShapesOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.shapes[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n  plotinfo.xsizemode = options.xsizemode;\n  plotinfo.ysizemode = options.ysizemode;\n  plotinfo.xanchor = options.xanchor;\n  plotinfo.yanchor = options.yanchor;\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};\n\n// TODO: move to selections helpers?\nexports.makeSelectionsOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.selections[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};\nexports.getPathString = function (gd, options) {\n  var type = options.type;\n  var xRefType = Axes.getRefType(options.xref);\n  var yRefType = Axes.getRefType(options.yref);\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  var gs = gd._fullLayout._size;\n  var x2r, x2p, y2r, y2p;\n  var xShiftStart = getPixelShift(xa, options.x0shift);\n  var xShiftEnd = getPixelShift(xa, options.x1shift);\n  var yShiftStart = getPixelShift(ya, options.y0shift);\n  var yShiftEnd = getPixelShift(ya, options.y1shift);\n  var x0, x1, y0, y1;\n  if (xa) {\n    if (xRefType === 'domain') {\n      x2p = function (v) {\n        return xa._offset + xa._length * v;\n      };\n    } else {\n      x2r = exports.shapePositionToRange(xa);\n      x2p = function (v) {\n        return xa._offset + xa.r2p(x2r(v, true));\n      };\n    }\n  } else {\n    x2p = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n  if (ya) {\n    if (yRefType === 'domain') {\n      y2p = function (v) {\n        return ya._offset + ya._length * (1 - v);\n      };\n    } else {\n      y2r = exports.shapePositionToRange(ya);\n      y2p = function (v) {\n        return ya._offset + ya.r2p(y2r(v, true));\n      };\n    }\n  } else {\n    y2p = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  }\n  if (type === 'path') {\n    if (xa && xa.type === 'date') x2p = exports.decodeDate(x2p);\n    if (ya && ya.type === 'date') y2p = exports.decodeDate(y2p);\n    return convertPath(options, x2p, y2p);\n  }\n  if (options.xsizemode === 'pixel') {\n    var xAnchorPos = x2p(options.xanchor);\n    x0 = xAnchorPos + options.x0 + xShiftStart;\n    x1 = xAnchorPos + options.x1 + xShiftEnd;\n  } else {\n    x0 = x2p(options.x0) + xShiftStart;\n    x1 = x2p(options.x1) + xShiftEnd;\n  }\n  if (options.ysizemode === 'pixel') {\n    var yAnchorPos = y2p(options.yanchor);\n    y0 = yAnchorPos - options.y0 + yShiftStart;\n    y1 = yAnchorPos - options.y1 + yShiftEnd;\n  } else {\n    y0 = y2p(options.y0) + yShiftStart;\n    y1 = y2p(options.y1) + yShiftEnd;\n  }\n  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n  // circle\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var rx = Math.abs(cx - x0);\n  var ry = Math.abs(cy - y0);\n  var rArc = 'A' + rx + ',' + ry;\n  var rightPt = cx + rx + ',' + cy;\n  var topPt = cx + ',' + (cy - ry);\n  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';\n};\nfunction convertPath(options, x2p, y2p) {\n  var pathIn = options.path;\n  var xSizemode = options.xsizemode;\n  var ySizemode = options.ysizemode;\n  var xAnchor = options.xanchor;\n  var yAnchor = options.yanchor;\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (xParams[paramNumber]) {\n        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);\n      } else if (yParams[paramNumber]) {\n        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);\n      }\n      paramNumber++;\n      if (paramNumber > nParams) param = 'X';\n      return param;\n    });\n    if (paramNumber > nParams) {\n      paramString = paramString.replace(/[\\s,]*X.*/, '');\n      Lib.log('Ignoring extra params in segment ' + segment);\n    }\n    return segmentType + paramString;\n  });\n}\nfunction getPixelShift(axis, shift) {\n  shift = shift || 0;\n  var shiftPixels = 0;\n  if (shift && axis && (axis.type === 'category' || axis.type === 'multicategory')) {\n    shiftPixels = (axis.r2p(1) - axis.r2p(0)) * shift;\n  }\n  return shiftPixels;\n}","map":{"version":3,"names":["constants","require","Lib","Axes","exports","rangeToShapePosition","ax","type","r2d","v","shapePositionToRange","d2r","decodeDate","convertToPx","replace","encodeDate","convertToDate","extractPathCoords","path","paramsToUse","isRaw","extractedCoordinates","segments","match","segmentRE","forEach","segment","relevantParamIdx","charAt","drawn","undefined","params","substr","paramRE","length","str","pos","cleanNumber","push","getDataToPixel","gd","axis","shift","isVertical","refType","gs","_fullLayout","_size","dataToPixel","_length","_offset","shiftPixels","getPixelShift","r2p","t","h","l","w","getPixelToData","opt","pixelToData","p","q","p2r","roundPositionForSharpStrokeRendering","strokeWidth","strokeWidthIsOdd","Math","round","posValAsInt","makeShapesOptionsAndPlotinfo","index","options","shapes","plotinfo","_plots","xref","yref","hasPlotinfo","_hadPlotinfo","xaxis","yaxis","xsizemode","ysizemode","xanchor","yanchor","makeSelectionsOptionsAndPlotinfo","selections","getPathString","xRefType","getRefType","yRefType","xa","getFromId","ya","x2r","x2p","y2r","y2p","xShiftStart","x0shift","xShiftEnd","x1shift","yShiftStart","y0shift","yShiftEnd","y1shift","x0","x1","y0","y1","convertPath","xAnchorPos","yAnchorPos","cx","cy","rx","abs","ry","rArc","rightPt","topPt","pathIn","xSizemode","ySizemode","xAnchor","yAnchor","paramNumber","segmentType","xParams","paramIsX","yParams","paramIsY","nParams","numParams","paramString","param","Number","log"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/components/shapes/helpers.js"],"sourcesContent":["'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function(ax) {\n    return (ax.type === 'log') ? ax.r2d : function(v) { return v; };\n};\n\nexports.shapePositionToRange = function(ax) {\n    return (ax.type === 'log') ? ax.d2r : function(v) { return v; };\n};\n\nexports.decodeDate = function(convertToPx) {\n    return function(v) {\n        if(v.replace) v = v.replace('_', ' ');\n        return convertToPx(v);\n    };\n};\n\nexports.encodeDate = function(convertToDate) {\n    return function(v) { return convertToDate(v).replace(' ', '_'); };\n};\n\nexports.extractPathCoords = function(path, paramsToUse, isRaw) {\n    var extractedCoordinates = [];\n\n    var segments = path.match(constants.segmentRE);\n    segments.forEach(function(segment) {\n        var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n        if(relevantParamIdx === undefined) return;\n\n        var params = segment.substr(1).match(constants.paramRE);\n        if(!params || params.length < relevantParamIdx) return;\n\n        var str = params[relevantParamIdx];\n        var pos = isRaw ? str : Lib.cleanNumber(str);\n\n        extractedCoordinates.push(pos);\n    });\n\n    return extractedCoordinates;\n};\n\nexports.getDataToPixel = function(gd, axis, shift, isVertical, refType) {\n    var gs = gd._fullLayout._size;\n    var dataToPixel;\n\n    if(axis) {\n        if(refType === 'domain') {\n            dataToPixel = function(v) {\n                return axis._length * (isVertical ? (1 - v) : v) + axis._offset;\n            };\n        } else {\n            var d2r = exports.shapePositionToRange(axis);\n\n            dataToPixel = function(v) {\n                var shiftPixels = getPixelShift(axis, shift);\n                return axis._offset + axis.r2p(d2r(v, true)) + shiftPixels;\n            };\n\n            if(axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n        }\n    } else if(isVertical) {\n        dataToPixel = function(v) { return gs.t + gs.h * (1 - v); };\n    } else {\n        dataToPixel = function(v) { return gs.l + gs.w * v; };\n    }\n\n    return dataToPixel;\n};\n\nexports.getPixelToData = function(gd, axis, isVertical, opt) {\n    var gs = gd._fullLayout._size;\n    var pixelToData;\n\n    if(axis) {\n        if(opt === 'domain') {\n            pixelToData = function(p) {\n                var q = (p - axis._offset) / axis._length;\n                return isVertical ? 1 - q : q;\n            };\n        } else {\n            var r2d = exports.rangeToShapePosition(axis);\n            pixelToData = function(p) { return r2d(axis.p2r(p - axis._offset)); };\n        }\n    } else if(isVertical) {\n        pixelToData = function(p) { return 1 - (p - gs.t) / gs.h; };\n    } else {\n        pixelToData = function(p) { return (p - gs.l) / gs.w; };\n    }\n\n    return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {\n    var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n    var posValAsInt = Math.round(pos);\n\n    return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeShapesOptionsAndPlotinfo = function(gd, index) {\n    var options = gd._fullLayout.shapes[index] || {};\n\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    var hasPlotinfo = !!plotinfo;\n    if(hasPlotinfo) {\n        plotinfo._hadPlotinfo = true;\n    } else {\n        plotinfo = {};\n        if(options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n        if(options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n    }\n\n    plotinfo.xsizemode = options.xsizemode;\n    plotinfo.ysizemode = options.ysizemode;\n    plotinfo.xanchor = options.xanchor;\n    plotinfo.yanchor = options.yanchor;\n\n    return {\n        options: options,\n        plotinfo: plotinfo\n    };\n};\n\n// TODO: move to selections helpers?\nexports.makeSelectionsOptionsAndPlotinfo = function(gd, index) {\n    var options = gd._fullLayout.selections[index] || {};\n\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    var hasPlotinfo = !!plotinfo;\n    if(hasPlotinfo) {\n        plotinfo._hadPlotinfo = true;\n    } else {\n        plotinfo = {};\n        if(options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n        if(options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n    }\n\n    return {\n        options: options,\n        plotinfo: plotinfo\n    };\n};\n\n\nexports.getPathString = function(gd, options) {\n    var type = options.type;\n    var xRefType = Axes.getRefType(options.xref);\n    var yRefType = Axes.getRefType(options.yref);\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n    var gs = gd._fullLayout._size;\n    var x2r, x2p, y2r, y2p;\n    var xShiftStart = getPixelShift(xa, options.x0shift);\n    var xShiftEnd = getPixelShift(xa, options.x1shift);\n    var yShiftStart = getPixelShift(ya, options.y0shift);\n    var yShiftEnd = getPixelShift(ya, options.y1shift);\n    var x0, x1, y0, y1;\n\n    if(xa) {\n        if(xRefType === 'domain') {\n            x2p = function(v) { return xa._offset + xa._length * v; };\n        } else {\n            x2r = exports.shapePositionToRange(xa);\n            x2p = function(v) { return xa._offset + xa.r2p(x2r(v, true)); };\n        }\n    } else {\n        x2p = function(v) { return gs.l + gs.w * v; };\n    }\n\n    if(ya) {\n        if(yRefType === 'domain') {\n            y2p = function(v) { return ya._offset + ya._length * (1 - v); };\n        } else {\n            y2r = exports.shapePositionToRange(ya);\n            y2p = function(v) { return ya._offset + ya.r2p(y2r(v, true)); };\n        }\n    } else {\n        y2p = function(v) { return gs.t + gs.h * (1 - v); };\n    }\n\n    if(type === 'path') {\n        if(xa && xa.type === 'date') x2p = exports.decodeDate(x2p);\n        if(ya && ya.type === 'date') y2p = exports.decodeDate(y2p);\n        return convertPath(options, x2p, y2p);\n    }\n    if(options.xsizemode === 'pixel') {\n        var xAnchorPos = x2p(options.xanchor);\n        x0 = xAnchorPos + options.x0 + xShiftStart;\n        x1 = xAnchorPos + options.x1 + xShiftEnd;\n    } else {\n        x0 = x2p(options.x0) + xShiftStart;\n        x1 = x2p(options.x1) + xShiftEnd;\n    }\n\n    if(options.ysizemode === 'pixel') {\n        var yAnchorPos = y2p(options.yanchor);\n        y0 = yAnchorPos - options.y0 + yShiftStart;\n        y1 = yAnchorPos - options.y1 + yShiftEnd;\n    } else {\n        y0 = y2p(options.y0) + yShiftStart;\n        y1 = y2p(options.y1) + yShiftEnd;\n    }\n\n    if(type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n    if(type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n    // circle\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n    var rx = Math.abs(cx - x0);\n    var ry = Math.abs(cy - y0);\n    var rArc = 'A' + rx + ',' + ry;\n    var rightPt = (cx + rx) + ',' + cy;\n    var topPt = cx + ',' + (cy - ry);\n    return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt +\n        rArc + ' 0 0,1 ' + rightPt + 'Z';\n};\n\n\nfunction convertPath(options, x2p, y2p) {\n    var pathIn = options.path;\n    var xSizemode = options.xsizemode;\n    var ySizemode = options.ysizemode;\n    var xAnchor = options.xanchor;\n    var yAnchor = options.yanchor;\n\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(xParams[paramNumber]) {\n                if(xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);\n                else param = x2p(param);\n            } else if(yParams[paramNumber]) {\n                if(ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);\n                else param = y2p(param);\n            }\n            paramNumber++;\n\n            if(paramNumber > nParams) param = 'X';\n            return param;\n        });\n\n        if(paramNumber > nParams) {\n            paramString = paramString.replace(/[\\s,]*X.*/, '');\n            Lib.log('Ignoring extra params in segment ' + segment);\n        }\n\n        return segmentType + paramString;\n    });\n}\n\nfunction getPixelShift(axis, shift) {\n    shift = shift || 0;\n    var shiftPixels = 0;\n    if(shift && axis && (axis.type === 'category' || axis.type === 'multicategory')) {\n        shiftPixels = (axis.r2p(1) - axis.r2p(0)) * shift;\n    }\n    return shiftPixels;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}