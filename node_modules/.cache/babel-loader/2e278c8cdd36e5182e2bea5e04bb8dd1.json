{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\nvar axIds = require('./axis_ids');\nvar getFromId = axIds.getFromId;\nvar isLinked = axIds.isLinked;\nmodule.exports = {\n  applyAutorangeOptions: applyAutorangeOptions,\n  getAutoRange: getAutoRange,\n  makePadFn: makePadFn,\n  doAutoRange: doAutoRange,\n  findExtremes: findExtremes,\n  concatExtremes: concatExtremes\n};\n\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\nfunction getAutoRange(gd, ax) {\n  var i, j;\n  var newRange = [];\n  var fullLayout = gd._fullLayout;\n  var getPadMin = makePadFn(fullLayout, ax, 0);\n  var getPadMax = makePadFn(fullLayout, ax, 1);\n  var extremes = concatExtremes(gd, ax);\n  var minArray = extremes.min;\n  var maxArray = extremes.max;\n  if (minArray.length === 0 || maxArray.length === 0) {\n    return Lib.simpleMap(ax.range, ax.r2l);\n  }\n  var minmin = minArray[0].val;\n  var maxmax = maxArray[0].val;\n  for (i = 1; i < minArray.length; i++) {\n    if (minmin !== maxmax) break;\n    minmin = Math.min(minmin, minArray[i].val);\n  }\n  for (i = 1; i < maxArray.length; i++) {\n    if (minmin !== maxmax) break;\n    maxmax = Math.max(maxmax, maxArray[i].val);\n  }\n  var autorange = ax.autorange;\n  var axReverse = autorange === 'reversed' || autorange === 'min reversed' || autorange === 'max reversed';\n  if (!axReverse && ax.range) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    axReverse = rng[1] < rng[0];\n  }\n\n  // one-time setting to easily reverse the axis\n  // when plotting from code\n  if (ax.autorange === 'reversed') {\n    ax.autorange = true;\n  }\n  var rangeMode = ax.rangemode;\n  var toZero = rangeMode === 'tozero';\n  var nonNegative = rangeMode === 'nonnegative';\n  var axLen = ax._length;\n  // don't allow padding to reduce the data to < 10% of the length\n  var minSpan = axLen / 10;\n  var mbest = 0;\n  var minpt, maxpt, minbest, maxbest, dp, dv;\n  for (i = 0; i < minArray.length; i++) {\n    minpt = minArray[i];\n    for (j = 0; j < maxArray.length; j++) {\n      maxpt = maxArray[j];\n      dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);\n      if (dv > 0) {\n        dp = axLen - getPadMin(minpt) - getPadMax(maxpt);\n        if (dp > minSpan) {\n          if (dv / dp > mbest) {\n            minbest = minpt;\n            maxbest = maxpt;\n            mbest = dv / dp;\n          }\n        } else if (dv / axLen > mbest) {\n          // in case of padding longer than the axis\n          // at least include the unpadded data values.\n          minbest = {\n            val: minpt.val,\n            nopad: 1\n          };\n          maxbest = {\n            val: maxpt.val,\n            nopad: 1\n          };\n          mbest = dv / axLen;\n        }\n      }\n    }\n  }\n  function maximumPad(prev, pt) {\n    return Math.max(prev, getPadMax(pt));\n  }\n  if (minmin === maxmax) {\n    var lower = minmin - 1;\n    var upper = minmin + 1;\n    if (toZero) {\n      if (minmin === 0) {\n        // The only value we have on this axis is 0, and we want to\n        // autorange so zero is one end.\n        // In principle this could be [0, 1] or [-1, 0] but usually\n        // 'tozero' pins 0 to the low end, so follow that.\n        newRange = [0, 1];\n      } else {\n        var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);\n        // we're pushing a single value away from the edge due to its\n        // padding, with the other end clamped at zero\n        // 0.5 means don't push it farther than the center.\n        var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n        newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n      }\n    } else if (nonNegative) {\n      newRange = [Math.max(0, lower), Math.max(1, upper)];\n    } else {\n      newRange = [lower, upper];\n    }\n  } else {\n    if (toZero) {\n      if (minbest.val >= 0) {\n        minbest = {\n          val: 0,\n          nopad: 1\n        };\n      }\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 0,\n          nopad: 1\n        };\n      }\n    } else if (nonNegative) {\n      if (minbest.val - mbest * getPadMin(minbest) < 0) {\n        minbest = {\n          val: 0,\n          nopad: 1\n        };\n      }\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 1,\n          nopad: 1\n        };\n      }\n    }\n\n    // in case it changed again...\n    mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) / (axLen - getPadMin(minbest) - getPadMax(maxbest));\n    newRange = [minbest.val - mbest * getPadMin(minbest), maxbest.val + mbest * getPadMax(maxbest)];\n  }\n  newRange = applyAutorangeOptions(newRange, ax);\n  if (ax.limitRange) ax.limitRange();\n\n  // maintain reversal\n  if (axReverse) newRange.reverse();\n  return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n\n// find axis rangebreaks in [v0,v1] and compute its length in value space\nfunction calcBreaksLength(ax, v0, v1) {\n  var lBreaks = 0;\n  if (ax.rangebreaks) {\n    var rangebreaksOut = ax.locateBreaks(v0, v1);\n    for (var i = 0; i < rangebreaksOut.length; i++) {\n      var brk = rangebreaksOut[i];\n      lBreaks += brk.max - brk.min;\n    }\n  }\n  return lBreaks;\n}\n\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\nfunction makePadFn(fullLayout, ax, max) {\n  // 5% padding for points that specify extrapad: true\n  var extrappad = 0.05 * ax._length;\n  var anchorAxis = ax._anchorAxis || {};\n  if ((ax.ticklabelposition || '').indexOf('inside') !== -1 || (anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {\n    var axReverse = ax.isReversed();\n    if (!axReverse) {\n      var rng = Lib.simpleMap(ax.range, ax.r2l);\n      axReverse = rng[1] < rng[0];\n    }\n    if (axReverse) max = !max;\n  }\n  var zero = 0;\n  if (!isLinked(fullLayout, ax._id)) {\n    zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);\n  }\n  extrappad = Math.max(zero, extrappad);\n\n  // domain-constrained axes: base extrappad on the unconstrained\n  // domain so it's consistent as the domain changes\n  if (ax.constrain === 'domain' && ax._inputDomain) {\n    extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);\n  }\n  return function getPad(pt) {\n    if (pt.nopad) return 0;\n    return pt.pad + (pt.extrapad ? extrappad : zero);\n  };\n}\nvar TEXTPAD = 3;\nfunction padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {\n  var pad = 0;\n  var isX = ax._id.charAt(0) === 'x';\n  for (var subplot in fullLayout._plots) {\n    var plotinfo = fullLayout._plots[subplot];\n    if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n    var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};\n    if ((anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {\n      // increase padding to make more room for inside tick labels of the counter axis\n      if (!max && (anchorAxis.side === 'left' || anchorAxis.side === 'bottom') || max && (anchorAxis.side === 'top' || anchorAxis.side === 'right')) {\n        if (anchorAxis._vals) {\n          var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + 'tick'] || 0);\n          var cosA = Math.abs(Math.cos(rad));\n          var sinA = Math.abs(Math.sin(rad));\n\n          // no stashed bounding boxes - stash bounding boxes\n          if (!anchorAxis._vals[0].bb) {\n            var cls = anchorAxis._id + 'tick';\n            var tickLabels = anchorAxis._selections[cls];\n            tickLabels.each(function (d) {\n              var thisLabel = d3.select(this);\n              var mathjaxGroup = thisLabel.select('.text-math-group');\n              if (mathjaxGroup.empty()) {\n                d.bb = Drawing.bBox(thisLabel.node());\n              }\n            });\n          }\n\n          // use bounding boxes\n          for (var i = 0; i < anchorAxis._vals.length; i++) {\n            var t = anchorAxis._vals[i];\n            var bb = t.bb;\n            if (bb) {\n              var w = 2 * TEXTPAD + bb.width;\n              var h = 2 * TEXTPAD + bb.height;\n              pad = Math.max(pad, isX ? Math.max(w * cosA, h * sinA) : Math.max(h * cosA, w * sinA));\n            }\n          }\n        }\n        if (anchorAxis.ticks === 'inside' && anchorAxis.ticklabelposition === 'inside') {\n          pad += anchorAxis.ticklen || 0;\n        }\n      }\n    }\n  }\n  return pad;\n}\nfunction concatExtremes(gd, ax, noMatch) {\n  var axId = ax._id;\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n  var minArray = [];\n  var maxArray = [];\n  var i, j, d;\n  function _concat(cont, indices) {\n    for (i = 0; i < indices.length; i++) {\n      var item = cont[indices[i]];\n      var extremes = (item._extremes || {})[axId];\n      if (item.visible === true && extremes) {\n        for (j = 0; j < extremes.min.length; j++) {\n          d = extremes.min[j];\n          collapseMinArray(minArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n        for (j = 0; j < extremes.max.length; j++) {\n          d = extremes.max[j];\n          collapseMaxArray(maxArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n      }\n    }\n  }\n  _concat(fullData, ax._traceIndices);\n  _concat(fullLayout.annotations || [], ax._annIndices || []);\n  _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n\n  // Include the extremes from other matched axes with this one\n  if (ax._matchGroup && !noMatch) {\n    for (var axId2 in ax._matchGroup) {\n      if (axId2 !== ax._id) {\n        var ax2 = getFromId(gd, axId2);\n        var extremes2 = concatExtremes(gd, ax2, true);\n        // convert padding on the second axis to the first with lenRatio\n        var lenRatio = ax._length / ax2._length;\n        for (j = 0; j < extremes2.min.length; j++) {\n          d = extremes2.min[j];\n          collapseMinArray(minArray, d.val, d.pad * lenRatio, {\n            extrapad: d.extrapad\n          });\n        }\n        for (j = 0; j < extremes2.max.length; j++) {\n          d = extremes2.max[j];\n          collapseMaxArray(maxArray, d.val, d.pad * lenRatio, {\n            extrapad: d.extrapad\n          });\n        }\n      }\n    }\n  }\n  return {\n    min: minArray,\n    max: maxArray\n  };\n}\nfunction doAutoRange(gd, ax, presetRange) {\n  ax.setScale();\n  if (ax.autorange) {\n    ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);\n    ax._r = ax.range.slice();\n    ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n    // doAutoRange will get called on fullLayout,\n    // but we want to report its results back to layout\n\n    var axIn = ax._input;\n\n    // before we edit _input, store preGUI values\n    var edits = {};\n    edits[ax._attr + '.range'] = ax.range;\n    edits[ax._attr + '.autorange'] = ax.autorange;\n    Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n    axIn.range = ax.range.slice();\n    axIn.autorange = ax.autorange;\n  }\n  var anchorAx = ax._anchorAxis;\n  if (anchorAx && anchorAx.rangeslider) {\n    var axeRangeOpts = anchorAx.rangeslider[ax._name];\n    if (axeRangeOpts) {\n      if (axeRangeOpts.rangemode === 'auto') {\n        axeRangeOpts.range = getAutoRange(gd, ax);\n      }\n    }\n    anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n  }\n}\n\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)\n *          is linearized (for log scale axes)\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\nfunction findExtremes(ax, data, opts) {\n  if (!opts) opts = {};\n  if (!ax._m) ax.setScale();\n  var minArray = [];\n  var maxArray = [];\n  var len = data.length;\n  var extrapad = opts.padded || false;\n  var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n  var isLog = ax.type === 'log';\n  var hasArrayOption = false;\n  var vpadLinearized = opts.vpadLinearized || false;\n  var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n  function makePadAccessor(item) {\n    if (Array.isArray(item)) {\n      hasArrayOption = true;\n      return function (i) {\n        return Math.max(Number(item[i] || 0), 0);\n      };\n    } else {\n      var v = Math.max(Number(item || 0), 0);\n      return function () {\n        return v;\n      };\n    }\n  }\n  var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n  var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n  var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n  var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n  if (!hasArrayOption) {\n    // with no arrays other than `data` we don't need to consider\n    // every point, only the extreme data points\n    vmin = Infinity;\n    vmax = -Infinity;\n    if (isLog) {\n      for (i = 0; i < len; i++) {\n        v = data[i];\n        // data is not linearized yet so we still have to filter out negative logs\n        if (v < vmin && v > 0) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        v = data[i];\n        if (v < vmin && v > -FP_SAFE) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    }\n    data = [vmin, vmax];\n    len = 2;\n  }\n  var collapseOpts = {\n    tozero: tozero,\n    extrapad: extrapad\n  };\n  function addItem(i) {\n    di = data[i];\n    if (!isNumeric(di)) return;\n    ppadiplus = ppadplus(i);\n    ppadiminus = ppadminus(i);\n    if (vpadLinearized) {\n      dmin = ax.c2l(di) - vpadminus(i);\n      dmax = ax.c2l(di) + vpadplus(i);\n    } else {\n      vmin = di - vpadminus(i);\n      vmax = di + vpadplus(i);\n      // special case for log axes: if vpad makes this object span\n      // more than an order of mag, clip it to one order. This is so\n      // we don't have non-positive errors or absurdly large lower\n      // range due to rounding errors\n      if (isLog && vmin < vmax / 10) vmin = vmax / 10;\n      dmin = ax.c2l(vmin);\n      dmax = ax.c2l(vmax);\n    }\n    if (tozero) {\n      dmin = Math.min(0, dmin);\n      dmax = Math.max(0, dmax);\n    }\n    if (goodNumber(dmin)) {\n      collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n    }\n    if (goodNumber(dmax)) {\n      collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n    }\n  }\n\n  // For efficiency covering monotonic or near-monotonic data,\n  // check a few points at both ends first and then sweep\n  // through the middle\n  var iMax = Math.min(6, len);\n  for (i = 0; i < iMax; i++) addItem(i);\n  for (i = len - 1; i >= iMax; i--) addItem(i);\n  return {\n    min: minArray,\n    max: maxArray,\n    opts: opts\n  };\n}\nfunction collapseMinArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n  var tozero = opts.tozero;\n  var extrapad = opts.extrapad;\n  var includeThis = true;\n  for (var j = 0; j < array.length && includeThis; j++) {\n    var v = array[j];\n    if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n      includeThis = false;\n      break;\n    } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n      array.splice(j, 1);\n      j--;\n    }\n  }\n  if (includeThis) {\n    var clipAtZero = tozero && newVal === 0;\n    array.push({\n      val: newVal,\n      pad: clipAtZero ? 0 : newPad,\n      extrapad: clipAtZero ? false : extrapad\n    });\n  }\n}\n\n// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v) {\n  return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\nfunction lessOrEqual(v0, v1) {\n  return v0 <= v1;\n}\nfunction greaterOrEqual(v0, v1) {\n  return v0 >= v1;\n}\nfunction applyAutorangeMinOptions(v, ax) {\n  var autorangeoptions = ax.autorangeoptions;\n  if (autorangeoptions && autorangeoptions.minallowed !== undefined && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {\n    return autorangeoptions.minallowed;\n  }\n  if (autorangeoptions && autorangeoptions.clipmin !== undefined && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {\n    return Math.max(v, ax.d2l(autorangeoptions.clipmin));\n  }\n  return v;\n}\nfunction applyAutorangeMaxOptions(v, ax) {\n  var autorangeoptions = ax.autorangeoptions;\n  if (autorangeoptions && autorangeoptions.maxallowed !== undefined && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {\n    return autorangeoptions.maxallowed;\n  }\n  if (autorangeoptions && autorangeoptions.clipmax !== undefined && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {\n    return Math.min(v, ax.d2l(autorangeoptions.clipmax));\n  }\n  return v;\n}\nfunction hasValidMinAndMax(ax, min, max) {\n  // in case both min and max are defined, ensure min < max\n  if (min !== undefined && max !== undefined) {\n    min = ax.d2l(min);\n    max = ax.d2l(max);\n    return min < max;\n  }\n  return true;\n}\n\n// this function should be (and is) called before reversing the range\n// so range[0] is the minimum and range[1] is the maximum\nfunction applyAutorangeOptions(range, ax) {\n  if (!ax || !ax.autorangeoptions) return range;\n  var min = range[0];\n  var max = range[1];\n  var include = ax.autorangeoptions.include;\n  if (include !== undefined) {\n    var lMin = ax.d2l(min);\n    var lMax = ax.d2l(max);\n    if (!Lib.isArrayOrTypedArray(include)) include = [include];\n    for (var i = 0; i < include.length; i++) {\n      var v = ax.d2l(include[i]);\n      if (lMin >= v) {\n        lMin = v;\n        min = v;\n      }\n      if (lMax <= v) {\n        lMax = v;\n        max = v;\n      }\n    }\n  }\n  min = applyAutorangeMinOptions(min, ax);\n  max = applyAutorangeMaxOptions(max, ax);\n  return [min, max];\n}","map":{"version":3,"names":["d3","require","isNumeric","Lib","FP_SAFE","Registry","Drawing","axIds","getFromId","isLinked","module","exports","applyAutorangeOptions","getAutoRange","makePadFn","doAutoRange","findExtremes","concatExtremes","gd","ax","i","j","newRange","fullLayout","_fullLayout","getPadMin","getPadMax","extremes","minArray","min","maxArray","max","length","simpleMap","range","r2l","minmin","val","maxmax","Math","autorange","axReverse","rng","rangeMode","rangemode","toZero","nonNegative","axLen","_length","minSpan","mbest","minpt","maxpt","minbest","maxbest","dp","dv","calcBreaksLength","nopad","maximumPad","prev","pt","lower","upper","maxPad","reduce","rangeEnd","limitRange","reverse","l2r","Number","v0","v1","lBreaks","rangebreaks","rangebreaksOut","locateBreaks","brk","extrappad","anchorAxis","_anchorAxis","ticklabelposition","indexOf","isReversed","zero","_id","padInsideLabelsOnAnchorAxis","constrain","_inputDomain","domain","getPad","pad","extrapad","TEXTPAD","isX","charAt","subplot","_plots","plotinfo","xaxis","yaxis","side","_vals","rad","deg2rad","_tickAngles","cosA","abs","cos","sinA","sin","bb","cls","tickLabels","_selections","each","d","thisLabel","select","mathjaxGroup","empty","bBox","node","t","w","width","h","height","ticks","ticklen","noMatch","axId","fullData","_fullData","_concat","cont","indices","item","_extremes","visible","collapseMinArray","collapseMaxArray","_traceIndices","annotations","_annIndices","shapes","_shapeIndices","_matchGroup","axId2","ax2","extremes2","lenRatio","presetRange","setScale","slice","_r","_rl","axIn","_input","edits","_attr","call","layout","_preGUI","anchorAx","rangeslider","axeRangeOpts","_name","extendFlat","data","opts","_m","len","padded","tozero","type","isLog","hasArrayOption","vpadLinearized","v","di","dmin","dmax","ppadiplus","ppadiminus","vmin","vmax","makePadAccessor","Array","isArray","ppadplus","ppadminus","ppad","vpadplus","vpad","vpadminus","Infinity","collapseOpts","addItem","c2l","goodNumber","iMax","array","newVal","newPad","collapseArray","lessOrEqual","greaterOrEqual","atLeastAsExtreme","includeThis","splice","clipAtZero","push","applyAutorangeMinOptions","autorangeoptions","minallowed","undefined","hasValidMinAndMax","maxallowed","clipmin","clipmax","d2l","applyAutorangeMaxOptions","include","lMin","lMax","isArrayOrTypedArray"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/plots/cartesian/autorange.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\n\nvar axIds = require('./axis_ids');\nvar getFromId = axIds.getFromId;\nvar isLinked = axIds.isLinked;\n\nmodule.exports = {\n    applyAutorangeOptions: applyAutorangeOptions,\n    getAutoRange: getAutoRange,\n    makePadFn: makePadFn,\n    doAutoRange: doAutoRange,\n    findExtremes: findExtremes,\n    concatExtremes: concatExtremes\n};\n\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\nfunction getAutoRange(gd, ax) {\n    var i, j;\n    var newRange = [];\n\n    var fullLayout = gd._fullLayout;\n    var getPadMin = makePadFn(fullLayout, ax, 0);\n    var getPadMax = makePadFn(fullLayout, ax, 1);\n    var extremes = concatExtremes(gd, ax);\n    var minArray = extremes.min;\n    var maxArray = extremes.max;\n\n    if(minArray.length === 0 || maxArray.length === 0) {\n        return Lib.simpleMap(ax.range, ax.r2l);\n    }\n\n    var minmin = minArray[0].val;\n    var maxmax = maxArray[0].val;\n\n    for(i = 1; i < minArray.length; i++) {\n        if(minmin !== maxmax) break;\n        minmin = Math.min(minmin, minArray[i].val);\n    }\n    for(i = 1; i < maxArray.length; i++) {\n        if(minmin !== maxmax) break;\n        maxmax = Math.max(maxmax, maxArray[i].val);\n    }\n\n    var autorange = ax.autorange;\n    var axReverse =\n        autorange === 'reversed' ||\n        autorange === 'min reversed' ||\n        autorange === 'max reversed';\n\n    if(!axReverse && ax.range) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        axReverse = rng[1] < rng[0];\n    }\n\n    // one-time setting to easily reverse the axis\n    // when plotting from code\n    if(ax.autorange === 'reversed') {\n        ax.autorange = true;\n    }\n\n    var rangeMode = ax.rangemode;\n    var toZero = rangeMode === 'tozero';\n    var nonNegative = rangeMode === 'nonnegative';\n    var axLen = ax._length;\n    // don't allow padding to reduce the data to < 10% of the length\n    var minSpan = axLen / 10;\n\n    var mbest = 0;\n    var minpt, maxpt, minbest, maxbest, dp, dv;\n\n    for(i = 0; i < minArray.length; i++) {\n        minpt = minArray[i];\n        for(j = 0; j < maxArray.length; j++) {\n            maxpt = maxArray[j];\n            dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);\n            if(dv > 0) {\n                dp = axLen - getPadMin(minpt) - getPadMax(maxpt);\n                if(dp > minSpan) {\n                    if(dv / dp > mbest) {\n                        minbest = minpt;\n                        maxbest = maxpt;\n                        mbest = dv / dp;\n                    }\n                } else if(dv / axLen > mbest) {\n                    // in case of padding longer than the axis\n                    // at least include the unpadded data values.\n                    minbest = {val: minpt.val, nopad: 1};\n                    maxbest = {val: maxpt.val, nopad: 1};\n                    mbest = dv / axLen;\n                }\n            }\n        }\n    }\n\n    function maximumPad(prev, pt) {\n        return Math.max(prev, getPadMax(pt));\n    }\n\n    if(minmin === maxmax) {\n        var lower = minmin - 1;\n        var upper = minmin + 1;\n        if(toZero) {\n            if(minmin === 0) {\n                // The only value we have on this axis is 0, and we want to\n                // autorange so zero is one end.\n                // In principle this could be [0, 1] or [-1, 0] but usually\n                // 'tozero' pins 0 to the low end, so follow that.\n                newRange = [0, 1];\n            } else {\n                var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);\n                // we're pushing a single value away from the edge due to its\n                // padding, with the other end clamped at zero\n                // 0.5 means don't push it farther than the center.\n                var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n                newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n            }\n        } else if(nonNegative) {\n            newRange = [Math.max(0, lower), Math.max(1, upper)];\n        } else {\n            newRange = [lower, upper];\n        }\n    } else {\n        if(toZero) {\n            if(minbest.val >= 0) {\n                minbest = {val: 0, nopad: 1};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 0, nopad: 1};\n            }\n        } else if(nonNegative) {\n            if(minbest.val - mbest * getPadMin(minbest) < 0) {\n                minbest = {val: 0, nopad: 1};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 1, nopad: 1};\n            }\n        }\n\n        // in case it changed again...\n        mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) /\n            (axLen - getPadMin(minbest) - getPadMax(maxbest));\n\n        newRange = [\n            minbest.val - mbest * getPadMin(minbest),\n            maxbest.val + mbest * getPadMax(maxbest)\n        ];\n    }\n\n    newRange = applyAutorangeOptions(newRange, ax);\n\n    if(ax.limitRange) ax.limitRange();\n\n    // maintain reversal\n    if(axReverse) newRange.reverse();\n\n    return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n\n// find axis rangebreaks in [v0,v1] and compute its length in value space\nfunction calcBreaksLength(ax, v0, v1) {\n    var lBreaks = 0;\n    if(ax.rangebreaks) {\n        var rangebreaksOut = ax.locateBreaks(v0, v1);\n        for(var i = 0; i < rangebreaksOut.length; i++) {\n            var brk = rangebreaksOut[i];\n            lBreaks += brk.max - brk.min;\n        }\n    }\n    return lBreaks;\n}\n\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\nfunction makePadFn(fullLayout, ax, max) {\n    // 5% padding for points that specify extrapad: true\n    var extrappad = 0.05 * ax._length;\n\n    var anchorAxis = ax._anchorAxis || {};\n\n    if(\n        (ax.ticklabelposition || '').indexOf('inside') !== -1 ||\n        (anchorAxis.ticklabelposition || '').indexOf('inside') !== -1\n    ) {\n        var axReverse = ax.isReversed();\n        if(!axReverse) {\n            var rng = Lib.simpleMap(ax.range, ax.r2l);\n            axReverse = rng[1] < rng[0];\n        }\n        if(axReverse) max = !max;\n    }\n\n    var zero = 0;\n    if(!isLinked(fullLayout, ax._id)) {\n        zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);\n    }\n    extrappad = Math.max(zero, extrappad);\n\n    // domain-constrained axes: base extrappad on the unconstrained\n    // domain so it's consistent as the domain changes\n    if((ax.constrain === 'domain') && ax._inputDomain) {\n        extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) /\n            (ax.domain[1] - ax.domain[0]);\n    }\n\n    return function getPad(pt) {\n        if(pt.nopad) return 0;\n        return pt.pad + (pt.extrapad ? extrappad : zero);\n    };\n}\n\nvar TEXTPAD = 3;\n\nfunction padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {\n    var pad = 0;\n\n    var isX = ax._id.charAt(0) === 'x';\n\n    for(var subplot in fullLayout._plots) {\n        var plotinfo = fullLayout._plots[subplot];\n\n        if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n\n        var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};\n\n        if((anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {\n            // increase padding to make more room for inside tick labels of the counter axis\n            if((\n                !max && (\n                    anchorAxis.side === 'left' ||\n                    anchorAxis.side === 'bottom'\n                )\n            ) || (\n                max && (\n                    anchorAxis.side === 'top' ||\n                    anchorAxis.side === 'right'\n                )\n            )) {\n                if(anchorAxis._vals) {\n                    var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + 'tick'] || 0);\n                    var cosA = Math.abs(Math.cos(rad));\n                    var sinA = Math.abs(Math.sin(rad));\n\n                    // no stashed bounding boxes - stash bounding boxes\n                    if(!anchorAxis._vals[0].bb) {\n                        var cls = anchorAxis._id + 'tick';\n                        var tickLabels = anchorAxis._selections[cls];\n                        tickLabels.each(function(d) {\n                            var thisLabel = d3.select(this);\n                            var mathjaxGroup = thisLabel.select('.text-math-group');\n                            if(mathjaxGroup.empty()) {\n                                d.bb = Drawing.bBox(thisLabel.node());\n                            }\n                        });\n                    }\n\n                    // use bounding boxes\n                    for(var i = 0; i < anchorAxis._vals.length; i++) {\n                        var t = anchorAxis._vals[i];\n                        var bb = t.bb;\n\n                        if(bb) {\n                            var w = 2 * TEXTPAD + bb.width;\n                            var h = 2 * TEXTPAD + bb.height;\n\n                            pad = Math.max(pad, isX ?\n                                Math.max(w * cosA, h * sinA) :\n                                Math.max(h * cosA, w * sinA)\n                            );\n                        }\n                    }\n                }\n\n                if(anchorAxis.ticks === 'inside' && anchorAxis.ticklabelposition === 'inside') {\n                    pad += anchorAxis.ticklen || 0;\n                }\n            }\n        }\n    }\n\n    return pad;\n}\n\nfunction concatExtremes(gd, ax, noMatch) {\n    var axId = ax._id;\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var minArray = [];\n    var maxArray = [];\n    var i, j, d;\n\n    function _concat(cont, indices) {\n        for(i = 0; i < indices.length; i++) {\n            var item = cont[indices[i]];\n            var extremes = (item._extremes || {})[axId];\n            if(item.visible === true && extremes) {\n                for(j = 0; j < extremes.min.length; j++) {\n                    d = extremes.min[j];\n                    collapseMinArray(minArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n                for(j = 0; j < extremes.max.length; j++) {\n                    d = extremes.max[j];\n                    collapseMaxArray(maxArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n            }\n        }\n    }\n\n    _concat(fullData, ax._traceIndices);\n    _concat(fullLayout.annotations || [], ax._annIndices || []);\n    _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n\n    // Include the extremes from other matched axes with this one\n    if(ax._matchGroup && !noMatch) {\n        for(var axId2 in ax._matchGroup) {\n            if(axId2 !== ax._id) {\n                var ax2 = getFromId(gd, axId2);\n                var extremes2 = concatExtremes(gd, ax2, true);\n                // convert padding on the second axis to the first with lenRatio\n                var lenRatio = ax._length / ax2._length;\n                for(j = 0; j < extremes2.min.length; j++) {\n                    d = extremes2.min[j];\n                    collapseMinArray(minArray, d.val, d.pad * lenRatio, {extrapad: d.extrapad});\n                }\n                for(j = 0; j < extremes2.max.length; j++) {\n                    d = extremes2.max[j];\n                    collapseMaxArray(maxArray, d.val, d.pad * lenRatio, {extrapad: d.extrapad});\n                }\n            }\n        }\n    }\n\n    return {min: minArray, max: maxArray};\n}\n\nfunction doAutoRange(gd, ax, presetRange) {\n    ax.setScale();\n\n    if(ax.autorange) {\n        ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);\n\n        ax._r = ax.range.slice();\n        ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n        // doAutoRange will get called on fullLayout,\n        // but we want to report its results back to layout\n\n        var axIn = ax._input;\n\n        // before we edit _input, store preGUI values\n        var edits = {};\n        edits[ax._attr + '.range'] = ax.range;\n        edits[ax._attr + '.autorange'] = ax.autorange;\n        Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n\n        axIn.range = ax.range.slice();\n        axIn.autorange = ax.autorange;\n    }\n\n    var anchorAx = ax._anchorAxis;\n\n    if(anchorAx && anchorAx.rangeslider) {\n        var axeRangeOpts = anchorAx.rangeslider[ax._name];\n        if(axeRangeOpts) {\n            if(axeRangeOpts.rangemode === 'auto') {\n                axeRangeOpts.range = getAutoRange(gd, ax);\n            }\n        }\n        anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n    }\n}\n\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)\n *          is linearized (for log scale axes)\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\nfunction findExtremes(ax, data, opts) {\n    if(!opts) opts = {};\n    if(!ax._m) ax.setScale();\n\n    var minArray = [];\n    var maxArray = [];\n\n    var len = data.length;\n    var extrapad = opts.padded || false;\n    var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n    var isLog = ax.type === 'log';\n    var hasArrayOption = false;\n    var vpadLinearized = opts.vpadLinearized || false;\n    var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n\n    function makePadAccessor(item) {\n        if(Array.isArray(item)) {\n            hasArrayOption = true;\n            return function(i) { return Math.max(Number(item[i]||0), 0); };\n        } else {\n            var v = Math.max(Number(item||0), 0);\n            return function() { return v; };\n        }\n    }\n\n    var ppadplus = makePadAccessor((ax._m > 0 ?\n        opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n    var ppadminus = makePadAccessor((ax._m > 0 ?\n        opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n    var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n    var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n\n    if(!hasArrayOption) {\n        // with no arrays other than `data` we don't need to consider\n        // every point, only the extreme data points\n        vmin = Infinity;\n        vmax = -Infinity;\n\n        if(isLog) {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                // data is not linearized yet so we still have to filter out negative logs\n                if(v < vmin && v > 0) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        } else {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                if(v < vmin && v > -FP_SAFE) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        }\n\n        data = [vmin, vmax];\n        len = 2;\n    }\n\n    var collapseOpts = {tozero: tozero, extrapad: extrapad};\n\n    function addItem(i) {\n        di = data[i];\n        if(!isNumeric(di)) return;\n        ppadiplus = ppadplus(i);\n        ppadiminus = ppadminus(i);\n\n        if(vpadLinearized) {\n            dmin = ax.c2l(di) - vpadminus(i);\n            dmax = ax.c2l(di) + vpadplus(i);\n        } else {\n            vmin = di - vpadminus(i);\n            vmax = di + vpadplus(i);\n            // special case for log axes: if vpad makes this object span\n            // more than an order of mag, clip it to one order. This is so\n            // we don't have non-positive errors or absurdly large lower\n            // range due to rounding errors\n            if(isLog && vmin < vmax / 10) vmin = vmax / 10;\n\n            dmin = ax.c2l(vmin);\n            dmax = ax.c2l(vmax);\n        }\n\n        if(tozero) {\n            dmin = Math.min(0, dmin);\n            dmax = Math.max(0, dmax);\n        }\n        if(goodNumber(dmin)) {\n            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n        }\n        if(goodNumber(dmax)) {\n            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n        }\n    }\n\n    // For efficiency covering monotonic or near-monotonic data,\n    // check a few points at both ends first and then sweep\n    // through the middle\n    var iMax = Math.min(6, len);\n    for(i = 0; i < iMax; i++) addItem(i);\n    for(i = len - 1; i >= iMax; i--) addItem(i);\n\n    return {\n        min: minArray,\n        max: maxArray,\n        opts: opts\n    };\n}\n\nfunction collapseMinArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\n\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n    var tozero = opts.tozero;\n    var extrapad = opts.extrapad;\n    var includeThis = true;\n\n    for(var j = 0; j < array.length && includeThis; j++) {\n        var v = array[j];\n        if(atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n            includeThis = false;\n            break;\n        } else if(atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n            array.splice(j, 1);\n            j--;\n        }\n    }\n    if(includeThis) {\n        var clipAtZero = (tozero && newVal === 0);\n        array.push({\n            val: newVal,\n            pad: clipAtZero ? 0 : newPad,\n            extrapad: clipAtZero ? false : extrapad\n        });\n    }\n}\n\n// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v) {\n    return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\n\nfunction lessOrEqual(v0, v1) { return v0 <= v1; }\nfunction greaterOrEqual(v0, v1) { return v0 >= v1; }\n\nfunction applyAutorangeMinOptions(v, ax) {\n    var autorangeoptions = ax.autorangeoptions;\n    if(\n        autorangeoptions &&\n        autorangeoptions.minallowed !== undefined &&\n        hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)\n    ) {\n        return autorangeoptions.minallowed;\n    }\n\n    if(\n        autorangeoptions &&\n        autorangeoptions.clipmin !== undefined &&\n        hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)\n    ) {\n        return Math.max(v, ax.d2l(autorangeoptions.clipmin));\n    }\n    return v;\n}\n\nfunction applyAutorangeMaxOptions(v, ax) {\n    var autorangeoptions = ax.autorangeoptions;\n\n    if(\n        autorangeoptions &&\n        autorangeoptions.maxallowed !== undefined &&\n        hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)\n    ) {\n        return autorangeoptions.maxallowed;\n    }\n\n    if(\n        autorangeoptions &&\n        autorangeoptions.clipmax !== undefined &&\n        hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)\n    ) {\n        return Math.min(v, ax.d2l(autorangeoptions.clipmax));\n    }\n\n    return v;\n}\n\nfunction hasValidMinAndMax(ax, min, max) {\n    // in case both min and max are defined, ensure min < max\n    if(\n        min !== undefined &&\n        max !== undefined\n    ) {\n        min = ax.d2l(min);\n        max = ax.d2l(max);\n        return min < max;\n    }\n    return true;\n}\n\n// this function should be (and is) called before reversing the range\n// so range[0] is the minimum and range[1] is the maximum\nfunction applyAutorangeOptions(range, ax) {\n    if(!ax || !ax.autorangeoptions) return range;\n\n    var min = range[0];\n    var max = range[1];\n\n    var include = ax.autorangeoptions.include;\n    if(include !== undefined) {\n        var lMin = ax.d2l(min);\n        var lMax = ax.d2l(max);\n\n        if(!Lib.isArrayOrTypedArray(include)) include = [include];\n        for(var i = 0; i < include.length; i++) {\n            var v = ax.d2l(include[i]);\n            if(lMin >= v) {\n                lMin = v;\n                min = v;\n            }\n            if(lMax <= v) {\n                lMax = v;\n                max = v;\n            }\n        }\n    }\n\n    min = applyAutorangeMinOptions(min, ax);\n    max = applyAutorangeMaxOptions(max, ax);\n\n    return [min, max];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}