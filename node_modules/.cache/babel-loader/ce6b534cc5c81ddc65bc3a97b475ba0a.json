{"ast":null,"code":"'use strict';\n\n// Requirements\n// ============\nvar wrap = require('../../lib/gup').wrap;\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar filterUnique = require('../../lib/filter_unique.js');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar isNumeric = require('fast-isnumeric');\n\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\nmodule.exports = function calc(gd, trace) {\n  var visibleDims = Lib.filterVisible(trace.dimensions);\n  if (visibleDims.length === 0) return [];\n  var uniqueInfoDims = visibleDims.map(function (dim) {\n    var categoryValues;\n    if (dim.categoryorder === 'trace') {\n      // Use order of first occurrence in trace\n      categoryValues = null;\n    } else if (dim.categoryorder === 'array') {\n      // Use categories specified in `categoryarray` first,\n      // then add extra to the end in trace order\n      categoryValues = dim.categoryarray;\n    } else {\n      // Get all categories up front\n      categoryValues = filterUnique(dim.values);\n\n      // order them\n      var allNumeric = true;\n      for (var i = 0; i < categoryValues.length; i++) {\n        if (!isNumeric(categoryValues[i])) {\n          allNumeric = false;\n          break;\n        }\n      }\n      categoryValues.sort(allNumeric ? Lib.sorterAsc : undefined);\n      if (dim.categoryorder === 'category descending') {\n        categoryValues = categoryValues.reverse();\n      }\n    }\n    return getUniqueInfo(dim.values, categoryValues);\n  });\n  var counts, count, totalCount;\n  if (Lib.isArrayOrTypedArray(trace.counts)) {\n    counts = trace.counts;\n  } else {\n    counts = [trace.counts];\n  }\n  validateDimensionDisplayInds(visibleDims);\n  visibleDims.forEach(function (dim, dimInd) {\n    validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n  });\n\n  // Handle path colors\n  // ------------------\n  var line = trace.line;\n  var markerColorscale;\n\n  // Process colorscale\n  if (line) {\n    if (hasColorscale(trace, 'line')) {\n      colorscaleCalc(gd, trace, {\n        vals: trace.line.color,\n        containerStr: 'line',\n        cLetter: 'c'\n      });\n    }\n    markerColorscale = Drawing.tryColorscale(line);\n  } else {\n    markerColorscale = Lib.identity;\n  }\n\n  // Build color generation function\n  function getMarkerColorInfo(index) {\n    var value, rawColor;\n    if (Lib.isArrayOrTypedArray(line.color)) {\n      value = line.color[index % line.color.length];\n      rawColor = value;\n    } else {\n      value = line.color;\n    }\n    return {\n      color: markerColorscale(value),\n      rawColor: rawColor\n    };\n  }\n\n  // Number of values and counts\n  // ---------------------------\n  var numValues = visibleDims[0].values.length;\n\n  // Build path info\n  // ---------------\n  // Mapping from category inds to PathModel objects\n  var pathModels = {};\n\n  // Category inds array for each dimension\n  var categoryIndsDims = uniqueInfoDims.map(function (di) {\n    return di.inds;\n  });\n\n  // Initialize total count\n  totalCount = 0;\n  var valueInd;\n  var d;\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    // Category inds for this input value across dimensions\n    var categoryIndsPath = [];\n    for (d = 0; d < categoryIndsDims.length; d++) {\n      categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n    }\n\n    // Count\n    count = counts[valueInd % counts.length];\n\n    // Update total count\n    totalCount += count;\n\n    // Path color\n    var pathColorInfo = getMarkerColorInfo(valueInd);\n\n    // path key\n    var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor;\n\n    // Create / Update PathModel\n    if (pathModels[pathKey] === undefined) {\n      pathModels[pathKey] = createPathModel(categoryIndsPath, pathColorInfo.color, pathColorInfo.rawColor);\n    }\n    updatePathModel(pathModels[pathKey], valueInd, count);\n  }\n  var dimensionModels = visibleDims.map(function (di, i) {\n    return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n  });\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    count = counts[valueInd % counts.length];\n    for (d = 0; d < dimensionModels.length; d++) {\n      var containerInd = dimensionModels[d].containerInd;\n      var catInd = uniqueInfoDims[d].inds[valueInd];\n      var cats = dimensionModels[d].categories;\n      if (cats[catInd] === undefined) {\n        var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n        var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n        cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n      }\n      updateCategoryModel(cats[catInd], valueInd, count);\n    }\n  }\n\n  // Compute unique\n  return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n};\n\n// Models\n// ======\n\n// Parcats Model\n// -------------\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\nfunction createParcatsModel(dimensions, paths, count) {\n  var maxCats = dimensions.map(function (d) {\n    return d.categories.length;\n  }).reduce(function (v1, v2) {\n    return Math.max(v1, v2);\n  });\n  return {\n    dimensions: dimensions,\n    paths: paths,\n    trace: undefined,\n    maxCats: maxCats,\n    count: count\n  };\n}\n\n// Dimension Model\n// ---------------\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n  return {\n    dimensionInd: dimensionInd,\n    containerInd: containerInd,\n    displayInd: displayInd,\n    dimensionLabel: dimensionLabel,\n    count: count,\n    categories: [],\n    dragX: null\n  };\n}\n\n// Category Model\n// --------------\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n  return {\n    dimensionInd: dimensionInd,\n    categoryInd: categoryInd,\n    categoryValue: categoryValue,\n    displayInd: categoryInd,\n    categoryLabel: categoryLabel,\n    valueInds: [],\n    count: 0,\n    dragY: null\n  };\n}\n\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n  categoryModel.valueInds.push(valueInd);\n  categoryModel.count += count;\n}\n\n// Path Model\n// ----------\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\nfunction createPathModel(categoryInds, color, rawColor) {\n  return {\n    categoryInds: categoryInds,\n    color: color,\n    rawColor: rawColor,\n    valueInds: [],\n    count: 0\n  };\n}\n\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updatePathModel(pathModel, valueInd, count) {\n  pathModel.valueInds.push(valueInd);\n  pathModel.count += count;\n}\n\n// Unique calculations\n// ===================\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\nfunction getUniqueInfo(values, uniqueValues) {\n  // Initialize uniqueValues if not specified\n  if (uniqueValues === undefined || uniqueValues === null) {\n    uniqueValues = [];\n  } else {\n    // Shallow copy so append below doesn't alter input array\n    uniqueValues = uniqueValues.map(function (e) {\n      return e;\n    });\n  }\n\n  // Initialize Variables\n  var uniqueValueCounts = {};\n  var uniqueValueInds = {};\n  var inds = [];\n\n  // Initialize uniqueValueCounts and\n  uniqueValues.forEach(function (uniqueVal, valInd) {\n    uniqueValueCounts[uniqueVal] = 0;\n    uniqueValueInds[uniqueVal] = valInd;\n  });\n\n  // Compute the necessary unique info in a single pass\n  for (var i = 0; i < values.length; i++) {\n    var item = values[i];\n    var itemInd;\n    if (uniqueValueCounts[item] === undefined) {\n      // This item has a previously unseen value\n      uniqueValueCounts[item] = 1;\n      itemInd = uniqueValues.push(item) - 1;\n      uniqueValueInds[item] = itemInd;\n    } else {\n      // Increment count for this item\n      uniqueValueCounts[item]++;\n      itemInd = uniqueValueInds[item];\n    }\n    inds.push(itemInd);\n  }\n\n  // Build UniqueInfo\n  var uniqueCounts = uniqueValues.map(function (v) {\n    return uniqueValueCounts[v];\n  });\n  return {\n    uniqueValues: uniqueValues,\n    uniqueCounts: uniqueCounts,\n    inds: inds\n  };\n}\n\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\nfunction validateDimensionDisplayInds(visibleDims) {\n  var displayInds = visibleDims.map(function (d) {\n    return d.displayindex;\n  });\n  var i;\n  if (isRangePermutation(displayInds)) {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = visibleDims[i].displayindex;\n    }\n  } else {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = i;\n    }\n  }\n}\n\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n  // Update categoryarray\n  dim._categoryarray = uniqueInfoDim.uniqueValues;\n\n  // Handle ticktext\n  if (dim.ticktext === null || dim.ticktext === undefined) {\n    dim._ticktext = [];\n  } else {\n    // Shallow copy to avoid modifying input array\n    dim._ticktext = dim.ticktext.slice();\n  }\n\n  // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n  for (var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n    dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n  }\n}\n\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\nfunction isRangePermutation(inds) {\n  var indsSpecified = new Array(inds.length);\n  for (var i = 0; i < inds.length; i++) {\n    // Check for out of bounds\n    if (inds[i] < 0 || inds[i] >= inds.length) {\n      return false;\n    }\n\n    // Check for collisions with already specified index\n    if (indsSpecified[inds[i]] !== undefined) {\n      return false;\n    }\n    indsSpecified[inds[i]] = true;\n  }\n\n  // Nothing out of bounds and no collisions. We have a permutation\n  return true;\n}","map":{"version":3,"names":["wrap","require","hasColorscale","colorscaleCalc","filterUnique","Drawing","Lib","isNumeric","module","exports","calc","gd","trace","visibleDims","filterVisible","dimensions","length","uniqueInfoDims","map","dim","categoryValues","categoryorder","categoryarray","values","allNumeric","i","sort","sorterAsc","undefined","reverse","getUniqueInfo","counts","count","totalCount","isArrayOrTypedArray","validateDimensionDisplayInds","forEach","dimInd","validateCategoryProperties","line","markerColorscale","vals","color","containerStr","cLetter","tryColorscale","identity","getMarkerColorInfo","index","value","rawColor","numValues","pathModels","categoryIndsDims","di","inds","valueInd","d","categoryIndsPath","push","pathColorInfo","pathKey","createPathModel","updatePathModel","dimensionModels","createDimensionModel","_index","_displayindex","label","containerInd","catInd","cats","categories","catValue","_categoryarray","catLabel","_ticktext","createCategoryModel","updateCategoryModel","createParcatsModel","paths","maxCats","reduce","v1","v2","Math","max","dimensionInd","displayInd","dimensionLabel","dragX","categoryInd","categoryValue","categoryLabel","valueInds","dragY","categoryModel","categoryInds","pathModel","uniqueValues","e","uniqueValueCounts","uniqueValueInds","uniqueVal","valInd","item","itemInd","uniqueCounts","v","displayInds","displayindex","isRangePermutation","uniqueInfoDim","ticktext","slice","indsSpecified","Array"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/parcats/calc.js"],"sourcesContent":["'use strict';\n\n// Requirements\n// ============\nvar wrap = require('../../lib/gup').wrap;\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar filterUnique = require('../../lib/filter_unique.js');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar isNumeric = require('fast-isnumeric');\n\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\nmodule.exports = function calc(gd, trace) {\n    var visibleDims = Lib.filterVisible(trace.dimensions);\n\n    if(visibleDims.length === 0) return [];\n\n    var uniqueInfoDims = visibleDims.map(function(dim) {\n        var categoryValues;\n        if(dim.categoryorder === 'trace') {\n            // Use order of first occurrence in trace\n            categoryValues = null;\n        } else if(dim.categoryorder === 'array') {\n            // Use categories specified in `categoryarray` first,\n            // then add extra to the end in trace order\n            categoryValues = dim.categoryarray;\n        } else {\n            // Get all categories up front\n            categoryValues = filterUnique(dim.values);\n\n            // order them\n            var allNumeric = true;\n            for(var i = 0; i < categoryValues.length; i++) {\n                if(!isNumeric(categoryValues[i])) {\n                    allNumeric = false;\n                    break;\n                }\n            }\n            categoryValues.sort(allNumeric ? Lib.sorterAsc : undefined);\n\n            if(dim.categoryorder === 'category descending') {\n                categoryValues = categoryValues.reverse();\n            }\n        }\n        return getUniqueInfo(dim.values, categoryValues);\n    });\n\n    var counts,\n        count,\n        totalCount;\n    if(Lib.isArrayOrTypedArray(trace.counts)) {\n        counts = trace.counts;\n    } else {\n        counts = [trace.counts];\n    }\n\n    validateDimensionDisplayInds(visibleDims);\n\n    visibleDims.forEach(function(dim, dimInd) {\n        validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n    });\n\n    // Handle path colors\n    // ------------------\n    var line = trace.line;\n    var markerColorscale;\n\n    // Process colorscale\n    if(line) {\n        if(hasColorscale(trace, 'line')) {\n            colorscaleCalc(gd, trace, {\n                vals: trace.line.color,\n                containerStr: 'line',\n                cLetter: 'c'\n            });\n        }\n        markerColorscale = Drawing.tryColorscale(line);\n    } else {\n        markerColorscale = Lib.identity;\n    }\n\n    // Build color generation function\n    function getMarkerColorInfo(index) {\n        var value, rawColor;\n        if(Lib.isArrayOrTypedArray(line.color)) {\n            value = line.color[index % line.color.length];\n            rawColor = value;\n        } else {\n            value = line.color;\n        }\n\n        return {color: markerColorscale(value), rawColor: rawColor};\n    }\n\n    // Number of values and counts\n    // ---------------------------\n    var numValues = visibleDims[0].values.length;\n\n    // Build path info\n    // ---------------\n    // Mapping from category inds to PathModel objects\n    var pathModels = {};\n\n    // Category inds array for each dimension\n    var categoryIndsDims = uniqueInfoDims.map(function(di) {return di.inds;});\n\n    // Initialize total count\n    totalCount = 0;\n    var valueInd;\n    var d;\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n        // Category inds for this input value across dimensions\n        var categoryIndsPath = [];\n        for(d = 0; d < categoryIndsDims.length; d++) {\n            categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n        }\n\n        // Count\n        count = counts[valueInd % counts.length];\n\n        // Update total count\n        totalCount += count;\n\n        // Path color\n        var pathColorInfo = getMarkerColorInfo(valueInd);\n\n        // path key\n        var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor;\n\n        // Create / Update PathModel\n        if(pathModels[pathKey] === undefined) {\n            pathModels[pathKey] = createPathModel(categoryIndsPath,\n                pathColorInfo.color,\n                pathColorInfo.rawColor);\n        }\n        updatePathModel(pathModels[pathKey], valueInd, count);\n    }\n\n    var dimensionModels = visibleDims.map(function(di, i) {\n        return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n    });\n\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n        count = counts[valueInd % counts.length];\n\n        for(d = 0; d < dimensionModels.length; d++) {\n            var containerInd = dimensionModels[d].containerInd;\n            var catInd = uniqueInfoDims[d].inds[valueInd];\n            var cats = dimensionModels[d].categories;\n\n            if(cats[catInd] === undefined) {\n                var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n                var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n                cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n            }\n\n            updateCategoryModel(cats[catInd], valueInd, count);\n        }\n    }\n\n    // Compute unique\n    return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n};\n\n// Models\n// ======\n\n// Parcats Model\n// -------------\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\nfunction createParcatsModel(dimensions, paths, count) {\n    var maxCats = dimensions\n        .map(function(d) {return d.categories.length;})\n        .reduce(function(v1, v2) {return Math.max(v1, v2);});\n    return {dimensions: dimensions, paths: paths, trace: undefined, maxCats: maxCats, count: count};\n}\n\n// Dimension Model\n// ---------------\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n    return {\n        dimensionInd: dimensionInd,\n        containerInd: containerInd,\n        displayInd: displayInd,\n        dimensionLabel: dimensionLabel,\n        count: count,\n        categories: [],\n        dragX: null\n    };\n}\n\n// Category Model\n// --------------\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n    return {\n        dimensionInd: dimensionInd,\n        categoryInd: categoryInd,\n        categoryValue: categoryValue,\n        displayInd: categoryInd,\n        categoryLabel: categoryLabel,\n        valueInds: [],\n        count: 0,\n        dragY: null\n    };\n}\n\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n    categoryModel.valueInds.push(valueInd);\n    categoryModel.count += count;\n}\n\n\n// Path Model\n// ----------\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\nfunction createPathModel(categoryInds, color, rawColor) {\n    return {\n        categoryInds: categoryInds,\n        color: color,\n        rawColor: rawColor,\n        valueInds: [],\n        count: 0\n    };\n}\n\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updatePathModel(pathModel, valueInd, count) {\n    pathModel.valueInds.push(valueInd);\n    pathModel.count += count;\n}\n\n// Unique calculations\n// ===================\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\nfunction getUniqueInfo(values, uniqueValues) {\n    // Initialize uniqueValues if not specified\n    if(uniqueValues === undefined || uniqueValues === null) {\n        uniqueValues = [];\n    } else {\n        // Shallow copy so append below doesn't alter input array\n        uniqueValues = uniqueValues.map(function(e) {return e;});\n    }\n\n    // Initialize Variables\n    var uniqueValueCounts = {};\n    var uniqueValueInds = {};\n    var inds = [];\n\n    // Initialize uniqueValueCounts and\n    uniqueValues.forEach(function(uniqueVal, valInd) {\n        uniqueValueCounts[uniqueVal] = 0;\n        uniqueValueInds[uniqueVal] = valInd;\n    });\n\n    // Compute the necessary unique info in a single pass\n    for(var i = 0; i < values.length; i++) {\n        var item = values[i];\n        var itemInd;\n\n        if(uniqueValueCounts[item] === undefined) {\n            // This item has a previously unseen value\n            uniqueValueCounts[item] = 1;\n            itemInd = uniqueValues.push(item) - 1;\n            uniqueValueInds[item] = itemInd;\n        } else {\n            // Increment count for this item\n            uniqueValueCounts[item]++;\n            itemInd = uniqueValueInds[item];\n        }\n        inds.push(itemInd);\n    }\n\n    // Build UniqueInfo\n    var uniqueCounts = uniqueValues.map(function(v) { return uniqueValueCounts[v]; });\n\n    return {\n        uniqueValues: uniqueValues,\n        uniqueCounts: uniqueCounts,\n        inds: inds\n    };\n}\n\n\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\nfunction validateDimensionDisplayInds(visibleDims) {\n    var displayInds = visibleDims.map(function(d) { return d.displayindex; });\n    var i;\n\n    if(isRangePermutation(displayInds)) {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = visibleDims[i].displayindex;\n        }\n    } else {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = i;\n        }\n    }\n}\n\n\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n    // Update categoryarray\n    dim._categoryarray = uniqueInfoDim.uniqueValues;\n\n    // Handle ticktext\n    if(dim.ticktext === null || dim.ticktext === undefined) {\n        dim._ticktext = [];\n    } else {\n        // Shallow copy to avoid modifying input array\n        dim._ticktext = dim.ticktext.slice();\n    }\n\n    // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n    for(var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n        dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n    }\n}\n\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\nfunction isRangePermutation(inds) {\n    var indsSpecified = new Array(inds.length);\n\n    for(var i = 0; i < inds.length; i++) {\n        // Check for out of bounds\n        if(inds[i] < 0 || inds[i] >= inds.length) {\n            return false;\n        }\n\n        // Check for collisions with already specified index\n        if(indsSpecified[inds[i]] !== undefined) {\n            return false;\n        }\n\n        indsSpecified[inds[i]] = true;\n    }\n\n    // Nothing out of bounds and no collisions. We have a permutation\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}