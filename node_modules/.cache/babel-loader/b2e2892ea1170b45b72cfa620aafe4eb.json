{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar d3Hierarchy = require('d3-hierarchy');\nvar interpolate = require('d3-interpolate').interpolate;\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar piePlot = require('../pie/plot');\nvar getRotationAngle = require('../pie/helpers').getRotationAngle;\nvar computeTransform = piePlot.computeTransform;\nvar transformInsideText = piePlot.transformInsideText;\nvar styleOne = require('./style').styleOne;\nvar resizeText = require('../bar/style').resizeText;\nvar attachFxHandlers = require('./fx');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nexports.plot = function (gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var layer = fullLayout._sunburstlayer;\n  var join, onComplete;\n\n  // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  clearMinTextSize('sunburst', fullLayout);\n  join = layer.selectAll('g.trace.sunburst').data(cdmodule, function (cd) {\n    return cd[0].trace.uid;\n  });\n\n  // using same 'stroke-linejoin' as pie traces\n  join.enter().append('g').classed('trace', true).classed('sunburst', true).attr('stroke-linejoin', 'round');\n  join.order();\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      layer.selectAll('g.trace').each(function (cd) {\n        plotOne(gd, cd, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (cd) {\n      plotOne(gd, cd, this, transitionOpts);\n    });\n    if (fullLayout.uniformtext.mode) {\n      resizeText(gd, fullLayout._sunburstlayer.selectAll('.trace'), 'sunburst');\n    }\n  }\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n};\nfunction plotOne(gd, cd, element, transitionOpts) {\n  var isStatic = gd._context.staticPlot;\n  var fullLayout = gd._fullLayout;\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var gTrace = d3.select(element);\n  var slices = gTrace.selectAll('g.slice');\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var maxDepth = helpers.getMaxDepth(trace);\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var rMax = 0.5 * Math.min(vpw, vph);\n  var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n  if (!entry) {\n    return slices.remove();\n  }\n\n  // previous root 'pt' (can be empty)\n  var prevEntry = null;\n  // stash of 'previous' position data used by tweening functions\n  var prevLookup = {};\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    slices.each(function (pt) {\n      prevLookup[helpers.getPtId(pt)] = {\n        rpx0: pt.rpx0,\n        rpx1: pt.rpx1,\n        x0: pt.x0,\n        x1: pt.x1,\n        transform: pt.transform\n      };\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  }\n\n  // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n  var sliceData = partition(entry).descendants();\n  var maxHeight = entry.height + 1;\n  var yOffset = 0;\n  var cutoff = maxDepth;\n  // N.B. handle multiple-root special case\n  if (cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n    sliceData = sliceData.slice(1);\n    maxHeight -= 1;\n    yOffset = 1;\n    cutoff += 1;\n  }\n\n  // filter out slices that won't show up on graph\n  sliceData = sliceData.filter(function (pt) {\n    return pt.y1 <= cutoff;\n  });\n  var baseX = getRotationAngle(trace.rotation);\n  if (baseX) {\n    sliceData.forEach(function (pt) {\n      pt.x0 += baseX;\n      pt.x1 += baseX;\n    });\n  }\n\n  // partition span ('y') to sector radial px value\n  var maxY = Math.min(maxHeight, maxDepth);\n  var y2rpx = function (y) {\n    return (y - yOffset) / maxY * rMax;\n  };\n  // (radial px value, partition angle ('x'))  to px [x,y]\n  var rx2px = function (r, x) {\n    return [r * Math.cos(x), -r * Math.sin(x)];\n  };\n  // slice path generation fn\n  var pathSlice = function (d) {\n    return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy);\n  };\n  // slice text translate x/y\n\n  var getTargetX = function (d) {\n    return cx + getTextXY(d)[0] * (d.transform.rCenter || 0) + (d.transform.x || 0);\n  };\n  var getTargetY = function (d) {\n    return cy + getTextXY(d)[1] * (d.transform.rCenter || 0) + (d.transform.y || 0);\n  };\n  slices = slices.data(sliceData, helpers.getPtId);\n  slices.enter().append('g').classed('slice', true);\n  if (hasTransition) {\n    slices.exit().transition().each(function () {\n      var sliceTop = d3.select(this);\n      var slicePath = sliceTop.select('path.surface');\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeExitSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n      var sliceTextGroup = sliceTop.select('g.slicetext');\n      sliceTextGroup.attr('opacity', 0);\n    }).remove();\n  } else {\n    slices.exit().remove();\n  }\n  slices.order();\n\n  // next x1 (i.e. sector end angle) of previous entry\n  var nextX1ofPrevEntry = null;\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextX1ofPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextX1ofPrevEntry = pt.x1;\n      }\n    });\n  }\n  var updateSlices = slices;\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: true,\n        isTransitioning: false\n      });\n    });\n  }\n  updateSlices.each(function (pt) {\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', isStatic ? 'none' : 'all');\n    });\n    pt.rpx0 = y2rpx(pt.y0);\n    pt.rpx1 = y2rpx(pt.y1);\n    pt.xmid = (pt.x0 + pt.x1) / 2;\n    pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n    pt.midangle = -(pt.xmid - Math.PI / 2);\n    pt.startangle = -(pt.x0 - Math.PI / 2);\n    pt.stopangle = -(pt.x1 - Math.PI / 2);\n    pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n    pt.ring = 1 - pt.rpx0 / pt.rpx1;\n    pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      hideOnRoot: true,\n      hideOnLeaves: true,\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace, gd);\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n    sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout)).classed('slicetext', true).attr('text-anchor', 'middle').call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n\n    // position the text relative to the slice\n    var textBB = Drawing.bBox(sliceText.node());\n    pt.transform = transformInsideText(textBB, pt, cd0);\n    pt.transform.targetX = getTargetX(pt);\n    pt.transform.targetY = getTargetY(pt);\n    var strTransform = function (d, textBB) {\n      var transform = d.transform;\n      computeTransform(transform, textBB);\n      transform.fontSize = font.size;\n      recordMinTextSize(trace.type, transform, fullLayout);\n      return Lib.getTextTransform(transform);\n    };\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2);\n        return function (t) {\n          return strTransform(interp(t), textBB);\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt, textBB));\n    }\n  });\n  function makeExitSliceInterpolator(pt) {\n    var id = helpers.getPtId(pt);\n    var prev = prevLookup[id];\n    var entryPrev = prevLookup[helpers.getPtId(entry)];\n    var next;\n    if (entryPrev) {\n      var a = (pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0) + baseX;\n      // if pt to remove:\n      // - if 'below' where the root-node used to be: shrink it radially inward\n      // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n      next = pt.rpx1 < entryPrev.rpx1 ? {\n        x0: pt.x0,\n        x1: pt.x1,\n        rpx0: 0,\n        rpx1: 0\n      } : {\n        x0: a,\n        x1: a,\n        rpx0: pt.rpx0,\n        rpx1: pt.rpx1\n      };\n    } else {\n      // this happens when maxdepth is set, when leaves must\n      // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n      var parent;\n      var parentId = helpers.getPtId(pt.parent);\n      slices.each(function (pt2) {\n        if (helpers.getPtId(pt2) === parentId) {\n          return parent = pt2;\n        }\n      });\n      var parentChildren = parent.children;\n      var ci;\n      parentChildren.forEach(function (pt2, i) {\n        if (helpers.getPtId(pt2) === id) {\n          return ci = i;\n        }\n      });\n      var n = parentChildren.length;\n      var interp = interpolate(parent.x0, parent.x1);\n      next = {\n        rpx0: rMax,\n        rpx1: rMax,\n        x0: interp(ci / n),\n        x1: interp((ci + 1) / n)\n      };\n    }\n    return interpolate(prev, next);\n  }\n  function makeUpdateSliceInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var next = {\n      x0: pt.x0,\n      x1: pt.x1,\n      rpx0: pt.rpx0,\n      rpx1: pt.rpx1\n    };\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = (pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0) + baseX;\n            prev = {\n              x0: a,\n              x1: a\n            };\n          } else {\n            // if new leaf (when maxdepth is set),\n            // grow it radially and angularly from\n            // its parent node\n            prev = {\n              rpx0: rMax,\n              rpx1: rMax\n            };\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node, grow it radially\n          prev = {\n            rpx0: 0,\n            rpx1: 0\n          };\n        }\n      } else {\n        // start sector of new traces from theta=0\n        prev = {\n          x0: baseX,\n          x1: baseX\n        };\n      }\n    }\n    return interpolate(prev, next);\n  }\n  function makeUpdateTextInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var transform = pt.transform;\n    if (prev0) {\n      prev = prev0;\n    } else {\n      prev = {\n        rpx1: pt.rpx1,\n        transform: {\n          textPosAngle: transform.textPosAngle,\n          scale: 0,\n          rotate: transform.rotate,\n          rCenter: transform.rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      };\n\n      // for new pts:\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n            prev.x0 = prev.x1 = a;\n          } else {\n            // if leaf\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node\n          prev.x0 = prev.x1 = baseX;\n        }\n      } else {\n        // on new traces\n        prev.x0 = prev.x1 = baseX;\n      }\n    }\n    var textPosAngleFn = interpolate(prev.transform.textPosAngle, pt.transform.textPosAngle);\n    var rpx1Fn = interpolate(prev.rpx1, pt.rpx1);\n    var x0Fn = interpolate(prev.x0, pt.x0);\n    var x1Fn = interpolate(prev.x1, pt.x1);\n    var scaleFn = interpolate(prev.transform.scale, transform.scale);\n    var rotateFn = interpolate(prev.transform.rotate, transform.rotate);\n\n    // smooth out start/end from entry, to try to keep text inside sector\n    // while keeping transition smooth\n    var pow = transform.rCenter === 0 ? 3 : prev.transform.rCenter === 0 ? 1 / 3 : 1;\n    var _rCenterFn = interpolate(prev.transform.rCenter, transform.rCenter);\n    var rCenterFn = function (t) {\n      return _rCenterFn(Math.pow(t, pow));\n    };\n    return function (t) {\n      var rpx1 = rpx1Fn(t);\n      var x0 = x0Fn(t);\n      var x1 = x1Fn(t);\n      var rCenter = rCenterFn(t);\n      var pxmid = rx2px(rpx1, (x0 + x1) / 2);\n      var textPosAngle = textPosAngleFn(t);\n      var d = {\n        pxmid: pxmid,\n        rpx1: rpx1,\n        transform: {\n          textPosAngle: textPosAngle,\n          rCenter: rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      };\n      recordMinTextSize(trace.type, transform, fullLayout);\n      return {\n        transform: {\n          targetX: getTargetX(d),\n          targetY: getTargetY(d),\n          scale: scaleFn(t),\n          rotate: rotateFn(t),\n          rCenter: rCenter\n        }\n      };\n    };\n  }\n  function interpX0X1FromParent(pt) {\n    var parent = pt.parent;\n    var parentPrev = prevLookup[helpers.getPtId(parent)];\n    var out = {};\n    if (parentPrev) {\n      // if parent is visible\n      var parentChildren = parent.children;\n      var ci = parentChildren.indexOf(pt);\n      var n = parentChildren.length;\n      var interp = interpolate(parentPrev.x0, parentPrev.x1);\n      out.x0 = interp(ci / n);\n      out.x1 = interp(ci / n);\n    } else {\n      // w/o visible parent\n      // TODO !!! HOW ???\n      out.x0 = out.x1 = 0;\n    }\n    return out;\n  }\n}\n\n// x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\nfunction partition(entry) {\n  return d3Hierarchy.partition().size([2 * Math.PI, entry.height + 1])(entry);\n}\nexports.formatSliceLabel = function (pt, entry, trace, cd, fullLayout) {\n  var texttemplate = trace.texttemplate;\n  var textinfo = trace.textinfo;\n  if (!texttemplate && (!textinfo || textinfo === 'none')) {\n    return '';\n  }\n  var separators = fullLayout.separators;\n  var cd0 = cd[0];\n  var cdi = pt.data.data;\n  var hierarchy = cd0.hierarchy;\n  var isRoot = helpers.isHierarchyRoot(pt);\n  var parent = helpers.getParent(hierarchy, pt);\n  var val = helpers.getValue(pt);\n  if (!texttemplate) {\n    var parts = textinfo.split('+');\n    var hasFlag = function (flag) {\n      return parts.indexOf(flag) !== -1;\n    };\n    var thisText = [];\n    var tx;\n    if (hasFlag('label') && cdi.label) {\n      thisText.push(cdi.label);\n    }\n    if (cdi.hasOwnProperty('v') && hasFlag('value')) {\n      thisText.push(helpers.formatValue(cdi.v, separators));\n    }\n    if (!isRoot) {\n      if (hasFlag('current path')) {\n        thisText.push(helpers.getPath(pt.data));\n      }\n      var nPercent = 0;\n      if (hasFlag('percent parent')) nPercent++;\n      if (hasFlag('percent entry')) nPercent++;\n      if (hasFlag('percent root')) nPercent++;\n      var hasMultiplePercents = nPercent > 1;\n      if (nPercent) {\n        var percent;\n        var addPercent = function (key) {\n          tx = helpers.formatPercent(percent, separators);\n          if (hasMultiplePercents) tx += ' of ' + key;\n          thisText.push(tx);\n        };\n        if (hasFlag('percent parent') && !isRoot) {\n          percent = val / helpers.getValue(parent);\n          addPercent('parent');\n        }\n        if (hasFlag('percent entry')) {\n          percent = val / helpers.getValue(entry);\n          addPercent('entry');\n        }\n        if (hasFlag('percent root')) {\n          percent = val / helpers.getValue(hierarchy);\n          addPercent('root');\n        }\n      }\n    }\n    if (hasFlag('text')) {\n      tx = Lib.castOption(trace, cdi.i, 'text');\n      if (Lib.isValidTextValue(tx)) thisText.push(tx);\n    }\n    return thisText.join('<br>');\n  }\n  var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n  if (!txt) return '';\n  var obj = {};\n  if (cdi.label) obj.label = cdi.label;\n  if (cdi.hasOwnProperty('v')) {\n    obj.value = cdi.v;\n    obj.valueLabel = helpers.formatValue(cdi.v, separators);\n  }\n  obj.currentPath = helpers.getPath(pt.data);\n  if (!isRoot) {\n    obj.percentParent = val / helpers.getValue(parent);\n    obj.percentParentLabel = helpers.formatPercent(obj.percentParent, separators);\n    obj.parent = helpers.getPtLabel(parent);\n  }\n  obj.percentEntry = val / helpers.getValue(entry);\n  obj.percentEntryLabel = helpers.formatPercent(obj.percentEntry, separators);\n  obj.entry = helpers.getPtLabel(entry);\n  obj.percentRoot = val / helpers.getValue(hierarchy);\n  obj.percentRootLabel = helpers.formatPercent(obj.percentRoot, separators);\n  obj.root = helpers.getPtLabel(hierarchy);\n  if (cdi.hasOwnProperty('color')) {\n    obj.color = cdi.color;\n  }\n  var ptTx = Lib.castOption(trace, cdi.i, 'text');\n  if (Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n  obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\nfunction getInscribedRadiusFraction(pt) {\n  if (pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n    // special case of 100% with no hole\n    return 1;\n  } else {\n    return Math.max(0, Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2));\n  }\n}\nfunction getTextXY(d) {\n  return getCoords(d.rpx1, d.transform.textPosAngle);\n}\nfunction getCoords(r, angle) {\n  return [r * Math.sin(angle), -r * Math.cos(angle)];\n}","map":{"version":3,"names":["d3","require","d3Hierarchy","interpolate","Drawing","Lib","svgTextUtils","uniformText","recordMinTextSize","clearMinTextSize","piePlot","getRotationAngle","computeTransform","transformInsideText","styleOne","resizeText","attachFxHandlers","constants","helpers","exports","plot","gd","cdmodule","transitionOpts","makeOnCompleteCallback","fullLayout","_fullLayout","layer","_sunburstlayer","join","onComplete","isFullReplot","hasTransition","uniformtext","mode","selectAll","data","cd","trace","uid","enter","append","classed","attr","order","transition","duration","ease","easing","each","plotOne","exit","remove","element","isStatic","_context","staticPlot","gTrace","select","slices","cd0","hierarchy","entry","findEntryWithLevel","level","maxDepth","getMaxDepth","gs","_size","domain","vpw","w","x","vph","h","y","rMax","Math","min","cx","l","cy","t","prevEntry","prevLookup","pt","getPtId","rpx0","rpx1","x0","x1","transform","isEntry","sliceData","partition","descendants","maxHeight","height","yOffset","cutoff","hasMultipleRoots","isHierarchyRoot","slice","filter","y1","baseX","rotation","forEach","maxY","y2rpx","rx2px","r","cos","sin","pathSlice","d","pathAnnulus","getTargetX","getTextXY","rCenter","getTargetY","sliceTop","slicePath","attrTween","pt2","interp","makeExitSliceInterpolator","sliceTextGroup","nextX1ofPrevEntry","prevEntryId","updateSlices","setSliceCursor","hideOnRoot","hideOnLeaves","isTransitioning","ensureSingle","s","style","y0","xmid","pxmid","midangle","PI","startangle","stopangle","halfangle","angleDelta","ring","rInscribed","getInscribedRadiusFraction","makeUpdateSliceInterpolator","call","eventDataKeys","transitionTime","CLICK_TRANSITION_TIME","transitionEasing","CLICK_TRANSITION_EASING","_transitioning","sliceText","font","ensureUniformFontSize","determineTextFont","text","formatSliceLabel","convertToTspans","textBB","bBox","node","targetX","targetY","strTransform","fontSize","size","type","getTextTransform","makeUpdateTextInterpolator","id","prev","entryPrev","next","a","parent","parentId","parentChildren","children","ci","i","n","length","prev0","extendFlat","interpX0X1FromParent","textPosAngle","scale","rotate","textPosAngleFn","rpx1Fn","x0Fn","x1Fn","scaleFn","rotateFn","pow","_rCenterFn","rCenterFn","parentPrev","out","indexOf","texttemplate","textinfo","separators","cdi","isRoot","getParent","val","getValue","parts","split","hasFlag","flag","thisText","tx","label","push","hasOwnProperty","formatValue","v","getPath","nPercent","hasMultiplePercents","percent","addPercent","key","formatPercent","castOption","isValidTextValue","txt","obj","value","valueLabel","currentPath","percentParent","percentParentLabel","getPtLabel","percentEntry","percentEntryLabel","percentRoot","percentRootLabel","root","color","ptTx","customdata","texttemplateString","_d3locale","_meta","isFullCircle","max","getCoords","angle"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/sunburst/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar d3Hierarchy = require('d3-hierarchy');\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar piePlot = require('../pie/plot');\nvar getRotationAngle = require('../pie/helpers').getRotationAngle;\nvar computeTransform = piePlot.computeTransform;\nvar transformInsideText = piePlot.transformInsideText;\nvar styleOne = require('./style').styleOne;\nvar resizeText = require('../bar/style').resizeText;\nvar attachFxHandlers = require('./fx');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\nexports.plot = function(gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout;\n    var layer = fullLayout._sunburstlayer;\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    clearMinTextSize('sunburst', fullLayout);\n\n    join = layer.selectAll('g.trace.sunburst')\n        .data(cdmodule, function(cd) { return cd[0].trace.uid; });\n\n    // using same 'stroke-linejoin' as pie traces\n    join.enter().append('g')\n        .classed('trace', true)\n        .classed('sunburst', true)\n        .attr('stroke-linejoin', 'round');\n\n    join.order();\n\n    if(hasTransition) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() { onComplete && onComplete(); })\n            .each('interrupt', function() { onComplete && onComplete(); });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            layer.selectAll('g.trace').each(function(cd) {\n                plotOne(gd, cd, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(cd) {\n            plotOne(gd, cd, this, transitionOpts);\n        });\n\n        if(fullLayout.uniformtext.mode) {\n            resizeText(gd, fullLayout._sunburstlayer.selectAll('.trace'), 'sunburst');\n        }\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n};\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n    var isStatic = gd._context.staticPlot;\n\n    var fullLayout = gd._fullLayout;\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    var gTrace = d3.select(element);\n    var slices = gTrace.selectAll('g.slice');\n\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var hierarchy = cd0.hierarchy;\n    var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n    var maxDepth = helpers.getMaxDepth(trace);\n\n    var gs = fullLayout._size;\n    var domain = trace.domain;\n    var vpw = gs.w * (domain.x[1] - domain.x[0]);\n    var vph = gs.h * (domain.y[1] - domain.y[0]);\n    var rMax = 0.5 * Math.min(vpw, vph);\n    var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n    var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n\n    if(!entry) {\n        return slices.remove();\n    }\n\n    // previous root 'pt' (can be empty)\n    var prevEntry = null;\n    // stash of 'previous' position data used by tweening functions\n    var prevLookup = {};\n\n    if(hasTransition) {\n        // Important: do this before binding new sliceData!\n        slices.each(function(pt) {\n            prevLookup[helpers.getPtId(pt)] = {\n                rpx0: pt.rpx0,\n                rpx1: pt.rpx1,\n                x0: pt.x0,\n                x1: pt.x1,\n                transform: pt.transform\n            };\n\n            if(!prevEntry && helpers.isEntry(pt)) {\n                prevEntry = pt;\n            }\n        });\n    }\n\n    // N.B. slice data isn't the calcdata,\n    // grab corresponding calcdata item in sliceData[i].data.data\n    var sliceData = partition(entry).descendants();\n\n    var maxHeight = entry.height + 1;\n    var yOffset = 0;\n    var cutoff = maxDepth;\n    // N.B. handle multiple-root special case\n    if(cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n        sliceData = sliceData.slice(1);\n        maxHeight -= 1;\n        yOffset = 1;\n        cutoff += 1;\n    }\n\n    // filter out slices that won't show up on graph\n    sliceData = sliceData.filter(function(pt) { return pt.y1 <= cutoff; });\n\n    var baseX = getRotationAngle(trace.rotation);\n    if(baseX) {\n        sliceData.forEach(function(pt) {\n            pt.x0 += baseX;\n            pt.x1 += baseX;\n        });\n    }\n\n    // partition span ('y') to sector radial px value\n    var maxY = Math.min(maxHeight, maxDepth);\n    var y2rpx = function(y) { return (y - yOffset) / maxY * rMax; };\n    // (radial px value, partition angle ('x'))  to px [x,y]\n    var rx2px = function(r, x) { return [r * Math.cos(x), -r * Math.sin(x)]; };\n    // slice path generation fn\n    var pathSlice = function(d) { return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy); };\n    // slice text translate x/y\n\n    var getTargetX = function(d) { return cx + getTextXY(d)[0] * (d.transform.rCenter || 0) + (d.transform.x || 0); };\n    var getTargetY = function(d) { return cy + getTextXY(d)[1] * (d.transform.rCenter || 0) + (d.transform.y || 0); };\n\n    slices = slices.data(sliceData, helpers.getPtId);\n\n    slices.enter().append('g')\n        .classed('slice', true);\n\n    if(hasTransition) {\n        slices.exit().transition()\n            .each(function() {\n                var sliceTop = d3.select(this);\n\n                var slicePath = sliceTop.select('path.surface');\n                slicePath.transition().attrTween('d', function(pt2) {\n                    var interp = makeExitSliceInterpolator(pt2);\n                    return function(t) { return pathSlice(interp(t)); };\n                });\n\n                var sliceTextGroup = sliceTop.select('g.slicetext');\n                sliceTextGroup.attr('opacity', 0);\n            })\n            .remove();\n    } else {\n        slices.exit().remove();\n    }\n\n    slices.order();\n\n    // next x1 (i.e. sector end angle) of previous entry\n    var nextX1ofPrevEntry = null;\n    if(hasTransition && prevEntry) {\n        var prevEntryId = helpers.getPtId(prevEntry);\n        slices.each(function(pt) {\n            if(nextX1ofPrevEntry === null && (helpers.getPtId(pt) === prevEntryId)) {\n                nextX1ofPrevEntry = pt.x1;\n            }\n        });\n    }\n\n    var updateSlices = slices;\n    if(hasTransition) {\n        updateSlices = updateSlices.transition().each('end', function() {\n            // N.B. gd._transitioning is (still) *true* by the time\n            // transition updates get here\n            var sliceTop = d3.select(this);\n            helpers.setSliceCursor(sliceTop, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: true,\n                isTransitioning: false\n            });\n        });\n    }\n\n    updateSlices.each(function(pt) {\n        var sliceTop = d3.select(this);\n\n        var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function(s) {\n            s.style('pointer-events', isStatic ? 'none' : 'all');\n        });\n\n        pt.rpx0 = y2rpx(pt.y0);\n        pt.rpx1 = y2rpx(pt.y1);\n        pt.xmid = (pt.x0 + pt.x1) / 2;\n        pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n        pt.midangle = -(pt.xmid - Math.PI / 2);\n        pt.startangle = -(pt.x0 - Math.PI / 2);\n        pt.stopangle = -(pt.x1 - Math.PI / 2);\n        pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n        pt.ring = 1 - (pt.rpx0 / pt.rpx1);\n        pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n\n        if(hasTransition) {\n            slicePath.transition().attrTween('d', function(pt2) {\n                var interp = makeUpdateSliceInterpolator(pt2);\n                return function(t) { return pathSlice(interp(t)); };\n            });\n        } else {\n            slicePath.attr('d', pathSlice);\n        }\n\n        sliceTop\n            .call(attachFxHandlers, entry, gd, cd, {\n                eventDataKeys: constants.eventDataKeys,\n                transitionTime: constants.CLICK_TRANSITION_TIME,\n                transitionEasing: constants.CLICK_TRANSITION_EASING\n            })\n            .call(helpers.setSliceCursor, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: true,\n                isTransitioning: gd._transitioning\n            });\n\n        slicePath.call(styleOne, pt, trace, gd);\n\n        var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n        var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n\n        sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout))\n            .classed('slicetext', true)\n            .attr('text-anchor', 'middle')\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        // position the text relative to the slice\n        var textBB = Drawing.bBox(sliceText.node());\n        pt.transform = transformInsideText(textBB, pt, cd0);\n        pt.transform.targetX = getTargetX(pt);\n        pt.transform.targetY = getTargetY(pt);\n\n        var strTransform = function(d, textBB) {\n            var transform = d.transform;\n            computeTransform(transform, textBB);\n\n            transform.fontSize = font.size;\n            recordMinTextSize(trace.type, transform, fullLayout);\n\n            return Lib.getTextTransform(transform);\n        };\n\n        if(hasTransition) {\n            sliceText.transition().attrTween('transform', function(pt2) {\n                var interp = makeUpdateTextInterpolator(pt2);\n                return function(t) { return strTransform(interp(t), textBB); };\n            });\n        } else {\n            sliceText.attr('transform', strTransform(pt, textBB));\n        }\n    });\n\n    function makeExitSliceInterpolator(pt) {\n        var id = helpers.getPtId(pt);\n        var prev = prevLookup[id];\n        var entryPrev = prevLookup[helpers.getPtId(entry)];\n        var next;\n\n        if(entryPrev) {\n            var a = (pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0) + baseX;\n            // if pt to remove:\n            // - if 'below' where the root-node used to be: shrink it radially inward\n            // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n            next = pt.rpx1 < entryPrev.rpx1 ?\n                {x0: pt.x0, x1: pt.x1, rpx0: 0, rpx1: 0} :\n                {x0: a, x1: a, rpx0: pt.rpx0, rpx1: pt.rpx1};\n        } else {\n            // this happens when maxdepth is set, when leaves must\n            // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n            var parent;\n            var parentId = helpers.getPtId(pt.parent);\n            slices.each(function(pt2) {\n                if(helpers.getPtId(pt2) === parentId) {\n                    return parent = pt2;\n                }\n            });\n            var parentChildren = parent.children;\n            var ci;\n            parentChildren.forEach(function(pt2, i) {\n                if(helpers.getPtId(pt2) === id) {\n                    return ci = i;\n                }\n            });\n            var n = parentChildren.length;\n            var interp = interpolate(parent.x0, parent.x1);\n            next = {\n                rpx0: rMax, rpx1: rMax,\n                x0: interp(ci / n), x1: interp((ci + 1) / n)\n            };\n        }\n\n        return interpolate(prev, next);\n    }\n\n    function makeUpdateSliceInterpolator(pt) {\n        var prev0 = prevLookup[helpers.getPtId(pt)];\n        var prev;\n        var next = {x0: pt.x0, x1: pt.x1, rpx0: pt.rpx0, rpx1: pt.rpx1};\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(prevEntry) {\n                // if trace was visible before\n                if(pt.parent) {\n                    if(nextX1ofPrevEntry) {\n                        // if new branch, twist it in clockwise or\n                        // counterclockwise which ever is shorter to\n                        // its final angle\n                        var a = (pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0) + baseX;\n                        prev = {x0: a, x1: a};\n                    } else {\n                        // if new leaf (when maxdepth is set),\n                        // grow it radially and angularly from\n                        // its parent node\n                        prev = {rpx0: rMax, rpx1: rMax};\n                        Lib.extendFlat(prev, interpX0X1FromParent(pt));\n                    }\n                } else {\n                    // if new root-node, grow it radially\n                    prev = {rpx0: 0, rpx1: 0};\n                }\n            } else {\n                // start sector of new traces from theta=0\n                prev = {x0: baseX, x1: baseX};\n            }\n        }\n\n        return interpolate(prev, next);\n    }\n\n    function makeUpdateTextInterpolator(pt) {\n        var prev0 = prevLookup[helpers.getPtId(pt)];\n        var prev;\n        var transform = pt.transform;\n\n        if(prev0) {\n            prev = prev0;\n        } else {\n            prev = {\n                rpx1: pt.rpx1,\n                transform: {\n                    textPosAngle: transform.textPosAngle,\n                    scale: 0,\n                    rotate: transform.rotate,\n                    rCenter: transform.rCenter,\n                    x: transform.x,\n                    y: transform.y\n                }\n            };\n\n            // for new pts:\n            if(prevEntry) {\n                // if trace was visible before\n                if(pt.parent) {\n                    if(nextX1ofPrevEntry) {\n                        // if new branch, twist it in clockwise or\n                        // counterclockwise which ever is shorter to\n                        // its final angle\n                        var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n                        prev.x0 = prev.x1 = a;\n                    } else {\n                        // if leaf\n                        Lib.extendFlat(prev, interpX0X1FromParent(pt));\n                    }\n                } else {\n                    // if new root-node\n                    prev.x0 = prev.x1 = baseX;\n                }\n            } else {\n                // on new traces\n                prev.x0 = prev.x1 = baseX;\n            }\n        }\n\n        var textPosAngleFn = interpolate(prev.transform.textPosAngle, pt.transform.textPosAngle);\n        var rpx1Fn = interpolate(prev.rpx1, pt.rpx1);\n        var x0Fn = interpolate(prev.x0, pt.x0);\n        var x1Fn = interpolate(prev.x1, pt.x1);\n        var scaleFn = interpolate(prev.transform.scale, transform.scale);\n        var rotateFn = interpolate(prev.transform.rotate, transform.rotate);\n\n        // smooth out start/end from entry, to try to keep text inside sector\n        // while keeping transition smooth\n        var pow = transform.rCenter === 0 ? 3 :\n            prev.transform.rCenter === 0 ? 1 / 3 :\n            1;\n        var _rCenterFn = interpolate(prev.transform.rCenter, transform.rCenter);\n        var rCenterFn = function(t) { return _rCenterFn(Math.pow(t, pow)); };\n\n        return function(t) {\n            var rpx1 = rpx1Fn(t);\n            var x0 = x0Fn(t);\n            var x1 = x1Fn(t);\n            var rCenter = rCenterFn(t);\n            var pxmid = rx2px(rpx1, (x0 + x1) / 2);\n            var textPosAngle = textPosAngleFn(t);\n\n            var d = {\n                pxmid: pxmid,\n                rpx1: rpx1,\n                transform: {\n                    textPosAngle: textPosAngle,\n                    rCenter: rCenter,\n                    x: transform.x,\n                    y: transform.y\n                }\n            };\n\n            recordMinTextSize(trace.type, transform, fullLayout);\n            return {\n                transform: {\n                    targetX: getTargetX(d),\n                    targetY: getTargetY(d),\n                    scale: scaleFn(t),\n                    rotate: rotateFn(t),\n                    rCenter: rCenter\n                }\n            };\n        };\n    }\n\n    function interpX0X1FromParent(pt) {\n        var parent = pt.parent;\n        var parentPrev = prevLookup[helpers.getPtId(parent)];\n        var out = {};\n\n        if(parentPrev) {\n            // if parent is visible\n            var parentChildren = parent.children;\n            var ci = parentChildren.indexOf(pt);\n            var n = parentChildren.length;\n            var interp = interpolate(parentPrev.x0, parentPrev.x1);\n            out.x0 = interp(ci / n);\n            out.x1 = interp(ci / n);\n        } else {\n            // w/o visible parent\n            // TODO !!! HOW ???\n            out.x0 = out.x1 = 0;\n        }\n\n        return out;\n    }\n}\n\n// x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\nfunction partition(entry) {\n    return d3Hierarchy.partition()\n        .size([2 * Math.PI, entry.height + 1])(entry);\n}\n\nexports.formatSliceLabel = function(pt, entry, trace, cd, fullLayout) {\n    var texttemplate = trace.texttemplate;\n    var textinfo = trace.textinfo;\n\n    if(!texttemplate && (!textinfo || textinfo === 'none')) {\n        return '';\n    }\n\n    var separators = fullLayout.separators;\n    var cd0 = cd[0];\n    var cdi = pt.data.data;\n    var hierarchy = cd0.hierarchy;\n    var isRoot = helpers.isHierarchyRoot(pt);\n    var parent = helpers.getParent(hierarchy, pt);\n    var val = helpers.getValue(pt);\n\n    if(!texttemplate) {\n        var parts = textinfo.split('+');\n        var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n        var thisText = [];\n        var tx;\n\n        if(hasFlag('label') && cdi.label) {\n            thisText.push(cdi.label);\n        }\n\n        if(cdi.hasOwnProperty('v') && hasFlag('value')) {\n            thisText.push(helpers.formatValue(cdi.v, separators));\n        }\n\n        if(!isRoot) {\n            if(hasFlag('current path')) {\n                thisText.push(helpers.getPath(pt.data));\n            }\n\n            var nPercent = 0;\n            if(hasFlag('percent parent')) nPercent++;\n            if(hasFlag('percent entry')) nPercent++;\n            if(hasFlag('percent root')) nPercent++;\n            var hasMultiplePercents = nPercent > 1;\n\n            if(nPercent) {\n                var percent;\n                var addPercent = function(key) {\n                    tx = helpers.formatPercent(percent, separators);\n\n                    if(hasMultiplePercents) tx += ' of ' + key;\n                    thisText.push(tx);\n                };\n\n                if(hasFlag('percent parent') && !isRoot) {\n                    percent = val / helpers.getValue(parent);\n                    addPercent('parent');\n                }\n                if(hasFlag('percent entry')) {\n                    percent = val / helpers.getValue(entry);\n                    addPercent('entry');\n                }\n                if(hasFlag('percent root')) {\n                    percent = val / helpers.getValue(hierarchy);\n                    addPercent('root');\n                }\n            }\n        }\n\n        if(hasFlag('text')) {\n            tx = Lib.castOption(trace, cdi.i, 'text');\n            if(Lib.isValidTextValue(tx)) thisText.push(tx);\n        }\n\n        return thisText.join('<br>');\n    }\n\n    var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n    if(!txt) return '';\n    var obj = {};\n    if(cdi.label) obj.label = cdi.label;\n    if(cdi.hasOwnProperty('v')) {\n        obj.value = cdi.v;\n        obj.valueLabel = helpers.formatValue(cdi.v, separators);\n    }\n\n    obj.currentPath = helpers.getPath(pt.data);\n\n    if(!isRoot) {\n        obj.percentParent = val / helpers.getValue(parent);\n        obj.percentParentLabel = helpers.formatPercent(\n            obj.percentParent, separators\n        );\n        obj.parent = helpers.getPtLabel(parent);\n    }\n\n    obj.percentEntry = val / helpers.getValue(entry);\n    obj.percentEntryLabel = helpers.formatPercent(\n        obj.percentEntry, separators\n    );\n    obj.entry = helpers.getPtLabel(entry);\n\n    obj.percentRoot = val / helpers.getValue(hierarchy);\n    obj.percentRootLabel = helpers.formatPercent(\n        obj.percentRoot, separators\n    );\n    obj.root = helpers.getPtLabel(hierarchy);\n\n    if(cdi.hasOwnProperty('color')) {\n        obj.color = cdi.color;\n    }\n    var ptTx = Lib.castOption(trace, cdi.i, 'text');\n    if(Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n    obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n    return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\n\nfunction getInscribedRadiusFraction(pt) {\n    if(pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n        // special case of 100% with no hole\n        return 1;\n    } else {\n        return Math.max(0, Math.min(\n            1 / (1 + 1 / Math.sin(pt.halfangle)),\n            pt.ring / 2\n        ));\n    }\n}\n\nfunction getTextXY(d) {\n    return getCoords(d.rpx1, d.transform.textPosAngle);\n}\n\nfunction getCoords(r, angle) {\n    return [r * Math.sin(angle), -r * Math.cos(angle)];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}