{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar loggers = require('./loggers');\nvar identity = require('./identity');\nvar BADNUM = require('../constants/numerical').BADNUM;\n\n// don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\nvar roundingError = 1e-9;\n\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\nexports.findBin = function (val, bins, linelow) {\n  if (isNumeric(bins.start)) {\n    return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);\n  } else {\n    var n1 = 0;\n    var n2 = bins.length;\n    var c = 0;\n    var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n    var n, test;\n    if (binSize >= 0) {\n      test = linelow ? lessThan : lessOrEqual;\n    } else {\n      test = linelow ? greaterOrEqual : greaterThan;\n    }\n    val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);\n    // c is just to avoid infinite loops if there's an error\n    while (n1 < n2 && c++ < 100) {\n      n = Math.floor((n1 + n2) / 2);\n      if (test(bins[n], val)) n1 = n + 1;else n2 = n;\n    }\n    if (c > 90) loggers.log('Long binary search...');\n    return n1 - 1;\n  }\n};\nfunction lessThan(a, b) {\n  return a < b;\n}\nfunction lessOrEqual(a, b) {\n  return a <= b;\n}\nfunction greaterThan(a, b) {\n  return a > b;\n}\nfunction greaterOrEqual(a, b) {\n  return a >= b;\n}\nexports.sorterAsc = function (a, b) {\n  return a - b;\n};\nexports.sorterDes = function (a, b) {\n  return b - a;\n};\n\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\nexports.distinctVals = function (valsIn) {\n  var vals = valsIn.slice(); // otherwise we sort the original array...\n  vals.sort(exports.sorterAsc); // undefined listed in the end - also works on IE11\n\n  var last;\n  for (last = vals.length - 1; last > -1; last--) {\n    if (vals[last] !== BADNUM) break;\n  }\n  var minDiff = vals[last] - vals[0] || 1;\n  var errDiff = minDiff / (last || 1) / 10000;\n  var newVals = [];\n  var preV;\n  for (var i = 0; i <= last; i++) {\n    var v = vals[i];\n\n    // make sure values aren't just off by a rounding error\n    var diff = v - preV;\n    if (preV === undefined) {\n      newVals.push(v);\n      preV = v;\n    } else if (diff > errDiff) {\n      minDiff = Math.min(minDiff, diff);\n      newVals.push(v);\n      preV = v;\n    }\n  }\n  return {\n    vals: newVals,\n    minDiff: minDiff\n  };\n};\n\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\nexports.roundUp = function (val, arrayIn, reverse) {\n  var low = 0;\n  var high = arrayIn.length - 1;\n  var mid;\n  var c = 0;\n  var dlow = reverse ? 0 : 1;\n  var dhigh = reverse ? 1 : 0;\n  var rounded = reverse ? Math.ceil : Math.floor;\n  // c is just to avoid infinite loops if there's an error\n  while (low < high && c++ < 100) {\n    mid = rounded((low + high) / 2);\n    if (arrayIn[mid] <= val) low = mid + dlow;else high = mid - dhigh;\n  }\n  return arrayIn[low];\n};\n\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\nexports.sort = function (array, sortFn) {\n  var notOrdered = 0;\n  var notReversed = 0;\n  for (var i = 1; i < array.length; i++) {\n    var pairOrder = sortFn(array[i], array[i - 1]);\n    if (pairOrder < 0) notOrdered = 1;else if (pairOrder > 0) notReversed = 1;\n    if (notOrdered && notReversed) return array.sort(sortFn);\n  }\n  return notReversed ? array : array.reverse();\n};\n\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\nexports.findIndexOfMin = function (arr, fn) {\n  fn = fn || identity;\n  var min = Infinity;\n  var ind;\n  for (var i = 0; i < arr.length; i++) {\n    var v = fn(arr[i]);\n    if (v < min) {\n      min = v;\n      ind = i;\n    }\n  }\n  return ind;\n};","map":{"version":3,"names":["isNumeric","require","loggers","identity","BADNUM","roundingError","exports","findBin","val","bins","linelow","start","Math","ceil","size","floor","n1","n2","length","c","binSize","n","test","lessThan","lessOrEqual","greaterOrEqual","greaterThan","log","a","b","sorterAsc","sorterDes","distinctVals","valsIn","vals","slice","sort","last","minDiff","errDiff","newVals","preV","i","v","diff","undefined","push","min","roundUp","arrayIn","reverse","low","high","mid","dlow","dhigh","rounded","array","sortFn","notOrdered","notReversed","pairOrder","findIndexOfMin","arr","fn","Infinity","ind"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/lib/search.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar loggers = require('./loggers');\nvar identity = require('./identity');\nvar BADNUM = require('../constants/numerical').BADNUM;\n\n// don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\nvar roundingError = 1e-9;\n\n\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\nexports.findBin = function(val, bins, linelow) {\n    if(isNumeric(bins.start)) {\n        return linelow ?\n            Math.ceil((val - bins.start) / bins.size - roundingError) - 1 :\n            Math.floor((val - bins.start) / bins.size + roundingError);\n    } else {\n        var n1 = 0;\n        var n2 = bins.length;\n        var c = 0;\n        var binSize = (n2 > 1) ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n        var n, test;\n        if(binSize >= 0) {\n            test = linelow ? lessThan : lessOrEqual;\n        } else {\n            test = linelow ? greaterOrEqual : greaterThan;\n        }\n        val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);\n        // c is just to avoid infinite loops if there's an error\n        while(n1 < n2 && c++ < 100) {\n            n = Math.floor((n1 + n2) / 2);\n            if(test(bins[n], val)) n1 = n + 1;\n            else n2 = n;\n        }\n        if(c > 90) loggers.log('Long binary search...');\n        return n1 - 1;\n    }\n};\n\nfunction lessThan(a, b) { return a < b; }\nfunction lessOrEqual(a, b) { return a <= b; }\nfunction greaterThan(a, b) { return a > b; }\nfunction greaterOrEqual(a, b) { return a >= b; }\n\nexports.sorterAsc = function(a, b) { return a - b; };\nexports.sorterDes = function(a, b) { return b - a; };\n\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\nexports.distinctVals = function(valsIn) {\n    var vals = valsIn.slice();  // otherwise we sort the original array...\n    vals.sort(exports.sorterAsc); // undefined listed in the end - also works on IE11\n\n    var last;\n    for(last = vals.length - 1; last > -1; last--) {\n        if(vals[last] !== BADNUM) break;\n    }\n\n    var minDiff = (vals[last] - vals[0]) || 1;\n    var errDiff = minDiff / (last || 1) / 10000;\n    var newVals = [];\n    var preV;\n    for(var i = 0; i <= last; i++) {\n        var v = vals[i];\n\n        // make sure values aren't just off by a rounding error\n        var diff = v - preV;\n\n        if(preV === undefined) {\n            newVals.push(v);\n            preV = v;\n        } else if(diff > errDiff) {\n            minDiff = Math.min(minDiff, diff);\n\n            newVals.push(v);\n            preV = v;\n        }\n    }\n\n    return {vals: newVals, minDiff: minDiff};\n};\n\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\nexports.roundUp = function(val, arrayIn, reverse) {\n    var low = 0;\n    var high = arrayIn.length - 1;\n    var mid;\n    var c = 0;\n    var dlow = reverse ? 0 : 1;\n    var dhigh = reverse ? 1 : 0;\n    var rounded = reverse ? Math.ceil : Math.floor;\n    // c is just to avoid infinite loops if there's an error\n    while(low < high && c++ < 100) {\n        mid = rounded((low + high) / 2);\n        if(arrayIn[mid] <= val) low = mid + dlow;\n        else high = mid - dhigh;\n    }\n    return arrayIn[low];\n};\n\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\nexports.sort = function(array, sortFn) {\n    var notOrdered = 0;\n    var notReversed = 0;\n    for(var i = 1; i < array.length; i++) {\n        var pairOrder = sortFn(array[i], array[i - 1]);\n        if(pairOrder < 0) notOrdered = 1;\n        else if(pairOrder > 0) notReversed = 1;\n        if(notOrdered && notReversed) return array.sort(sortFn);\n    }\n    return notReversed ? array : array.reverse();\n};\n\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\nexports.findIndexOfMin = function(arr, fn) {\n    fn = fn || identity;\n\n    var min = Infinity;\n    var ind;\n\n    for(var i = 0; i < arr.length; i++) {\n        var v = fn(arr[i]);\n        if(v < min) {\n            min = v;\n            ind = i;\n        }\n    }\n    return ind;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}