{"ast":null,"code":"'use strict';\n\nmodule.exports = function (pathinfo, contours) {\n  var pi0 = pathinfo[0];\n  var z = pi0.z;\n  var i;\n  switch (contours.type) {\n    case 'levels':\n      // Why (just) use z[0][0] and z[0][1]?\n      //\n      // N.B. using boundaryMin instead of edgeVal2 here makes the\n      //      `contour_scatter` mock fail\n      var edgeVal2 = Math.min(z[0][0], z[0][1]);\n      for (i = 0; i < pathinfo.length; i++) {\n        var pi = pathinfo[i];\n        pi.prefixBoundary = !pi.edgepaths.length && (edgeVal2 > pi.level || pi.starts.length && edgeVal2 === pi.level);\n      }\n      break;\n    case 'constraint':\n      // after convertToConstraints, pathinfo has length=0\n      pi0.prefixBoundary = false;\n\n      // joinAllPaths does enough already when edgepaths are present\n      if (pi0.edgepaths.length) return;\n      var na = pi0.x.length;\n      var nb = pi0.y.length;\n      var boundaryMax = -Infinity;\n      var boundaryMin = Infinity;\n      for (i = 0; i < nb; i++) {\n        boundaryMin = Math.min(boundaryMin, z[i][0]);\n        boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n        boundaryMax = Math.max(boundaryMax, z[i][0]);\n        boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n      }\n      for (i = 1; i < na - 1; i++) {\n        boundaryMin = Math.min(boundaryMin, z[0][i]);\n        boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n        boundaryMax = Math.max(boundaryMax, z[0][i]);\n        boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n      }\n      var contoursValue = contours.value;\n      var v1, v2;\n      switch (contours._operation) {\n        case '>':\n          if (contoursValue > boundaryMax) {\n            pi0.prefixBoundary = true;\n          }\n          break;\n        case '<':\n          if (contoursValue < boundaryMin || pi0.starts.length && contoursValue === boundaryMin) {\n            pi0.prefixBoundary = true;\n          }\n          break;\n        case '[]':\n          v1 = Math.min(contoursValue[0], contoursValue[1]);\n          v2 = Math.max(contoursValue[0], contoursValue[1]);\n          if (v2 < boundaryMin || v1 > boundaryMax || pi0.starts.length && v2 === boundaryMin) {\n            pi0.prefixBoundary = true;\n          }\n          break;\n        case '][':\n          v1 = Math.min(contoursValue[0], contoursValue[1]);\n          v2 = Math.max(contoursValue[0], contoursValue[1]);\n          if (v1 < boundaryMin && v2 > boundaryMax) {\n            pi0.prefixBoundary = true;\n          }\n          break;\n      }\n      break;\n  }\n};","map":{"version":3,"names":["module","exports","pathinfo","contours","pi0","z","i","type","edgeVal2","Math","min","length","pi","prefixBoundary","edgepaths","level","starts","na","x","nb","y","boundaryMax","Infinity","boundaryMin","max","contoursValue","value","v1","v2","_operation"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/contour/close_boundaries.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function(pathinfo, contours) {\n    var pi0 = pathinfo[0];\n    var z = pi0.z;\n    var i;\n\n    switch(contours.type) {\n        case 'levels':\n            // Why (just) use z[0][0] and z[0][1]?\n            //\n            // N.B. using boundaryMin instead of edgeVal2 here makes the\n            //      `contour_scatter` mock fail\n            var edgeVal2 = Math.min(z[0][0], z[0][1]);\n\n            for(i = 0; i < pathinfo.length; i++) {\n                var pi = pathinfo[i];\n                pi.prefixBoundary = !pi.edgepaths.length &&\n                    (edgeVal2 > pi.level || pi.starts.length && edgeVal2 === pi.level);\n            }\n            break;\n        case 'constraint':\n            // after convertToConstraints, pathinfo has length=0\n            pi0.prefixBoundary = false;\n\n            // joinAllPaths does enough already when edgepaths are present\n            if(pi0.edgepaths.length) return;\n\n            var na = pi0.x.length;\n            var nb = pi0.y.length;\n            var boundaryMax = -Infinity;\n            var boundaryMin = Infinity;\n\n            for(i = 0; i < nb; i++) {\n                boundaryMin = Math.min(boundaryMin, z[i][0]);\n                boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n                boundaryMax = Math.max(boundaryMax, z[i][0]);\n                boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n            }\n            for(i = 1; i < na - 1; i++) {\n                boundaryMin = Math.min(boundaryMin, z[0][i]);\n                boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n                boundaryMax = Math.max(boundaryMax, z[0][i]);\n                boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n            }\n\n            var contoursValue = contours.value;\n            var v1, v2;\n\n            switch(contours._operation) {\n                case '>':\n                    if(contoursValue > boundaryMax) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n                case '<':\n                    if(contoursValue < boundaryMin ||\n                        (pi0.starts.length && contoursValue === boundaryMin)) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n                case '[]':\n                    v1 = Math.min(contoursValue[0], contoursValue[1]);\n                    v2 = Math.max(contoursValue[0], contoursValue[1]);\n                    if(v2 < boundaryMin || v1 > boundaryMax ||\n                        (pi0.starts.length && v2 === boundaryMin)) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n                case '][':\n                    v1 = Math.min(contoursValue[0], contoursValue[1]);\n                    v2 = Math.max(contoursValue[0], contoursValue[1]);\n                    if(v1 < boundaryMin && v2 > boundaryMax) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n            }\n            break;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}