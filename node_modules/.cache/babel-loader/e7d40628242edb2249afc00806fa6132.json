{"ast":null,"code":"'use strict';\n\nconst rgba = require('color-normalize');\nconst getBounds = require('array-bounds');\nconst extend = require('object-assign');\nconst pick = require('pick-by-alias');\nconst flatten = require('flatten-vertex-data');\nconst triangulate = require('earcut');\nconst normalize = require('array-normalize');\nconst {\n  float32,\n  fract32\n} = require('to-float32');\nconst WeakMap = require('es6-weak-map');\nconst parseRect = require('parse-rect');\nconst findIndex = require('array-find-index');\nconst rectVert = \"\\nprecision highp float;\\n\\nattribute vec2 aCoord, bCoord, aCoordFract, bCoordFract;\\nattribute vec4 color;\\nattribute float lineEnd, lineTop;\\n\\nuniform vec2 scale, scaleFract, translate, translateFract;\\nuniform float thickness, pixelRatio, id, depth;\\nuniform vec4 viewport;\\n\\nvarying vec4 fragColor;\\nvarying vec2 tangent;\\n\\nvec2 project(vec2 position, vec2 positionFract, vec2 scale, vec2 scaleFract, vec2 translate, vec2 translateFract) {\\n\\t// the order is important\\n\\treturn position * scale + translate\\n       + positionFract * scale + translateFract\\n       + position * scaleFract\\n       + positionFract * scaleFract;\\n}\\n\\nvoid main() {\\n\\tfloat lineStart = 1. - lineEnd;\\n\\tfloat lineOffset = lineTop * 2. - 1.;\\n\\n\\tvec2 diff = (bCoord + bCoordFract - aCoord - aCoordFract);\\n\\ttangent = normalize(diff * scale * viewport.zw);\\n\\tvec2 normal = vec2(-tangent.y, tangent.x);\\n\\n\\tvec2 position = project(aCoord, aCoordFract, scale, scaleFract, translate, translateFract) * lineStart\\n\\t\\t+ project(bCoord, bCoordFract, scale, scaleFract, translate, translateFract) * lineEnd\\n\\n\\t\\t+ thickness * normal * .5 * lineOffset / viewport.zw;\\n\\n\\tgl_Position = vec4(position * 2.0 - 1.0, depth, 1);\\n\\n\\tfragColor = color / 255.;\\n}\\n\";\nconst rectFrag = \"\\nprecision highp float;\\n\\nuniform float dashLength, pixelRatio, thickness, opacity, id;\\nuniform sampler2D dashTexture;\\n\\nvarying vec4 fragColor;\\nvarying vec2 tangent;\\n\\nvoid main() {\\n\\tfloat alpha = 1.;\\n\\n\\tfloat t = fract(dot(tangent, gl_FragCoord.xy) / dashLength) * .5 + .25;\\n\\tfloat dash = texture2D(dashTexture, vec2(t, .5)).r;\\n\\n\\tgl_FragColor = fragColor;\\n\\tgl_FragColor.a *= alpha * opacity * dash;\\n}\\n\";\nconst fillVert = \"\\nprecision highp float;\\n\\nattribute vec2 position, positionFract;\\n\\nuniform vec4 color;\\nuniform vec2 scale, scaleFract, translate, translateFract;\\nuniform float pixelRatio, id;\\nuniform vec4 viewport;\\nuniform float opacity;\\n\\nvarying vec4 fragColor;\\n\\nconst float MAX_LINES = 256.;\\n\\nvoid main() {\\n\\tfloat depth = (MAX_LINES - 4. - id) / (MAX_LINES);\\n\\n\\tvec2 position = position * scale + translate\\n       + positionFract * scale + translateFract\\n       + position * scaleFract\\n       + positionFract * scaleFract;\\n\\n\\tgl_Position = vec4(position * 2.0 - 1.0, depth, 1);\\n\\n\\tfragColor = color / 255.;\\n\\tfragColor.a *= opacity;\\n}\\n\";\nconst fillFrag = \"\\nprecision highp float;\\nvarying vec4 fragColor;\\n\\nvoid main() {\\n\\tgl_FragColor = fragColor;\\n}\\n\";\nconst milterVert = \"\\nprecision highp float;\\n\\nattribute vec2 aCoord, bCoord, nextCoord, prevCoord;\\nattribute vec4 aColor, bColor;\\nattribute float lineEnd, lineTop;\\n\\nuniform vec2 scale, translate;\\nuniform float thickness, pixelRatio, id, depth;\\nuniform vec4 viewport;\\nuniform float miterLimit, miterMode;\\n\\nvarying vec4 fragColor;\\nvarying vec4 startCutoff, endCutoff;\\nvarying vec2 tangent;\\nvarying vec2 startCoord, endCoord;\\nvarying float enableStartMiter, enableEndMiter;\\n\\nconst float REVERSE_THRESHOLD = -.875;\\nconst float MIN_DIFF = 1e-6;\\n\\n// TODO: possible optimizations: avoid overcalculating all for vertices and calc just one instead\\n// TODO: precalculate dot products, normalize things beforehead etc.\\n// TODO: refactor to rectangular algorithm\\n\\nfloat distToLine(vec2 p, vec2 a, vec2 b) {\\n\\tvec2 diff = b - a;\\n\\tvec2 perp = normalize(vec2(-diff.y, diff.x));\\n\\treturn dot(p - a, perp);\\n}\\n\\nbool isNaN( float val ){\\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\\n}\\n\\nvoid main() {\\n\\tvec2 aCoord = aCoord, bCoord = bCoord, prevCoord = prevCoord, nextCoord = nextCoord;\\n\\n  vec2 adjustedScale;\\n  adjustedScale.x = (abs(scale.x) < MIN_DIFF) ? MIN_DIFF : scale.x;\\n  adjustedScale.y = (abs(scale.y) < MIN_DIFF) ? MIN_DIFF : scale.y;\\n\\n  vec2 scaleRatio = adjustedScale * viewport.zw;\\n\\tvec2 normalWidth = thickness / scaleRatio;\\n\\n\\tfloat lineStart = 1. - lineEnd;\\n\\tfloat lineBot = 1. - lineTop;\\n\\n\\tfragColor = (lineStart * aColor + lineEnd * bColor) / 255.;\\n\\n\\tif (isNaN(aCoord.x) || isNaN(aCoord.y) || isNaN(bCoord.x) || isNaN(bCoord.y)) return;\\n\\n\\tif (aCoord == prevCoord) prevCoord = aCoord + normalize(bCoord - aCoord);\\n\\tif (bCoord == nextCoord) nextCoord = bCoord - normalize(bCoord - aCoord);\\n\\n\\n\\tvec2 prevDiff = aCoord - prevCoord;\\n\\tvec2 currDiff = bCoord - aCoord;\\n\\tvec2 nextDiff = nextCoord - bCoord;\\n\\n\\tvec2 prevTangent = normalize(prevDiff * scaleRatio);\\n\\tvec2 currTangent = normalize(currDiff * scaleRatio);\\n\\tvec2 nextTangent = normalize(nextDiff * scaleRatio);\\n\\n\\tvec2 prevNormal = vec2(-prevTangent.y, prevTangent.x);\\n\\tvec2 currNormal = vec2(-currTangent.y, currTangent.x);\\n\\tvec2 nextNormal = vec2(-nextTangent.y, nextTangent.x);\\n\\n\\tvec2 startJoinDirection = normalize(prevTangent - currTangent);\\n\\tvec2 endJoinDirection = normalize(currTangent - nextTangent);\\n\\n\\t// collapsed/unidirectional segment cases\\n\\t// FIXME: there should be more elegant solution\\n\\tvec2 prevTanDiff = abs(prevTangent - currTangent);\\n\\tvec2 nextTanDiff = abs(nextTangent - currTangent);\\n\\tif (max(prevTanDiff.x, prevTanDiff.y) < MIN_DIFF) {\\n\\t\\tstartJoinDirection = currNormal;\\n\\t}\\n\\tif (max(nextTanDiff.x, nextTanDiff.y) < MIN_DIFF) {\\n\\t\\tendJoinDirection = currNormal;\\n\\t}\\n\\tif (aCoord == bCoord) {\\n\\t\\tendJoinDirection = startJoinDirection;\\n\\t\\tcurrNormal = prevNormal;\\n\\t\\tcurrTangent = prevTangent;\\n\\t}\\n\\n\\ttangent = currTangent;\\n\\n\\t//calculate join shifts relative to normals\\n\\tfloat startJoinShift = dot(currNormal, startJoinDirection);\\n\\tfloat endJoinShift = dot(currNormal, endJoinDirection);\\n\\n\\tfloat startMiterRatio = abs(1. / startJoinShift);\\n\\tfloat endMiterRatio = abs(1. / endJoinShift);\\n\\n\\tvec2 startJoin = startJoinDirection * startMiterRatio;\\n\\tvec2 endJoin = endJoinDirection * endMiterRatio;\\n\\n\\tvec2 startTopJoin, startBotJoin, endTopJoin, endBotJoin;\\n\\tstartTopJoin = sign(startJoinShift) * startJoin * .5;\\n\\tstartBotJoin = -startTopJoin;\\n\\n\\tendTopJoin = sign(endJoinShift) * endJoin * .5;\\n\\tendBotJoin = -endTopJoin;\\n\\n\\tvec2 aTopCoord = aCoord + normalWidth * startTopJoin;\\n\\tvec2 bTopCoord = bCoord + normalWidth * endTopJoin;\\n\\tvec2 aBotCoord = aCoord + normalWidth * startBotJoin;\\n\\tvec2 bBotCoord = bCoord + normalWidth * endBotJoin;\\n\\n\\t//miter anti-clipping\\n\\tfloat baClipping = distToLine(bCoord, aCoord, aBotCoord) / dot(normalize(normalWidth * endBotJoin), normalize(normalWidth.yx * vec2(-startBotJoin.y, startBotJoin.x)));\\n\\tfloat abClipping = distToLine(aCoord, bCoord, bTopCoord) / dot(normalize(normalWidth * startBotJoin), normalize(normalWidth.yx * vec2(-endBotJoin.y, endBotJoin.x)));\\n\\n\\t//prevent close to reverse direction switch\\n\\tbool prevReverse = dot(currTangent, prevTangent) <= REVERSE_THRESHOLD && abs(dot(currTangent, prevNormal)) * min(length(prevDiff), length(currDiff)) <  length(normalWidth * currNormal);\\n\\tbool nextReverse = dot(currTangent, nextTangent) <= REVERSE_THRESHOLD && abs(dot(currTangent, nextNormal)) * min(length(nextDiff), length(currDiff)) <  length(normalWidth * currNormal);\\n\\n\\tif (prevReverse) {\\n\\t\\t//make join rectangular\\n\\t\\tvec2 miterShift = normalWidth * startJoinDirection * miterLimit * .5;\\n\\t\\tfloat normalAdjust = 1. - min(miterLimit / startMiterRatio, 1.);\\n\\t\\taBotCoord = aCoord + miterShift - normalAdjust * normalWidth * currNormal * .5;\\n\\t\\taTopCoord = aCoord + miterShift + normalAdjust * normalWidth * currNormal * .5;\\n\\t}\\n\\telse if (!nextReverse && baClipping > 0. && baClipping < length(normalWidth * endBotJoin)) {\\n\\t\\t//handle miter clipping\\n\\t\\tbTopCoord -= normalWidth * endTopJoin;\\n\\t\\tbTopCoord += normalize(endTopJoin * normalWidth) * baClipping;\\n\\t}\\n\\n\\tif (nextReverse) {\\n\\t\\t//make join rectangular\\n\\t\\tvec2 miterShift = normalWidth * endJoinDirection * miterLimit * .5;\\n\\t\\tfloat normalAdjust = 1. - min(miterLimit / endMiterRatio, 1.);\\n\\t\\tbBotCoord = bCoord + miterShift - normalAdjust * normalWidth * currNormal * .5;\\n\\t\\tbTopCoord = bCoord + miterShift + normalAdjust * normalWidth * currNormal * .5;\\n\\t}\\n\\telse if (!prevReverse && abClipping > 0. && abClipping < length(normalWidth * startBotJoin)) {\\n\\t\\t//handle miter clipping\\n\\t\\taBotCoord -= normalWidth * startBotJoin;\\n\\t\\taBotCoord += normalize(startBotJoin * normalWidth) * abClipping;\\n\\t}\\n\\n\\tvec2 aTopPosition = (aTopCoord) * adjustedScale + translate;\\n\\tvec2 aBotPosition = (aBotCoord) * adjustedScale + translate;\\n\\n\\tvec2 bTopPosition = (bTopCoord) * adjustedScale + translate;\\n\\tvec2 bBotPosition = (bBotCoord) * adjustedScale + translate;\\n\\n\\t//position is normalized 0..1 coord on the screen\\n\\tvec2 position = (aTopPosition * lineTop + aBotPosition * lineBot) * lineStart + (bTopPosition * lineTop + bBotPosition * lineBot) * lineEnd;\\n\\n\\tstartCoord = aCoord * scaleRatio + translate * viewport.zw + viewport.xy;\\n\\tendCoord = bCoord * scaleRatio + translate * viewport.zw + viewport.xy;\\n\\n\\tgl_Position = vec4(position  * 2.0 - 1.0, depth, 1);\\n\\n\\tenableStartMiter = step(dot(currTangent, prevTangent), .5);\\n\\tenableEndMiter = step(dot(currTangent, nextTangent), .5);\\n\\n\\t//bevel miter cutoffs\\n\\tif (miterMode == 1.) {\\n\\t\\tif (enableStartMiter == 1.) {\\n\\t\\t\\tvec2 startMiterWidth = vec2(startJoinDirection) * thickness * miterLimit * .5;\\n\\t\\t\\tstartCutoff = vec4(aCoord, aCoord);\\n\\t\\t\\tstartCutoff.zw += vec2(-startJoinDirection.y, startJoinDirection.x) / scaleRatio;\\n\\t\\t\\tstartCutoff = startCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\\n\\t\\t\\tstartCutoff += viewport.xyxy;\\n\\t\\t\\tstartCutoff += startMiterWidth.xyxy;\\n\\t\\t}\\n\\n\\t\\tif (enableEndMiter == 1.) {\\n\\t\\t\\tvec2 endMiterWidth = vec2(endJoinDirection) * thickness * miterLimit * .5;\\n\\t\\t\\tendCutoff = vec4(bCoord, bCoord);\\n\\t\\t\\tendCutoff.zw += vec2(-endJoinDirection.y, endJoinDirection.x)  / scaleRatio;\\n\\t\\t\\tendCutoff = endCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\\n\\t\\t\\tendCutoff += viewport.xyxy;\\n\\t\\t\\tendCutoff += endMiterWidth.xyxy;\\n\\t\\t}\\n\\t}\\n\\n\\t//round miter cutoffs\\n\\telse if (miterMode == 2.) {\\n\\t\\tif (enableStartMiter == 1.) {\\n\\t\\t\\tvec2 startMiterWidth = vec2(startJoinDirection) * thickness * abs(dot(startJoinDirection, currNormal)) * .5;\\n\\t\\t\\tstartCutoff = vec4(aCoord, aCoord);\\n\\t\\t\\tstartCutoff.zw += vec2(-startJoinDirection.y, startJoinDirection.x) / scaleRatio;\\n\\t\\t\\tstartCutoff = startCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\\n\\t\\t\\tstartCutoff += viewport.xyxy;\\n\\t\\t\\tstartCutoff += startMiterWidth.xyxy;\\n\\t\\t}\\n\\n\\t\\tif (enableEndMiter == 1.) {\\n\\t\\t\\tvec2 endMiterWidth = vec2(endJoinDirection) * thickness * abs(dot(endJoinDirection, currNormal)) * .5;\\n\\t\\t\\tendCutoff = vec4(bCoord, bCoord);\\n\\t\\t\\tendCutoff.zw += vec2(-endJoinDirection.y, endJoinDirection.x)  / scaleRatio;\\n\\t\\t\\tendCutoff = endCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\\n\\t\\t\\tendCutoff += viewport.xyxy;\\n\\t\\t\\tendCutoff += endMiterWidth.xyxy;\\n\\t\\t}\\n\\t}\\n}\\n\";\nconst milterFrag = \"\\nprecision highp float;\\n\\nuniform float dashLength, pixelRatio, thickness, opacity, id, miterMode;\\nuniform sampler2D dashTexture;\\n\\nvarying vec4 fragColor;\\nvarying vec2 tangent;\\nvarying vec4 startCutoff, endCutoff;\\nvarying vec2 startCoord, endCoord;\\nvarying float enableStartMiter, enableEndMiter;\\n\\nfloat distToLine(vec2 p, vec2 a, vec2 b) {\\n\\tvec2 diff = b - a;\\n\\tvec2 perp = normalize(vec2(-diff.y, diff.x));\\n\\treturn dot(p - a, perp);\\n}\\n\\nvoid main() {\\n\\tfloat alpha = 1., distToStart, distToEnd;\\n\\tfloat cutoff = thickness * .5;\\n\\n\\t//bevel miter\\n\\tif (miterMode == 1.) {\\n\\t\\tif (enableStartMiter == 1.) {\\n\\t\\t\\tdistToStart = distToLine(gl_FragCoord.xy, startCutoff.xy, startCutoff.zw);\\n\\t\\t\\tif (distToStart < -1.) {\\n\\t\\t\\t\\tdiscard;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\talpha *= min(max(distToStart + 1., 0.), 1.);\\n\\t\\t}\\n\\n\\t\\tif (enableEndMiter == 1.) {\\n\\t\\t\\tdistToEnd = distToLine(gl_FragCoord.xy, endCutoff.xy, endCutoff.zw);\\n\\t\\t\\tif (distToEnd < -1.) {\\n\\t\\t\\t\\tdiscard;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\talpha *= min(max(distToEnd + 1., 0.), 1.);\\n\\t\\t}\\n\\t}\\n\\n\\t// round miter\\n\\telse if (miterMode == 2.) {\\n\\t\\tif (enableStartMiter == 1.) {\\n\\t\\t\\tdistToStart = distToLine(gl_FragCoord.xy, startCutoff.xy, startCutoff.zw);\\n\\t\\t\\tif (distToStart < 0.) {\\n\\t\\t\\t\\tfloat radius = length(gl_FragCoord.xy - startCoord);\\n\\n\\t\\t\\t\\tif(radius > cutoff + .5) {\\n\\t\\t\\t\\t\\tdiscard;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\talpha -= smoothstep(cutoff - .5, cutoff + .5, radius);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (enableEndMiter == 1.) {\\n\\t\\t\\tdistToEnd = distToLine(gl_FragCoord.xy, endCutoff.xy, endCutoff.zw);\\n\\t\\t\\tif (distToEnd < 0.) {\\n\\t\\t\\t\\tfloat radius = length(gl_FragCoord.xy - endCoord);\\n\\n\\t\\t\\t\\tif(radius > cutoff + .5) {\\n\\t\\t\\t\\t\\tdiscard;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\talpha -= smoothstep(cutoff - .5, cutoff + .5, radius);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfloat t = fract(dot(tangent, gl_FragCoord.xy) / dashLength) * .5 + .25;\\n\\tfloat dash = texture2D(dashTexture, vec2(t, .5)).r;\\n\\n\\tgl_FragColor = fragColor;\\n\\tgl_FragColor.a *= alpha * opacity * dash;\\n}\\n\";\nmodule.exports = Line2D;\n\n/** @constructor */\nfunction Line2D(regl, options) {\n  if (!(this instanceof Line2D)) return new Line2D(regl, options);\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n  }\n  if (options.length) options.positions = options;\n  regl = options.regl;\n  if (!regl.hasExtension('ANGLE_instanced_arrays')) {\n    throw Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n  }\n\n  // persistent variables\n  this.gl = regl._gl;\n  this.regl = regl;\n\n  // list of options for lines\n  this.passes = [];\n\n  // cached shaders instance\n  this.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl);\n\n  // init defaults\n  this.update(options);\n}\nLine2D.dashMult = 2;\nLine2D.maxPatternLength = 256;\nLine2D.precisionThreshold = 3e6;\nLine2D.maxPoints = 1e4;\nLine2D.maxLines = 2048;\n\n// cache of created draw calls per-regl instance\nLine2D.shaders = new WeakMap();\n\n// create static shaders once\nLine2D.createShaders = function (regl) {\n  let offsetBuffer = regl.buffer({\n    usage: 'static',\n    type: 'float',\n    data: [0, 1, 0, 0, 1, 1, 1, 0]\n  });\n  let shaderOptions = {\n    primitive: 'triangle strip',\n    instances: regl.prop('count'),\n    count: 4,\n    offset: 0,\n    uniforms: {\n      miterMode: (ctx, prop) => prop.join === 'round' ? 2 : 1,\n      miterLimit: regl.prop('miterLimit'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      thickness: regl.prop('thickness'),\n      dashTexture: regl.prop('dashTexture'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      dashLength: regl.prop('dashLength'),\n      viewport: (c, p) => [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight],\n      depth: regl.prop('depth')\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 0],\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    depth: {\n      enable: (c, p) => {\n        return !p.overlay;\n      }\n    },\n    stencil: {\n      enable: false\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport')\n  };\n\n  // simplified rectangular line shader\n  let drawRectLine = regl(extend({\n    vert: rectVert,\n    frag: rectFrag,\n    attributes: {\n      // if point is at the end of segment\n      lineEnd: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 0\n      },\n      // if point is at the top of segment\n      lineTop: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 4\n      },\n      // beginning of line coordinate\n      aCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      // end of line coordinate\n      bCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      aCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      bCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      color: {\n        buffer: regl.prop('colorBuffer'),\n        stride: 4,\n        offset: 0,\n        divisor: 1\n      }\n    }\n  }, shaderOptions));\n\n  // create regl draw\n  let drawMiterLine;\n  try {\n    drawMiterLine = regl(extend({\n      // culling removes polygon creasing\n      cull: {\n        enable: true,\n        face: 'back'\n      },\n      vert: milterVert,\n      frag: milterFrag,\n      attributes: {\n        // is line end\n        lineEnd: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 0\n        },\n        // is line top\n        lineTop: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 4\n        },\n        // left color\n        aColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 0,\n          divisor: 1\n        },\n        // right color\n        bColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 4,\n          divisor: 1\n        },\n        prevCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 0,\n          divisor: 1\n        },\n        aCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 8,\n          divisor: 1\n        },\n        bCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 16,\n          divisor: 1\n        },\n        nextCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 24,\n          divisor: 1\n        }\n      }\n    }, shaderOptions));\n  } catch (e) {\n    // IE/bad Webkit fallback\n    drawMiterLine = drawRectLine;\n  }\n\n  // fill shader\n  let drawFill = regl({\n    primitive: 'triangle',\n    elements: (ctx, prop) => prop.triangles,\n    offset: 0,\n    vert: fillVert,\n    frag: fillFrag,\n    uniforms: {\n      scale: regl.prop('scale'),\n      color: regl.prop('fill'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      viewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\n    },\n    attributes: {\n      position: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8\n      },\n      positionFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8\n      }\n    },\n    blend: shaderOptions.blend,\n    depth: {\n      enable: false\n    },\n    scissor: shaderOptions.scissor,\n    stencil: shaderOptions.stencil,\n    viewport: shaderOptions.viewport\n  });\n  return {\n    fill: drawFill,\n    rect: drawRectLine,\n    miter: drawMiterLine\n  };\n};\n\n// used to for new lines instances\nLine2D.defaults = {\n  dashes: null,\n  join: 'miter',\n  miterLimit: 1,\n  thickness: 10,\n  cap: 'square',\n  color: 'black',\n  opacity: 1,\n  overlay: false,\n  viewport: null,\n  range: null,\n  close: false,\n  fill: null\n};\nLine2D.prototype.render = function () {\n  if (arguments.length) {\n    this.update(...arguments);\n  }\n  this.draw();\n};\nLine2D.prototype.draw = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  // render multiple polylines via regl batch\n  (args.length ? args : this.passes).forEach((s, i) => {\n    // render array pass as a list of passes\n    if (s && Array.isArray(s)) return this.draw(...s);\n    if (typeof s === 'number') s = this.passes[s];\n    if (!(s && s.count > 1 && s.opacity)) return;\n    this.regl._refresh();\n    if (s.fill && s.triangles && s.triangles.length > 2) {\n      this.shaders.fill(s);\n    }\n    if (!s.thickness) return;\n\n    // high scale is only available for rect mode with precision\n    if (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {\n      this.shaders.rect(s);\n    }\n\n    // thin this.passes or too many points are rendered as simplified rect shader\n    else if (s.join === 'rect' || !s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints)) {\n      this.shaders.rect(s);\n    } else {\n      this.shaders.miter(s);\n    }\n  });\n  return this;\n};\nLine2D.prototype.update = function (options) {\n  if (!options) return;\n  if (options.length != null) {\n    if (typeof options[0] === 'number') options = [{\n      positions: options\n    }];\n  }\n\n  // make options a batch\n  else if (!Array.isArray(options)) options = [options];\n  let {\n    regl,\n    gl\n  } = this;\n\n  // process per-line settings\n  options.forEach((o, i) => {\n    let state = this.passes[i];\n    if (o === undefined) return;\n\n    // null-argument removes pass\n    if (o === null) {\n      this.passes[i] = null;\n      return;\n    }\n    if (typeof o[0] === 'number') o = {\n      positions: o\n    };\n\n    // handle aliases\n    o = pick(o, {\n      positions: 'positions points data coords',\n      thickness: 'thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth',\n      join: 'lineJoin linejoin join type mode',\n      miterLimit: 'miterlimit miterLimit',\n      dashes: 'dash dashes dasharray dash-array dashArray',\n      color: 'color colour stroke colors colours stroke-color strokeColor',\n      fill: 'fill fill-color fillColor',\n      opacity: 'alpha opacity',\n      overlay: 'overlay crease overlap intersect',\n      close: 'closed close closed-path closePath',\n      range: 'range dataBox',\n      viewport: 'viewport viewBox',\n      hole: 'holes hole hollow',\n      splitNull: 'splitNull'\n    });\n\n    // init state\n    if (!state) {\n      this.passes[i] = state = {\n        id: i,\n        scale: null,\n        scaleFract: null,\n        translate: null,\n        translateFract: null,\n        count: 0,\n        hole: [],\n        depth: 0,\n        dashLength: 1,\n        dashTexture: regl.texture({\n          channels: 1,\n          data: new Uint8Array([255]),\n          width: 1,\n          height: 1,\n          mag: 'linear',\n          min: 'linear'\n        }),\n        colorBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'uint8',\n          data: new Uint8Array()\n        }),\n        positionBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        }),\n        positionFractBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        })\n      };\n      o = extend({}, Line2D.defaults, o);\n    }\n    if (o.thickness != null) state.thickness = parseFloat(o.thickness);\n    if (o.opacity != null) state.opacity = parseFloat(o.opacity);\n    if (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit);\n    if (o.overlay != null) {\n      state.overlay = !!o.overlay;\n      if (i < Line2D.maxLines) {\n        state.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1.;\n      }\n    }\n    if (o.join != null) state.join = o.join;\n    if (o.hole != null) state.hole = o.hole;\n    if (o.fill != null) state.fill = !o.fill ? null : rgba(o.fill, 'uint8');\n    if (o.viewport != null) state.viewport = parseRect(o.viewport);\n    if (!state.viewport) {\n      state.viewport = parseRect([gl.drawingBufferWidth, gl.drawingBufferHeight]);\n    }\n    if (o.close != null) state.close = o.close;\n\n    // reset positions\n    if (o.positions === null) o.positions = [];\n    if (o.positions) {\n      let positions, count;\n\n      // if positions are an object with x/y\n      if (o.positions.x && o.positions.y) {\n        let xPos = o.positions.x;\n        let yPos = o.positions.y;\n        count = state.count = Math.max(xPos.length, yPos.length);\n        positions = new Float64Array(count * 2);\n        for (let i = 0; i < count; i++) {\n          positions[i * 2] = xPos[i];\n          positions[i * 2 + 1] = yPos[i];\n        }\n      } else {\n        positions = flatten(o.positions, 'float64');\n        count = state.count = Math.floor(positions.length / 2);\n      }\n      let bounds = state.bounds = getBounds(positions, 2);\n\n      // create fill positions\n      // FIXME: fill positions can be set only along with positions\n      if (state.fill) {\n        let pos = [];\n\n        // filter bad vertices and remap triangles to ensure shape\n        let ids = {};\n        let lastId = 0;\n        for (let i = 0, ptr = 0, l = state.count; i < l; i++) {\n          let x = positions[i * 2];\n          let y = positions[i * 2 + 1];\n          if (isNaN(x) || isNaN(y) || x == null || y == null) {\n            x = positions[lastId * 2];\n            y = positions[lastId * 2 + 1];\n            ids[i] = lastId;\n          } else {\n            lastId = i;\n          }\n          pos[ptr++] = x;\n          pos[ptr++] = y;\n        }\n\n        // split the input into multiple polygon at Null/NaN\n        if (o.splitNull) {\n          // use \"ids\" to track the boundary of segment\n          // the keys in \"ids\" is the end boundary of a segment, or split point\n\n          // make sure there is at least one segment\n          if (!(state.count - 1 in ids)) ids[state.count] = state.count - 1;\n          let splits = Object.keys(ids).map(Number).sort((a, b) => a - b);\n          let split_triangles = [];\n          let base = 0;\n\n          // do not split holes\n          let hole_base = state.hole != null ? state.hole[0] : null;\n          if (hole_base != null) {\n            let last_id = findIndex(splits, e => e >= hole_base);\n            splits = splits.slice(0, last_id);\n            splits.push(hole_base);\n          }\n          for (let i = 0; i < splits.length; i++) {\n            // create temporary pos array with only one segment and all the holes\n            let seg_pos = pos.slice(base * 2, splits[i] * 2).concat(hole_base ? pos.slice(hole_base * 2) : []);\n            let hole = (state.hole || []).map(e => e - hole_base + (splits[i] - base));\n            let triangles = triangulate(seg_pos, hole);\n            // map triangle index back to the original pos buffer\n            triangles = triangles.map(e => e + base + (e + base < splits[i] ? 0 : hole_base - splits[i]));\n            split_triangles.push(...triangles);\n\n            // skip split point\n            base = splits[i] + 1;\n          }\n          for (let i = 0, l = split_triangles.length; i < l; i++) {\n            if (ids[split_triangles[i]] != null) split_triangles[i] = ids[split_triangles[i]];\n          }\n          state.triangles = split_triangles;\n        } else {\n          // treat the wholw input as a single polygon\n          let triangles = triangulate(pos, state.hole || []);\n          for (let i = 0, l = triangles.length; i < l; i++) {\n            if (ids[triangles[i]] != null) triangles[i] = ids[triangles[i]];\n          }\n          state.triangles = triangles;\n        }\n      }\n\n      // update position buffers\n      let npos = new Float64Array(positions);\n      normalize(npos, 2, bounds);\n      let positionData = new Float64Array(count * 2 + 6);\n\n      // rotate first segment join\n      if (state.close) {\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[0] = npos[count * 2 - 4];\n          positionData[1] = npos[count * 2 - 3];\n        } else {\n          positionData[0] = npos[count * 2 - 2];\n          positionData[1] = npos[count * 2 - 1];\n        }\n      } else {\n        positionData[0] = npos[0];\n        positionData[1] = npos[1];\n      }\n      positionData.set(npos, 2);\n\n      // add last segment\n      if (state.close) {\n        // ignore coinciding start/end\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[count * 2 + 2] = npos[2];\n          positionData[count * 2 + 3] = npos[3];\n          state.count -= 1;\n        } else {\n          positionData[count * 2 + 2] = npos[0];\n          positionData[count * 2 + 3] = npos[1];\n          positionData[count * 2 + 4] = npos[2];\n          positionData[count * 2 + 5] = npos[3];\n        }\n      }\n      // add stub\n      else {\n        positionData[count * 2 + 2] = npos[count * 2 - 2];\n        positionData[count * 2 + 3] = npos[count * 2 - 1];\n        positionData[count * 2 + 4] = npos[count * 2 - 2];\n        positionData[count * 2 + 5] = npos[count * 2 - 1];\n      }\n      var float_data = float32(positionData);\n      state.positionBuffer(float_data);\n      var frac_data = fract32(positionData, float_data);\n      state.positionFractBuffer(frac_data);\n    }\n    if (o.range) {\n      state.range = o.range;\n    } else if (!state.range) {\n      state.range = state.bounds;\n    }\n    if ((o.range || o.positions) && state.count) {\n      let bounds = state.bounds;\n      let boundsW = bounds[2] - bounds[0],\n        boundsH = bounds[3] - bounds[1];\n      let rangeW = state.range[2] - state.range[0],\n        rangeH = state.range[3] - state.range[1];\n      state.scale = [boundsW / rangeW, boundsH / rangeH];\n      state.translate = [-state.range[0] / rangeW + bounds[0] / rangeW || 0, -state.range[1] / rangeH + bounds[1] / rangeH || 0];\n      state.scaleFract = fract32(state.scale);\n      state.translateFract = fract32(state.translate);\n    }\n    if (o.dashes) {\n      let dashLength = 0.,\n        dashData;\n      if (!o.dashes || o.dashes.length < 2) {\n        dashLength = 1.;\n        dashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);\n      } else {\n        dashLength = 0.;\n        for (let i = 0; i < o.dashes.length; ++i) {\n          dashLength += o.dashes[i];\n        }\n        dashData = new Uint8Array(dashLength * Line2D.dashMult);\n        let ptr = 0;\n        let fillColor = 255;\n\n        // repeat texture two times to provide smooth 0-step\n        for (let k = 0; k < 2; k++) {\n          for (let i = 0; i < o.dashes.length; ++i) {\n            for (let j = 0, l = o.dashes[i] * Line2D.dashMult * .5; j < l; ++j) {\n              dashData[ptr++] = fillColor;\n            }\n            fillColor ^= 255;\n          }\n        }\n      }\n      state.dashLength = dashLength;\n      state.dashTexture({\n        channels: 1,\n        data: dashData,\n        width: dashData.length,\n        height: 1,\n        mag: 'linear',\n        min: 'linear'\n      }, 0, 0);\n    }\n    if (o.color) {\n      let count = state.count;\n      let colors = o.color;\n      if (!colors) colors = 'transparent';\n      let colorData = new Uint8Array(count * 4 + 4);\n\n      // convert colors to typed arrays\n      if (!Array.isArray(colors) || typeof colors[0] === 'number') {\n        let c = rgba(colors, 'uint8');\n        for (let i = 0; i < count + 1; i++) {\n          colorData.set(c, i * 4);\n        }\n      } else {\n        for (let i = 0; i < count; i++) {\n          let c = rgba(colors[i], 'uint8');\n          colorData.set(c, i * 4);\n        }\n        colorData.set(rgba(colors[0], 'uint8'), count * 4);\n      }\n      state.colorBuffer({\n        usage: 'dynamic',\n        type: 'uint8',\n        data: colorData\n      });\n    }\n  });\n\n  // remove unmentioned passes\n  if (options.length < this.passes.length) {\n    for (let i = options.length; i < this.passes.length; i++) {\n      let pass = this.passes[i];\n      if (!pass) continue;\n      pass.colorBuffer.destroy();\n      pass.positionBuffer.destroy();\n      pass.dashTexture.destroy();\n    }\n    this.passes.length = options.length;\n  }\n\n  // remove null items\n  let passes = [];\n  for (let i = 0; i < this.passes.length; i++) {\n    if (this.passes[i] !== null) passes.push(this.passes[i]);\n  }\n  this.passes = passes;\n  return this;\n};\nLine2D.prototype.destroy = function () {\n  this.passes.forEach(pass => {\n    pass.colorBuffer.destroy();\n    pass.positionBuffer.destroy();\n    pass.dashTexture.destroy();\n  });\n  this.passes.length = 0;\n  return this;\n};","map":{"version":3,"names":["rgba","require","getBounds","extend","pick","flatten","triangulate","normalize","float32","fract32","WeakMap","parseRect","findIndex","rectVert","rectFrag","fillVert","fillFrag","milterVert","milterFrag","module","exports","Line2D","regl","options","length","positions","hasExtension","Error","gl","_gl","passes","shaders","has","get","set","createShaders","update","dashMult","maxPatternLength","precisionThreshold","maxPoints","maxLines","offsetBuffer","buffer","usage","type","data","shaderOptions","primitive","instances","prop","count","offset","uniforms","miterMode","ctx","join","miterLimit","scale","scaleFract","translateFract","translate","thickness","dashTexture","opacity","pixelRatio","context","id","dashLength","viewport","c","p","x","y","viewportWidth","viewportHeight","depth","blend","enable","color","equation","rgb","alpha","func","srcRGB","dstRGB","srcAlpha","dstAlpha","overlay","stencil","scissor","box","drawRectLine","vert","frag","attributes","lineEnd","divisor","stride","lineTop","aCoord","bCoord","aCoordFract","bCoordFract","drawMiterLine","cull","face","aColor","bColor","prevCoord","nextCoord","e","drawFill","elements","triangles","position","positionFract","fill","rect","miter","defaults","dashes","cap","range","close","prototype","render","arguments","draw","_len","args","Array","_key","forEach","s","i","isArray","_refresh","width","height","o","state","undefined","hole","splitNull","texture","channels","Uint8Array","mag","min","colorBuffer","positionBuffer","positionFractBuffer","parseFloat","drawingBufferWidth","drawingBufferHeight","xPos","yPos","Math","max","Float64Array","floor","bounds","pos","ids","lastId","ptr","l","isNaN","splits","Object","keys","map","Number","sort","a","b","split_triangles","base","hole_base","last_id","slice","push","seg_pos","concat","npos","positionData","float_data","frac_data","boundsW","boundsH","rangeW","rangeH","dashData","fillColor","k","j","colors","colorData","pass","destroy"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/regl-line2d/index.js"],"sourcesContent":["'use strict'\n\n\nconst rgba = require('color-normalize')\nconst getBounds = require('array-bounds')\nconst extend = require('object-assign')\nconst pick = require('pick-by-alias')\nconst flatten = require('flatten-vertex-data')\nconst triangulate = require('earcut')\nconst normalize = require('array-normalize')\nconst { float32, fract32 } = require('to-float32')\nconst WeakMap = require('es6-weak-map')\nconst parseRect = require('parse-rect')\nconst findIndex = require('array-find-index')\n\nconst rectVert = `\nprecision highp float;\n\nattribute vec2 aCoord, bCoord, aCoordFract, bCoordFract;\nattribute vec4 color;\nattribute float lineEnd, lineTop;\n\nuniform vec2 scale, scaleFract, translate, translateFract;\nuniform float thickness, pixelRatio, id, depth;\nuniform vec4 viewport;\n\nvarying vec4 fragColor;\nvarying vec2 tangent;\n\nvec2 project(vec2 position, vec2 positionFract, vec2 scale, vec2 scaleFract, vec2 translate, vec2 translateFract) {\n\t// the order is important\n\treturn position * scale + translate\n       + positionFract * scale + translateFract\n       + position * scaleFract\n       + positionFract * scaleFract;\n}\n\nvoid main() {\n\tfloat lineStart = 1. - lineEnd;\n\tfloat lineOffset = lineTop * 2. - 1.;\n\n\tvec2 diff = (bCoord + bCoordFract - aCoord - aCoordFract);\n\ttangent = normalize(diff * scale * viewport.zw);\n\tvec2 normal = vec2(-tangent.y, tangent.x);\n\n\tvec2 position = project(aCoord, aCoordFract, scale, scaleFract, translate, translateFract) * lineStart\n\t\t+ project(bCoord, bCoordFract, scale, scaleFract, translate, translateFract) * lineEnd\n\n\t\t+ thickness * normal * .5 * lineOffset / viewport.zw;\n\n\tgl_Position = vec4(position * 2.0 - 1.0, depth, 1);\n\n\tfragColor = color / 255.;\n}\n`\n\nconst rectFrag =`\nprecision highp float;\n\nuniform float dashLength, pixelRatio, thickness, opacity, id;\nuniform sampler2D dashTexture;\n\nvarying vec4 fragColor;\nvarying vec2 tangent;\n\nvoid main() {\n\tfloat alpha = 1.;\n\n\tfloat t = fract(dot(tangent, gl_FragCoord.xy) / dashLength) * .5 + .25;\n\tfloat dash = texture2D(dashTexture, vec2(t, .5)).r;\n\n\tgl_FragColor = fragColor;\n\tgl_FragColor.a *= alpha * opacity * dash;\n}\n`\n\nconst fillVert = `\nprecision highp float;\n\nattribute vec2 position, positionFract;\n\nuniform vec4 color;\nuniform vec2 scale, scaleFract, translate, translateFract;\nuniform float pixelRatio, id;\nuniform vec4 viewport;\nuniform float opacity;\n\nvarying vec4 fragColor;\n\nconst float MAX_LINES = 256.;\n\nvoid main() {\n\tfloat depth = (MAX_LINES - 4. - id) / (MAX_LINES);\n\n\tvec2 position = position * scale + translate\n       + positionFract * scale + translateFract\n       + position * scaleFract\n       + positionFract * scaleFract;\n\n\tgl_Position = vec4(position * 2.0 - 1.0, depth, 1);\n\n\tfragColor = color / 255.;\n\tfragColor.a *= opacity;\n}\n`\n\nconst fillFrag = `\nprecision highp float;\nvarying vec4 fragColor;\n\nvoid main() {\n\tgl_FragColor = fragColor;\n}\n`\n\nconst milterVert = `\nprecision highp float;\n\nattribute vec2 aCoord, bCoord, nextCoord, prevCoord;\nattribute vec4 aColor, bColor;\nattribute float lineEnd, lineTop;\n\nuniform vec2 scale, translate;\nuniform float thickness, pixelRatio, id, depth;\nuniform vec4 viewport;\nuniform float miterLimit, miterMode;\n\nvarying vec4 fragColor;\nvarying vec4 startCutoff, endCutoff;\nvarying vec2 tangent;\nvarying vec2 startCoord, endCoord;\nvarying float enableStartMiter, enableEndMiter;\n\nconst float REVERSE_THRESHOLD = -.875;\nconst float MIN_DIFF = 1e-6;\n\n// TODO: possible optimizations: avoid overcalculating all for vertices and calc just one instead\n// TODO: precalculate dot products, normalize things beforehead etc.\n// TODO: refactor to rectangular algorithm\n\nfloat distToLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 diff = b - a;\n\tvec2 perp = normalize(vec2(-diff.y, diff.x));\n\treturn dot(p - a, perp);\n}\n\nbool isNaN( float val ){\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nvoid main() {\n\tvec2 aCoord = aCoord, bCoord = bCoord, prevCoord = prevCoord, nextCoord = nextCoord;\n\n  vec2 adjustedScale;\n  adjustedScale.x = (abs(scale.x) < MIN_DIFF) ? MIN_DIFF : scale.x;\n  adjustedScale.y = (abs(scale.y) < MIN_DIFF) ? MIN_DIFF : scale.y;\n\n  vec2 scaleRatio = adjustedScale * viewport.zw;\n\tvec2 normalWidth = thickness / scaleRatio;\n\n\tfloat lineStart = 1. - lineEnd;\n\tfloat lineBot = 1. - lineTop;\n\n\tfragColor = (lineStart * aColor + lineEnd * bColor) / 255.;\n\n\tif (isNaN(aCoord.x) || isNaN(aCoord.y) || isNaN(bCoord.x) || isNaN(bCoord.y)) return;\n\n\tif (aCoord == prevCoord) prevCoord = aCoord + normalize(bCoord - aCoord);\n\tif (bCoord == nextCoord) nextCoord = bCoord - normalize(bCoord - aCoord);\n\n\n\tvec2 prevDiff = aCoord - prevCoord;\n\tvec2 currDiff = bCoord - aCoord;\n\tvec2 nextDiff = nextCoord - bCoord;\n\n\tvec2 prevTangent = normalize(prevDiff * scaleRatio);\n\tvec2 currTangent = normalize(currDiff * scaleRatio);\n\tvec2 nextTangent = normalize(nextDiff * scaleRatio);\n\n\tvec2 prevNormal = vec2(-prevTangent.y, prevTangent.x);\n\tvec2 currNormal = vec2(-currTangent.y, currTangent.x);\n\tvec2 nextNormal = vec2(-nextTangent.y, nextTangent.x);\n\n\tvec2 startJoinDirection = normalize(prevTangent - currTangent);\n\tvec2 endJoinDirection = normalize(currTangent - nextTangent);\n\n\t// collapsed/unidirectional segment cases\n\t// FIXME: there should be more elegant solution\n\tvec2 prevTanDiff = abs(prevTangent - currTangent);\n\tvec2 nextTanDiff = abs(nextTangent - currTangent);\n\tif (max(prevTanDiff.x, prevTanDiff.y) < MIN_DIFF) {\n\t\tstartJoinDirection = currNormal;\n\t}\n\tif (max(nextTanDiff.x, nextTanDiff.y) < MIN_DIFF) {\n\t\tendJoinDirection = currNormal;\n\t}\n\tif (aCoord == bCoord) {\n\t\tendJoinDirection = startJoinDirection;\n\t\tcurrNormal = prevNormal;\n\t\tcurrTangent = prevTangent;\n\t}\n\n\ttangent = currTangent;\n\n\t//calculate join shifts relative to normals\n\tfloat startJoinShift = dot(currNormal, startJoinDirection);\n\tfloat endJoinShift = dot(currNormal, endJoinDirection);\n\n\tfloat startMiterRatio = abs(1. / startJoinShift);\n\tfloat endMiterRatio = abs(1. / endJoinShift);\n\n\tvec2 startJoin = startJoinDirection * startMiterRatio;\n\tvec2 endJoin = endJoinDirection * endMiterRatio;\n\n\tvec2 startTopJoin, startBotJoin, endTopJoin, endBotJoin;\n\tstartTopJoin = sign(startJoinShift) * startJoin * .5;\n\tstartBotJoin = -startTopJoin;\n\n\tendTopJoin = sign(endJoinShift) * endJoin * .5;\n\tendBotJoin = -endTopJoin;\n\n\tvec2 aTopCoord = aCoord + normalWidth * startTopJoin;\n\tvec2 bTopCoord = bCoord + normalWidth * endTopJoin;\n\tvec2 aBotCoord = aCoord + normalWidth * startBotJoin;\n\tvec2 bBotCoord = bCoord + normalWidth * endBotJoin;\n\n\t//miter anti-clipping\n\tfloat baClipping = distToLine(bCoord, aCoord, aBotCoord) / dot(normalize(normalWidth * endBotJoin), normalize(normalWidth.yx * vec2(-startBotJoin.y, startBotJoin.x)));\n\tfloat abClipping = distToLine(aCoord, bCoord, bTopCoord) / dot(normalize(normalWidth * startBotJoin), normalize(normalWidth.yx * vec2(-endBotJoin.y, endBotJoin.x)));\n\n\t//prevent close to reverse direction switch\n\tbool prevReverse = dot(currTangent, prevTangent) <= REVERSE_THRESHOLD && abs(dot(currTangent, prevNormal)) * min(length(prevDiff), length(currDiff)) <  length(normalWidth * currNormal);\n\tbool nextReverse = dot(currTangent, nextTangent) <= REVERSE_THRESHOLD && abs(dot(currTangent, nextNormal)) * min(length(nextDiff), length(currDiff)) <  length(normalWidth * currNormal);\n\n\tif (prevReverse) {\n\t\t//make join rectangular\n\t\tvec2 miterShift = normalWidth * startJoinDirection * miterLimit * .5;\n\t\tfloat normalAdjust = 1. - min(miterLimit / startMiterRatio, 1.);\n\t\taBotCoord = aCoord + miterShift - normalAdjust * normalWidth * currNormal * .5;\n\t\taTopCoord = aCoord + miterShift + normalAdjust * normalWidth * currNormal * .5;\n\t}\n\telse if (!nextReverse && baClipping > 0. && baClipping < length(normalWidth * endBotJoin)) {\n\t\t//handle miter clipping\n\t\tbTopCoord -= normalWidth * endTopJoin;\n\t\tbTopCoord += normalize(endTopJoin * normalWidth) * baClipping;\n\t}\n\n\tif (nextReverse) {\n\t\t//make join rectangular\n\t\tvec2 miterShift = normalWidth * endJoinDirection * miterLimit * .5;\n\t\tfloat normalAdjust = 1. - min(miterLimit / endMiterRatio, 1.);\n\t\tbBotCoord = bCoord + miterShift - normalAdjust * normalWidth * currNormal * .5;\n\t\tbTopCoord = bCoord + miterShift + normalAdjust * normalWidth * currNormal * .5;\n\t}\n\telse if (!prevReverse && abClipping > 0. && abClipping < length(normalWidth * startBotJoin)) {\n\t\t//handle miter clipping\n\t\taBotCoord -= normalWidth * startBotJoin;\n\t\taBotCoord += normalize(startBotJoin * normalWidth) * abClipping;\n\t}\n\n\tvec2 aTopPosition = (aTopCoord) * adjustedScale + translate;\n\tvec2 aBotPosition = (aBotCoord) * adjustedScale + translate;\n\n\tvec2 bTopPosition = (bTopCoord) * adjustedScale + translate;\n\tvec2 bBotPosition = (bBotCoord) * adjustedScale + translate;\n\n\t//position is normalized 0..1 coord on the screen\n\tvec2 position = (aTopPosition * lineTop + aBotPosition * lineBot) * lineStart + (bTopPosition * lineTop + bBotPosition * lineBot) * lineEnd;\n\n\tstartCoord = aCoord * scaleRatio + translate * viewport.zw + viewport.xy;\n\tendCoord = bCoord * scaleRatio + translate * viewport.zw + viewport.xy;\n\n\tgl_Position = vec4(position  * 2.0 - 1.0, depth, 1);\n\n\tenableStartMiter = step(dot(currTangent, prevTangent), .5);\n\tenableEndMiter = step(dot(currTangent, nextTangent), .5);\n\n\t//bevel miter cutoffs\n\tif (miterMode == 1.) {\n\t\tif (enableStartMiter == 1.) {\n\t\t\tvec2 startMiterWidth = vec2(startJoinDirection) * thickness * miterLimit * .5;\n\t\t\tstartCutoff = vec4(aCoord, aCoord);\n\t\t\tstartCutoff.zw += vec2(-startJoinDirection.y, startJoinDirection.x) / scaleRatio;\n\t\t\tstartCutoff = startCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\n\t\t\tstartCutoff += viewport.xyxy;\n\t\t\tstartCutoff += startMiterWidth.xyxy;\n\t\t}\n\n\t\tif (enableEndMiter == 1.) {\n\t\t\tvec2 endMiterWidth = vec2(endJoinDirection) * thickness * miterLimit * .5;\n\t\t\tendCutoff = vec4(bCoord, bCoord);\n\t\t\tendCutoff.zw += vec2(-endJoinDirection.y, endJoinDirection.x)  / scaleRatio;\n\t\t\tendCutoff = endCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\n\t\t\tendCutoff += viewport.xyxy;\n\t\t\tendCutoff += endMiterWidth.xyxy;\n\t\t}\n\t}\n\n\t//round miter cutoffs\n\telse if (miterMode == 2.) {\n\t\tif (enableStartMiter == 1.) {\n\t\t\tvec2 startMiterWidth = vec2(startJoinDirection) * thickness * abs(dot(startJoinDirection, currNormal)) * .5;\n\t\t\tstartCutoff = vec4(aCoord, aCoord);\n\t\t\tstartCutoff.zw += vec2(-startJoinDirection.y, startJoinDirection.x) / scaleRatio;\n\t\t\tstartCutoff = startCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\n\t\t\tstartCutoff += viewport.xyxy;\n\t\t\tstartCutoff += startMiterWidth.xyxy;\n\t\t}\n\n\t\tif (enableEndMiter == 1.) {\n\t\t\tvec2 endMiterWidth = vec2(endJoinDirection) * thickness * abs(dot(endJoinDirection, currNormal)) * .5;\n\t\t\tendCutoff = vec4(bCoord, bCoord);\n\t\t\tendCutoff.zw += vec2(-endJoinDirection.y, endJoinDirection.x)  / scaleRatio;\n\t\t\tendCutoff = endCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;\n\t\t\tendCutoff += viewport.xyxy;\n\t\t\tendCutoff += endMiterWidth.xyxy;\n\t\t}\n\t}\n}\n`\n\nconst milterFrag = `\nprecision highp float;\n\nuniform float dashLength, pixelRatio, thickness, opacity, id, miterMode;\nuniform sampler2D dashTexture;\n\nvarying vec4 fragColor;\nvarying vec2 tangent;\nvarying vec4 startCutoff, endCutoff;\nvarying vec2 startCoord, endCoord;\nvarying float enableStartMiter, enableEndMiter;\n\nfloat distToLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 diff = b - a;\n\tvec2 perp = normalize(vec2(-diff.y, diff.x));\n\treturn dot(p - a, perp);\n}\n\nvoid main() {\n\tfloat alpha = 1., distToStart, distToEnd;\n\tfloat cutoff = thickness * .5;\n\n\t//bevel miter\n\tif (miterMode == 1.) {\n\t\tif (enableStartMiter == 1.) {\n\t\t\tdistToStart = distToLine(gl_FragCoord.xy, startCutoff.xy, startCutoff.zw);\n\t\t\tif (distToStart < -1.) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\talpha *= min(max(distToStart + 1., 0.), 1.);\n\t\t}\n\n\t\tif (enableEndMiter == 1.) {\n\t\t\tdistToEnd = distToLine(gl_FragCoord.xy, endCutoff.xy, endCutoff.zw);\n\t\t\tif (distToEnd < -1.) {\n\t\t\t\tdiscard;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\talpha *= min(max(distToEnd + 1., 0.), 1.);\n\t\t}\n\t}\n\n\t// round miter\n\telse if (miterMode == 2.) {\n\t\tif (enableStartMiter == 1.) {\n\t\t\tdistToStart = distToLine(gl_FragCoord.xy, startCutoff.xy, startCutoff.zw);\n\t\t\tif (distToStart < 0.) {\n\t\t\t\tfloat radius = length(gl_FragCoord.xy - startCoord);\n\n\t\t\t\tif(radius > cutoff + .5) {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\talpha -= smoothstep(cutoff - .5, cutoff + .5, radius);\n\t\t\t}\n\t\t}\n\n\t\tif (enableEndMiter == 1.) {\n\t\t\tdistToEnd = distToLine(gl_FragCoord.xy, endCutoff.xy, endCutoff.zw);\n\t\t\tif (distToEnd < 0.) {\n\t\t\t\tfloat radius = length(gl_FragCoord.xy - endCoord);\n\n\t\t\t\tif(radius > cutoff + .5) {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\talpha -= smoothstep(cutoff - .5, cutoff + .5, radius);\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat t = fract(dot(tangent, gl_FragCoord.xy) / dashLength) * .5 + .25;\n\tfloat dash = texture2D(dashTexture, vec2(t, .5)).r;\n\n\tgl_FragColor = fragColor;\n\tgl_FragColor.a *= alpha * opacity * dash;\n}\n`\n\n\nmodule.exports = Line2D\n\n\n/** @constructor */\nfunction Line2D (regl, options) {\n\tif (!(this instanceof Line2D)) return new Line2D(regl, options)\n\n\tif (typeof regl === 'function') {\n\t\tif (!options) options = {}\n\t\toptions.regl = regl\n\t}\n\telse {\n\t\toptions = regl\n\t}\n\tif (options.length) options.positions = options\n\tregl = options.regl\n\n\tif (!regl.hasExtension('ANGLE_instanced_arrays')) {\n\t\tthrow Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n\t}\n\n\t// persistent variables\n\tthis.gl = regl._gl\n\tthis.regl = regl\n\n\t// list of options for lines\n\tthis.passes = []\n\n\t// cached shaders instance\n\tthis.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl)\n\n\n\t// init defaults\n\tthis.update(options)\n}\n\n\nLine2D.dashMult = 2\nLine2D.maxPatternLength = 256\nLine2D.precisionThreshold = 3e6\nLine2D.maxPoints = 1e4\nLine2D.maxLines = 2048\n\n\n// cache of created draw calls per-regl instance\nLine2D.shaders = new WeakMap()\n\n\n// create static shaders once\nLine2D.createShaders = function (regl) {\n\tlet offsetBuffer = regl.buffer({\n\t\tusage: 'static',\n\t\ttype: 'float',\n\t\tdata: [0,1, 0,0, 1,1, 1,0]\n\t})\n\n\tlet shaderOptions = {\n\t\tprimitive: 'triangle strip',\n\t\tinstances: regl.prop('count'),\n\t\tcount: 4,\n\t\toffset: 0,\n\n\t\tuniforms: {\n\t\t\tmiterMode: (ctx, prop) => prop.join === 'round' ? 2 : 1,\n\t\t\tmiterLimit: regl.prop('miterLimit'),\n\t\t\tscale: regl.prop('scale'),\n\t\t\tscaleFract: regl.prop('scaleFract'),\n\t\t\ttranslateFract: regl.prop('translateFract'),\n\t\t\ttranslate: regl.prop('translate'),\n\t\t\tthickness: regl.prop('thickness'),\n\t\t\tdashTexture: regl.prop('dashTexture'),\n\t\t\topacity: regl.prop('opacity'),\n\t\t\tpixelRatio: regl.context('pixelRatio'),\n\t\t\tid: regl.prop('id'),\n\t\t\tdashLength: regl.prop('dashLength'),\n\t\t\tviewport: (c, p) => [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight],\n\t\t\tdepth: regl.prop('depth')\n\t\t},\n\n\t\tblend: {\n\t\t\tenable: true,\n\t\t\tcolor: [0,0,0,0],\n\t\t\tequation: {\n\t\t\t\trgb: 'add',\n\t\t\t\talpha: 'add'\n\t\t\t},\n\t\t\tfunc: {\n\t\t\t\tsrcRGB: 'src alpha',\n\t\t\t\tdstRGB: 'one minus src alpha',\n\t\t\t\tsrcAlpha: 'one minus dst alpha',\n\t\t\t\tdstAlpha: 'one'\n\t\t\t}\n\t\t},\n\t\tdepth: {\n\t\t\tenable: (c, p) => {\n\t\t\t\treturn !p.overlay\n\t\t\t}\n\t\t},\n\t\tstencil: {enable: false},\n\t\tscissor: {\n\t\t\tenable: true,\n\t\t\tbox: regl.prop('viewport')\n\t\t},\n\t\tviewport: regl.prop('viewport')\n\t}\n\n\n\t// simplified rectangular line shader\n\tlet drawRectLine = regl(extend({\n\t\tvert: rectVert,\n\t\tfrag: rectFrag,\n\n\t\tattributes: {\n\t\t\t// if point is at the end of segment\n\t\t\tlineEnd: {\n\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\tdivisor: 0,\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 0\n\t\t\t},\n\t\t\t// if point is at the top of segment\n\t\t\tlineTop: {\n\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\tdivisor: 0,\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 4\n\t\t\t},\n\t\t\t// beginning of line coordinate\n\t\t\taCoord: {\n\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\t// end of line coordinate\n\t\t\tbCoord: {\n\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 16,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\taCoordFract: {\n\t\t\t\tbuffer: regl.prop('positionFractBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\tbCoordFract: {\n\t\t\t\tbuffer: regl.prop('positionFractBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 16,\n\t\t\t\tdivisor: 1\n\t\t\t},\n\t\t\tcolor: {\n\t\t\t\tbuffer: regl.prop('colorBuffer'),\n\t\t\t\tstride: 4,\n\t\t\t\toffset: 0,\n\t\t\t\tdivisor: 1\n\t\t\t}\n\t\t}\n\t}, shaderOptions))\n\n\t// create regl draw\n\tlet drawMiterLine\n\n\ttry {\n\t\tdrawMiterLine = regl(extend({\n\t\t\t// culling removes polygon creasing\n\t\t\tcull: {\n\t\t\t\tenable: true,\n\t\t\t\tface: 'back'\n\t\t\t},\n\n\t\t\tvert: milterVert,\n\t\t\tfrag: milterFrag,\n\n\t\t\tattributes: {\n\t\t\t\t// is line end\n\t\t\t\tlineEnd: {\n\t\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\t\tdivisor: 0,\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 0\n\t\t\t\t},\n\t\t\t\t// is line top\n\t\t\t\tlineTop: {\n\t\t\t\t\tbuffer: offsetBuffer,\n\t\t\t\t\tdivisor: 0,\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 4\n\t\t\t\t},\n\t\t\t\t// left color\n\t\t\t\taColor: {\n\t\t\t\t\tbuffer: regl.prop('colorBuffer'),\n\t\t\t\t\tstride: 4,\n\t\t\t\t\toffset: 0,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\t// right color\n\t\t\t\tbColor: {\n\t\t\t\t\tbuffer: regl.prop('colorBuffer'),\n\t\t\t\t\tstride: 4,\n\t\t\t\t\toffset: 4,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\tprevCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 0,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\taCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 8,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\tbCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 16,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t},\n\t\t\t\tnextCoord: {\n\t\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\t\tstride: 8,\n\t\t\t\t\toffset: 24,\n\t\t\t\t\tdivisor: 1\n\t\t\t\t}\n\t\t\t}\n\t\t}, shaderOptions))\n\t} catch (e) {\n\t\t// IE/bad Webkit fallback\n\t\tdrawMiterLine = drawRectLine\n\t}\n\n\t// fill shader\n\tlet drawFill = regl({\n\t\tprimitive: 'triangle',\n\t\telements: (ctx, prop) => prop.triangles,\n\t\toffset: 0,\n\n\t\tvert: fillVert,\n\t\tfrag: fillFrag,\n\n\t\tuniforms: {\n\t\t\tscale: regl.prop('scale'),\n\t\t\tcolor: regl.prop('fill'),\n\t\t\tscaleFract: regl.prop('scaleFract'),\n\t\t\ttranslateFract: regl.prop('translateFract'),\n\t\t\ttranslate: regl.prop('translate'),\n\t\t\topacity: regl.prop('opacity'),\n\t\t\tpixelRatio: regl.context('pixelRatio'),\n\t\t\tid: regl.prop('id'),\n\t\t\tviewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]\n\t\t},\n\n\t\tattributes: {\n\t\t\tposition: {\n\t\t\t\tbuffer: regl.prop('positionBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8\n\t\t\t},\n\t\t\tpositionFract: {\n\t\t\t\tbuffer: regl.prop('positionFractBuffer'),\n\t\t\t\tstride: 8,\n\t\t\t\toffset: 8\n\t\t\t}\n\t\t},\n\n\t\tblend: shaderOptions.blend,\n\n\t\tdepth: { enable: false },\n\t\tscissor: shaderOptions.scissor,\n\t\tstencil: shaderOptions.stencil,\n\t\tviewport: shaderOptions.viewport\n\t})\n\n\treturn {\n\t\tfill: drawFill, rect: drawRectLine, miter: drawMiterLine\n\t}\n}\n\n\n// used to for new lines instances\nLine2D.defaults = {\n\tdashes: null,\n\tjoin: 'miter',\n\tmiterLimit: 1,\n\tthickness: 10,\n\tcap: 'square',\n\tcolor: 'black',\n\topacity: 1,\n\toverlay: false,\n\tviewport: null,\n\trange: null,\n\tclose: false,\n\tfill: null\n}\n\n\nLine2D.prototype.render = function (...args) {\n\tif (args.length) {\n\t\tthis.update(...args)\n\t}\n\n\tthis.draw()\n}\n\n\nLine2D.prototype.draw = function (...args) {\n\t// render multiple polylines via regl batch\n\t(args.length ? args : this.passes).forEach((s, i) => {\n\t\t// render array pass as a list of passes\n\t\tif (s && Array.isArray(s)) return this.draw(...s)\n\n\t\tif (typeof s === 'number') s = this.passes[s]\n\n\t\tif (!(s && s.count > 1 && s.opacity)) return\n\n\t\tthis.regl._refresh()\n\n\t\tif (s.fill && s.triangles && s.triangles.length > 2) {\n\t\t\tthis.shaders.fill(s)\n\t\t}\n\n\t\tif (!s.thickness) return\n\n\t\t// high scale is only available for rect mode with precision\n\t\tif (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {\n\t\t\tthis.shaders.rect(s)\n\t\t}\n\n\t\t// thin this.passes or too many points are rendered as simplified rect shader\n\t\telse if (s.join === 'rect' || (!s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints))) {\n\t\t\tthis.shaders.rect(s)\n\t\t}\n\t\telse {\n\t\t\tthis.shaders.miter(s)\n\t\t}\n\t})\n\n\treturn this\n}\n\nLine2D.prototype.update = function (options) {\n\tif (!options) return\n\n\tif (options.length != null) {\n\t\tif (typeof options[0] === 'number') options = [{positions: options}]\n\t}\n\n\t// make options a batch\n\telse if (!Array.isArray(options)) options = [options]\n\n\tlet { regl, gl } = this\n\n\t// process per-line settings\n\toptions.forEach((o, i) => {\n\t\tlet state = this.passes[i]\n\n\t\tif (o === undefined) return\n\n\t\t// null-argument removes pass\n\t\tif (o === null) {\n\t\t\tthis.passes[i] = null\n\t\t\treturn\n\t\t}\n\n\t\tif (typeof o[0] === 'number') o = {positions: o}\n\n\t\t// handle aliases\n\t\to = pick(o, {\n\t\t\tpositions: 'positions points data coords',\n\t\t\tthickness: 'thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth',\n\t\t\tjoin: 'lineJoin linejoin join type mode',\n\t\t\tmiterLimit: 'miterlimit miterLimit',\n\t\t\tdashes: 'dash dashes dasharray dash-array dashArray',\n\t\t\tcolor: 'color colour stroke colors colours stroke-color strokeColor',\n\t\t\tfill: 'fill fill-color fillColor',\n\t\t\topacity: 'alpha opacity',\n\t\t\toverlay: 'overlay crease overlap intersect',\n\t\t\tclose: 'closed close closed-path closePath',\n\t\t\trange: 'range dataBox',\n\t\t\tviewport: 'viewport viewBox',\n\t\t\thole: 'holes hole hollow',\n\t\t\tsplitNull: 'splitNull'\n\t\t})\n\n\t\t// init state\n\t\tif (!state) {\n\t\t\tthis.passes[i] = state = {\n\t\t\t\tid: i,\n\t\t\t\tscale: null,\n\t\t\t\tscaleFract: null,\n\t\t\t\ttranslate: null,\n\t\t\t\ttranslateFract: null,\n\t\t\t\tcount: 0,\n\t\t\t\thole: [],\n\t\t\t\tdepth: 0,\n\n\t\t\t\tdashLength: 1,\n\t\t\t\tdashTexture: regl.texture({\n\t\t\t\t\tchannels: 1,\n\t\t\t\t\tdata: new Uint8Array([255]),\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1,\n\t\t\t\t\tmag: 'linear',\n\t\t\t\t\tmin: 'linear'\n\t\t\t\t}),\n\n\t\t\t\tcolorBuffer: regl.buffer({\n\t\t\t\t\tusage: 'dynamic',\n\t\t\t\t\ttype: 'uint8',\n\t\t\t\t\tdata: new Uint8Array()\n\t\t\t\t}),\n\t\t\t\tpositionBuffer: regl.buffer({\n\t\t\t\t\tusage: 'dynamic',\n\t\t\t\t\ttype: 'float',\n\t\t\t\t\tdata: new Uint8Array()\n\t\t\t\t}),\n\t\t\t\tpositionFractBuffer: regl.buffer({\n\t\t\t\t\tusage: 'dynamic',\n\t\t\t\t\ttype: 'float',\n\t\t\t\t\tdata: new Uint8Array()\n\t\t\t\t})\n\t\t\t}\n\n\t\t\to = extend({}, Line2D.defaults, o)\n\t\t}\n\t\tif (o.thickness != null) state.thickness = parseFloat(o.thickness)\n\t\tif (o.opacity != null) state.opacity = parseFloat(o.opacity)\n\t\tif (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit)\n\t\tif (o.overlay != null) {\n\t\t\tstate.overlay = !!o.overlay\n\t\t\tif (i < Line2D.maxLines) {\n\t\t\t\tstate.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1.;\n\t\t\t}\n\t\t}\n\t\tif (o.join != null) state.join = o.join\n\t\tif (o.hole != null) state.hole = o.hole\n\t\tif (o.fill != null) state.fill = !o.fill ? null : rgba(o.fill, 'uint8')\n\t\tif (o.viewport != null) state.viewport = parseRect(o.viewport)\n\n\t\tif (!state.viewport) {\n\t\t\tstate.viewport = parseRect([\n\t\t\t\tgl.drawingBufferWidth,\n\t\t\t\tgl.drawingBufferHeight\n\t\t\t])\n\t\t}\n\n\t\tif (o.close != null) state.close = o.close\n\n\t\t// reset positions\n\t\tif (o.positions === null) o.positions = []\n\t\tif (o.positions) {\n\t\t\tlet positions, count\n\n\t\t\t// if positions are an object with x/y\n\t\t\tif (o.positions.x && o.positions.y) {\n\t\t\t\tlet xPos = o.positions.x\n\t\t\t\tlet yPos = o.positions.y\n\t\t\t\tcount = state.count = Math.max(\n\t\t\t\t\txPos.length,\n\t\t\t\t\tyPos.length\n\t\t\t\t)\n\t\t\t\tpositions = new Float64Array(count * 2)\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tpositions[i * 2] = xPos[i]\n\t\t\t\t\tpositions[i * 2 + 1] = yPos[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpositions = flatten(o.positions, 'float64')\n\t\t\t\tcount = state.count = Math.floor(positions.length / 2)\n\t\t\t}\n\n\t\t\tlet bounds = state.bounds = getBounds(positions, 2)\n\n\t\t\t// create fill positions\n\t\t\t// FIXME: fill positions can be set only along with positions\n\t\t\tif (state.fill) {\n\t\t\t\tlet pos = []\n\n\t\t\t\t// filter bad vertices and remap triangles to ensure shape\n\t\t\t\tlet ids = {}\n\t\t\t\tlet lastId = 0\n\n\t\t\t\tfor (let i = 0, ptr = 0, l = state.count; i < l; i++) {\n\t\t\t\t\tlet x = positions[i*2]\n\t\t\t\t\tlet y = positions[i*2 + 1]\n\t\t\t\t\tif (isNaN(x) || isNaN(y) || x == null || y == null) {\n\t\t\t\t\t\tx = positions[lastId*2]\n\t\t\t\t\t\ty = positions[lastId*2 + 1]\n\t\t\t\t\t\tids[i] = lastId\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlastId = i\n\t\t\t\t\t}\n\t\t\t\t\tpos[ptr++] = x\n\t\t\t\t\tpos[ptr++] = y\n\t\t\t\t}\n\n\t\t\t\t// split the input into multiple polygon at Null/NaN\n\t\t\t\tif(o.splitNull){\n\t\t\t\t\t// use \"ids\" to track the boundary of segment\n\t\t\t\t\t// the keys in \"ids\" is the end boundary of a segment, or split point\n\n\t\t\t\t\t// make sure there is at least one segment\n\t\t\t\t\tif(!(state.count-1 in ids)) ids[state.count] = state.count-1\n\n\t\t\t\t\tlet splits = Object.keys(ids).map(Number).sort((a, b) => a - b)\n\n\t\t\t\t\tlet split_triangles = []\n\t\t\t\t\tlet base = 0\n\n\t\t\t\t\t// do not split holes\n\t\t\t\t\tlet hole_base = state.hole != null ? state.hole[0] : null\n\t\t\t\t\tif(hole_base != null){\n\t\t\t\t\t\tlet last_id = findIndex(splits, (e)=>e>=hole_base)\n\t\t\t\t\t\tsplits = splits.slice(0,last_id)\n\t\t\t\t\t\tsplits.push(hole_base)\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < splits.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// create temporary pos array with only one segment and all the holes\n\t\t\t\t\t\tlet seg_pos = pos.slice(base*2, splits[i]*2).concat(\n\t\t\t\t\t\t\thole_base ? pos.slice(hole_base*2) : []\n\t\t\t\t\t\t)\n\t\t\t\t\t\tlet hole = (state.hole || []).map((e) => e-hole_base+(splits[i]-base) )\n\t\t\t\t\t\tlet triangles = triangulate(seg_pos, hole)\n\t\t\t\t\t\t// map triangle index back to the original pos buffer\n\t\t\t\t\t\ttriangles = triangles.map(\n\t\t\t\t\t\t\t(e)=> e + base + ((e + base < splits[i]) ? 0 : hole_base - splits[i])\n\t\t\t\t\t\t)\n\t\t\t\t\t\tsplit_triangles.push(...triangles)\n\n\t\t\t\t\t\t// skip split point\n\t\t\t\t\t\tbase = splits[i] + 1\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0, l = split_triangles.length; i < l; i++) {\n\t\t\t\t\t\tif (ids[split_triangles[i]] != null) split_triangles[i] = ids[split_triangles[i]]\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.triangles = split_triangles\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// treat the wholw input as a single polygon\n\t\t\t\t\tlet triangles = triangulate(pos, state.hole || [])\n\n\t\t\t\t\tfor (let i = 0, l = triangles.length; i < l; i++) {\n\t\t\t\t\t\tif (ids[triangles[i]] != null) triangles[i] = ids[triangles[i]]\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.triangles = triangles\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update position buffers\n\t\t\tlet npos = new Float64Array(positions)\n\t\t\tnormalize(npos, 2, bounds)\n\n\t\t\tlet positionData = new Float64Array(count * 2 + 6)\n\n\t\t\t// rotate first segment join\n\t\t\tif (state.close) {\n\t\t\t\tif (positions[0] === positions[count*2 - 2] &&\n\t\t\t\t\tpositions[1] === positions[count*2 - 1]) {\n\t\t\t\t\tpositionData[0] = npos[count*2 - 4]\n\t\t\t\t\tpositionData[1] = npos[count*2 - 3]\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpositionData[0] = npos[count*2 - 2]\n\t\t\t\t\tpositionData[1] = npos[count*2 - 1]\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpositionData[0] = npos[0]\n\t\t\t\tpositionData[1] = npos[1]\n\t\t\t}\n\n\t\t\tpositionData.set(npos, 2)\n\n\t\t\t// add last segment\n\t\t\tif (state.close) {\n\t\t\t\t// ignore coinciding start/end\n\t\t\t\tif (positions[0] === positions[count*2 - 2] &&\n\t\t\t\t\tpositions[1] === positions[count*2 - 1]) {\n\t\t\t\t\tpositionData[count*2 + 2] = npos[2]\n\t\t\t\t\tpositionData[count*2 + 3] = npos[3]\n\t\t\t\t\tstate.count -= 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpositionData[count*2 + 2] = npos[0]\n\t\t\t\t\tpositionData[count*2 + 3] = npos[1]\n\t\t\t\t\tpositionData[count*2 + 4] = npos[2]\n\t\t\t\t\tpositionData[count*2 + 5] = npos[3]\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add stub\n\t\t\telse {\n\t\t\t\tpositionData[count*2 + 2] = npos[count*2 - 2]\n\t\t\t\tpositionData[count*2 + 3] = npos[count*2 - 1]\n\t\t\t\tpositionData[count*2 + 4] = npos[count*2 - 2]\n\t\t\t\tpositionData[count*2 + 5] = npos[count*2 - 1]\n\t\t\t}\n\n\t\t\tvar float_data = float32(positionData)\n\t\t\tstate.positionBuffer(float_data)\n\t\t\tvar frac_data = fract32(positionData, float_data)\n\t\t\tstate.positionFractBuffer(frac_data)\n\t\t}\n\n\t\tif (o.range) {\n\t\t\tstate.range = o.range\n\t\t} else if (!state.range) {\n\t\t\tstate.range = state.bounds\n\t\t}\n\n\t\tif ((o.range || o.positions) && state.count) {\n\t\t\tlet bounds = state.bounds\n\n\t\t\tlet boundsW = bounds[2] - bounds[0],\n\t\t\t\tboundsH = bounds[3] - bounds[1]\n\n\t\t\tlet rangeW = state.range[2] - state.range[0],\n\t\t\t\trangeH = state.range[3] - state.range[1]\n\n\t\t\tstate.scale = [\n\t\t\t\tboundsW / rangeW,\n\t\t\t\tboundsH / rangeH\n\t\t\t]\n\t\t\tstate.translate = [\n\t\t\t\t-state.range[0] / rangeW + bounds[0] / rangeW || 0,\n\t\t\t\t-state.range[1] / rangeH + bounds[1] / rangeH || 0\n\t\t\t]\n\n\t\t\tstate.scaleFract = fract32(state.scale)\n\t\t\tstate.translateFract = fract32(state.translate)\n\t\t}\n\n\t\tif (o.dashes) {\n\t\t\tlet dashLength = 0., dashData\n\n\t\t\tif (!o.dashes || o.dashes.length < 2) {\n\t\t\t\tdashLength = 1.\n\t\t\t\tdashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255])\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tdashLength = 0.;\n\t\t\t\tfor(let i = 0; i < o.dashes.length; ++i) {\n\t\t\t\t\tdashLength += o.dashes[i]\n\t\t\t\t}\n\t\t\t\tdashData = new Uint8Array(dashLength * Line2D.dashMult)\n\t\t\t\tlet ptr = 0\n\t\t\t\tlet fillColor = 255\n\n\t\t\t\t// repeat texture two times to provide smooth 0-step\n\t\t\t\tfor (let k = 0; k < 2; k++) {\n\t\t\t\t\tfor(let i = 0; i < o.dashes.length; ++i) {\n\t\t\t\t\t\tfor(let j = 0, l = o.dashes[i] * Line2D.dashMult * .5; j < l; ++j) {\n\t\t\t\t\t\t\tdashData[ptr++] = fillColor\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfillColor ^= 255\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.dashLength = dashLength\n\t\t\tstate.dashTexture({\n\t\t\t\tchannels: 1,\n\t\t\t\tdata: dashData,\n\t\t\t\twidth: dashData.length,\n\t\t\t\theight: 1,\n\t\t\t\tmag: 'linear',\n\t\t\t\tmin: 'linear'\n\t\t\t}, 0, 0)\n\t\t}\n\n\t\tif (o.color) {\n\t\t\tlet count = state.count\n\t\t\tlet colors = o.color\n\n\t\t\tif (!colors) colors = 'transparent'\n\n\t\t\tlet colorData = new Uint8Array(count * 4 + 4)\n\n\t\t\t// convert colors to typed arrays\n\t\t\tif (!Array.isArray(colors) || typeof colors[0] === 'number') {\n\t\t\t\tlet c = rgba(colors, 'uint8')\n\n\t\t\t\tfor (let i = 0; i < count + 1; i++) {\n\t\t\t\t\tcolorData.set(c, i * 4)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tlet c = rgba(colors[i], 'uint8')\n\t\t\t\t\tcolorData.set(c, i * 4)\n\t\t\t\t}\n\t\t\t\tcolorData.set(rgba(colors[0], 'uint8'), count * 4)\n\t\t\t}\n\n\t\t\tstate.colorBuffer({\n\t\t\t\tusage: 'dynamic',\n\t\t\t\ttype: 'uint8',\n\t\t\t\tdata: colorData\n\t\t\t})\n\t\t}\n\t})\n\n\t// remove unmentioned passes\n\tif (options.length < this.passes.length) {\n\t\tfor (let i = options.length; i < this.passes.length; i++) {\n\t\t\tlet pass = this.passes[i]\n\t\t\tif (!pass) continue\n\t\t\tpass.colorBuffer.destroy()\n\t\t\tpass.positionBuffer.destroy()\n\t\t\tpass.dashTexture.destroy()\n\t\t}\n\t\tthis.passes.length = options.length\n\t}\n\n\t// remove null items\n\tlet passes = []\n\tfor (let i = 0; i < this.passes.length; i++) {\n\t\tif (this.passes[i] !== null) passes.push(this.passes[i])\n\t}\n\tthis.passes = passes\n\n\treturn this\n}\n\nLine2D.prototype.destroy = function () {\n\tthis.passes.forEach(pass => {\n\t\tpass.colorBuffer.destroy()\n\t\tpass.positionBuffer.destroy()\n\t\tpass.dashTexture.destroy()\n\t})\n\n\tthis.passes.length = 0\n\n\treturn this\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}