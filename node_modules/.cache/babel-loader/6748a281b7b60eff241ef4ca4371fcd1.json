{"ast":null,"code":"// Utils used to parse miaf-based files (avif/heic/heif)\n//\n// ISO media file spec:\n// https://web.archive.org/web/20180219054429/http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/ref/mp4.pdf\n//\n// ISO image file format spec:\n// https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip\n//\n\n'use strict';\n\n/* eslint-disable consistent-return */\n/* eslint-disable no-bitwise */\nvar readUInt16BE = require('./common').readUInt16BE;\nvar readUInt32BE = require('./common').readUInt32BE;\n\n/*\n * interface Box {\n *   size:       uint32;   // if size == 0, box lasts until EOF\n *   boxtype:    char[4];\n *   largesize?: uint64;   // only if size == 1\n *   usertype?:  char[16]; // only if boxtype == 'uuid'\n * }\n */\nfunction unbox(data, offset) {\n  if (data.length < 4 + offset) return null;\n  var size = readUInt32BE(data, offset);\n\n  // size includes first 4 bytes (length)\n  if (data.length < size + offset || size < 8) return null;\n\n  // if size === 1, real size is following uint64 (only for big boxes, not needed)\n  // if size === 0, real size is until the end of the file (only for big boxes, not needed)\n\n  return {\n    boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),\n    data: data.slice(offset + 8, offset + size),\n    end: offset + size\n  };\n}\nmodule.exports.unbox = unbox;\n\n// parses `meta` -> `iprp` -> `ipco` box, returns:\n// {\n//   sizes: [ { width, height } ],\n//   transforms: [ { type, value } ]\n// }\nfunction scan_ipco(data, sandbox) {\n  var offset = 0;\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    switch (box.boxtype) {\n      case 'ispe':\n        sandbox.sizes.push({\n          width: readUInt32BE(box.data, 4),\n          height: readUInt32BE(box.data, 8)\n        });\n        break;\n      case 'irot':\n        sandbox.transforms.push({\n          type: 'irot',\n          value: box.data[0] & 3\n        });\n        break;\n      case 'imir':\n        sandbox.transforms.push({\n          type: 'imir',\n          value: box.data[0] & 1\n        });\n        break;\n    }\n    offset = box.end;\n  }\n}\nfunction readUIntBE(data, offset, size) {\n  var result = 0;\n  for (var i = 0; i < size; i++) {\n    result = result * 256 + (data[offset + i] || 0);\n  }\n  return result;\n}\n\n// parses `meta` -> `iloc` box\nfunction scan_iloc(data, sandbox) {\n  var offset_size = data[4] >> 4 & 0xF;\n  var length_size = data[4] & 0xF;\n  var base_offset_size = data[5] >> 4 & 0xF;\n  var item_count = readUInt16BE(data, 6);\n  var offset = 8;\n  for (var i = 0; i < item_count; i++) {\n    var item_ID = readUInt16BE(data, offset);\n    offset += 2;\n    var data_reference_index = readUInt16BE(data, offset);\n    offset += 2;\n    var base_offset = readUIntBE(data, offset, base_offset_size);\n    offset += base_offset_size;\n    var extent_count = readUInt16BE(data, offset);\n    offset += 2;\n    if (data_reference_index === 0 && extent_count === 1) {\n      var first_extent_offset = readUIntBE(data, offset, offset_size);\n      var first_extent_length = readUIntBE(data, offset + offset_size, length_size);\n      sandbox.item_loc[item_ID] = {\n        length: first_extent_length,\n        offset: first_extent_offset + base_offset\n      };\n    }\n    offset += extent_count * (offset_size + length_size);\n  }\n}\n\n// parses `meta` -> `iinf` box\nfunction scan_iinf(data, sandbox) {\n  var item_count = readUInt16BE(data, 4);\n  var offset = 6;\n  for (var i = 0; i < item_count; i++) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'infe') {\n      var item_id = readUInt16BE(box.data, 4);\n      var item_name = '';\n      for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {\n        item_name += String.fromCharCode(box.data[pos]);\n      }\n      sandbox.item_inf[item_name] = item_id;\n    }\n    offset = box.end;\n  }\n}\n\n// parses `meta` -> `iprp` box\nfunction scan_iprp(data, sandbox) {\n  var offset = 0;\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'ipco') scan_ipco(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n// parses `meta` box\nfunction scan_meta(data, sandbox) {\n  var offset = 4; // version + flags\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'iprp') scan_iprp(box.data, sandbox);\n    if (box.boxtype === 'iloc') scan_iloc(box.data, sandbox);\n    if (box.boxtype === 'iinf') scan_iinf(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n// get image with largest single dimension as base\nfunction getMaxSize(sizes) {\n  var maxWidthSize = sizes.reduce(function (a, b) {\n    return a.width > b.width || a.width === b.width && a.height > b.height ? a : b;\n  });\n  var maxHeightSize = sizes.reduce(function (a, b) {\n    return a.height > b.height || a.height === b.height && a.width > b.width ? a : b;\n  });\n  var maxSize;\n  if (maxWidthSize.width > maxHeightSize.height || maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width) {\n    maxSize = maxWidthSize;\n  } else {\n    maxSize = maxHeightSize;\n  }\n  return maxSize;\n}\nmodule.exports.readSizeFromMeta = function (data) {\n  var sandbox = {\n    sizes: [],\n    transforms: [],\n    item_inf: {},\n    item_loc: {}\n  };\n  scan_meta(data, sandbox);\n  if (!sandbox.sizes.length) return;\n  var maxSize = getMaxSize(sandbox.sizes);\n  var orientation = 1;\n\n  // convert imir/irot to exif orientation\n  sandbox.transforms.forEach(function (transform) {\n    var rotate_ccw = {\n      1: 6,\n      2: 5,\n      3: 8,\n      4: 7,\n      5: 4,\n      6: 3,\n      7: 2,\n      8: 1\n    };\n    var mirror_vert = {\n      1: 4,\n      2: 3,\n      3: 2,\n      4: 1,\n      5: 6,\n      6: 5,\n      7: 8,\n      8: 7\n    };\n    if (transform.type === 'imir') {\n      if (transform.value === 0) {\n        // vertical flip\n        orientation = mirror_vert[orientation];\n      } else {\n        // horizontal flip = vertical flip + 180 deg rotation\n        orientation = mirror_vert[orientation];\n        orientation = rotate_ccw[orientation];\n        orientation = rotate_ccw[orientation];\n      }\n    }\n    if (transform.type === 'irot') {\n      // counter-clockwise rotation 90 deg 0-3 times\n      for (var i = 0; i < transform.value; i++) {\n        orientation = rotate_ccw[orientation];\n      }\n    }\n  });\n  var exif_location = null;\n  if (sandbox.item_inf.Exif) {\n    exif_location = sandbox.item_loc[sandbox.item_inf.Exif];\n  }\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    orientation: sandbox.transforms.length ? orientation : null,\n    variants: sandbox.sizes,\n    exif_location: exif_location\n  };\n};\nmodule.exports.getMimeType = function (data) {\n  var brand = String.fromCharCode.apply(null, data.slice(0, 4));\n  var compat = {};\n  compat[brand] = true;\n  for (var i = 8; i < data.length; i += 4) {\n    compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;\n  }\n\n  // heic and avif are superset of miaf, so they should all list mif1 as compatible\n  if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;\n  if (brand === 'avif' || brand === 'avis' || brand === 'avio') {\n    // `.avifs` and `image/avif-sequence` are removed from spec, all files have single type\n    return {\n      type: 'avif',\n      mime: 'image/avif'\n    };\n  }\n\n  // https://nokiatech.github.io/heif/technical.html\n  if (brand === 'heic' || brand === 'heix') {\n    return {\n      type: 'heic',\n      mime: 'image/heic'\n    };\n  }\n  if (brand === 'hevc' || brand === 'hevx') {\n    return {\n      type: 'heic',\n      mime: 'image/heic-sequence'\n    };\n  }\n  if (compat.avif || compat.avis) {\n    return {\n      type: 'avif',\n      mime: 'image/avif'\n    };\n  }\n  if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {\n    if (compat.msf1) {\n      return {\n        type: 'heif',\n        mime: 'image/heif-sequence'\n      };\n    }\n    return {\n      type: 'heif',\n      mime: 'image/heif'\n    };\n  }\n  return {\n    type: 'avif',\n    mime: 'image/avif'\n  };\n};","map":{"version":3,"names":["readUInt16BE","require","readUInt32BE","unbox","data","offset","length","size","boxtype","String","fromCharCode","apply","slice","end","module","exports","scan_ipco","sandbox","box","sizes","push","width","height","transforms","type","value","readUIntBE","result","i","scan_iloc","offset_size","length_size","base_offset_size","item_count","item_ID","data_reference_index","base_offset","extent_count","first_extent_offset","first_extent_length","item_loc","scan_iinf","item_id","item_name","pos","item_inf","scan_iprp","scan_meta","getMaxSize","maxWidthSize","reduce","a","b","maxHeightSize","maxSize","readSizeFromMeta","orientation","forEach","transform","rotate_ccw","mirror_vert","exif_location","Exif","variants","getMimeType","brand","compat","mif1","msf1","miaf","mime","avif","avis","heic","heix","hevc","hevx","heis"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/probe-image-size/lib/miaf_utils.js"],"sourcesContent":["// Utils used to parse miaf-based files (avif/heic/heif)\n//\n// ISO media file spec:\n// https://web.archive.org/web/20180219054429/http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/ref/mp4.pdf\n//\n// ISO image file format spec:\n// https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip\n//\n\n'use strict';\n\n/* eslint-disable consistent-return */\n/* eslint-disable no-bitwise */\n\nvar readUInt16BE = require('./common').readUInt16BE;\nvar readUInt32BE = require('./common').readUInt32BE;\n\n/*\n * interface Box {\n *   size:       uint32;   // if size == 0, box lasts until EOF\n *   boxtype:    char[4];\n *   largesize?: uint64;   // only if size == 1\n *   usertype?:  char[16]; // only if boxtype == 'uuid'\n * }\n */\nfunction unbox(data, offset) {\n  if (data.length < 4 + offset) return null;\n\n  var size = readUInt32BE(data, offset);\n\n  // size includes first 4 bytes (length)\n  if (data.length < size + offset || size < 8) return null;\n\n  // if size === 1, real size is following uint64 (only for big boxes, not needed)\n  // if size === 0, real size is until the end of the file (only for big boxes, not needed)\n\n  return {\n    boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),\n    data:    data.slice(offset + 8, offset + size),\n    end:     offset + size\n  };\n}\n\n\nmodule.exports.unbox = unbox;\n\n\n// parses `meta` -> `iprp` -> `ipco` box, returns:\n// {\n//   sizes: [ { width, height } ],\n//   transforms: [ { type, value } ]\n// }\nfunction scan_ipco(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    switch (box.boxtype) {\n      case 'ispe':\n        sandbox.sizes.push({\n          width:  readUInt32BE(box.data, 4),\n          height: readUInt32BE(box.data, 8)\n        });\n        break;\n\n      case 'irot':\n        sandbox.transforms.push({\n          type: 'irot',\n          value: box.data[0] & 3\n        });\n        break;\n\n      case 'imir':\n        sandbox.transforms.push({\n          type: 'imir',\n          value: box.data[0] & 1\n        });\n        break;\n    }\n\n    offset = box.end;\n  }\n}\n\n\nfunction readUIntBE(data, offset, size) {\n  var result = 0;\n\n  for (var i = 0; i < size; i++) {\n    result = result * 256 + (data[offset + i] || 0);\n  }\n\n  return result;\n}\n\n\n// parses `meta` -> `iloc` box\nfunction scan_iloc(data, sandbox) {\n  var offset_size = (data[4] >> 4) & 0xF;\n  var length_size = data[4] & 0xF;\n  var base_offset_size = (data[5] >> 4) & 0xF;\n  var item_count = readUInt16BE(data, 6);\n  var offset = 8;\n\n  for (var i = 0; i < item_count; i++) {\n    var item_ID = readUInt16BE(data, offset);\n    offset += 2;\n\n    var data_reference_index = readUInt16BE(data, offset);\n    offset += 2;\n\n    var base_offset = readUIntBE(data, offset, base_offset_size);\n    offset += base_offset_size;\n\n    var extent_count = readUInt16BE(data, offset);\n    offset += 2;\n\n    if (data_reference_index === 0 && extent_count === 1) {\n      var first_extent_offset = readUIntBE(data, offset, offset_size);\n      var first_extent_length = readUIntBE(data, offset + offset_size, length_size);\n      sandbox.item_loc[item_ID] = { length: first_extent_length, offset: first_extent_offset + base_offset };\n    }\n\n    offset += extent_count * (offset_size + length_size);\n  }\n}\n\n\n// parses `meta` -> `iinf` box\nfunction scan_iinf(data, sandbox) {\n  var item_count = readUInt16BE(data, 4);\n  var offset = 6;\n\n  for (var i = 0; i < item_count; i++) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'infe') {\n      var item_id = readUInt16BE(box.data, 4);\n      var item_name = '';\n\n      for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {\n        item_name += String.fromCharCode(box.data[pos]);\n      }\n\n      sandbox.item_inf[item_name] = item_id;\n    }\n    offset = box.end;\n  }\n}\n\n\n// parses `meta` -> `iprp` box\nfunction scan_iprp(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'ipco') scan_ipco(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n\n// parses `meta` box\nfunction scan_meta(data, sandbox) {\n  var offset = 4; // version + flags\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'iprp') scan_iprp(box.data, sandbox);\n    if (box.boxtype === 'iloc') scan_iloc(box.data, sandbox);\n    if (box.boxtype === 'iinf') scan_iinf(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n\n// get image with largest single dimension as base\nfunction getMaxSize(sizes) {\n  var maxWidthSize = sizes.reduce(function (a, b) {\n    return a.width > b.width || (a.width === b.width && a.height > b.height) ? a : b;\n  });\n\n  var maxHeightSize = sizes.reduce(function (a, b) {\n    return a.height > b.height || (a.height === b.height && a.width > b.width) ? a : b;\n  });\n\n  var maxSize;\n\n  if (maxWidthSize.width > maxHeightSize.height ||\n      (maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width)) {\n    maxSize = maxWidthSize;\n  } else {\n    maxSize = maxHeightSize;\n  }\n\n  return maxSize;\n}\n\n\nmodule.exports.readSizeFromMeta = function (data) {\n  var sandbox = {\n    sizes: [],\n    transforms: [],\n    item_inf: {},\n    item_loc: {}\n  };\n\n  scan_meta(data, sandbox);\n\n  if (!sandbox.sizes.length) return;\n\n  var maxSize = getMaxSize(sandbox.sizes);\n\n  var orientation = 1;\n\n  // convert imir/irot to exif orientation\n  sandbox.transforms.forEach(function (transform) {\n    var rotate_ccw  = { 1: 6, 2: 5, 3: 8, 4: 7, 5: 4, 6: 3, 7: 2, 8: 1 };\n    var mirror_vert = { 1: 4, 2: 3, 3: 2, 4: 1, 5: 6, 6: 5, 7: 8, 8: 7 };\n\n    if (transform.type === 'imir') {\n      if (transform.value === 0) {\n        // vertical flip\n        orientation = mirror_vert[orientation];\n      } else {\n        // horizontal flip = vertical flip + 180 deg rotation\n        orientation = mirror_vert[orientation];\n        orientation = rotate_ccw[orientation];\n        orientation = rotate_ccw[orientation];\n      }\n    }\n\n    if (transform.type === 'irot') {\n      // counter-clockwise rotation 90 deg 0-3 times\n      for (var i = 0; i < transform.value; i++) {\n        orientation = rotate_ccw[orientation];\n      }\n    }\n  });\n\n  var exif_location = null;\n\n  if (sandbox.item_inf.Exif) {\n    exif_location = sandbox.item_loc[sandbox.item_inf.Exif];\n  }\n\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    orientation: sandbox.transforms.length ? orientation : null,\n    variants: sandbox.sizes,\n    exif_location: exif_location\n  };\n};\n\n\nmodule.exports.getMimeType = function (data) {\n  var brand = String.fromCharCode.apply(null, data.slice(0, 4));\n  var compat = {};\n\n  compat[brand] = true;\n\n  for (var i = 8; i < data.length; i += 4) {\n    compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;\n  }\n\n  // heic and avif are superset of miaf, so they should all list mif1 as compatible\n  if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;\n\n  if (brand === 'avif' || brand === 'avis' || brand === 'avio') {\n    // `.avifs` and `image/avif-sequence` are removed from spec, all files have single type\n    return { type: 'avif', mime: 'image/avif' };\n  }\n\n  // https://nokiatech.github.io/heif/technical.html\n  if (brand === 'heic' || brand === 'heix') {\n    return { type: 'heic', mime: 'image/heic' };\n  }\n\n  if (brand === 'hevc' || brand === 'hevx') {\n    return { type: 'heic', mime: 'image/heic-sequence' };\n  }\n\n  if (compat.avif || compat.avis) {\n    return { type: 'avif', mime: 'image/avif' };\n  }\n\n  if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {\n    if (compat.msf1) {\n      return { type: 'heif', mime: 'image/heif-sequence' };\n    }\n    return { type: 'heif', mime: 'image/heif' };\n  }\n\n  return { type: 'avif', mime: 'image/avif' };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}