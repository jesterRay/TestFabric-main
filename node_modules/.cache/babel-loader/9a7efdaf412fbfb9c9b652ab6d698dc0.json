{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\nvar Lib = require('../../lib');\nvar getTraceColor = require('../scatter/get_trace_color');\nvar fillText = Lib.fillText;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar LAYER_PREFIX = require('../../plots/mapbox/constants').traceLayerPrefix;\nfunction hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var subplot = pointData.subplot;\n  var clusteredPointsIds = [];\n  var layer = LAYER_PREFIX + trace.uid + '-circle';\n  var hasCluster = trace.cluster && trace.cluster.enabled;\n  if (hasCluster) {\n    var elems = subplot.map.queryRenderedFeatures(null, {\n      layers: [layer]\n    });\n    clusteredPointsIds = elems.map(function (elem) {\n      return elem.id;\n    });\n  }\n\n  // compute winding number about [-180, 180] globe\n  var winding = xval >= 0 ? Math.floor((xval + 180) / 360) : Math.ceil((xval - 180) / 360);\n\n  // shift longitude to [-180, 180] to determine closest point\n  var lonShift = winding * 360;\n  var xval2 = xval - lonShift;\n  function distFn(d) {\n    var lonlat = d.lonlat;\n    if (lonlat[0] === BADNUM) return Infinity;\n    if (hasCluster && clusteredPointsIds.indexOf(d.i + 1) === -1) return Infinity;\n    var lon = Lib.modHalf(lonlat[0], 360);\n    var lat = lonlat[1];\n    var pt = subplot.project([lon, lat]);\n    var dx = pt.x - xa.c2p([xval2, lat]);\n    var dy = pt.y - ya.c2p([lon, yval]);\n    var rad = Math.max(3, d.mrc || 0);\n    return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n  }\n  Fx.getClosest(cd, distFn, pointData);\n\n  // skip the rest (for this trace) if we didn't find a close point\n  if (pointData.index === false) return;\n  var di = cd[pointData.index];\n  var lonlat = di.lonlat;\n  var lonlatShifted = [Lib.modHalf(lonlat[0], 360) + lonShift, lonlat[1]];\n\n  // shift labels back to original winded globe\n  var xc = xa.c2p(lonlatShifted);\n  var yc = ya.c2p(lonlatShifted);\n  var rad = di.mrc || 1;\n  pointData.x0 = xc - rad;\n  pointData.x1 = xc + rad;\n  pointData.y0 = yc - rad;\n  pointData.y1 = yc + rad;\n  var fullLayout = {};\n  fullLayout[trace.subplot] = {\n    _subplot: subplot\n  };\n  var labels = trace._module.formatLabels(di, trace, fullLayout);\n  pointData.lonLabel = labels.lonLabel;\n  pointData.latLabel = labels.latLabel;\n  pointData.color = getTraceColor(trace, di);\n  pointData.extraText = getExtraText(trace, di, cd[0].t.labels);\n  pointData.hovertemplate = trace.hovertemplate;\n  return [pointData];\n}\nfunction getExtraText(trace, di, labels) {\n  if (trace.hovertemplate) return;\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var parts = hoverinfo.split('+');\n  var isAll = parts.indexOf('all') !== -1;\n  var hasLon = parts.indexOf('lon') !== -1;\n  var hasLat = parts.indexOf('lat') !== -1;\n  var lonlat = di.lonlat;\n  var text = [];\n\n  // TODO should we use a mock axis to format hover?\n  // If so, we'll need to make precision be zoom-level dependent\n  function format(v) {\n    return v + '\\u00B0';\n  }\n  if (isAll || hasLon && hasLat) {\n    text.push('(' + format(lonlat[1]) + ', ' + format(lonlat[0]) + ')');\n  } else if (hasLon) {\n    text.push(labels.lon + format(lonlat[0]));\n  } else if (hasLat) {\n    text.push(labels.lat + format(lonlat[1]));\n  }\n  if (isAll || parts.indexOf('text') !== -1) {\n    fillText(di, trace, text);\n  }\n  return text.join('<br>');\n}\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  getExtraText: getExtraText\n};","map":{"version":3,"names":["Fx","require","Lib","getTraceColor","fillText","BADNUM","LAYER_PREFIX","traceLayerPrefix","hoverPoints","pointData","xval","yval","cd","trace","xa","ya","subplot","clusteredPointsIds","layer","uid","hasCluster","cluster","enabled","elems","map","queryRenderedFeatures","layers","elem","id","winding","Math","floor","ceil","lonShift","xval2","distFn","d","lonlat","Infinity","indexOf","i","lon","modHalf","lat","pt","project","dx","x","c2p","dy","y","rad","max","mrc","sqrt","getClosest","index","di","lonlatShifted","xc","yc","x0","x1","y0","y1","fullLayout","_subplot","labels","_module","formatLabels","lonLabel","latLabel","color","extraText","getExtraText","t","hovertemplate","hoverinfo","hi","parts","split","isAll","hasLon","hasLat","text","format","v","push","join","module","exports"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/scattermapbox/hover.js"],"sourcesContent":["'use strict';\n\nvar Fx = require('../../components/fx');\nvar Lib = require('../../lib');\nvar getTraceColor = require('../scatter/get_trace_color');\nvar fillText = Lib.fillText;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar LAYER_PREFIX = require('../../plots/mapbox/constants').traceLayerPrefix;\n\nfunction hoverPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var subplot = pointData.subplot;\n    var clusteredPointsIds = [];\n    var layer = LAYER_PREFIX + trace.uid + '-circle';\n    var hasCluster = trace.cluster && trace.cluster.enabled;\n\n    if(hasCluster) {\n        var elems = subplot.map.queryRenderedFeatures(null, {layers: [layer]});\n        clusteredPointsIds = elems.map(function(elem) {return elem.id;});\n    }\n\n    // compute winding number about [-180, 180] globe\n    var winding = (xval >= 0) ?\n        Math.floor((xval + 180) / 360) :\n        Math.ceil((xval - 180) / 360);\n\n    // shift longitude to [-180, 180] to determine closest point\n    var lonShift = winding * 360;\n    var xval2 = xval - lonShift;\n\n    function distFn(d) {\n        var lonlat = d.lonlat;\n        if(lonlat[0] === BADNUM) return Infinity;\n        if(hasCluster && clusteredPointsIds.indexOf(d.i + 1) === -1) return Infinity;\n\n        var lon = Lib.modHalf(lonlat[0], 360);\n        var lat = lonlat[1];\n        var pt = subplot.project([lon, lat]);\n        var dx = pt.x - xa.c2p([xval2, lat]);\n        var dy = pt.y - ya.c2p([lon, yval]);\n        var rad = Math.max(3, d.mrc || 0);\n\n        return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n    }\n\n    Fx.getClosest(cd, distFn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    var di = cd[pointData.index];\n    var lonlat = di.lonlat;\n    var lonlatShifted = [Lib.modHalf(lonlat[0], 360) + lonShift, lonlat[1]];\n\n    // shift labels back to original winded globe\n    var xc = xa.c2p(lonlatShifted);\n    var yc = ya.c2p(lonlatShifted);\n    var rad = di.mrc || 1;\n\n    pointData.x0 = xc - rad;\n    pointData.x1 = xc + rad;\n    pointData.y0 = yc - rad;\n    pointData.y1 = yc + rad;\n\n    var fullLayout = {};\n    fullLayout[trace.subplot] = {_subplot: subplot};\n    var labels = trace._module.formatLabels(di, trace, fullLayout);\n    pointData.lonLabel = labels.lonLabel;\n    pointData.latLabel = labels.latLabel;\n\n    pointData.color = getTraceColor(trace, di);\n    pointData.extraText = getExtraText(trace, di, cd[0].t.labels);\n    pointData.hovertemplate = trace.hovertemplate;\n\n    return [pointData];\n}\n\nfunction getExtraText(trace, di, labels) {\n    if(trace.hovertemplate) return;\n\n    var hoverinfo = di.hi || trace.hoverinfo;\n    var parts = hoverinfo.split('+');\n    var isAll = parts.indexOf('all') !== -1;\n    var hasLon = parts.indexOf('lon') !== -1;\n    var hasLat = parts.indexOf('lat') !== -1;\n    var lonlat = di.lonlat;\n    var text = [];\n\n    // TODO should we use a mock axis to format hover?\n    // If so, we'll need to make precision be zoom-level dependent\n    function format(v) {\n        return v + '\\u00B0';\n    }\n\n    if(isAll || (hasLon && hasLat)) {\n        text.push('(' + format(lonlat[1]) + ', ' + format(lonlat[0]) + ')');\n    } else if(hasLon) {\n        text.push(labels.lon + format(lonlat[0]));\n    } else if(hasLat) {\n        text.push(labels.lat + format(lonlat[1]));\n    }\n\n    if(isAll || parts.indexOf('text') !== -1) {\n        fillText(di, trace, text);\n    }\n\n    return text.join('<br>');\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    getExtraText: getExtraText\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}