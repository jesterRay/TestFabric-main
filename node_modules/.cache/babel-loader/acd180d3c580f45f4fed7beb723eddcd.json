{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\nvar calcAxisExpansion = require('../scatter/calc').calcAxisExpansion;\nvar calcColorscale = require('../scatter/colorscale_calc');\nvar convertMarkerSelection = require('../scattergl/convert').markerSelection;\nvar convertMarkerStyle = require('../scattergl/convert').markerStyle;\nvar sceneUpdate = require('./scene_update');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\nmodule.exports = function calc(gd, trace) {\n  var dimensions = trace.dimensions;\n  var commonLength = trace._length;\n  var opts = {};\n  // 'c' for calculated, 'l' for linear,\n  // only differ here for log axes, pass ldata to createMatrix as 'data'\n  var cdata = opts.cdata = [];\n  var ldata = opts.data = [];\n  // keep track of visible dimensions\n  var visibleDims = trace._visibleDims = [];\n  var i, k, dim, xa, ya;\n  function makeCalcdata(ax, dim) {\n    // call makeCalcdata with fake input\n    var ccol = ax.makeCalcdata({\n      v: dim.values,\n      vcalendar: trace.calendar\n    }, 'v');\n    for (var j = 0; j < ccol.length; j++) {\n      ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];\n    }\n    cdata.push(ccol);\n    ldata.push(ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol);\n  }\n  for (i = 0; i < dimensions.length; i++) {\n    dim = dimensions[i];\n    if (dim.visible) {\n      xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n      ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n\n      // if corresponding x & y axes don't have matching types, skip dim\n      if (xa && ya && xa.type !== ya.type) {\n        Lib.log('Skipping splom dimension ' + i + ' with conflicting axis types');\n        continue;\n      }\n      if (xa) {\n        makeCalcdata(xa, dim);\n        if (ya && ya.type === 'category') {\n          ya._categories = xa._categories.slice();\n        }\n      } else {\n        // should not make it here, if both xa and ya undefined\n        makeCalcdata(ya, dim);\n      }\n      visibleDims.push(i);\n    }\n  }\n  calcColorscale(gd, trace);\n  Lib.extendFlat(opts, convertMarkerStyle(gd, trace));\n  var visibleLength = cdata.length;\n  var hasTooManyPoints = visibleLength * commonLength > TOO_MANY_POINTS;\n\n  // Reuse SVG scatter axis expansion routine.\n  // For graphs with very large number of points and array marker.size,\n  // use average marker size instead to speed things up.\n  var ppad;\n  if (hasTooManyPoints) {\n    ppad = opts.sizeAvg || Math.max(opts.size, 3);\n  } else {\n    ppad = calcMarkerSize(trace, commonLength);\n  }\n  for (k = 0; k < visibleDims.length; k++) {\n    i = visibleDims[k];\n    dim = dimensions[i];\n    xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};\n    ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};\n    calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);\n  }\n  var scene = sceneUpdate(gd, trace);\n  if (!scene.matrix) scene.matrix = true;\n  scene.matrixOptions = opts;\n  scene.selectedOptions = convertMarkerSelection(gd, trace, trace.selected);\n  scene.unselectedOptions = convertMarkerSelection(gd, trace, trace.unselected);\n  return [{\n    x: false,\n    y: false,\n    t: {},\n    trace: trace\n  }];\n};","map":{"version":3,"names":["Lib","require","AxisIDs","calcMarkerSize","calcAxisExpansion","calcColorscale","convertMarkerSelection","markerSelection","convertMarkerStyle","markerStyle","sceneUpdate","BADNUM","TOO_MANY_POINTS","module","exports","calc","gd","trace","dimensions","commonLength","_length","opts","cdata","ldata","data","visibleDims","_visibleDims","i","k","dim","xa","ya","makeCalcdata","ax","ccol","v","values","vcalendar","calendar","j","length","NaN","push","type","simpleMap","c2l","visible","getFromId","_diag","log","_categories","slice","extendFlat","visibleLength","hasTooManyPoints","ppad","sizeAvg","Math","max","size","scene","matrix","matrixOptions","selectedOptions","selected","unselectedOptions","unselected","x","y","t"],"sources":["E:/tog_workspace/TestFabric_main/TestFabric-main/node_modules/plotly.js/src/traces/splom/calc.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\nvar calcAxisExpansion = require('../scatter/calc').calcAxisExpansion;\nvar calcColorscale = require('../scatter/colorscale_calc');\nvar convertMarkerSelection = require('../scattergl/convert').markerSelection;\nvar convertMarkerStyle = require('../scattergl/convert').markerStyle;\nvar sceneUpdate = require('./scene_update');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\n\nmodule.exports = function calc(gd, trace) {\n    var dimensions = trace.dimensions;\n    var commonLength = trace._length;\n    var opts = {};\n    // 'c' for calculated, 'l' for linear,\n    // only differ here for log axes, pass ldata to createMatrix as 'data'\n    var cdata = opts.cdata = [];\n    var ldata = opts.data = [];\n    // keep track of visible dimensions\n    var visibleDims = trace._visibleDims = [];\n    var i, k, dim, xa, ya;\n\n    function makeCalcdata(ax, dim) {\n        // call makeCalcdata with fake input\n        var ccol = ax.makeCalcdata({\n            v: dim.values,\n            vcalendar: trace.calendar\n        }, 'v');\n\n        for(var j = 0; j < ccol.length; j++) {\n            ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];\n        }\n        cdata.push(ccol);\n        ldata.push(ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol);\n    }\n\n    for(i = 0; i < dimensions.length; i++) {\n        dim = dimensions[i];\n\n        if(dim.visible) {\n            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n\n            // if corresponding x & y axes don't have matching types, skip dim\n            if(xa && ya && xa.type !== ya.type) {\n                Lib.log('Skipping splom dimension ' + i + ' with conflicting axis types');\n                continue;\n            }\n\n            if(xa) {\n                makeCalcdata(xa, dim);\n                if(ya && ya.type === 'category') {\n                    ya._categories = xa._categories.slice();\n                }\n            } else {\n                // should not make it here, if both xa and ya undefined\n                makeCalcdata(ya, dim);\n            }\n\n            visibleDims.push(i);\n        }\n    }\n\n    calcColorscale(gd, trace);\n    Lib.extendFlat(opts, convertMarkerStyle(gd, trace));\n\n    var visibleLength = cdata.length;\n    var hasTooManyPoints = (visibleLength * commonLength) > TOO_MANY_POINTS;\n\n    // Reuse SVG scatter axis expansion routine.\n    // For graphs with very large number of points and array marker.size,\n    // use average marker size instead to speed things up.\n    var ppad;\n    if(hasTooManyPoints) {\n        ppad = opts.sizeAvg || Math.max(opts.size, 3);\n    } else {\n        ppad = calcMarkerSize(trace, commonLength);\n    }\n\n    for(k = 0; k < visibleDims.length; k++) {\n        i = visibleDims[k];\n        dim = dimensions[i];\n        xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};\n        ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};\n        calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);\n    }\n\n    var scene = sceneUpdate(gd, trace);\n    if(!scene.matrix) scene.matrix = true;\n    scene.matrixOptions = opts;\n\n    scene.selectedOptions = convertMarkerSelection(gd, trace, trace.selected);\n    scene.unselectedOptions = convertMarkerSelection(gd, trace, trace.unselected);\n\n    return [{x: false, y: false, t: {}, trace: trace}];\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIC,OAAO,GAAGD,OAAO,CAAC,gCAAgC,CAAC;AAEvD,IAAIE,cAAc,GAAGF,OAAO,CAAC,iBAAiB,CAAC,CAACE,cAAc;AAC9D,IAAIC,iBAAiB,GAAGH,OAAO,CAAC,iBAAiB,CAAC,CAACG,iBAAiB;AACpE,IAAIC,cAAc,GAAGJ,OAAO,CAAC,4BAA4B,CAAC;AAC1D,IAAIK,sBAAsB,GAAGL,OAAO,CAAC,sBAAsB,CAAC,CAACM,eAAe;AAC5E,IAAIC,kBAAkB,GAAGP,OAAO,CAAC,sBAAsB,CAAC,CAACQ,WAAW;AACpE,IAAIC,WAAW,GAAGT,OAAO,CAAC,gBAAgB,CAAC;AAE3C,IAAIU,MAAM,GAAGV,OAAO,CAAC,2BAA2B,CAAC,CAACU,MAAM;AACxD,IAAIC,eAAe,GAAGX,OAAO,CAAC,wBAAwB,CAAC,CAACW,eAAe;AAEvEC,MAAM,CAACC,OAAO,GAAG,SAASC,IAAIA,CAACC,EAAE,EAAEC,KAAK,EAAE;EACtC,IAAIC,UAAU,GAAGD,KAAK,CAACC,UAAU;EACjC,IAAIC,YAAY,GAAGF,KAAK,CAACG,OAAO;EAChC,IAAIC,IAAI,GAAG,CAAC,CAAC;EACb;EACA;EACA,IAAIC,KAAK,GAAGD,IAAI,CAACC,KAAK,GAAG,EAAE;EAC3B,IAAIC,KAAK,GAAGF,IAAI,CAACG,IAAI,GAAG,EAAE;EAC1B;EACA,IAAIC,WAAW,GAAGR,KAAK,CAACS,YAAY,GAAG,EAAE;EACzC,IAAIC,CAAC,EAAEC,CAAC,EAAEC,GAAG,EAAEC,EAAE,EAAEC,EAAE;EAErB,SAASC,YAAYA,CAACC,EAAE,EAAEJ,GAAG,EAAE;IAC3B;IACA,IAAIK,IAAI,GAAGD,EAAE,CAACD,YAAY,CAAC;MACvBG,CAAC,EAAEN,GAAG,CAACO,MAAM;MACbC,SAAS,EAAEpB,KAAK,CAACqB;IACrB,CAAC,EAAE,GAAG,CAAC;IAEP,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;MACjCL,IAAI,CAACK,CAAC,CAAC,GAAGL,IAAI,CAACK,CAAC,CAAC,KAAK5B,MAAM,GAAG8B,GAAG,GAAGP,IAAI,CAACK,CAAC,CAAC;IAChD;IACAjB,KAAK,CAACoB,IAAI,CAACR,IAAI,CAAC;IAChBX,KAAK,CAACmB,IAAI,CAACT,EAAE,CAACU,IAAI,KAAK,KAAK,GAAG3C,GAAG,CAAC4C,SAAS,CAACV,IAAI,EAAED,EAAE,CAACY,GAAG,CAAC,GAAGX,IAAI,CAAC;EACtE;EAEA,KAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,UAAU,CAACsB,MAAM,EAAEb,CAAC,EAAE,EAAE;IACnCE,GAAG,GAAGX,UAAU,CAACS,CAAC,CAAC;IAEnB,IAAGE,GAAG,CAACiB,OAAO,EAAE;MACZhB,EAAE,GAAG5B,OAAO,CAAC6C,SAAS,CAAC/B,EAAE,EAAEC,KAAK,CAAC+B,KAAK,CAACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC7CI,EAAE,GAAG7B,OAAO,CAAC6C,SAAS,CAAC/B,EAAE,EAAEC,KAAK,CAAC+B,KAAK,CAACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;MAE7C;MACA,IAAGG,EAAE,IAAIC,EAAE,IAAID,EAAE,CAACa,IAAI,KAAKZ,EAAE,CAACY,IAAI,EAAE;QAChC3C,GAAG,CAACiD,GAAG,CAAC,2BAA2B,GAAGtB,CAAC,GAAG,8BAA8B,CAAC;QACzE;MACJ;MAEA,IAAGG,EAAE,EAAE;QACHE,YAAY,CAACF,EAAE,EAAED,GAAG,CAAC;QACrB,IAAGE,EAAE,IAAIA,EAAE,CAACY,IAAI,KAAK,UAAU,EAAE;UAC7BZ,EAAE,CAACmB,WAAW,GAAGpB,EAAE,CAACoB,WAAW,CAACC,KAAK,CAAC,CAAC;QAC3C;MACJ,CAAC,MAAM;QACH;QACAnB,YAAY,CAACD,EAAE,EAAEF,GAAG,CAAC;MACzB;MAEAJ,WAAW,CAACiB,IAAI,CAACf,CAAC,CAAC;IACvB;EACJ;EAEAtB,cAAc,CAACW,EAAE,EAAEC,KAAK,CAAC;EACzBjB,GAAG,CAACoD,UAAU,CAAC/B,IAAI,EAAEb,kBAAkB,CAACQ,EAAE,EAAEC,KAAK,CAAC,CAAC;EAEnD,IAAIoC,aAAa,GAAG/B,KAAK,CAACkB,MAAM;EAChC,IAAIc,gBAAgB,GAAID,aAAa,GAAGlC,YAAY,GAAIP,eAAe;;EAEvE;EACA;EACA;EACA,IAAI2C,IAAI;EACR,IAAGD,gBAAgB,EAAE;IACjBC,IAAI,GAAGlC,IAAI,CAACmC,OAAO,IAAIC,IAAI,CAACC,GAAG,CAACrC,IAAI,CAACsC,IAAI,EAAE,CAAC,CAAC;EACjD,CAAC,MAAM;IACHJ,IAAI,GAAGpD,cAAc,CAACc,KAAK,EAAEE,YAAY,CAAC;EAC9C;EAEA,KAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,CAACe,MAAM,EAAEZ,CAAC,EAAE,EAAE;IACpCD,CAAC,GAAGF,WAAW,CAACG,CAAC,CAAC;IAClBC,GAAG,GAAGX,UAAU,CAACS,CAAC,CAAC;IACnBG,EAAE,GAAG5B,OAAO,CAAC6C,SAAS,CAAC/B,EAAE,EAAEC,KAAK,CAAC+B,KAAK,CAACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACnDI,EAAE,GAAG7B,OAAO,CAAC6C,SAAS,CAAC/B,EAAE,EAAEC,KAAK,CAAC+B,KAAK,CAACrB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IACnDvB,iBAAiB,CAACY,EAAE,EAAEC,KAAK,EAAEa,EAAE,EAAEC,EAAE,EAAET,KAAK,CAACM,CAAC,CAAC,EAAEN,KAAK,CAACM,CAAC,CAAC,EAAE2B,IAAI,CAAC;EAClE;EAEA,IAAIK,KAAK,GAAGlD,WAAW,CAACM,EAAE,EAAEC,KAAK,CAAC;EAClC,IAAG,CAAC2C,KAAK,CAACC,MAAM,EAAED,KAAK,CAACC,MAAM,GAAG,IAAI;EACrCD,KAAK,CAACE,aAAa,GAAGzC,IAAI;EAE1BuC,KAAK,CAACG,eAAe,GAAGzD,sBAAsB,CAACU,EAAE,EAAEC,KAAK,EAAEA,KAAK,CAAC+C,QAAQ,CAAC;EACzEJ,KAAK,CAACK,iBAAiB,GAAG3D,sBAAsB,CAACU,EAAE,EAAEC,KAAK,EAAEA,KAAK,CAACiD,UAAU,CAAC;EAE7E,OAAO,CAAC;IAACC,CAAC,EAAE,KAAK;IAAEC,CAAC,EAAE,KAAK;IAAEC,CAAC,EAAE,CAAC,CAAC;IAAEpD,KAAK,EAAEA;EAAK,CAAC,CAAC;AACtD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}